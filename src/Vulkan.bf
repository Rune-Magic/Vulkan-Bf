/*  Auto Generated by Setup/Program.bf
 *  DO NOT EDIT
 */

using System;
using System.Interop;

using Vulkan.Video;

namespace Vulkan;

// Header boilerplate
// Fundamental types used by many commands and structures
[CRepr] struct VkExtent2D
{
	public uint32 width;
	public uint32 height;

	public this(uint32 width, uint32 height)
	{
		this.width = width;
		this.height = height;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkExtent3D
{
	public uint32 width;
	public uint32 height;
	public uint32 depth;

	public this(uint32 width, uint32 height, uint32 depth)
	{
		this.width = width;
		this.height = height;
		this.depth = depth;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkOffset2D
{
	public int32 x;
	public int32 y;

	public this(int32 x, int32 y)
	{
		this.x = x;
		this.y = y;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkOffset3D
{
	public int32 x;
	public int32 y;
	public int32 z;

	public this(int32 x, int32 y, int32 z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkRect2D
{
	public VkOffset2D offset;
	public VkExtent2D extent;

	public this(VkOffset2D offset, VkExtent2D extent)
	{
		this.offset = offset;
		this.extent = extent;
	}

	public this()
	{
		this = default;
	}
}

[NoDiscard, AllowDuplicates] enum VkResult : int32
{
	VkSuccess = 0, // Command completed successfully
	VkNotReady = 1, // A fence or query has not yet completed
	VkTimeout = 2, // A wait operation has not completed in the specified time
	VkEventSet = 3, // An event is signaled
	VkEventReset = 4, // An event is unsignaled
	VkIncomplete = 5, // A return array was too small for the result
	VkErrorOutOfHostMemory = -1, // A host memory allocation has failed
	VkErrorOutOfDeviceMemory = -2, // A device memory allocation has failed
	VkErrorInitializationFailed = -3, // Initialization of an object has failed
	VkErrorDeviceLost = -4, // The logical device has been lost. See <<devsandqueues-lost-device>>
	VkErrorMemoryMapFailed = -5, // Mapping of a memory object has failed
	VkErrorLayerNotPresent = -6, // Layer specified does not exist
	VkErrorExtensionNotPresent = -7, // Extension specified does not exist
	VkErrorFeatureNotPresent = -8, // Requested feature is not available on this device
	VkErrorIncompatibleDriver = -9, // Unable to find a Vulkan driver
	VkErrorTooManyObjects = -10, // Too many objects of the type have already been created
	VkErrorFormatNotSupported = -11, // Requested format is not supported on this device
	VkErrorFragmentedPool = -12, // A requested pool allocation has failed due to fragmentation of the pool's memory
	VkErrorUnknown = -13, // An unknown error has occurred, due to an implementation or application bug
	VkErrorOutOfPoolMemory = -1000069000,
	VkErrorInvalidExternalHandle = -1000072003,
	VkErrorFragmentation = -1000161000,
	VkErrorInvalidOpaqueCaptureAddress = -1000257000,
	VkPipelineCompileRequired = 1000297000,
	VkErrorNotPermitted = -1000174001,
	VkErrorSurfaceLostKHR = -1000000000,
	VkErrorNativeWindowInUseKHR = -1000000001,
	VkSuboptimalKHR = 1000001003,
	VkErrorOutOfDateKHR = -1000001004,
	VkErrorIncompatibleDisplayKHR = -1000003001,
	VkErrorValidationFailedEXT = -1000011001,
	VkErrorInvalidShaderNV = -1000012000,
	VkErrorImageUsageNotSupportedKHR = -1000023000,
	VkErrorVideoPictureLayoutNotSupportedKHR = -1000023001,
	VkErrorVideoProfileOperationNotSupportedKHR = -1000023002,
	VkErrorVideoProfileFormatNotSupportedKHR = -1000023003,
	VkErrorVideoProfileCodecNotSupportedKHR = -1000023004,
	VkErrorVideoStdVersionNotSupportedKHR = -1000023005,
	VkErrorOutOfPoolMemoryKHR = VkErrorOutOfPoolMemory,
	VkErrorInvalidExternalHandleKHR = VkErrorInvalidExternalHandle,
	VkErrorInvalidDrmFormatModifierPlaneLayoutEXT = -1000158000,
	VkErrorFragmentationEXT = VkErrorFragmentation,
	VkErrorNotPermittedEXT = VkErrorNotPermitted,
	VkErrorNotPermittedKHR = VkErrorNotPermitted,
	VkErrorInvalidDeviceAddressEXT = VkErrorInvalidOpaqueCaptureAddress,
	VkErrorFullScreenExclusiveModeLostEXT = -1000255000,
	VkErrorInvalidOpaqueCaptureAddressKHR = VkErrorInvalidOpaqueCaptureAddress,
	VkThreadIdleKHR = 1000268000,
	VkThreadDoneKHR = 1000268001,
	VkOperationDeferredKHR = 1000268002,
	VkOperationNotDeferredKHR = 1000268003,
	VkPipelineCompileRequiredEXT = VkPipelineCompileRequired,
	VkErrorPipelineCompileRequiredEXT = VkPipelineCompileRequired,
	VkErrorInvalidVideoStdParametersKHR = -1000299000,
	VkErrorCompressionExhaustedEXT = -1000338000,
	VkIncompatibleShaderBinaryEXT = 1000482000,
	VkErrorIncompatibleShaderBinaryEXT = VkIncompatibleShaderBinaryEXT,
	VkPipelineBinaryMissingKHR = 1000483000,
	VkErrorNotEnoughSpaceKHR = -1000483000,
}

[AllowDuplicates] enum VkStructureType : int32
{
	VkApplicationInfo = 0,
	VkInstanceCreateInfo = 1,
	VkDeviceQueueCreateInfo = 2,
	VkDeviceCreateInfo = 3,
	VkSubmitInfo = 4,
	VkMemoryAllocateInfo = 5,
	VkMappedMemoryRange = 6,
	VkBindSparseInfo = 7,
	VkFenceCreateInfo = 8,
	VkSemaphoreCreateInfo = 9,
	VkEventCreateInfo = 10,
	VkQueryPoolCreateInfo = 11,
	VkBufferCreateInfo = 12,
	VkBufferViewCreateInfo = 13,
	VkImageCreateInfo = 14,
	VkImageViewCreateInfo = 15,
	VkShaderModuleCreateInfo = 16,
	VkPipelineCacheCreateInfo = 17,
	VkPipelineShaderStageCreateInfo = 18,
	VkPipelineVertexInputStateCreateInfo = 19,
	VkPipelineInputAssemblyStateCreateInfo = 20,
	VkPipelineTessellationStateCreateInfo = 21,
	VkPipelineViewportStateCreateInfo = 22,
	VkPipelineRasterizationStateCreateInfo = 23,
	VkPipelineMultisampleStateCreateInfo = 24,
	VkPipelineDepthStencilStateCreateInfo = 25,
	VkPipelineColorBlendStateCreateInfo = 26,
	VkPipelineDynamicStateCreateInfo = 27,
	VkGraphicsPipelineCreateInfo = 28,
	VkComputePipelineCreateInfo = 29,
	VkPipelineLayoutCreateInfo = 30,
	VkSamplerCreateInfo = 31,
	VkDescriptorSetLayoutCreateInfo = 32,
	VkDescriptorPoolCreateInfo = 33,
	VkDescriptorSetAllocateInfo = 34,
	VkWriteDescriptorSet = 35,
	VkCopyDescriptorSet = 36,
	VkFramebufferCreateInfo = 37,
	VkRenderPassCreateInfo = 38,
	VkCommandPoolCreateInfo = 39,
	VkCommandBufferAllocateInfo = 40,
	VkCommandBufferInheritanceInfo = 41,
	VkCommandBufferBeginInfo = 42,
	VkRenderPassBeginInfo = 43,
	VkBufferMemoryBarrier = 44,
	VkImageMemoryBarrier = 45,
	VkMemoryBarrier = 46,
	VkLoaderInstanceCreateInfo = 47, // Reserved for internal use by the loader, layers, and ICDs
	VkLoaderDeviceCreateInfo = 48, // Reserved for internal use by the loader, layers, and ICDs
	VkPhysicalDeviceSubgroupProperties = 1000094000,
	VkBindBufferMemoryInfo = 1000157000,
	VkBindImageMemoryInfo = 1000157001,
	VkPhysicalDevice16bitStorageFeatures = 1000083000,
	VkMemoryDedicatedRequirements = 1000127000,
	VkMemoryDedicatedAllocateInfo = 1000127001,
	VkMemoryAllocateFlagsInfo = 1000060000,
	VkDeviceGroupRenderPassBeginInfo = 1000060003,
	VkDeviceGroupCommandBufferBeginInfo = 1000060004,
	VkDeviceGroupSubmitInfo = 1000060005,
	VkDeviceGroupBindSparseInfo = 1000060006,
	VkBindBufferMemoryDeviceGroupInfo = 1000060013,
	VkBindImageMemoryDeviceGroupInfo = 1000060014,
	VkPhysicalDeviceGroupProperties = 1000070000,
	VkDeviceGroupDeviceCreateInfo = 1000070001,
	VkBufferMemoryRequirementsInfo2 = 1000146000,
	VkImageMemoryRequirementsInfo2 = 1000146001,
	VkImageSparseMemoryRequirementsInfo2 = 1000146002,
	VkMemoryRequirements2 = 1000146003,
	VkSparseImageMemoryRequirements2 = 1000146004,
	VkPhysicalDeviceFeatures2 = 1000059000,
	VkPhysicalDeviceProperties2 = 1000059001,
	VkFormatProperties2 = 1000059002,
	VkImageFormatProperties2 = 1000059003,
	VkPhysicalDeviceImageFormatInfo2 = 1000059004,
	VkQueueFamilyProperties2 = 1000059005,
	VkPhysicalDeviceMemoryProperties2 = 1000059006,
	VkSparseImageFormatProperties2 = 1000059007,
	VkPhysicalDeviceSparseImageFormatInfo2 = 1000059008,
	VkPhysicalDevicePointClippingProperties = 1000117000,
	VkRenderPassInputAttachmentAspectCreateInfo = 1000117001,
	VkImageViewUsageCreateInfo = 1000117002,
	VkPipelineTessellationDomainOriginStateCreateInfo = 1000117003,
	VkRenderPassMultiviewCreateInfo = 1000053000,
	VkPhysicalDeviceMultiviewFeatures = 1000053001,
	VkPhysicalDeviceMultiviewProperties = 1000053002,
	VkPhysicalDeviceVariablePointersFeatures = 1000120000,
	VkPhysicalDeviceVariablePointerFeatures = VkPhysicalDeviceVariablePointersFeatures,
	VkProtectedSubmitInfo = 1000145000,
	VkPhysicalDeviceProtectedMemoryFeatures = 1000145001,
	VkPhysicalDeviceProtectedMemoryProperties = 1000145002,
	VkDeviceQueueInfo2 = 1000145003,
	VkSamplerYcbcrConversionCreateInfo = 1000156000,
	VkSamplerYcbcrConversionInfo = 1000156001,
	VkBindImagePlaneMemoryInfo = 1000156002,
	VkImagePlaneMemoryRequirementsInfo = 1000156003,
	VkPhysicalDeviceSamplerYcbcrConversionFeatures = 1000156004,
	VkSamplerYcbcrConversionImageFormatProperties = 1000156005,
	VkDescriptorUpdateTemplateCreateInfo = 1000085000,
	VkPhysicalDeviceExternalImageFormatInfo = 1000071000,
	VkExternalImageFormatProperties = 1000071001,
	VkPhysicalDeviceExternalBufferInfo = 1000071002,
	VkExternalBufferProperties = 1000071003,
	VkPhysicalDeviceIdProperties = 1000071004,
	VkExternalMemoryBufferCreateInfo = 1000072000,
	VkExternalMemoryImageCreateInfo = 1000072001,
	VkExportMemoryAllocateInfo = 1000072002,
	VkPhysicalDeviceExternalFenceInfo = 1000112000,
	VkExternalFenceProperties = 1000112001,
	VkExportFenceCreateInfo = 1000113000,
	VkExportSemaphoreCreateInfo = 1000077000,
	VkPhysicalDeviceExternalSemaphoreInfo = 1000076000,
	VkExternalSemaphoreProperties = 1000076001,
	VkPhysicalDeviceMaintenance3Properties = 1000168000,
	VkDescriptorSetLayoutSupport = 1000168001,
	VkPhysicalDeviceShaderDrawParametersFeatures = 1000063000,
	VkPhysicalDeviceShaderDrawParameterFeatures = VkPhysicalDeviceShaderDrawParametersFeatures,
	VkPhysicalDeviceVulkan11Features = 49,
	VkPhysicalDeviceVulkan11Properties = 50,
	VkPhysicalDeviceVulkan12Features = 51,
	VkPhysicalDeviceVulkan12Properties = 52,
	VkImageFormatListCreateInfo = 1000147000,
	VkAttachmentDescription2 = 1000109000,
	VkAttachmentReference2 = 1000109001,
	VkSubpassDescription2 = 1000109002,
	VkSubpassDependency2 = 1000109003,
	VkRenderPassCreateInfo2 = 1000109004,
	VkSubpassBeginInfo = 1000109005,
	VkSubpassEndInfo = 1000109006,
	VkPhysicalDevice8bitStorageFeatures = 1000177000,
	VkPhysicalDeviceDriverProperties = 1000196000,
	VkPhysicalDeviceShaderAtomicInt64Features = 1000180000,
	VkPhysicalDeviceShaderFloat16Int8Features = 1000082000,
	VkPhysicalDeviceFloatControlsProperties = 1000197000,
	VkDescriptorSetLayoutBindingFlagsCreateInfo = 1000161000,
	VkPhysicalDeviceDescriptorIndexingFeatures = 1000161001,
	VkPhysicalDeviceDescriptorIndexingProperties = 1000161002,
	VkDescriptorSetVariableDescriptorCountAllocateInfo = 1000161003,
	VkDescriptorSetVariableDescriptorCountLayoutSupport = 1000161004,
	VkPhysicalDeviceDepthStencilResolveProperties = 1000199000,
	VkSubpassDescriptionDepthStencilResolve = 1000199001,
	VkPhysicalDeviceScalarBlockLayoutFeatures = 1000221000,
	VkImageStencilUsageCreateInfo = 1000246000,
	VkPhysicalDeviceSamplerFilterMinmaxProperties = 1000130000,
	VkSamplerReductionModeCreateInfo = 1000130001,
	VkPhysicalDeviceVulkanMemoryModelFeatures = 1000211000,
	VkPhysicalDeviceImagelessFramebufferFeatures = 1000108000,
	VkFramebufferAttachmentsCreateInfo = 1000108001,
	VkFramebufferAttachmentImageInfo = 1000108002,
	VkRenderPassAttachmentBeginInfo = 1000108003,
	VkPhysicalDeviceUniformBufferStandardLayoutFeatures = 1000253000,
	VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = 1000175000,
	VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = 1000241000,
	VkAttachmentReferenceStencilLayout = 1000241001,
	VkAttachmentDescriptionStencilLayout = 1000241002,
	VkPhysicalDeviceHostQueryResetFeatures = 1000261000,
	VkPhysicalDeviceTimelineSemaphoreFeatures = 1000207000,
	VkPhysicalDeviceTimelineSemaphoreProperties = 1000207001,
	VkSemaphoreTypeCreateInfo = 1000207002,
	VkTimelineSemaphoreSubmitInfo = 1000207003,
	VkSemaphoreWaitInfo = 1000207004,
	VkSemaphoreSignalInfo = 1000207005,
	VkPhysicalDeviceBufferDeviceAddressFeatures = 1000257000,
	VkBufferDeviceAddressInfo = 1000244001,
	VkBufferOpaqueCaptureAddressCreateInfo = 1000257002,
	VkMemoryOpaqueCaptureAddressAllocateInfo = 1000257003,
	VkDeviceMemoryOpaqueCaptureAddressInfo = 1000257004,
	VkPhysicalDeviceVulkan13Features = 53,
	VkPhysicalDeviceVulkan13Properties = 54,
	VkPipelineCreationFeedbackCreateInfo = 1000192000,
	VkPhysicalDeviceShaderTerminateInvocationFeatures = 1000215000,
	VkPhysicalDeviceToolProperties = 1000245000,
	VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures = 1000276000,
	VkPhysicalDevicePrivateDataFeatures = 1000295000,
	VkDevicePrivateDataCreateInfo = 1000295001,
	VkPrivateDataSlotCreateInfo = 1000295002,
	VkPhysicalDevicePipelineCreationCacheControlFeatures = 1000297000,
	VkMemoryBarrier2 = 1000314000,
	VkBufferMemoryBarrier2 = 1000314001,
	VkImageMemoryBarrier2 = 1000314002,
	VkDependencyInfo = 1000314003,
	VkSubmitInfo2 = 1000314004,
	VkSemaphoreSubmitInfo = 1000314005,
	VkCommandBufferSubmitInfo = 1000314006,
	VkPhysicalDeviceSynchronization2Features = 1000314007,
	VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = 1000325000,
	VkPhysicalDeviceImageRobustnessFeatures = 1000335000,
	VkCopyBufferInfo2 = 1000337000,
	VkCopyImageInfo2 = 1000337001,
	VkCopyBufferToImageInfo2 = 1000337002,
	VkCopyImageToBufferInfo2 = 1000337003,
	VkBlitImageInfo2 = 1000337004,
	VkResolveImageInfo2 = 1000337005,
	VkBufferCopy2 = 1000337006,
	VkImageCopy2 = 1000337007,
	VkImageBlit2 = 1000337008,
	VkBufferImageCopy2 = 1000337009,
	VkImageResolve2 = 1000337010,
	VkPhysicalDeviceSubgroupSizeControlProperties = 1000225000,
	VkPipelineShaderStageRequiredSubgroupSizeCreateInfo = 1000225001,
	VkPhysicalDeviceSubgroupSizeControlFeatures = 1000225002,
	VkPhysicalDeviceInlineUniformBlockFeatures = 1000138000,
	VkPhysicalDeviceInlineUniformBlockProperties = 1000138001,
	VkWriteDescriptorSetInlineUniformBlock = 1000138002,
	VkDescriptorPoolInlineUniformBlockCreateInfo = 1000138003,
	VkPhysicalDeviceTextureCompressionAstcHdrFeatures = 1000066000,
	VkRenderingInfo = 1000044000,
	VkRenderingAttachmentInfo = 1000044001,
	VkPipelineRenderingCreateInfo = 1000044002,
	VkPhysicalDeviceDynamicRenderingFeatures = 1000044003,
	VkCommandBufferInheritanceRenderingInfo = 1000044004,
	VkPhysicalDeviceShaderIntegerDotProductFeatures = 1000280000,
	VkPhysicalDeviceShaderIntegerDotProductProperties = 1000280001,
	VkPhysicalDeviceTexelBufferAlignmentProperties = 1000281001,
	VkFormatProperties3 = 1000360000,
	VkPhysicalDeviceMaintenance4Features = 1000413000,
	VkPhysicalDeviceMaintenance4Properties = 1000413001,
	VkDeviceBufferMemoryRequirements = 1000413002,
	VkDeviceImageMemoryRequirements = 1000413003,
	VkPhysicalDeviceVulkan14Features = 55,
	VkPhysicalDeviceVulkan14Properties = 56,
	VkDeviceQueueGlobalPriorityCreateInfo = 1000174000,
	VkPhysicalDeviceGlobalPriorityQueryFeatures = 1000388000,
	VkQueueFamilyGlobalPriorityProperties = 1000388001,
	VkPhysicalDeviceShaderSubgroupRotateFeatures = 1000416000,
	VkPhysicalDeviceShaderFloatControls2Features = 1000528000,
	VkPhysicalDeviceShaderExpectAssumeFeatures = 1000544000,
	VkPhysicalDeviceLineRasterizationFeatures = 1000259000,
	VkPipelineRasterizationLineStateCreateInfo = 1000259001,
	VkPhysicalDeviceLineRasterizationProperties = 1000259002,
	VkPhysicalDeviceVertexAttributeDivisorProperties = 1000525000,
	VkPipelineVertexInputDivisorStateCreateInfo = 1000190001,
	VkPhysicalDeviceVertexAttributeDivisorFeatures = 1000190002,
	VkPhysicalDeviceIndexTypeUint8Features = 1000265000,
	VkMemoryMapInfo = 1000271000,
	VkMemoryUnmapInfo = 1000271001,
	VkPhysicalDeviceMaintenance5Features = 1000470000,
	VkPhysicalDeviceMaintenance5Properties = 1000470001,
	VkRenderingAreaInfo = 1000470003,
	VkDeviceImageSubresourceInfo = 1000470004,
	VkSubresourceLayout2 = 1000338002,
	VkImageSubresource2 = 1000338003,
	VkPipelineCreateFlags2CreateInfo = 1000470005,
	VkBufferUsageFlags2CreateInfo = 1000470006,
	VkPhysicalDevicePushDescriptorProperties = 1000080000,
	VkPhysicalDeviceDynamicRenderingLocalReadFeatures = 1000232000,
	VkRenderingAttachmentLocationInfo = 1000232001,
	VkRenderingInputAttachmentIndexInfo = 1000232002,
	VkPhysicalDeviceMaintenance6Features = 1000545000,
	VkPhysicalDeviceMaintenance6Properties = 1000545001,
	VkBindMemoryStatus = 1000545002,
	VkBindDescriptorSetsInfo = 1000545003,
	VkPushConstantsInfo = 1000545004,
	VkPushDescriptorSetInfo = 1000545005,
	VkPushDescriptorSetWithTemplateInfo = 1000545006,
	VkPhysicalDevicePipelineProtectedAccessFeatures = 1000466000,
	VkPipelineRobustnessCreateInfo = 1000068000,
	VkPhysicalDevicePipelineRobustnessFeatures = 1000068001,
	VkPhysicalDevicePipelineRobustnessProperties = 1000068002,
	VkPhysicalDeviceHostImageCopyFeatures = 1000270000,
	VkPhysicalDeviceHostImageCopyProperties = 1000270001,
	VkMemoryToImageCopy = 1000270002,
	VkImageToMemoryCopy = 1000270003,
	VkCopyImageToMemoryInfo = 1000270004,
	VkCopyMemoryToImageInfo = 1000270005,
	VkHostImageLayoutTransitionInfo = 1000270006,
	VkCopyImageToImageInfo = 1000270007,
	VkSubresourceHostMemcpySize = 1000270008,
	VkHostImageCopyDevicePerformanceQuery = 1000270009,
	VkSwapchainCreateInfoKHR = 1000001000,
	VkPresentInfoKHR = 1000001001,
	VkDeviceGroupPresentCapabilitiesKHR = 1000060007,
	VkImageSwapchainCreateInfoKHR = 1000060008,
	VkBindImageMemorySwapchainInfoKHR = 1000060009,
	VkAcquireNextImageInfoKHR = 1000060010,
	VkDeviceGroupPresentInfoKHR = 1000060011,
	VkDeviceGroupSwapchainCreateInfoKHR = 1000060012,
	VkDisplayModeCreateInfoKHR = 1000002000,
	VkDisplaySurfaceCreateInfoKHR = 1000002001,
	VkDisplayPresentInfoKHR = 1000003000,
	VkXlibSurfaceCreateInfoKHR = 1000004000,
	VkXcbSurfaceCreateInfoKHR = 1000005000,
	VkWaylandSurfaceCreateInfoKHR = 1000006000,
	VkAndroidSurfaceCreateInfoKHR = 1000008000,
	VkWin32SurfaceCreateInfoKHR = 1000009000,
	VkDebugReportCallbackCreateInfoEXT = 1000011000,
	VkDebugReportCreateInfoEXT = VkDebugReportCallbackCreateInfoEXT,
	VkPipelineRasterizationStateRasterizationOrderAMD = 1000018000,
	VkDebugMarkerObjectNameInfoEXT = 1000022000,
	VkDebugMarkerObjectTagInfoEXT = 1000022001,
	VkDebugMarkerMarkerInfoEXT = 1000022002,
	VkVideoProfileInfoKHR = 1000023000,
	VkVideoCapabilitiesKHR = 1000023001,
	VkVideoPictureResourceInfoKHR = 1000023002,
	VkVideoSessionMemoryRequirementsKHR = 1000023003,
	VkBindVideoSessionMemoryInfoKHR = 1000023004,
	VkVideoSessionCreateInfoKHR = 1000023005,
	VkVideoSessionParametersCreateInfoKHR = 1000023006,
	VkVideoSessionParametersUpdateInfoKHR = 1000023007,
	VkVideoBeginCodingInfoKHR = 1000023008,
	VkVideoEndCodingInfoKHR = 1000023009,
	VkVideoCodingControlInfoKHR = 1000023010,
	VkVideoReferenceSlotInfoKHR = 1000023011,
	VkQueueFamilyVideoPropertiesKHR = 1000023012,
	VkVideoProfileListInfoKHR = 1000023013,
	VkPhysicalDeviceVideoFormatInfoKHR = 1000023014,
	VkVideoFormatPropertiesKHR = 1000023015,
	VkQueueFamilyQueryResultStatusPropertiesKHR = 1000023016,
	VkVideoDecodeInfoKHR = 1000024000,
	VkVideoDecodeCapabilitiesKHR = 1000024001,
	VkVideoDecodeUsageInfoKHR = 1000024002,
	VkDedicatedAllocationImageCreateInfoNV = 1000026000,
	VkDedicatedAllocationBufferCreateInfoNV = 1000026001,
	VkDedicatedAllocationMemoryAllocateInfoNV = 1000026002,
	VkPhysicalDeviceTransformFeedbackFeaturesEXT = 1000028000,
	VkPhysicalDeviceTransformFeedbackPropertiesEXT = 1000028001,
	VkPipelineRasterizationStateStreamCreateInfoEXT = 1000028002,
	VkCuModuleCreateInfoNVX = 1000029000,
	VkCuFunctionCreateInfoNVX = 1000029001,
	VkCuLaunchInfoNVX = 1000029002,
	VkCuModuleTexturingModeCreateInfoNVX = 1000029004,
	VkImageViewHandleInfoNVX = 1000030000,
	VkImageViewAddressPropertiesNVX = 1000030001,
	VkVideoEncodeH264CapabilitiesKHR = 1000038000,
	VkVideoEncodeH264SessionParametersCreateInfoKHR = 1000038001,
	VkVideoEncodeH264SessionParametersAddInfoKHR = 1000038002,
	VkVideoEncodeH264PictureInfoKHR = 1000038003,
	VkVideoEncodeH264DpbSlotInfoKHR = 1000038004,
	VkVideoEncodeH264NaluSliceInfoKHR = 1000038005,
	VkVideoEncodeH264GopRemainingFrameInfoKHR = 1000038006,
	VkVideoEncodeH264ProfileInfoKHR = 1000038007,
	VkVideoEncodeH264RateControlInfoKHR = 1000038008,
	VkVideoEncodeH264RateControlLayerInfoKHR = 1000038009,
	VkVideoEncodeH264SessionCreateInfoKHR = 1000038010,
	VkVideoEncodeH264QualityLevelPropertiesKHR = 1000038011,
	VkVideoEncodeH264SessionParametersGetInfoKHR = 1000038012,
	VkVideoEncodeH264SessionParametersFeedbackInfoKHR = 1000038013,
	VkVideoEncodeH265CapabilitiesKHR = 1000039000,
	VkVideoEncodeH265SessionParametersCreateInfoKHR = 1000039001,
	VkVideoEncodeH265SessionParametersAddInfoKHR = 1000039002,
	VkVideoEncodeH265PictureInfoKHR = 1000039003,
	VkVideoEncodeH265DpbSlotInfoKHR = 1000039004,
	VkVideoEncodeH265NaluSliceSegmentInfoKHR = 1000039005,
	VkVideoEncodeH265GopRemainingFrameInfoKHR = 1000039006,
	VkVideoEncodeH265ProfileInfoKHR = 1000039007,
	VkVideoEncodeH265RateControlInfoKHR = 1000039009,
	VkVideoEncodeH265RateControlLayerInfoKHR = 1000039010,
	VkVideoEncodeH265SessionCreateInfoKHR = 1000039011,
	VkVideoEncodeH265QualityLevelPropertiesKHR = 1000039012,
	VkVideoEncodeH265SessionParametersGetInfoKHR = 1000039013,
	VkVideoEncodeH265SessionParametersFeedbackInfoKHR = 1000039014,
	VkVideoDecodeH264CapabilitiesKHR = 1000040000,
	VkVideoDecodeH264PictureInfoKHR = 1000040001,
	VkVideoDecodeH264ProfileInfoKHR = 1000040003,
	VkVideoDecodeH264SessionParametersCreateInfoKHR = 1000040004,
	VkVideoDecodeH264SessionParametersAddInfoKHR = 1000040005,
	VkVideoDecodeH264DpbSlotInfoKHR = 1000040006,
	VkTextureLodGatherFormatPropertiesAMD = 1000041000,
	VkRenderingInfoKHR = VkRenderingInfo,
	VkRenderingAttachmentInfoKHR = VkRenderingAttachmentInfo,
	VkPipelineRenderingCreateInfoKHR = VkPipelineRenderingCreateInfo,
	VkPhysicalDeviceDynamicRenderingFeaturesKHR = VkPhysicalDeviceDynamicRenderingFeatures,
	VkCommandBufferInheritanceRenderingInfoKHR = VkCommandBufferInheritanceRenderingInfo,
	VkStreamDescriptorSurfaceCreateInfoGGP = 1000049000,
	VkPhysicalDeviceCornerSampledImageFeaturesNV = 1000050000,
	VkRenderPassMultiviewCreateInfoKHR = VkRenderPassMultiviewCreateInfo,
	VkPhysicalDeviceMultiviewFeaturesKHR = VkPhysicalDeviceMultiviewFeatures,
	VkPhysicalDeviceMultiviewPropertiesKHR = VkPhysicalDeviceMultiviewProperties,
	VkExternalMemoryImageCreateInfoNV = 1000056000,
	VkExportMemoryAllocateInfoNV = 1000056001,
	VkImportMemoryWin32HandleInfoNV = 1000057000,
	VkExportMemoryWin32HandleInfoNV = 1000057001,
	VkWin32KeyedMutexAcquireReleaseInfoNV = 1000058000,
	VkPhysicalDeviceFeatures2KHR = VkPhysicalDeviceFeatures2,
	VkPhysicalDeviceProperties2KHR = VkPhysicalDeviceProperties2,
	VkFormatProperties2KHR = VkFormatProperties2,
	VkImageFormatProperties2KHR = VkImageFormatProperties2,
	VkPhysicalDeviceImageFormatInfo2KHR = VkPhysicalDeviceImageFormatInfo2,
	VkQueueFamilyProperties2KHR = VkQueueFamilyProperties2,
	VkPhysicalDeviceMemoryProperties2KHR = VkPhysicalDeviceMemoryProperties2,
	VkSparseImageFormatProperties2KHR = VkSparseImageFormatProperties2,
	VkPhysicalDeviceSparseImageFormatInfo2KHR = VkPhysicalDeviceSparseImageFormatInfo2,
	VkMemoryAllocateFlagsInfoKHR = VkMemoryAllocateFlagsInfo,
	VkDeviceGroupRenderPassBeginInfoKHR = VkDeviceGroupRenderPassBeginInfo,
	VkDeviceGroupCommandBufferBeginInfoKHR = VkDeviceGroupCommandBufferBeginInfo,
	VkDeviceGroupSubmitInfoKHR = VkDeviceGroupSubmitInfo,
	VkDeviceGroupBindSparseInfoKHR = VkDeviceGroupBindSparseInfo,
	VkBindBufferMemoryDeviceGroupInfoKHR = VkBindBufferMemoryDeviceGroupInfo,
	VkBindImageMemoryDeviceGroupInfoKHR = VkBindImageMemoryDeviceGroupInfo,
	VkValidationFlagsEXT = 1000061000,
	VkViSurfaceCreateInfoNN = 1000062000,
	VkPhysicalDeviceTextureCompressionAstcHdrFeaturesEXT = VkPhysicalDeviceTextureCompressionAstcHdrFeatures,
	VkImageViewAstcDecodeModeEXT = 1000067000,
	VkPhysicalDeviceAstcDecodeFeaturesEXT = 1000067001,
	VkPipelineRobustnessCreateInfoEXT = VkPipelineRobustnessCreateInfo,
	VkPhysicalDevicePipelineRobustnessFeaturesEXT = VkPhysicalDevicePipelineRobustnessFeatures,
	VkPhysicalDevicePipelineRobustnessPropertiesEXT = VkPhysicalDevicePipelineRobustnessProperties,
	VkPhysicalDeviceGroupPropertiesKHR = VkPhysicalDeviceGroupProperties,
	VkDeviceGroupDeviceCreateInfoKHR = VkDeviceGroupDeviceCreateInfo,
	VkPhysicalDeviceExternalImageFormatInfoKHR = VkPhysicalDeviceExternalImageFormatInfo,
	VkExternalImageFormatPropertiesKHR = VkExternalImageFormatProperties,
	VkPhysicalDeviceExternalBufferInfoKHR = VkPhysicalDeviceExternalBufferInfo,
	VkExternalBufferPropertiesKHR = VkExternalBufferProperties,
	VkPhysicalDeviceIdPropertiesKHR = VkPhysicalDeviceIdProperties,
	VkExternalMemoryBufferCreateInfoKHR = VkExternalMemoryBufferCreateInfo,
	VkExternalMemoryImageCreateInfoKHR = VkExternalMemoryImageCreateInfo,
	VkExportMemoryAllocateInfoKHR = VkExportMemoryAllocateInfo,
	VkImportMemoryWin32HandleInfoKHR = 1000073000,
	VkExportMemoryWin32HandleInfoKHR = 1000073001,
	VkMemoryWin32HandlePropertiesKHR = 1000073002,
	VkMemoryGetWin32HandleInfoKHR = 1000073003,
	VkImportMemoryFdInfoKHR = 1000074000,
	VkMemoryFdPropertiesKHR = 1000074001,
	VkMemoryGetFdInfoKHR = 1000074002,
	VkWin32KeyedMutexAcquireReleaseInfoKHR = 1000075000,
	VkPhysicalDeviceExternalSemaphoreInfoKHR = VkPhysicalDeviceExternalSemaphoreInfo,
	VkExternalSemaphorePropertiesKHR = VkExternalSemaphoreProperties,
	VkExportSemaphoreCreateInfoKHR = VkExportSemaphoreCreateInfo,
	VkImportSemaphoreWin32HandleInfoKHR = 1000078000,
	VkExportSemaphoreWin32HandleInfoKHR = 1000078001,
	VkD3d12FenceSubmitInfoKHR = 1000078002,
	VkSemaphoreGetWin32HandleInfoKHR = 1000078003,
	VkImportSemaphoreFdInfoKHR = 1000079000,
	VkSemaphoreGetFdInfoKHR = 1000079001,
	VkPhysicalDevicePushDescriptorPropertiesKHR = VkPhysicalDevicePushDescriptorProperties,
	VkCommandBufferInheritanceConditionalRenderingInfoEXT = 1000081000,
	VkPhysicalDeviceConditionalRenderingFeaturesEXT = 1000081001,
	VkConditionalRenderingBeginInfoEXT = 1000081002,
	VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features,
	VkPhysicalDeviceFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features,
	VkPhysicalDevice16bitStorageFeaturesKHR = VkPhysicalDevice16bitStorageFeatures,
	VkPresentRegionsKHR = 1000084000,
	VkDescriptorUpdateTemplateCreateInfoKHR = VkDescriptorUpdateTemplateCreateInfo,
	VkPipelineViewportWScalingStateCreateInfoNV = 1000087000,
	VkSurfaceCapabilities2EXT = 1000090000,
	VkDisplayPowerInfoEXT = 1000091000,
	VkDeviceEventInfoEXT = 1000091001,
	VkDisplayEventInfoEXT = 1000091002,
	VkSwapchainCounterCreateInfoEXT = 1000091003,
	VkPresentTimesInfoGOOGLE = 1000092000,
	VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = 1000097000,
	VkMultiviewPerViewAttributesInfoNVX = 1000044009,
	VkPipelineViewportSwizzleStateCreateInfoNV = 1000098000,
	VkPhysicalDeviceDiscardRectanglePropertiesEXT = 1000099000,
	VkPipelineDiscardRectangleStateCreateInfoEXT = 1000099001,
	VkPhysicalDeviceConservativeRasterizationPropertiesEXT = 1000101000,
	VkPipelineRasterizationConservativeStateCreateInfoEXT = 1000101001,
	VkPhysicalDeviceDepthClipEnableFeaturesEXT = 1000102000,
	VkPipelineRasterizationDepthClipStateCreateInfoEXT = 1000102001,
	VkHdrMetadataEXT = 1000105000,
	VkPhysicalDeviceImagelessFramebufferFeaturesKHR = VkPhysicalDeviceImagelessFramebufferFeatures,
	VkFramebufferAttachmentsCreateInfoKHR = VkFramebufferAttachmentsCreateInfo,
	VkFramebufferAttachmentImageInfoKHR = VkFramebufferAttachmentImageInfo,
	VkRenderPassAttachmentBeginInfoKHR = VkRenderPassAttachmentBeginInfo,
	VkAttachmentDescription2KHR = VkAttachmentDescription2,
	VkAttachmentReference2KHR = VkAttachmentReference2,
	VkSubpassDescription2KHR = VkSubpassDescription2,
	VkSubpassDependency2KHR = VkSubpassDependency2,
	VkRenderPassCreateInfo2KHR = VkRenderPassCreateInfo2,
	VkSubpassBeginInfoKHR = VkSubpassBeginInfo,
	VkSubpassEndInfoKHR = VkSubpassEndInfo,
	VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG = 1000110000,
	VkSharedPresentSurfaceCapabilitiesKHR = 1000111000,
	VkPhysicalDeviceExternalFenceInfoKHR = VkPhysicalDeviceExternalFenceInfo,
	VkExternalFencePropertiesKHR = VkExternalFenceProperties,
	VkExportFenceCreateInfoKHR = VkExportFenceCreateInfo,
	VkImportFenceWin32HandleInfoKHR = 1000114000,
	VkExportFenceWin32HandleInfoKHR = 1000114001,
	VkFenceGetWin32HandleInfoKHR = 1000114002,
	VkImportFenceFdInfoKHR = 1000115000,
	VkFenceGetFdInfoKHR = 1000115001,
	VkPhysicalDevicePerformanceQueryFeaturesKHR = 1000116000,
	VkPhysicalDevicePerformanceQueryPropertiesKHR = 1000116001,
	VkQueryPoolPerformanceCreateInfoKHR = 1000116002,
	VkPerformanceQuerySubmitInfoKHR = 1000116003,
	VkAcquireProfilingLockInfoKHR = 1000116004,
	VkPerformanceCounterKHR = 1000116005,
	VkPerformanceCounterDescriptionKHR = 1000116006,
	VkPhysicalDevicePointClippingPropertiesKHR = VkPhysicalDevicePointClippingProperties,
	VkRenderPassInputAttachmentAspectCreateInfoKHR = VkRenderPassInputAttachmentAspectCreateInfo,
	VkImageViewUsageCreateInfoKHR = VkImageViewUsageCreateInfo,
	VkPipelineTessellationDomainOriginStateCreateInfoKHR = VkPipelineTessellationDomainOriginStateCreateInfo,
	VkPhysicalDeviceSurfaceInfo2KHR = 1000119000,
	VkSurfaceCapabilities2KHR = 1000119001,
	VkSurfaceFormat2KHR = 1000119002,
	VkPhysicalDeviceVariablePointersFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures,
	VkPhysicalDeviceVariablePointerFeaturesKHR = VkPhysicalDeviceVariablePointersFeaturesKHR,
	VkDisplayProperties2KHR = 1000121000,
	VkDisplayPlaneProperties2KHR = 1000121001,
	VkDisplayModeProperties2KHR = 1000121002,
	VkDisplayPlaneInfo2KHR = 1000121003,
	VkDisplayPlaneCapabilities2KHR = 1000121004,
	VkIosSurfaceCreateInfoMVK = 1000122000,
	VkMacosSurfaceCreateInfoMVK = 1000123000,
	VkMemoryDedicatedRequirementsKHR = VkMemoryDedicatedRequirements,
	VkMemoryDedicatedAllocateInfoKHR = VkMemoryDedicatedAllocateInfo,
	VkDebugUtilsObjectNameInfoEXT = 1000128000,
	VkDebugUtilsObjectTagInfoEXT = 1000128001,
	VkDebugUtilsLabelEXT = 1000128002,
	VkDebugUtilsMessengerCallbackDataEXT = 1000128003,
	VkDebugUtilsMessengerCreateInfoEXT = 1000128004,
	VkAndroidHardwareBufferUsageANDROID = 1000129000,
	VkAndroidHardwareBufferPropertiesANDROID = 1000129001,
	VkAndroidHardwareBufferFormatPropertiesANDROID = 1000129002,
	VkImportAndroidHardwareBufferInfoANDROID = 1000129003,
	VkMemoryGetAndroidHardwareBufferInfoANDROID = 1000129004,
	VkExternalFormatANDROID = 1000129005,
	VkAndroidHardwareBufferFormatProperties2ANDROID = 1000129006,
	VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = VkPhysicalDeviceSamplerFilterMinmaxProperties,
	VkSamplerReductionModeCreateInfoEXT = VkSamplerReductionModeCreateInfo,
	VkPhysicalDeviceShaderEnqueueFeaturesAMDX = 1000134000,
	VkPhysicalDeviceShaderEnqueuePropertiesAMDX = 1000134001,
	VkExecutionGraphPipelineScratchSizeAMDX = 1000134002,
	VkExecutionGraphPipelineCreateInfoAMDX = 1000134003,
	VkPipelineShaderStageNodeCreateInfoAMDX = 1000134004,
	VkAttachmentSampleCountInfoAMD = 1000044008,
	VkPhysicalDeviceInlineUniformBlockFeaturesEXT = VkPhysicalDeviceInlineUniformBlockFeatures,
	VkPhysicalDeviceInlineUniformBlockPropertiesEXT = VkPhysicalDeviceInlineUniformBlockProperties,
	VkWriteDescriptorSetInlineUniformBlockEXT = VkWriteDescriptorSetInlineUniformBlock,
	VkDescriptorPoolInlineUniformBlockCreateInfoEXT = VkDescriptorPoolInlineUniformBlockCreateInfo,
	VkPhysicalDeviceShaderBfloat16FeaturesKHR = 1000141000,
	VkSampleLocationsInfoEXT = 1000143000,
	VkRenderPassSampleLocationsBeginInfoEXT = 1000143001,
	VkPipelineSampleLocationsStateCreateInfoEXT = 1000143002,
	VkPhysicalDeviceSampleLocationsPropertiesEXT = 1000143003,
	VkMultisamplePropertiesEXT = 1000143004,
	VkBufferMemoryRequirementsInfo2KHR = VkBufferMemoryRequirementsInfo2,
	VkImageMemoryRequirementsInfo2KHR = VkImageMemoryRequirementsInfo2,
	VkImageSparseMemoryRequirementsInfo2KHR = VkImageSparseMemoryRequirementsInfo2,
	VkMemoryRequirements2KHR = VkMemoryRequirements2,
	VkSparseImageMemoryRequirements2KHR = VkSparseImageMemoryRequirements2,
	VkImageFormatListCreateInfoKHR = VkImageFormatListCreateInfo,
	VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = 1000148000,
	VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = 1000148001,
	VkPipelineColorBlendAdvancedStateCreateInfoEXT = 1000148002,
	VkPipelineCoverageToColorStateCreateInfoNV = 1000149000,
	VkWriteDescriptorSetAccelerationStructureKHR = 1000150007,
	VkAccelerationStructureBuildGeometryInfoKHR = 1000150000,
	VkAccelerationStructureDeviceAddressInfoKHR = 1000150002,
	VkAccelerationStructureGeometryAabbsDataKHR = 1000150003,
	VkAccelerationStructureGeometryInstancesDataKHR = 1000150004,
	VkAccelerationStructureGeometryTrianglesDataKHR = 1000150005,
	VkAccelerationStructureGeometryKHR = 1000150006,
	VkAccelerationStructureVersionInfoKHR = 1000150009,
	VkCopyAccelerationStructureInfoKHR = 1000150010,
	VkCopyAccelerationStructureToMemoryInfoKHR = 1000150011,
	VkCopyMemoryToAccelerationStructureInfoKHR = 1000150012,
	VkPhysicalDeviceAccelerationStructureFeaturesKHR = 1000150013,
	VkPhysicalDeviceAccelerationStructurePropertiesKHR = 1000150014,
	VkAccelerationStructureCreateInfoKHR = 1000150017,
	VkAccelerationStructureBuildSizesInfoKHR = 1000150020,
	VkPhysicalDeviceRayTracingPipelineFeaturesKHR = 1000347000,
	VkPhysicalDeviceRayTracingPipelinePropertiesKHR = 1000347001,
	VkRayTracingPipelineCreateInfoKHR = 1000150015,
	VkRayTracingShaderGroupCreateInfoKHR = 1000150016,
	VkRayTracingPipelineInterfaceCreateInfoKHR = 1000150018,
	VkPhysicalDeviceRayQueryFeaturesKHR = 1000348013,
	VkPipelineCoverageModulationStateCreateInfoNV = 1000152000,
	VkAttachmentSampleCountInfoNV = VkAttachmentSampleCountInfoAMD,
	VkPhysicalDeviceShaderSmBuiltinsFeaturesNV = 1000154000,
	VkPhysicalDeviceShaderSmBuiltinsPropertiesNV = 1000154001,
	VkSamplerYcbcrConversionCreateInfoKHR = VkSamplerYcbcrConversionCreateInfo,
	VkSamplerYcbcrConversionInfoKHR = VkSamplerYcbcrConversionInfo,
	VkBindImagePlaneMemoryInfoKHR = VkBindImagePlaneMemoryInfo,
	VkImagePlaneMemoryRequirementsInfoKHR = VkImagePlaneMemoryRequirementsInfo,
	VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = VkPhysicalDeviceSamplerYcbcrConversionFeatures,
	VkSamplerYcbcrConversionImageFormatPropertiesKHR = VkSamplerYcbcrConversionImageFormatProperties,
	VkBindBufferMemoryInfoKHR = VkBindBufferMemoryInfo,
	VkBindImageMemoryInfoKHR = VkBindImageMemoryInfo,
	VkDrmFormatModifierPropertiesListEXT = 1000158000,
	VkPhysicalDeviceImageDrmFormatModifierInfoEXT = 1000158002,
	VkImageDrmFormatModifierListCreateInfoEXT = 1000158003,
	VkImageDrmFormatModifierExplicitCreateInfoEXT = 1000158004,
	VkImageDrmFormatModifierPropertiesEXT = 1000158005,
	VkDrmFormatModifierPropertiesList2EXT = 1000158006,
	VkValidationCacheCreateInfoEXT = 1000160000,
	VkShaderModuleValidationCacheCreateInfoEXT = 1000160001,
	VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = VkDescriptorSetLayoutBindingFlagsCreateInfo,
	VkPhysicalDeviceDescriptorIndexingFeaturesEXT = VkPhysicalDeviceDescriptorIndexingFeatures,
	VkPhysicalDeviceDescriptorIndexingPropertiesEXT = VkPhysicalDeviceDescriptorIndexingProperties,
	VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = VkDescriptorSetVariableDescriptorCountAllocateInfo,
	VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = VkDescriptorSetVariableDescriptorCountLayoutSupport,
	VkPhysicalDevicePortabilitySubsetFeaturesKHR = 1000163000,
	VkPhysicalDevicePortabilitySubsetPropertiesKHR = 1000163001,
	VkPipelineViewportShadingRateImageStateCreateInfoNV = 1000164000,
	VkPhysicalDeviceShadingRateImageFeaturesNV = 1000164001,
	VkPhysicalDeviceShadingRateImagePropertiesNV = 1000164002,
	VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = 1000164005,
	VkRayTracingPipelineCreateInfoNV = 1000165000,
	VkAccelerationStructureCreateInfoNV = 1000165001,
	VkGeometryNV = 1000165003,
	VkGeometryTrianglesNV = 1000165004,
	VkGeometryAabbNV = 1000165005,
	VkBindAccelerationStructureMemoryInfoNV = 1000165006,
	VkWriteDescriptorSetAccelerationStructureNV = 1000165007,
	VkAccelerationStructureMemoryRequirementsInfoNV = 1000165008,
	VkPhysicalDeviceRayTracingPropertiesNV = 1000165009,
	VkRayTracingShaderGroupCreateInfoNV = 1000165011,
	VkAccelerationStructureInfoNV = 1000165012,
	VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = 1000166000,
	VkPipelineRepresentativeFragmentTestStateCreateInfoNV = 1000166001,
	VkPhysicalDeviceMaintenance3PropertiesKHR = VkPhysicalDeviceMaintenance3Properties,
	VkDescriptorSetLayoutSupportKHR = VkDescriptorSetLayoutSupport,
	VkPhysicalDeviceImageViewImageFormatInfoEXT = 1000170000,
	VkFilterCubicImageViewImageFormatPropertiesEXT = 1000170001,
	VkDeviceQueueGlobalPriorityCreateInfoEXT = VkDeviceQueueGlobalPriorityCreateInfo,
	VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,
	VkPhysicalDevice8bitStorageFeaturesKHR = VkPhysicalDevice8bitStorageFeatures,
	VkImportMemoryHostPointerInfoEXT = 1000178000,
	VkMemoryHostPointerPropertiesEXT = 1000178001,
	VkPhysicalDeviceExternalMemoryHostPropertiesEXT = 1000178002,
	VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = VkPhysicalDeviceShaderAtomicInt64Features,
	VkPhysicalDeviceShaderClockFeaturesKHR = 1000181000,
	VkPipelineCompilerControlCreateInfoAMD = 1000183000,
	VkCalibratedTimestampInfoEXT = VkCalibratedTimestampInfoKHR,
	VkPhysicalDeviceShaderCorePropertiesAMD = 1000185000,
	VkVideoDecodeH265CapabilitiesKHR = 1000187000,
	VkVideoDecodeH265SessionParametersCreateInfoKHR = 1000187001,
	VkVideoDecodeH265SessionParametersAddInfoKHR = 1000187002,
	VkVideoDecodeH265ProfileInfoKHR = 1000187003,
	VkVideoDecodeH265PictureInfoKHR = 1000187004,
	VkVideoDecodeH265DpbSlotInfoKHR = 1000187005,
	VkDeviceQueueGlobalPriorityCreateInfoKHR = VkDeviceQueueGlobalPriorityCreateInfo,
	VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR = VkPhysicalDeviceGlobalPriorityQueryFeatures,
	VkQueueFamilyGlobalPriorityPropertiesKHR = VkQueueFamilyGlobalPriorityProperties,
	VkDeviceMemoryOverallocationCreateInfoAMD = 1000189000,
	VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = 1000190000,
	VkPipelineVertexInputDivisorStateCreateInfoEXT = VkPipelineVertexInputDivisorStateCreateInfo,
	VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = VkPhysicalDeviceVertexAttributeDivisorFeatures,
	VkPresentFrameTokenGGP = 1000191000,
	VkPipelineCreationFeedbackCreateInfoEXT = VkPipelineCreationFeedbackCreateInfo,
	VkPhysicalDeviceDriverPropertiesKHR = VkPhysicalDeviceDriverProperties,
	VkPhysicalDeviceFloatControlsPropertiesKHR = VkPhysicalDeviceFloatControlsProperties,
	VkPhysicalDeviceDepthStencilResolvePropertiesKHR = VkPhysicalDeviceDepthStencilResolveProperties,
	VkSubpassDescriptionDepthStencilResolveKHR = VkSubpassDescriptionDepthStencilResolve,
	VkPhysicalDeviceComputeShaderDerivativesFeaturesNV = VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR,
	VkPhysicalDeviceMeshShaderFeaturesNV = 1000202000,
	VkPhysicalDeviceMeshShaderPropertiesNV = 1000202001,
	VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV = VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR,
	VkPhysicalDeviceShaderImageFootprintFeaturesNV = 1000204000,
	VkPipelineViewportExclusiveScissorStateCreateInfoNV = 1000205000,
	VkPhysicalDeviceExclusiveScissorFeaturesNV = 1000205002,
	VkCheckpointDataNV = 1000206000,
	VkQueueFamilyCheckpointPropertiesNV = 1000206001,
	VkQueueFamilyCheckpointProperties2NV = 1000314008,
	VkCheckpointData2NV = 1000314009,
	VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = VkPhysicalDeviceTimelineSemaphoreFeatures,
	VkPhysicalDeviceTimelineSemaphorePropertiesKHR = VkPhysicalDeviceTimelineSemaphoreProperties,
	VkSemaphoreTypeCreateInfoKHR = VkSemaphoreTypeCreateInfo,
	VkTimelineSemaphoreSubmitInfoKHR = VkTimelineSemaphoreSubmitInfo,
	VkSemaphoreWaitInfoKHR = VkSemaphoreWaitInfo,
	VkSemaphoreSignalInfoKHR = VkSemaphoreSignalInfo,
	VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = 1000209000,
	VkQueryPoolPerformanceQueryCreateInfoINTEL = 1000210000,
	VkQueryPoolCreateInfoINTEL = VkQueryPoolPerformanceQueryCreateInfoINTEL,
	VkInitializePerformanceApiInfoINTEL = 1000210001,
	VkPerformanceMarkerInfoINTEL = 1000210002,
	VkPerformanceStreamMarkerInfoINTEL = 1000210003,
	VkPerformanceOverrideInfoINTEL = 1000210004,
	VkPerformanceConfigurationAcquireInfoINTEL = 1000210005,
	VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = VkPhysicalDeviceVulkanMemoryModelFeatures,
	VkPhysicalDevicePciBusInfoPropertiesEXT = 1000212000,
	VkDisplayNativeHdrSurfaceCapabilitiesAMD = 1000213000,
	VkSwapchainDisplayNativeHdrCreateInfoAMD = 1000213001,
	VkImagepipeSurfaceCreateInfoFUCHSIA = 1000214000,
	VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR = VkPhysicalDeviceShaderTerminateInvocationFeatures,
	VkMetalSurfaceCreateInfoEXT = 1000217000,
	VkPhysicalDeviceFragmentDensityMapFeaturesEXT = 1000218000,
	VkPhysicalDeviceFragmentDensityMapPropertiesEXT = 1000218001,
	VkRenderPassFragmentDensityMapCreateInfoEXT = 1000218002,
	VkRenderingFragmentDensityMapAttachmentInfoEXT = 1000044007,
	VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = VkPhysicalDeviceScalarBlockLayoutFeatures,
	VkPhysicalDeviceSubgroupSizeControlPropertiesEXT = VkPhysicalDeviceSubgroupSizeControlProperties,
	VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo,
	VkPhysicalDeviceSubgroupSizeControlFeaturesEXT = VkPhysicalDeviceSubgroupSizeControlFeatures,
	VkFragmentShadingRateAttachmentInfoKHR = 1000226000,
	VkPipelineFragmentShadingRateStateCreateInfoKHR = 1000226001,
	VkPhysicalDeviceFragmentShadingRatePropertiesKHR = 1000226002,
	VkPhysicalDeviceFragmentShadingRateFeaturesKHR = 1000226003,
	VkPhysicalDeviceFragmentShadingRateKHR = 1000226004,
	VkRenderingFragmentShadingRateAttachmentInfoKHR = 1000044006,
	VkPhysicalDeviceShaderCoreProperties2AMD = 1000227000,
	VkPhysicalDeviceCoherentMemoryFeaturesAMD = 1000229000,
	VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = VkPhysicalDeviceDynamicRenderingLocalReadFeatures,
	VkRenderingAttachmentLocationInfoKHR = VkRenderingAttachmentLocationInfo,
	VkRenderingInputAttachmentIndexInfoKHR = VkRenderingInputAttachmentIndexInfo,
	VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = 1000234000,
	VkPhysicalDeviceShaderQuadControlFeaturesKHR = 1000235000,
	VkPhysicalDeviceMemoryBudgetPropertiesEXT = 1000237000,
	VkPhysicalDeviceMemoryPriorityFeaturesEXT = 1000238000,
	VkMemoryPriorityAllocateInfoEXT = 1000238001,
	VkSurfaceProtectedCapabilitiesKHR = 1000239000,
	VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = 1000240000,
	VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures,
	VkAttachmentReferenceStencilLayoutKHR = VkAttachmentReferenceStencilLayout,
	VkAttachmentDescriptionStencilLayoutKHR = VkAttachmentDescriptionStencilLayout,
	VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = 1000244000,
	VkPhysicalDeviceBufferAddressFeaturesEXT = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,
	VkBufferDeviceAddressInfoEXT = VkBufferDeviceAddressInfo,
	VkBufferDeviceAddressCreateInfoEXT = 1000244002,
	VkPhysicalDeviceToolPropertiesEXT = VkPhysicalDeviceToolProperties,
	VkImageStencilUsageCreateInfoEXT = VkImageStencilUsageCreateInfo,
	VkValidationFeaturesEXT = 1000247000,
	VkPhysicalDevicePresentWaitFeaturesKHR = 1000248000,
	VkPhysicalDeviceCooperativeMatrixFeaturesNV = 1000249000,
	VkCooperativeMatrixPropertiesNV = 1000249001,
	VkPhysicalDeviceCooperativeMatrixPropertiesNV = 1000249002,
	VkPhysicalDeviceCoverageReductionModeFeaturesNV = 1000250000,
	VkPipelineCoverageReductionStateCreateInfoNV = 1000250001,
	VkFramebufferMixedSamplesCombinationNV = 1000250002,
	VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = 1000251000,
	VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = 1000252000,
	VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = VkPhysicalDeviceUniformBufferStandardLayoutFeatures,
	VkPhysicalDeviceProvokingVertexFeaturesEXT = 1000254000,
	VkPipelineRasterizationProvokingVertexStateCreateInfoEXT = 1000254001,
	VkPhysicalDeviceProvokingVertexPropertiesEXT = 1000254002,
	VkSurfaceFullScreenExclusiveInfoEXT = 1000255000,
	VkSurfaceCapabilitiesFullScreenExclusiveEXT = 1000255002,
	VkSurfaceFullScreenExclusiveWin32InfoEXT = 1000255001,
	VkHeadlessSurfaceCreateInfoEXT = 1000256000,
	VkPhysicalDeviceBufferDeviceAddressFeaturesKHR = VkPhysicalDeviceBufferDeviceAddressFeatures,
	VkBufferDeviceAddressInfoKHR = VkBufferDeviceAddressInfo,
	VkBufferOpaqueCaptureAddressCreateInfoKHR = VkBufferOpaqueCaptureAddressCreateInfo,
	VkMemoryOpaqueCaptureAddressAllocateInfoKHR = VkMemoryOpaqueCaptureAddressAllocateInfo,
	VkDeviceMemoryOpaqueCaptureAddressInfoKHR = VkDeviceMemoryOpaqueCaptureAddressInfo,
	VkPhysicalDeviceLineRasterizationFeaturesEXT = VkPhysicalDeviceLineRasterizationFeatures,
	VkPipelineRasterizationLineStateCreateInfoEXT = VkPipelineRasterizationLineStateCreateInfo,
	VkPhysicalDeviceLineRasterizationPropertiesEXT = VkPhysicalDeviceLineRasterizationProperties,
	VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = 1000260000,
	VkPhysicalDeviceHostQueryResetFeaturesEXT = VkPhysicalDeviceHostQueryResetFeatures,
	VkPhysicalDeviceIndexTypeUint8FeaturesEXT = VkPhysicalDeviceIndexTypeUint8Features,
	VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = 1000267000, // Not promoted to 1.3
	VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = 1000269000,
	VkPipelineInfoKHR = 1000269001,
	VkPipelineExecutablePropertiesKHR = 1000269002,
	VkPipelineExecutableInfoKHR = 1000269003,
	VkPipelineExecutableStatisticKHR = 1000269004,
	VkPipelineExecutableInternalRepresentationKHR = 1000269005,
	VkPhysicalDeviceHostImageCopyFeaturesEXT = VkPhysicalDeviceHostImageCopyFeatures,
	VkPhysicalDeviceHostImageCopyPropertiesEXT = VkPhysicalDeviceHostImageCopyProperties,
	VkMemoryToImageCopyEXT = VkMemoryToImageCopy,
	VkImageToMemoryCopyEXT = VkImageToMemoryCopy,
	VkCopyImageToMemoryInfoEXT = VkCopyImageToMemoryInfo,
	VkCopyMemoryToImageInfoEXT = VkCopyMemoryToImageInfo,
	VkHostImageLayoutTransitionInfoEXT = VkHostImageLayoutTransitionInfo,
	VkCopyImageToImageInfoEXT = VkCopyImageToImageInfo,
	VkSubresourceHostMemcpySizeEXT = VkSubresourceHostMemcpySize,
	VkHostImageCopyDevicePerformanceQueryEXT = VkHostImageCopyDevicePerformanceQuery,
	VkMemoryMapInfoKHR = VkMemoryMapInfo,
	VkMemoryUnmapInfoKHR = VkMemoryUnmapInfo,
	VkPhysicalDeviceMapMemoryPlacedFeaturesEXT = 1000272000,
	VkPhysicalDeviceMapMemoryPlacedPropertiesEXT = 1000272001,
	VkMemoryMapPlacedInfoEXT = 1000272002,
	VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = 1000273000,
	VkSurfacePresentModeEXT = VkSurfacePresentModeKHR,
	VkSurfacePresentScalingCapabilitiesEXT = VkSurfacePresentScalingCapabilitiesKHR,
	VkSurfacePresentModeCompatibilityEXT = VkSurfacePresentModeCompatibilityKHR,
	VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT = VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR,
	VkSwapchainPresentFenceInfoEXT = VkSwapchainPresentFenceInfoKHR,
	VkSwapchainPresentModesCreateInfoEXT = VkSwapchainPresentModesCreateInfoKHR,
	VkSwapchainPresentModeInfoEXT = VkSwapchainPresentModeInfoKHR,
	VkSwapchainPresentScalingCreateInfoEXT = VkSwapchainPresentScalingCreateInfoKHR,
	VkReleaseSwapchainImagesInfoEXT = VkReleaseSwapchainImagesInfoKHR,
	VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures,
	VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV = 1000277000,
	VkGraphicsShaderGroupCreateInfoNV = 1000277001,
	VkGraphicsPipelineShaderGroupsCreateInfoNV = 1000277002,
	VkIndirectCommandsLayoutTokenNV = 1000277003,
	VkIndirectCommandsLayoutCreateInfoNV = 1000277004,
	VkGeneratedCommandsInfoNV = 1000277005,
	VkGeneratedCommandsMemoryRequirementsInfoNV = 1000277006,
	VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = 1000277007,
	VkPhysicalDeviceInheritedViewportScissorFeaturesNV = 1000278000,
	VkCommandBufferInheritanceViewportScissorInfoNV = 1000278001,
	VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = VkPhysicalDeviceShaderIntegerDotProductFeatures,
	VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR = VkPhysicalDeviceShaderIntegerDotProductProperties,
	VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = 1000281000, // Not promoted to 1.3
	VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = VkPhysicalDeviceTexelBufferAlignmentProperties,
	VkCommandBufferInheritanceRenderPassTransformInfoQCOM = 1000282000,
	VkRenderPassTransformBeginInfoQCOM = 1000282001,
	VkPhysicalDeviceDepthBiasControlFeaturesEXT = 1000283000,
	VkDepthBiasInfoEXT = 1000283001,
	VkDepthBiasRepresentationInfoEXT = 1000283002,
	VkPhysicalDeviceDeviceMemoryReportFeaturesEXT = 1000284000,
	VkDeviceDeviceMemoryReportCreateInfoEXT = 1000284001,
	VkDeviceMemoryReportCallbackDataEXT = 1000284002,
	VkPhysicalDeviceRobustness2FeaturesEXT = VkPhysicalDeviceRobustness2FeaturesKHR,
	VkPhysicalDeviceRobustness2PropertiesEXT = VkPhysicalDeviceRobustness2PropertiesKHR,
	VkSamplerCustomBorderColorCreateInfoEXT = 1000287000,
	VkPhysicalDeviceCustomBorderColorPropertiesEXT = 1000287001,
	VkPhysicalDeviceCustomBorderColorFeaturesEXT = 1000287002,
	VkPipelineLibraryCreateInfoKHR = 1000290000,
	VkPhysicalDevicePresentBarrierFeaturesNV = 1000292000,
	VkSurfaceCapabilitiesPresentBarrierNV = 1000292001,
	VkSwapchainPresentBarrierCreateInfoNV = 1000292002,
	VkPresentIdKHR = 1000294000,
	VkPhysicalDevicePresentIdFeaturesKHR = 1000294001,
	VkPhysicalDevicePrivateDataFeaturesEXT = VkPhysicalDevicePrivateDataFeatures,
	VkDevicePrivateDataCreateInfoEXT = VkDevicePrivateDataCreateInfo,
	VkPrivateDataSlotCreateInfoEXT = VkPrivateDataSlotCreateInfo,
	VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT = VkPhysicalDevicePipelineCreationCacheControlFeatures,
	VkVideoEncodeInfoKHR = 1000299000,
	VkVideoEncodeRateControlInfoKHR = 1000299001,
	VkVideoEncodeRateControlLayerInfoKHR = 1000299002,
	VkVideoEncodeCapabilitiesKHR = 1000299003,
	VkVideoEncodeUsageInfoKHR = 1000299004,
	VkQueryPoolVideoEncodeFeedbackCreateInfoKHR = 1000299005,
	VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR = 1000299006,
	VkVideoEncodeQualityLevelPropertiesKHR = 1000299007,
	VkVideoEncodeQualityLevelInfoKHR = 1000299008,
	VkVideoEncodeSessionParametersGetInfoKHR = 1000299009,
	VkVideoEncodeSessionParametersFeedbackInfoKHR = 1000299010,
	VkPhysicalDeviceDiagnosticsConfigFeaturesNV = 1000300000,
	VkDeviceDiagnosticsConfigCreateInfoNV = 1000300001,
	VkCudaModuleCreateInfoNV = 1000307000,
	VkCudaFunctionCreateInfoNV = 1000307001,
	VkCudaLaunchInfoNV = 1000307002,
	VkPhysicalDeviceCudaKernelLaunchFeaturesNV = 1000307003,
	VkPhysicalDeviceCudaKernelLaunchPropertiesNV = 1000307004,
	VkPhysicalDeviceTileShadingFeaturesQCOM = 1000309000,
	VkPhysicalDeviceTileShadingPropertiesQCOM = 1000309001,
	VkRenderPassTileShadingCreateInfoQCOM = 1000309002,
	VkPerTileBeginInfoQCOM = 1000309003,
	VkPerTileEndInfoQCOM = 1000309004,
	VkDispatchTileInfoQCOM = 1000309005,
	VkQueryLowLatencySupportNV = 1000310000,
	VkExportMetalObjectCreateInfoEXT = 1000311000,
	VkExportMetalObjectsInfoEXT = 1000311001,
	VkExportMetalDeviceInfoEXT = 1000311002,
	VkExportMetalCommandQueueInfoEXT = 1000311003,
	VkExportMetalBufferInfoEXT = 1000311004,
	VkImportMetalBufferInfoEXT = 1000311005,
	VkExportMetalTextureInfoEXT = 1000311006,
	VkImportMetalTextureInfoEXT = 1000311007,
	VkExportMetalIoSurfaceInfoEXT = 1000311008,
	VkImportMetalIoSurfaceInfoEXT = 1000311009,
	VkExportMetalSharedEventInfoEXT = 1000311010,
	VkImportMetalSharedEventInfoEXT = 1000311011,
	VkMemoryBarrier2KHR = VkMemoryBarrier2,
	VkBufferMemoryBarrier2KHR = VkBufferMemoryBarrier2,
	VkImageMemoryBarrier2KHR = VkImageMemoryBarrier2,
	VkDependencyInfoKHR = VkDependencyInfo,
	VkSubmitInfo2KHR = VkSubmitInfo2,
	VkSemaphoreSubmitInfoKHR = VkSemaphoreSubmitInfo,
	VkCommandBufferSubmitInfoKHR = VkCommandBufferSubmitInfo,
	VkPhysicalDeviceSynchronization2FeaturesKHR = VkPhysicalDeviceSynchronization2Features,
	VkPhysicalDeviceDescriptorBufferPropertiesEXT = 1000316000,
	VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = 1000316001,
	VkPhysicalDeviceDescriptorBufferFeaturesEXT = 1000316002,
	VkDescriptorAddressInfoEXT = 1000316003,
	VkDescriptorGetInfoEXT = 1000316004,
	VkBufferCaptureDescriptorDataInfoEXT = 1000316005,
	VkImageCaptureDescriptorDataInfoEXT = 1000316006,
	VkImageViewCaptureDescriptorDataInfoEXT = 1000316007,
	VkSamplerCaptureDescriptorDataInfoEXT = 1000316008,
	VkOpaqueCaptureDescriptorDataCreateInfoEXT = 1000316010,
	VkDescriptorBufferBindingInfoEXT = 1000316011,
	VkDescriptorBufferBindingPushDescriptorBufferHandleEXT = 1000316012,
	VkAccelerationStructureCaptureDescriptorDataInfoEXT = 1000316009,
	VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = 1000320000,
	VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = 1000320001,
	VkGraphicsPipelineLibraryCreateInfoEXT = 1000320002,
	VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = 1000321000,
	VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = 1000203000,
	VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR = 1000322000,
	VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = 1000323000,
	VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures,
	VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV = 1000326000,
	VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = 1000326001,
	VkPipelineFragmentShadingRateEnumStateCreateInfoNV = 1000326002,
	VkAccelerationStructureGeometryMotionTrianglesDataNV = 1000327000,
	VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = 1000327001,
	VkAccelerationStructureMotionInfoNV = 1000327002,
	VkPhysicalDeviceMeshShaderFeaturesEXT = 1000328000,
	VkPhysicalDeviceMeshShaderPropertiesEXT = 1000328001,
	VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = 1000330000,
	VkPhysicalDeviceFragmentDensityMap2FeaturesEXT = 1000332000,
	VkPhysicalDeviceFragmentDensityMap2PropertiesEXT = 1000332001,
	VkCopyCommandTransformInfoQCOM = 1000333000,
	VkPhysicalDeviceImageRobustnessFeaturesEXT = VkPhysicalDeviceImageRobustnessFeatures,
	VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = 1000336000,
	VkCopyBufferInfo2KHR = VkCopyBufferInfo2,
	VkCopyImageInfo2KHR = VkCopyImageInfo2,
	VkCopyBufferToImageInfo2KHR = VkCopyBufferToImageInfo2,
	VkCopyImageToBufferInfo2KHR = VkCopyImageToBufferInfo2,
	VkBlitImageInfo2KHR = VkBlitImageInfo2,
	VkResolveImageInfo2KHR = VkResolveImageInfo2,
	VkBufferCopy2KHR = VkBufferCopy2,
	VkImageCopy2KHR = VkImageCopy2,
	VkImageBlit2KHR = VkImageBlit2,
	VkBufferImageCopy2KHR = VkBufferImageCopy2,
	VkImageResolve2KHR = VkImageResolve2,
	VkPhysicalDeviceImageCompressionControlFeaturesEXT = 1000338000,
	VkImageCompressionControlEXT = 1000338001,
	VkSubresourceLayout2EXT = VkSubresourceLayout2,
	VkImageSubresource2EXT = VkImageSubresource2,
	VkImageCompressionPropertiesEXT = 1000338004,
	VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = 1000339000,
	VkPhysicalDevice4444FormatsFeaturesEXT = 1000340000,
	VkPhysicalDeviceFaultFeaturesEXT = 1000341000,
	VkDeviceFaultCountsEXT = 1000341001,
	VkDeviceFaultInfoEXT = 1000341002,
	VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT,
	VkPhysicalDeviceRgba10x6FormatsFeaturesEXT = 1000344000,
	VkDirectfbSurfaceCreateInfoEXT = 1000346000,
	VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE = VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT,
	VkMutableDescriptorTypeCreateInfoVALVE = VkMutableDescriptorTypeCreateInfoEXT,
	VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = 1000352000,
	VkVertexInputBindingDescription2EXT = 1000352001,
	VkVertexInputAttributeDescription2EXT = 1000352002,
	VkPhysicalDeviceDrmPropertiesEXT = 1000353000,
	VkPhysicalDeviceAddressBindingReportFeaturesEXT = 1000354000,
	VkDeviceAddressBindingCallbackDataEXT = 1000354001,
	VkPhysicalDeviceDepthClipControlFeaturesEXT = 1000355000,
	VkPipelineViewportDepthClipControlCreateInfoEXT = 1000355001,
	VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = 1000356000,
	VkFormatProperties3KHR = VkFormatProperties3,
	VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT = VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR,
	VkImportMemoryZirconHandleInfoFUCHSIA = 1000364000,
	VkMemoryZirconHandlePropertiesFUCHSIA = 1000364001,
	VkMemoryGetZirconHandleInfoFUCHSIA = 1000364002,
	VkImportSemaphoreZirconHandleInfoFUCHSIA = 1000365000,
	VkSemaphoreGetZirconHandleInfoFUCHSIA = 1000365001,
	VkBufferCollectionCreateInfoFUCHSIA = 1000366000,
	VkImportMemoryBufferCollectionFUCHSIA = 1000366001,
	VkBufferCollectionImageCreateInfoFUCHSIA = 1000366002,
	VkBufferCollectionPropertiesFUCHSIA = 1000366003,
	VkBufferConstraintsInfoFUCHSIA = 1000366004,
	VkBufferCollectionBufferCreateInfoFUCHSIA = 1000366005,
	VkImageConstraintsInfoFUCHSIA = 1000366006,
	VkImageFormatConstraintsInfoFUCHSIA = 1000366007,
	VkSysmemColorSpaceFUCHSIA = 1000366008,
	VkBufferCollectionConstraintsInfoFUCHSIA = 1000366009,
	VkSubpassShadingPipelineCreateInfoHUAWEI = 1000369000,
	VkPhysicalDeviceSubpassShadingFeaturesHUAWEI = 1000369001,
	VkPhysicalDeviceSubpassShadingPropertiesHUAWEI = 1000369002,
	VkPhysicalDeviceInvocationMaskFeaturesHUAWEI = 1000370000,
	VkMemoryGetRemoteAddressInfoNV = 1000371000,
	VkPhysicalDeviceExternalMemoryRdmaFeaturesNV = 1000371001,
	VkPipelinePropertiesIdentifierEXT = 1000372000,
	VkPhysicalDevicePipelinePropertiesFeaturesEXT = 1000372001,
	VkPipelineInfoEXT = VkPipelineInfoKHR,
	VkPhysicalDeviceFrameBoundaryFeaturesEXT = 1000375000,
	VkFrameBoundaryEXT = 1000375001,
	VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = 1000376000,
	VkSubpassResolvePerformanceQueryEXT = 1000376001,
	VkMultisampledRenderToSingleSampledInfoEXT = 1000376002,
	VkPhysicalDeviceExtendedDynamicState2FeaturesEXT = 1000377000, // Not promoted to 1.3
	VkScreenSurfaceCreateInfoQNX = 1000378000,
	VkPhysicalDeviceColorWriteEnableFeaturesEXT = 1000381000,
	VkPipelineColorWriteCreateInfoEXT = 1000381001,
	VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = 1000382000,
	VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = 1000386000,
	VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT = VkPhysicalDeviceGlobalPriorityQueryFeatures,
	VkQueueFamilyGlobalPriorityPropertiesEXT = VkQueueFamilyGlobalPriorityProperties,
	VkPhysicalDeviceImageViewMinLodFeaturesEXT = 1000391000,
	VkImageViewMinLodCreateInfoEXT = 1000391001,
	VkPhysicalDeviceMultiDrawFeaturesEXT = 1000392000,
	VkPhysicalDeviceMultiDrawPropertiesEXT = 1000392001,
	VkPhysicalDeviceImage2dViewOf3dFeaturesEXT = 1000393000,
	VkPhysicalDeviceShaderTileImageFeaturesEXT = 1000395000,
	VkPhysicalDeviceShaderTileImagePropertiesEXT = 1000395001,
	VkMicromapBuildInfoEXT = 1000396000,
	VkMicromapVersionInfoEXT = 1000396001,
	VkCopyMicromapInfoEXT = 1000396002,
	VkCopyMicromapToMemoryInfoEXT = 1000396003,
	VkCopyMemoryToMicromapInfoEXT = 1000396004,
	VkPhysicalDeviceOpacityMicromapFeaturesEXT = 1000396005,
	VkPhysicalDeviceOpacityMicromapPropertiesEXT = 1000396006,
	VkMicromapCreateInfoEXT = 1000396007,
	VkMicromapBuildSizesInfoEXT = 1000396008,
	VkAccelerationStructureTrianglesOpacityMicromapEXT = 1000396009,
	VkPhysicalDeviceDisplacementMicromapFeaturesNV = 1000397000,
	VkPhysicalDeviceDisplacementMicromapPropertiesNV = 1000397001,
	VkAccelerationStructureTrianglesDisplacementMicromapNV = 1000397002,
	VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI = 1000404000,
	VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI = 1000404001,
	VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI = 1000404002,
	VkPhysicalDeviceBorderColorSwizzleFeaturesEXT = 1000411000,
	VkSamplerBorderColorComponentMappingCreateInfoEXT = 1000411001,
	VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = 1000412000,
	VkPhysicalDeviceMaintenance4FeaturesKHR = VkPhysicalDeviceMaintenance4Features,
	VkPhysicalDeviceMaintenance4PropertiesKHR = VkPhysicalDeviceMaintenance4Properties,
	VkDeviceBufferMemoryRequirementsKHR = VkDeviceBufferMemoryRequirements,
	VkDeviceImageMemoryRequirementsKHR = VkDeviceImageMemoryRequirements,
	VkPhysicalDeviceShaderCorePropertiesARM = 1000415000,
	VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR = VkPhysicalDeviceShaderSubgroupRotateFeatures,
	VkDeviceQueueShaderCoreControlCreateInfoARM = 1000417000,
	VkPhysicalDeviceSchedulingControlsFeaturesARM = 1000417001,
	VkPhysicalDeviceSchedulingControlsPropertiesARM = 1000417002,
	VkPhysicalDeviceImageSlicedViewOf3dFeaturesEXT = 1000418000,
	VkImageViewSlicedCreateInfoEXT = 1000418001,
	VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = 1000420000,
	VkDescriptorSetBindingReferenceVALVE = 1000420001,
	VkDescriptorSetLayoutHostMappingInfoVALVE = 1000420002,
	VkPhysicalDeviceDepthClampZeroOneFeaturesEXT = VkPhysicalDeviceDepthClampZeroOneFeaturesKHR,
	VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = 1000422000,
	VkPhysicalDeviceRenderPassStripedFeaturesARM = 1000424000,
	VkPhysicalDeviceRenderPassStripedPropertiesARM = 1000424001,
	VkRenderPassStripeBeginInfoARM = 1000424002,
	VkRenderPassStripeInfoARM = 1000424003,
	VkRenderPassStripeSubmitInfoARM = 1000424004,
	VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT,
	VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT,
	VkSubpassFragmentDensityMapOffsetEndInfoQCOM = VkRenderPassFragmentDensityMapOffsetEndInfoEXT,
	VkPhysicalDeviceCopyMemoryIndirectFeaturesNV = 1000426000,
	VkPhysicalDeviceCopyMemoryIndirectPropertiesNV = 1000426001,
	VkPhysicalDeviceMemoryDecompressionFeaturesNV = 1000427000,
	VkPhysicalDeviceMemoryDecompressionPropertiesNV = 1000427001,
	VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = 1000428000,
	VkComputePipelineIndirectBufferInfoNV = 1000428001,
	VkPipelineIndirectDeviceAddressInfoNV = 1000428002,
	VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = 1000429008,
	VkAccelerationStructureGeometryLinearSweptSpheresDataNV = 1000429009,
	VkAccelerationStructureGeometrySpheresDataNV = 1000429010,
	VkPhysicalDeviceLinearColorAttachmentFeaturesNV = 1000430000,
	VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = 1000434000,
	VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = 1000437000,
	VkPhysicalDeviceImageProcessingFeaturesQCOM = 1000440000,
	VkPhysicalDeviceImageProcessingPropertiesQCOM = 1000440001,
	VkImageViewSampleWeightCreateInfoQCOM = 1000440002,
	VkPhysicalDeviceNestedCommandBufferFeaturesEXT = 1000451000,
	VkPhysicalDeviceNestedCommandBufferPropertiesEXT = 1000451001,
	VkExternalMemoryAcquireUnmodifiedEXT = 1000453000,
	VkPhysicalDeviceExtendedDynamicState3FeaturesEXT = 1000455000,
	VkPhysicalDeviceExtendedDynamicState3PropertiesEXT = 1000455001,
	VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = 1000458000,
	VkRenderPassCreationControlEXT = 1000458001,
	VkRenderPassCreationFeedbackCreateInfoEXT = 1000458002,
	VkRenderPassSubpassFeedbackCreateInfoEXT = 1000458003,
	VkDirectDriverLoadingInfoLUNARG = 1000459000,
	VkDirectDriverLoadingListLUNARG = 1000459001,
	VkTensorCreateInfoARM = 1000460000,
	VkTensorViewCreateInfoARM = 1000460001,
	VkBindTensorMemoryInfoARM = 1000460002,
	VkWriteDescriptorSetTensorARM = 1000460003,
	VkPhysicalDeviceTensorPropertiesARM = 1000460004,
	VkTensorFormatPropertiesARM = 1000460005,
	VkTensorDescriptionARM = 1000460006,
	VkTensorMemoryRequirementsInfoARM = 1000460007,
	VkTensorMemoryBarrierARM = 1000460008,
	VkPhysicalDeviceTensorFeaturesARM = 1000460009,
	VkDeviceTensorMemoryRequirementsARM = 1000460010,
	VkCopyTensorInfoARM = 1000460011,
	VkTensorCopyARM = 1000460012,
	VkTensorDependencyInfoARM = 1000460013,
	VkMemoryDedicatedAllocateInfoTensorARM = 1000460014,
	VkPhysicalDeviceExternalTensorInfoARM = 1000460015,
	VkExternalTensorPropertiesARM = 1000460016,
	VkExternalMemoryTensorCreateInfoARM = 1000460017,
	VkPhysicalDeviceDescriptorBufferTensorFeaturesARM = 1000460018,
	VkPhysicalDeviceDescriptorBufferTensorPropertiesARM = 1000460019,
	VkDescriptorGetTensorInfoARM = 1000460020,
	VkTensorCaptureDescriptorDataInfoARM = 1000460021,
	VkTensorViewCaptureDescriptorDataInfoARM = 1000460022,
	VkFrameBoundaryTensorsARM = 1000460023,
	VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = 1000462000,
	VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT = 1000462001,
	VkPipelineShaderStageModuleIdentifierCreateInfoEXT = 1000462002,
	VkShaderModuleIdentifierEXT = 1000462003,
	VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = 1000342000,
	VkPhysicalDeviceOpticalFlowFeaturesNV = 1000464000,
	VkPhysicalDeviceOpticalFlowPropertiesNV = 1000464001,
	VkOpticalFlowImageFormatInfoNV = 1000464002,
	VkOpticalFlowImageFormatPropertiesNV = 1000464003,
	VkOpticalFlowSessionCreateInfoNV = 1000464004,
	VkOpticalFlowExecuteInfoNV = 1000464005,
	VkOpticalFlowSessionCreatePrivateDataInfoNV = 1000464010,
	VkPhysicalDeviceLegacyDitheringFeaturesEXT = 1000465000,
	VkPhysicalDevicePipelineProtectedAccessFeaturesEXT = VkPhysicalDevicePipelineProtectedAccessFeatures,
	VkPhysicalDeviceExternalFormatResolveFeaturesANDROID = 1000468000,
	VkPhysicalDeviceExternalFormatResolvePropertiesANDROID = 1000468001,
	VkAndroidHardwareBufferFormatResolvePropertiesANDROID = 1000468002,
	VkPhysicalDeviceMaintenance5FeaturesKHR = VkPhysicalDeviceMaintenance5Features,
	VkPhysicalDeviceMaintenance5PropertiesKHR = VkPhysicalDeviceMaintenance5Properties,
	VkRenderingAreaInfoKHR = VkRenderingAreaInfo,
	VkDeviceImageSubresourceInfoKHR = VkDeviceImageSubresourceInfo,
	VkSubresourceLayout2KHR = VkSubresourceLayout2,
	VkImageSubresource2KHR = VkImageSubresource2,
	VkPipelineCreateFlags2CreateInfoKHR = VkPipelineCreateFlags2CreateInfo,
	VkBufferUsageFlags2CreateInfoKHR = VkBufferUsageFlags2CreateInfo,
	VkPhysicalDeviceAntiLagFeaturesAMD = 1000476000,
	VkAntiLagDataAMD = 1000476001,
	VkAntiLagPresentationInfoAMD = 1000476002,
	VkSurfaceCapabilitiesPresentId2KHR = 1000479000,
	VkPresentId2KHR = 1000479001,
	VkPhysicalDevicePresentId2FeaturesKHR = 1000479002,
	VkSurfaceCapabilitiesPresentWait2KHR = 1000480000,
	VkPhysicalDevicePresentWait2FeaturesKHR = 1000480001,
	VkPresentWait2InfoKHR = 1000480002,
	VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = 1000481000,
	VkPhysicalDeviceShaderObjectFeaturesEXT = 1000482000,
	VkPhysicalDeviceShaderObjectPropertiesEXT = 1000482001,
	VkShaderCreateInfoEXT = 1000482002,
	VkShaderRequiredSubgroupSizeCreateInfoEXT = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo,
	VkPhysicalDevicePipelineBinaryFeaturesKHR = 1000483000,
	VkPipelineBinaryCreateInfoKHR = 1000483001,
	VkPipelineBinaryInfoKHR = 1000483002,
	VkPipelineBinaryKeyKHR = 1000483003,
	VkPhysicalDevicePipelineBinaryPropertiesKHR = 1000483004,
	VkReleaseCapturedPipelineDataInfoKHR = 1000483005,
	VkPipelineBinaryDataInfoKHR = 1000483006,
	VkPipelineCreateInfoKHR = 1000483007,
	VkDevicePipelineBinaryInternalCacheControlKHR = 1000483008,
	VkPipelineBinaryHandlesInfoKHR = 1000483009,
	VkPhysicalDeviceTilePropertiesFeaturesQCOM = 1000484000,
	VkTilePropertiesQCOM = 1000484001,
	VkPhysicalDeviceAmigoProfilingFeaturesSEC = 1000485000,
	VkAmigoProfilingSubmitInfoSEC = 1000485001,
	VkSurfacePresentModeKHR = 1000274000,
	VkSurfacePresentScalingCapabilitiesKHR = 1000274001,
	VkSurfacePresentModeCompatibilityKHR = 1000274002,
	VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR = 1000275000,
	VkSwapchainPresentFenceInfoKHR = 1000275001,
	VkSwapchainPresentModesCreateInfoKHR = 1000275002,
	VkSwapchainPresentModeInfoKHR = 1000275003,
	VkSwapchainPresentScalingCreateInfoKHR = 1000275004,
	VkReleaseSwapchainImagesInfoKHR = 1000275005,
	VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = 1000488000,
	VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV = 1000490000,
	VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV = 1000490001,
	VkPhysicalDeviceCooperativeVectorFeaturesNV = 1000491000,
	VkPhysicalDeviceCooperativeVectorPropertiesNV = 1000491001,
	VkCooperativeVectorPropertiesNV = 1000491002,
	VkConvertCooperativeVectorMatrixInfoNV = 1000491004,
	VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = 1000492000,
	VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV = 1000492001,
	VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = 1000351000,
	VkMutableDescriptorTypeCreateInfoEXT = 1000351002,
	VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT = 1000495000,
	VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT = 1000495001,
	VkLayerSettingsCreateInfoEXT = 1000496000,
	VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = 1000497000,
	VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM = 1000497001,
	VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = 1000498000,
	VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = 1000499000,
	VkLatencySleepModeInfoNV = 1000505000,
	VkLatencySleepInfoNV = 1000505001,
	VkSetLatencyMarkerInfoNV = 1000505002,
	VkGetLatencyMarkerInfoNV = 1000505003,
	VkLatencyTimingsFrameReportNV = 1000505004,
	VkLatencySubmissionPresentIdNV = 1000505005,
	VkOutOfBandQueueTypeInfoNV = 1000505006,
	VkSwapchainLatencyCreateInfoNV = 1000505007,
	VkLatencySurfaceCapabilitiesNV = 1000505008,
	VkPhysicalDeviceCooperativeMatrixFeaturesKHR = 1000506000,
	VkCooperativeMatrixPropertiesKHR = 1000506001,
	VkPhysicalDeviceCooperativeMatrixPropertiesKHR = 1000506002,
	VkDataGraphPipelineCreateInfoARM = 1000507000,
	VkDataGraphPipelineSessionCreateInfoARM = 1000507001,
	VkDataGraphPipelineResourceInfoARM = 1000507002,
	VkDataGraphPipelineConstantARM = 1000507003,
	VkDataGraphPipelineSessionMemoryRequirementsInfoARM = 1000507004,
	VkBindDataGraphPipelineSessionMemoryInfoARM = 1000507005,
	VkPhysicalDeviceDataGraphFeaturesARM = 1000507006,
	VkDataGraphPipelineShaderModuleCreateInfoARM = 1000507007,
	VkDataGraphPipelinePropertyQueryResultARM = 1000507008,
	VkDataGraphPipelineInfoARM = 1000507009,
	VkDataGraphPipelineCompilerControlCreateInfoARM = 1000507010,
	VkDataGraphPipelineSessionBindPointRequirementsInfoARM = 1000507011,
	VkDataGraphPipelineSessionBindPointRequirementARM = 1000507012,
	VkDataGraphPipelineIdentifierCreateInfoARM = 1000507013,
	VkDataGraphPipelineDispatchInfoARM = 1000507014,
	VkDataGraphProcessingEngineCreateInfoARM = 1000507016,
	VkQueueFamilyDataGraphProcessingEnginePropertiesARM = 1000507017,
	VkQueueFamilyDataGraphPropertiesARM = 1000507018,
	VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = 1000507019,
	VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = 1000507015,
	VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = 1000510000,
	VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = 1000510001,
	VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR = 1000201000,
	VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR = 1000511000,
	VkVideoDecodeAv1CapabilitiesKHR = 1000512000,
	VkVideoDecodeAv1PictureInfoKHR = 1000512001,
	VkVideoDecodeAv1ProfileInfoKHR = 1000512003,
	VkVideoDecodeAv1SessionParametersCreateInfoKHR = 1000512004,
	VkVideoDecodeAv1DpbSlotInfoKHR = 1000512005,
	VkVideoEncodeAv1CapabilitiesKHR = 1000513000,
	VkVideoEncodeAv1SessionParametersCreateInfoKHR = 1000513001,
	VkVideoEncodeAv1PictureInfoKHR = 1000513002,
	VkVideoEncodeAv1DpbSlotInfoKHR = 1000513003,
	VkPhysicalDeviceVideoEncodeAv1FeaturesKHR = 1000513004,
	VkVideoEncodeAv1ProfileInfoKHR = 1000513005,
	VkVideoEncodeAv1RateControlInfoKHR = 1000513006,
	VkVideoEncodeAv1RateControlLayerInfoKHR = 1000513007,
	VkVideoEncodeAv1QualityLevelPropertiesKHR = 1000513008,
	VkVideoEncodeAv1SessionCreateInfoKHR = 1000513009,
	VkVideoEncodeAv1GopRemainingFrameInfoKHR = 1000513010,
	VkPhysicalDeviceVideoDecodeVp9FeaturesKHR = 1000514000,
	VkVideoDecodeVp9CapabilitiesKHR = 1000514001,
	VkVideoDecodeVp9PictureInfoKHR = 1000514002,
	VkVideoDecodeVp9ProfileInfoKHR = 1000514003,
	VkPhysicalDeviceVideoMaintenance1FeaturesKHR = 1000515000,
	VkVideoInlineQueryInfoKHR = 1000515001,
	VkPhysicalDevicePerStageDescriptorSetFeaturesNV = 1000516000,
	VkPhysicalDeviceImageProcessing2FeaturesQCOM = 1000518000,
	VkPhysicalDeviceImageProcessing2PropertiesQCOM = 1000518001,
	VkSamplerBlockMatchWindowCreateInfoQCOM = 1000518002,
	VkSamplerCubicWeightsCreateInfoQCOM = 1000519000,
	VkPhysicalDeviceCubicWeightsFeaturesQCOM = 1000519001,
	VkBlitImageCubicWeightsInfoQCOM = 1000519002,
	VkPhysicalDeviceYcbcrDegammaFeaturesQCOM = 1000520000,
	VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = 1000520001,
	VkPhysicalDeviceCubicClampFeaturesQCOM = 1000521000,
	VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = 1000524000,
	VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR = VkPhysicalDeviceVertexAttributeDivisorProperties,
	VkPipelineVertexInputDivisorStateCreateInfoKHR = VkPipelineVertexInputDivisorStateCreateInfo,
	VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR = VkPhysicalDeviceVertexAttributeDivisorFeatures,
	VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR = 1000527000,
	VkAttachmentFeedbackLoopInfoEXT = 1000527001,
	VkPhysicalDeviceShaderFloatControls2FeaturesKHR = VkPhysicalDeviceShaderFloatControls2Features,
	VkScreenBufferPropertiesQNX = 1000529000,
	VkScreenBufferFormatPropertiesQNX = 1000529001,
	VkImportScreenBufferInfoQNX = 1000529002,
	VkExternalFormatQNX = 1000529003,
	VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX = 1000529004,
	VkPhysicalDeviceLayeredDriverPropertiesMSFT = 1000530000,
	VkPhysicalDeviceIndexTypeUint8FeaturesKHR = VkPhysicalDeviceIndexTypeUint8Features,
	VkPhysicalDeviceLineRasterizationFeaturesKHR = VkPhysicalDeviceLineRasterizationFeatures,
	VkPipelineRasterizationLineStateCreateInfoKHR = VkPipelineRasterizationLineStateCreateInfo,
	VkPhysicalDeviceLineRasterizationPropertiesKHR = VkPhysicalDeviceLineRasterizationProperties,
	VkCalibratedTimestampInfoKHR = 1000184000,
	VkPhysicalDeviceShaderExpectAssumeFeaturesKHR = VkPhysicalDeviceShaderExpectAssumeFeatures,
	VkPhysicalDeviceMaintenance6FeaturesKHR = VkPhysicalDeviceMaintenance6Features,
	VkPhysicalDeviceMaintenance6PropertiesKHR = VkPhysicalDeviceMaintenance6Properties,
	VkBindMemoryStatusKHR = VkBindMemoryStatus,
	VkBindDescriptorSetsInfoKHR = VkBindDescriptorSetsInfo,
	VkPushConstantsInfoKHR = VkPushConstantsInfo,
	VkPushDescriptorSetInfoKHR = VkPushDescriptorSetInfo,
	VkPushDescriptorSetWithTemplateInfoKHR = VkPushDescriptorSetWithTemplateInfo,
	VkSetDescriptorBufferOffsetsInfoEXT = 1000545007,
	VkBindDescriptorBufferEmbeddedSamplersInfoEXT = 1000545008,
	VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV = 1000546000,
	VkPhysicalDeviceTileMemoryHeapFeaturesQCOM = 1000547000,
	VkPhysicalDeviceTileMemoryHeapPropertiesQCOM = 1000547001,
	VkTileMemoryRequirementsQCOM = 1000547002,
	VkTileMemoryBindInfoQCOM = 1000547003,
	VkTileMemorySizeInfoQCOM = 1000547004,
	VkDisplaySurfaceStereoCreateInfoNV = 1000551000,
	VkDisplayModeStereoPropertiesNV = 1000551001,
	VkVideoEncodeIntraRefreshCapabilitiesKHR = 1000552000,
	VkVideoEncodeSessionIntraRefreshCreateInfoKHR = 1000552001,
	VkVideoEncodeIntraRefreshInfoKHR = 1000552002,
	VkVideoReferenceIntraRefreshInfoKHR = 1000552003,
	VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = 1000552004,
	VkVideoEncodeQuantizationMapCapabilitiesKHR = 1000553000,
	VkVideoFormatQuantizationMapPropertiesKHR = 1000553001,
	VkVideoEncodeQuantizationMapInfoKHR = 1000553002,
	VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR = 1000553005,
	VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = 1000553009,
	VkVideoEncodeH264QuantizationMapCapabilitiesKHR = 1000553003,
	VkVideoEncodeH265QuantizationMapCapabilitiesKHR = 1000553004,
	VkVideoFormatH265QuantizationMapPropertiesKHR = 1000553006,
	VkVideoEncodeAv1QuantizationMapCapabilitiesKHR = 1000553007,
	VkVideoFormatAv1QuantizationMapPropertiesKHR = 1000553008,
	VkPhysicalDeviceRawAccessChainsFeaturesNV = 1000555000,
	VkExternalComputeQueueDeviceCreateInfoNV = 1000556000,
	VkExternalComputeQueueCreateInfoNV = 1000556001,
	VkExternalComputeQueueDataParamsNV = 1000556002,
	VkPhysicalDeviceExternalComputeQueuePropertiesNV = 1000556003,
	VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = 1000558000,
	VkPhysicalDeviceCommandBufferInheritanceFeaturesNV = 1000559000,
	VkPhysicalDeviceMaintenance7FeaturesKHR = 1000562000,
	VkPhysicalDeviceMaintenance7PropertiesKHR = 1000562001,
	VkPhysicalDeviceLayeredApiPropertiesListKHR = 1000562002,
	VkPhysicalDeviceLayeredApiPropertiesKHR = 1000562003,
	VkPhysicalDeviceLayeredApiVulkanPropertiesKHR = 1000562004,
	VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = 1000563000,
	VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT = 1000564000,
	VkPhysicalDeviceShaderFloat8FeaturesEXT = 1000567000,
	VkPhysicalDeviceRayTracingValidationFeaturesNV = 1000568000,
	VkPhysicalDeviceClusterAccelerationStructureFeaturesNV = 1000569000,
	VkPhysicalDeviceClusterAccelerationStructurePropertiesNV = 1000569001,
	VkClusterAccelerationStructureClustersBottomLevelInputNV = 1000569002,
	VkClusterAccelerationStructureTriangleClusterInputNV = 1000569003,
	VkClusterAccelerationStructureMoveObjectsInputNV = 1000569004,
	VkClusterAccelerationStructureInputInfoNV = 1000569005,
	VkClusterAccelerationStructureCommandsInfoNV = 1000569006,
	VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV = 1000569007,
	VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV = 1000570000,
	VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV = 1000570001,
	VkWriteDescriptorSetPartitionedAccelerationStructureNV = 1000570002,
	VkPartitionedAccelerationStructureInstancesInputNV = 1000570003,
	VkBuildPartitionedAccelerationStructureInfoNV = 1000570004,
	VkPartitionedAccelerationStructureFlagsNV = 1000570005,
	VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = 1000572000,
	VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = 1000572001,
	VkGeneratedCommandsMemoryRequirementsInfoEXT = 1000572002,
	VkIndirectExecutionSetCreateInfoEXT = 1000572003,
	VkGeneratedCommandsInfoEXT = 1000572004,
	VkIndirectCommandsLayoutCreateInfoEXT = 1000572006,
	VkIndirectCommandsLayoutTokenEXT = 1000572007,
	VkWriteIndirectExecutionSetPipelineEXT = 1000572008,
	VkWriteIndirectExecutionSetShaderEXT = 1000572009,
	VkIndirectExecutionSetPipelineInfoEXT = 1000572010,
	VkIndirectExecutionSetShaderInfoEXT = 1000572011,
	VkIndirectExecutionSetShaderLayoutInfoEXT = 1000572012,
	VkGeneratedCommandsPipelineInfoEXT = 1000572013,
	VkGeneratedCommandsShaderInfoEXT = 1000572014,
	VkPhysicalDeviceMaintenance8FeaturesKHR = 1000574000,
	VkMemoryBarrierAccessFlags3KHR = 1000574002,
	VkPhysicalDeviceImageAlignmentControlFeaturesMESA = 1000575000,
	VkPhysicalDeviceImageAlignmentControlPropertiesMESA = 1000575001,
	VkImageAlignmentControlCreateInfoMESA = 1000575002,
	VkPhysicalDeviceDepthClampControlFeaturesEXT = 1000582000,
	VkPipelineViewportDepthClampControlCreateInfoEXT = 1000582001,
	VkPhysicalDeviceMaintenance9FeaturesKHR = 1000584000,
	VkPhysicalDeviceMaintenance9PropertiesKHR = 1000584001,
	VkQueueFamilyOwnershipTransferPropertiesKHR = 1000584002,
	VkPhysicalDeviceVideoMaintenance2FeaturesKHR = 1000586000,
	VkVideoDecodeH264InlineSessionParametersInfoKHR = 1000586001,
	VkVideoDecodeH265InlineSessionParametersInfoKHR = 1000586002,
	VkVideoDecodeAv1InlineSessionParametersInfoKHR = 1000586003,
	VkOhSurfaceCreateInfoOHOS = 1000587000,
	VkPhysicalDeviceHdrVividFeaturesHUAWEI = 1000590000,
	VkHdrVividDynamicMetadataHUAWEI = 1000590001,
	VkPhysicalDeviceCooperativeMatrix2FeaturesNV = 1000593000,
	VkCooperativeMatrixFlexibleDimensionsPropertiesNV = 1000593001,
	VkPhysicalDeviceCooperativeMatrix2PropertiesNV = 1000593002,
	VkPhysicalDevicePipelineOpacityMicromapFeaturesARM = 1000596000,
	VkImportMemoryMetalHandleInfoEXT = 1000602000,
	VkMemoryMetalHandlePropertiesEXT = 1000602001,
	VkMemoryGetMetalHandleInfoEXT = 1000602002,
	VkPhysicalDeviceDepthClampZeroOneFeaturesKHR = 1000421000,
	VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT = 1000608000,
	VkPhysicalDeviceFormatPackFeaturesARM = 1000609000,
	VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = 1000611000,
	VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = 1000611001,
	VkPipelineFragmentDensityMapLayeredCreateInfoVALVE = 1000611002,
	VkPhysicalDeviceRobustness2FeaturesKHR = 1000286000,
	VkPhysicalDeviceRobustness2PropertiesKHR = 1000286001,
	VkSetPresentConfigNV = 1000613000,
	VkPhysicalDevicePresentMeteringFeaturesNV = 1000613001,
	VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = 1000425000,
	VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = 1000425001,
	VkRenderPassFragmentDensityMapOffsetEndInfoEXT = 1000425002,
	VkRenderingEndInfoEXT = 1000619003,
	VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = 1000620000,
	VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = 1000361000,
	VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = 1000637000,
}

// API constants
static { public const uint32 VK_ATTACHMENT_UNUSED = (.)(~0U); }
static { public const uint32 VK_FALSE = 0; }
static { public const float VK_LOD_CLAMP_NONE = 1000.0F; }
static { public const uint32 VK_QUEUE_FAMILY_IGNORED = (.)(~0U); }
static { public const uint32 VK_REMAINING_ARRAY_LAYERS = (.)(~0U); }
static { public const uint32 VK_REMAINING_MIP_LEVELS = (.)(~0U); }
static { public const uint32 VK_SUBPASS_EXTERNAL = (.)(~0U); }
static { public const uint32 VK_TRUE = 1; }
static { public const uint64 VK_WHOLE_SIZE = (.)(~0UL); }
static { public const uint32 VK_MAX_MEMORY_TYPES = 32; }
static { public const uint32 VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = 256; }
static { public const uint32 VK_UUID_SIZE = 16; }
static { public const uint32 VK_MAX_EXTENSION_NAME_SIZE = 256; }
static { public const uint32 VK_MAX_DESCRIPTION_SIZE = 256; }
static { public const uint32 VK_MAX_MEMORY_HEAPS = 16; } // The maximum number of unique memory heaps, each of which supporting 1 or more memory types

[AllowDuplicates] enum VkPipelineCacheHeaderVersion : int32
{
	One = 1,
}

// These types are part of the API, though not directly used in API commands or data structures
[CRepr] struct VkBaseInStructure
{
	public VkStructureType sType;
	public VkBaseInStructure* pNext;

	public this(VkStructureType sType, VkBaseInStructure* pNext = null)
	{
		this.sType = sType;
		this.pNext = pNext;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkBaseOutStructure
{
	public VkStructureType sType;
	public VkBaseOutStructure* pNext;

	public this(VkStructureType sType, VkBaseOutStructure* pNext = null)
	{
		this.sType = sType;
		this.pNext = pNext;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkBufferMemoryBarrier
{
	public const VkStructureType SType = .VkBufferMemoryBarrier;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAccessFlags srcAccessMask; // Memory accesses from the source of the dependency to synchronize
	public VkAccessFlags dstAccessMask; // Memory accesses from the destination of the dependency to synchronize
	public uint32 srcQueueFamilyIndex; // Queue family to transition ownership from
	public uint32 dstQueueFamilyIndex; // Queue family to transition ownership to
	public VkBuffer buffer; // Buffer to sync
	public VkDeviceSize offset; // Offset within the buffer to sync
	public VkDeviceSize size; // Amount of bytes to sync

	public this(void* pNext, VkAccessFlags srcAccessMask, VkAccessFlags dstAccessMask, uint32 srcQueueFamilyIndex, uint32 dstQueueFamilyIndex, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size)
	{
		this.pNext = pNext;
		this.srcAccessMask = srcAccessMask;
		this.dstAccessMask = dstAccessMask;
		this.srcQueueFamilyIndex = srcQueueFamilyIndex;
		this.dstQueueFamilyIndex = dstQueueFamilyIndex;
		this.buffer = buffer;
		this.offset = offset;
		this.size = size;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDispatchIndirectCommand
{
	public uint32 x;
	public uint32 y;
	public uint32 z;

	public this(uint32 x, uint32 y, uint32 z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkDrawIndexedIndirectCommand
{
	public uint32 indexCount;
	public uint32 instanceCount;
	public uint32 firstIndex;
	public int32 vertexOffset;
	public uint32 firstInstance;

	public this(uint32 indexCount, uint32 instanceCount, uint32 firstIndex, int32 vertexOffset, uint32 firstInstance)
	{
		this.indexCount = indexCount;
		this.instanceCount = instanceCount;
		this.firstIndex = firstIndex;
		this.vertexOffset = vertexOffset;
		this.firstInstance = firstInstance;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkDrawIndirectCommand
{
	public uint32 vertexCount;
	public uint32 instanceCount;
	public uint32 firstVertex;
	public uint32 firstInstance;

	public this(uint32 vertexCount, uint32 instanceCount, uint32 firstVertex, uint32 firstInstance)
	{
		this.vertexCount = vertexCount;
		this.instanceCount = instanceCount;
		this.firstVertex = firstVertex;
		this.firstInstance = firstInstance;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkImageMemoryBarrier
{
	public const VkStructureType SType = .VkImageMemoryBarrier;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAccessFlags srcAccessMask; // Memory accesses from the source of the dependency to synchronize
	public VkAccessFlags dstAccessMask; // Memory accesses from the destination of the dependency to synchronize
	public VkImageLayout oldLayout; // Current layout of the image
	public VkImageLayout newLayout; // New layout to transition the image to
	public uint32 srcQueueFamilyIndex; // Queue family to transition ownership from
	public uint32 dstQueueFamilyIndex; // Queue family to transition ownership to
	public VkImage image; // Image to sync
	public VkImageSubresourceRange subresourceRange; // Subresource range to sync

	public this(void* pNext, VkAccessFlags srcAccessMask, VkAccessFlags dstAccessMask, VkImageLayout oldLayout, VkImageLayout newLayout, uint32 srcQueueFamilyIndex, uint32 dstQueueFamilyIndex, VkImage image, VkImageSubresourceRange subresourceRange)
	{
		this.pNext = pNext;
		this.srcAccessMask = srcAccessMask;
		this.dstAccessMask = dstAccessMask;
		this.oldLayout = oldLayout;
		this.newLayout = newLayout;
		this.srcQueueFamilyIndex = srcQueueFamilyIndex;
		this.dstQueueFamilyIndex = dstQueueFamilyIndex;
		this.image = image;
		this.subresourceRange = subresourceRange;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryBarrier
{
	public const VkStructureType SType = .VkMemoryBarrier;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAccessFlags srcAccessMask; // Memory accesses from the source of the dependency to synchronize
	public VkAccessFlags dstAccessMask; // Memory accesses from the destination of the dependency to synchronize

	public this(void* pNext = null, VkAccessFlags srcAccessMask = 0, VkAccessFlags dstAccessMask = 0)
	{
		this.pNext = pNext;
		this.srcAccessMask = srcAccessMask;
		this.dstAccessMask = dstAccessMask;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkObjectType : int32
{
	Unknown = 0,
	Instance = 1,
	PhysicalDevice = 2,
	Device = 3,
	Queue = 4,
	Semaphore = 5,
	CommandBuffer = 6,
	Fence = 7,
	DeviceMemory = 8,
	Buffer = 9,
	Image = 10,
	Event = 11,
	QueryPool = 12,
	BufferView = 13,
	ImageView = 14,
	ShaderModule = 15,
	PipelineCache = 16,
	PipelineLayout = 17,
	RenderPass = 18,
	Pipeline = 19,
	DescriptorSetLayout = 20,
	Sampler = 21,
	DescriptorPool = 22,
	DescriptorSet = 23,
	Framebuffer = 24,
	CommandPool = 25,
	SamplerYcbcrConversion = 1000156000,
	DescriptorUpdateTemplate = 1000085000,
	PrivateDataSlot = 1000295000,
	SurfaceKHR = 1000000000,
	SwapchainKHR = 1000001000,
	DisplayKHR = 1000002000,
	DisplayModeKHR = 1000002001,
	DebugReportCallbackEXT = 1000011000,
	VideoSessionKHR = 1000023000, // VkVideoSessionKHR
	VideoSessionParametersKHR = 1000023001, // VkVideoSessionParametersKHR
	CuModuleNVX = 1000029000,
	CuFunctionNVX = 1000029001,
	DescriptorUpdateTemplateKHR = DescriptorUpdateTemplate,
	DebugUtilsMessengerEXT = 1000128000,
	AccelerationStructureKHR = 1000150000,
	SamplerYcbcrConversionKHR = SamplerYcbcrConversion,
	ValidationCacheEXT = 1000160000,
	AccelerationStructureNV = 1000165000,
	PerformanceConfigurationINTEL = 1000210000,
	DeferredOperationKHR = 1000268000,
	IndirectCommandsLayoutNV = 1000277000,
	PrivateDataSlotEXT = PrivateDataSlot,
	CudaModuleNV = 1000307000,
	CudaFunctionNV = 1000307001,
	BufferCollectionFUCHSIA = 1000366000, // VkBufferCollectionFUCHSIA
	MicromapEXT = 1000396000,
	TensorARM = 1000460000,
	TensorViewARM = 1000460001,
	OpticalFlowSessionNV = 1000464000,
	ShaderEXT = 1000482000,
	PipelineBinaryKHR = 1000483000,
	DataGraphPipelineSessionARM = 1000507000,
	ExternalComputeQueueNV = 1000556000,
	IndirectCommandsLayoutEXT = 1000572000,
	IndirectExecutionSetEXT = 1000572001,
}

[CRepr] struct VkPipelineCacheHeaderVersionOne
{
	// The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.
	public uint32 headerSize;
	public VkPipelineCacheHeaderVersion headerVersion;
	public uint32 vendorID;
	public uint32 deviceID;
	public uint8[VK_UUID_SIZE] pipelineCacheUUID;

	public this(uint32 headerSize, VkPipelineCacheHeaderVersion headerVersion, uint32 vendorID, uint32 deviceID, uint8[VK_UUID_SIZE] pipelineCacheUUID)
	{
		this.headerSize = headerSize;
		this.headerVersion = headerVersion;
		this.vendorID = vendorID;
		this.deviceID = deviceID;
		this.pipelineCacheUUID = pipelineCacheUUID;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkVendorId : int32
{
	Khronos = 0x10000, // Khronos vendor ID
	VIV = 0x10001, // Vivante vendor ID
	VSI = 0x10002, // VeriSilicon vendor ID
	Kazan = 0x10003, // Kazan Software Renderer
	Codeplay = 0x10004, // Codeplay Software Ltd. vendor ID
	MESA = 0x10005, // Mesa vendor ID
	Pocl = 0x10006, // PoCL vendor ID
	Mobileye = 0x10007, // Mobileye vendor ID
}

// API version macros
static { public const uint32 VK_API_VERSION = VK_MAKE_API_VERSION(0, 1, 0, 0) /* Patch version should always be set to 0 */; }
static { public const uint32 VK_API_VERSION_1_0 = VK_MAKE_API_VERSION(0, 1, 0, 0)/* Patch version should always be set to 0 */; }
static { public const uint32 VK_HEADER_VERSION = 321; }
static { public const uint32 VK_HEADER_VERSION_COMPLETE = VK_MAKE_API_VERSION(0, 1, 4, VK_HEADER_VERSION); }
static { public static uint32 VK_MAKE_VERSION(uint32 major, uint32 minor, uint32 patch) => ((((uint32)(major)) << 22U) | (((uint32)(minor)) << 12U) | ((uint32)(patch))); }
static { public static uint32 VK_VERSION_MAJOR(uint32 version) => ((uint32)(version) >> 22U); }
static { public static uint32 VK_VERSION_MINOR(uint32 version) => (((uint32)(version) >> 12U) & 0x3FFU); }
static { public static uint32 VK_VERSION_PATCH(uint32 version) => ((uint32)(version) & 0xFFFU); }
static { public static uint32 VK_MAKE_API_VERSION(uint32 variant, uint32 major, uint32 minor, uint32 patch) => ((((uint32)(variant)) << 29U) | (((uint32)(major)) << 22U) | (((uint32)(minor)) << 12U) | ((uint32)(patch))); }
static { public static uint32 VK_API_VERSION_VARIANT(uint32 version) => ((uint32)(version) >> 29U); }
static { public static uint32 VK_API_VERSION_MAJOR(uint32 version) => (((uint32)(version) >> 22U) & 0x7FU); }
static { public static uint32 VK_API_VERSION_MINOR(uint32 version) => (((uint32)(version) >> 12U) & 0x3FFU); }
static { public static uint32 VK_API_VERSION_PATCH(uint32 version) => ((uint32)(version) & 0xFFFU); }

// Device initialization
[CallingConvention(VKAPI_PTR)] function void* PFN_vkAllocationFunction(void* pUserData, c_size size, c_size alignment, VkSystemAllocationScope allocationScope);
[CallingConvention(VKAPI_PTR)] function void PFN_vkFreeFunction(void* pUserData, void* pMemory);
[CallingConvention(VKAPI_PTR)] function void PFN_vkInternalAllocationNotification(void* pUserData, c_size size, VkInternalAllocationType allocationType, VkSystemAllocationScope allocationScope);
[CallingConvention(VKAPI_PTR)] function void PFN_vkInternalFreeNotification(void* pUserData, c_size size, VkInternalAllocationType allocationType, VkSystemAllocationScope allocationScope);
[CallingConvention(VKAPI_PTR)] function void* PFN_vkReallocationFunction(void* pUserData, void* pOriginal, c_size size, c_size alignment, VkSystemAllocationScope allocationScope);
[CallingConvention(VKAPI_PTR)] function void PFN_vkVoidFunction(void);

[CRepr] struct VkAllocationCallbacks
{
	public void* pUserData;
	public PFN_vkAllocationFunction pfnAllocation;
	public PFN_vkReallocationFunction pfnReallocation;
	public PFN_vkFreeFunction pfnFree;
	public PFN_vkInternalAllocationNotification pfnInternalAllocation;
	public PFN_vkInternalFreeNotification pfnInternalFree;

	public this(void* pUserData, PFN_vkAllocationFunction pfnAllocation, PFN_vkReallocationFunction pfnReallocation, PFN_vkFreeFunction pfnFree, PFN_vkInternalAllocationNotification pfnInternalAllocation = 0, PFN_vkInternalFreeNotification pfnInternalFree = 0)
	{
		this.pUserData = pUserData;
		this.pfnAllocation = pfnAllocation;
		this.pfnReallocation = pfnReallocation;
		this.pfnFree = pfnFree;
		this.pfnInternalAllocation = pfnInternalAllocation;
		this.pfnInternalFree = pfnInternalFree;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkApplicationInfo
{
	public const VkStructureType SType = .VkApplicationInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_char* pApplicationName;
	public uint32 applicationVersion;
	public c_char* pEngineName;
	public uint32 engineVersion;
	public uint32 apiVersion;

	public this(void* pNext, c_char* pApplicationName, uint32 applicationVersion, c_char* pEngineName, uint32 engineVersion, uint32 apiVersion)
	{
		this.pNext = pNext;
		this.pApplicationName = pApplicationName;
		this.applicationVersion = applicationVersion;
		this.pEngineName = pEngineName;
		this.engineVersion = engineVersion;
		this.apiVersion = apiVersion;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkFormat : int32
{
	UNDEFINED = 0,
	R4G4_UNORM_PACK8 = 1,
	R4G4B4A4_UNORM_PACK16 = 2,
	B4G4R4A4_UNORM_PACK16 = 3,
	R5G6B5_UNORM_PACK16 = 4,
	B5G6R5_UNORM_PACK16 = 5,
	R5G5B5A1_UNORM_PACK16 = 6,
	B5G5R5A1_UNORM_PACK16 = 7,
	A1R5G5B5_UNORM_PACK16 = 8,
	R8_UNORM = 9,
	R8_SNORM = 10,
	R8_USCALED = 11,
	R8_SSCALED = 12,
	R8_UINT = 13,
	R8_SINT = 14,
	R8_SRGB = 15,
	R8G8_UNORM = 16,
	R8G8_SNORM = 17,
	R8G8_USCALED = 18,
	R8G8_SSCALED = 19,
	R8G8_UINT = 20,
	R8G8_SINT = 21,
	R8G8_SRGB = 22,
	R8G8B8_UNORM = 23,
	R8G8B8_SNORM = 24,
	R8G8B8_USCALED = 25,
	R8G8B8_SSCALED = 26,
	R8G8B8_UINT = 27,
	R8G8B8_SINT = 28,
	R8G8B8_SRGB = 29,
	B8G8R8_UNORM = 30,
	B8G8R8_SNORM = 31,
	B8G8R8_USCALED = 32,
	B8G8R8_SSCALED = 33,
	B8G8R8_UINT = 34,
	B8G8R8_SINT = 35,
	B8G8R8_SRGB = 36,
	R8G8B8A8_UNORM = 37,
	R8G8B8A8_SNORM = 38,
	R8G8B8A8_USCALED = 39,
	R8G8B8A8_SSCALED = 40,
	R8G8B8A8_UINT = 41,
	R8G8B8A8_SINT = 42,
	R8G8B8A8_SRGB = 43,
	B8G8R8A8_UNORM = 44,
	B8G8R8A8_SNORM = 45,
	B8G8R8A8_USCALED = 46,
	B8G8R8A8_SSCALED = 47,
	B8G8R8A8_UINT = 48,
	B8G8R8A8_SINT = 49,
	B8G8R8A8_SRGB = 50,
	A8B8G8R8_UNORM_PACK32 = 51,
	A8B8G8R8_SNORM_PACK32 = 52,
	A8B8G8R8_USCALED_PACK32 = 53,
	A8B8G8R8_SSCALED_PACK32 = 54,
	A8B8G8R8_UINT_PACK32 = 55,
	A8B8G8R8_SINT_PACK32 = 56,
	A8B8G8R8_SRGB_PACK32 = 57,
	A2R10G10B10_UNORM_PACK32 = 58,
	A2R10G10B10_SNORM_PACK32 = 59,
	A2R10G10B10_USCALED_PACK32 = 60,
	A2R10G10B10_SSCALED_PACK32 = 61,
	A2R10G10B10_UINT_PACK32 = 62,
	A2R10G10B10_SINT_PACK32 = 63,
	A2B10G10R10_UNORM_PACK32 = 64,
	A2B10G10R10_SNORM_PACK32 = 65,
	A2B10G10R10_USCALED_PACK32 = 66,
	A2B10G10R10_SSCALED_PACK32 = 67,
	A2B10G10R10_UINT_PACK32 = 68,
	A2B10G10R10_SINT_PACK32 = 69,
	R16_UNORM = 70,
	R16_SNORM = 71,
	R16_USCALED = 72,
	R16_SSCALED = 73,
	R16_UINT = 74,
	R16_SINT = 75,
	R16_SFLOAT = 76,
	R16G16_UNORM = 77,
	R16G16_SNORM = 78,
	R16G16_USCALED = 79,
	R16G16_SSCALED = 80,
	R16G16_UINT = 81,
	R16G16_SINT = 82,
	R16G16_SFLOAT = 83,
	R16G16B16_UNORM = 84,
	R16G16B16_SNORM = 85,
	R16G16B16_USCALED = 86,
	R16G16B16_SSCALED = 87,
	R16G16B16_UINT = 88,
	R16G16B16_SINT = 89,
	R16G16B16_SFLOAT = 90,
	R16G16B16A16_UNORM = 91,
	R16G16B16A16_SNORM = 92,
	R16G16B16A16_USCALED = 93,
	R16G16B16A16_SSCALED = 94,
	R16G16B16A16_UINT = 95,
	R16G16B16A16_SINT = 96,
	R16G16B16A16_SFLOAT = 97,
	R32_UINT = 98,
	R32_SINT = 99,
	R32_SFLOAT = 100,
	R32G32_UINT = 101,
	R32G32_SINT = 102,
	R32G32_SFLOAT = 103,
	R32G32B32_UINT = 104,
	R32G32B32_SINT = 105,
	R32G32B32_SFLOAT = 106,
	R32G32B32A32_UINT = 107,
	R32G32B32A32_SINT = 108,
	R32G32B32A32_SFLOAT = 109,
	R64_UINT = 110,
	R64_SINT = 111,
	R64_SFLOAT = 112,
	R64G64_UINT = 113,
	R64G64_SINT = 114,
	R64G64_SFLOAT = 115,
	R64G64B64_UINT = 116,
	R64G64B64_SINT = 117,
	R64G64B64_SFLOAT = 118,
	R64G64B64A64_UINT = 119,
	R64G64B64A64_SINT = 120,
	R64G64B64A64_SFLOAT = 121,
	B10G11R11_UFLOAT_PACK32 = 122,
	E5B9G9R9_UFLOAT_PACK32 = 123,
	D16_UNORM = 124,
	X8_D24_UNORM_PACK32 = 125,
	D32_SFLOAT = 126,
	S8_UINT = 127,
	D16_UNORM_S8_UINT = 128,
	D24_UNORM_S8_UINT = 129,
	D32_SFLOAT_S8_UINT = 130,
	BC1_RGB_UNORM_BLOCK = 131,
	BC1_RGB_SRGB_BLOCK = 132,
	BC1_RGBA_UNORM_BLOCK = 133,
	BC1_RGBA_SRGB_BLOCK = 134,
	BC2_UNORM_BLOCK = 135,
	BC2_SRGB_BLOCK = 136,
	BC3_UNORM_BLOCK = 137,
	BC3_SRGB_BLOCK = 138,
	BC4_UNORM_BLOCK = 139,
	BC4_SNORM_BLOCK = 140,
	BC5_UNORM_BLOCK = 141,
	BC5_SNORM_BLOCK = 142,
	BC6H_UFLOAT_BLOCK = 143,
	BC6H_SFLOAT_BLOCK = 144,
	BC7_UNORM_BLOCK = 145,
	BC7_SRGB_BLOCK = 146,
	ETC2_R8G8B8_UNORM_BLOCK = 147,
	ETC2_R8G8B8_SRGB_BLOCK = 148,
	ETC2_R8G8B8A1_UNORM_BLOCK = 149,
	ETC2_R8G8B8A1_SRGB_BLOCK = 150,
	ETC2_R8G8B8A8_UNORM_BLOCK = 151,
	ETC2_R8G8B8A8_SRGB_BLOCK = 152,
	EAC_R11_UNORM_BLOCK = 153,
	EAC_R11_SNORM_BLOCK = 154,
	EAC_R11G11_UNORM_BLOCK = 155,
	EAC_R11G11_SNORM_BLOCK = 156,
	ASTC_4x4_UNORM_BLOCK = 157,
	ASTC_4x4_SRGB_BLOCK = 158,
	ASTC_5x4_UNORM_BLOCK = 159,
	ASTC_5x4_SRGB_BLOCK = 160,
	ASTC_5x5_UNORM_BLOCK = 161,
	ASTC_5x5_SRGB_BLOCK = 162,
	ASTC_6x5_UNORM_BLOCK = 163,
	ASTC_6x5_SRGB_BLOCK = 164,
	ASTC_6x6_UNORM_BLOCK = 165,
	ASTC_6x6_SRGB_BLOCK = 166,
	ASTC_8x5_UNORM_BLOCK = 167,
	ASTC_8x5_SRGB_BLOCK = 168,
	ASTC_8x6_UNORM_BLOCK = 169,
	ASTC_8x6_SRGB_BLOCK = 170,
	ASTC_8x8_UNORM_BLOCK = 171,
	ASTC_8x8_SRGB_BLOCK = 172,
	ASTC_10x5_UNORM_BLOCK = 173,
	ASTC_10x5_SRGB_BLOCK = 174,
	ASTC_10x6_UNORM_BLOCK = 175,
	ASTC_10x6_SRGB_BLOCK = 176,
	ASTC_10x8_UNORM_BLOCK = 177,
	ASTC_10x8_SRGB_BLOCK = 178,
	ASTC_10x10_UNORM_BLOCK = 179,
	ASTC_10x10_SRGB_BLOCK = 180,
	ASTC_12x10_UNORM_BLOCK = 181,
	ASTC_12x10_SRGB_BLOCK = 182,
	ASTC_12x12_UNORM_BLOCK = 183,
	ASTC_12x12_SRGB_BLOCK = 184,
	G8B8G8R8_422_UNORM = 1000156000,
	B8G8R8G8_422_UNORM = 1000156001,
	G8_B8_R8_3PLANE_420_UNORM = 1000156002,
	G8_B8R8_2PLANE_420_UNORM = 1000156003,
	G8_B8_R8_3PLANE_422_UNORM = 1000156004,
	G8_B8R8_2PLANE_422_UNORM = 1000156005,
	G8_B8_R8_3PLANE_444_UNORM = 1000156006,
	R10X6_UNORM_PACK16 = 1000156007,
	R10X6G10X6_UNORM_2PACK16 = 1000156008,
	R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
	G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
	B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
	G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
	G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
	G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
	G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
	G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
	R12X4_UNORM_PACK16 = 1000156017,
	R12X4G12X4_UNORM_2PACK16 = 1000156018,
	R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
	G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
	B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
	G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
	G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
	G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
	G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
	G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
	G16B16G16R16_422_UNORM = 1000156027,
	B16G16R16G16_422_UNORM = 1000156028,
	G16_B16_R16_3PLANE_420_UNORM = 1000156029,
	G16_B16R16_2PLANE_420_UNORM = 1000156030,
	G16_B16_R16_3PLANE_422_UNORM = 1000156031,
	G16_B16R16_2PLANE_422_UNORM = 1000156032,
	G16_B16_R16_3PLANE_444_UNORM = 1000156033,
	G8_B8R8_2PLANE_444_UNORM = 1000330000,
	G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
	G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
	G16_B16R16_2PLANE_444_UNORM = 1000330003,
	A4R4G4B4_UNORM_PACK16 = 1000340000,
	A4B4G4R4_UNORM_PACK16 = 1000340001,
	ASTC_4x4_SFLOAT_BLOCK = 1000066000,
	ASTC_5x4_SFLOAT_BLOCK = 1000066001,
	ASTC_5x5_SFLOAT_BLOCK = 1000066002,
	ASTC_6x5_SFLOAT_BLOCK = 1000066003,
	ASTC_6x6_SFLOAT_BLOCK = 1000066004,
	ASTC_8x5_SFLOAT_BLOCK = 1000066005,
	ASTC_8x6_SFLOAT_BLOCK = 1000066006,
	ASTC_8x8_SFLOAT_BLOCK = 1000066007,
	ASTC_10x5_SFLOAT_BLOCK = 1000066008,
	ASTC_10x6_SFLOAT_BLOCK = 1000066009,
	ASTC_10x8_SFLOAT_BLOCK = 1000066010,
	ASTC_10x10_SFLOAT_BLOCK = 1000066011,
	ASTC_12x10_SFLOAT_BLOCK = 1000066012,
	ASTC_12x12_SFLOAT_BLOCK = 1000066013,
	A1B5G5R5_UNORM_PACK16 = 1000470000,
	A8_UNORM = 1000470001,
	PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
	PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
	PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
	PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
	PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
	PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
	PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
	PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
	ASTC_4x4_SFLOAT_BLOCK_EXT = ASTC_4x4_SFLOAT_BLOCK,
	ASTC_5x4_SFLOAT_BLOCK_EXT = ASTC_5x4_SFLOAT_BLOCK,
	ASTC_5x5_SFLOAT_BLOCK_EXT = ASTC_5x5_SFLOAT_BLOCK,
	ASTC_6x5_SFLOAT_BLOCK_EXT = ASTC_6x5_SFLOAT_BLOCK,
	ASTC_6x6_SFLOAT_BLOCK_EXT = ASTC_6x6_SFLOAT_BLOCK,
	ASTC_8x5_SFLOAT_BLOCK_EXT = ASTC_8x5_SFLOAT_BLOCK,
	ASTC_8x6_SFLOAT_BLOCK_EXT = ASTC_8x6_SFLOAT_BLOCK,
	ASTC_8x8_SFLOAT_BLOCK_EXT = ASTC_8x8_SFLOAT_BLOCK,
	ASTC_10x5_SFLOAT_BLOCK_EXT = ASTC_10x5_SFLOAT_BLOCK,
	ASTC_10x6_SFLOAT_BLOCK_EXT = ASTC_10x6_SFLOAT_BLOCK,
	ASTC_10x8_SFLOAT_BLOCK_EXT = ASTC_10x8_SFLOAT_BLOCK,
	ASTC_10x10_SFLOAT_BLOCK_EXT = ASTC_10x10_SFLOAT_BLOCK,
	ASTC_12x10_SFLOAT_BLOCK_EXT = ASTC_12x10_SFLOAT_BLOCK,
	ASTC_12x12_SFLOAT_BLOCK_EXT = ASTC_12x12_SFLOAT_BLOCK,
	G8B8G8R8_422_UNORM_KHR = G8B8G8R8_422_UNORM,
	B8G8R8G8_422_UNORM_KHR = B8G8R8G8_422_UNORM,
	G8_B8_R8_3PLANE_420_UNORM_KHR = G8_B8_R8_3PLANE_420_UNORM,
	G8_B8R8_2PLANE_420_UNORM_KHR = G8_B8R8_2PLANE_420_UNORM,
	G8_B8_R8_3PLANE_422_UNORM_KHR = G8_B8_R8_3PLANE_422_UNORM,
	G8_B8R8_2PLANE_422_UNORM_KHR = G8_B8R8_2PLANE_422_UNORM,
	G8_B8_R8_3PLANE_444_UNORM_KHR = G8_B8_R8_3PLANE_444_UNORM,
	R10X6_UNORM_PACK16_KHR = R10X6_UNORM_PACK16,
	R10X6G10X6_UNORM_2PACK16_KHR = R10X6G10X6_UNORM_2PACK16,
	R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = R10X6G10X6B10X6A10X6_UNORM_4PACK16,
	G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
	B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
	G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
	G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
	G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
	G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
	G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
	R12X4_UNORM_PACK16_KHR = R12X4_UNORM_PACK16,
	R12X4G12X4_UNORM_2PACK16_KHR = R12X4G12X4_UNORM_2PACK16,
	R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = R12X4G12X4B12X4A12X4_UNORM_4PACK16,
	G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
	B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
	G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
	G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
	G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
	G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
	G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
	G16B16G16R16_422_UNORM_KHR = G16B16G16R16_422_UNORM,
	B16G16R16G16_422_UNORM_KHR = B16G16R16G16_422_UNORM,
	G16_B16_R16_3PLANE_420_UNORM_KHR = G16_B16_R16_3PLANE_420_UNORM,
	G16_B16R16_2PLANE_420_UNORM_KHR = G16_B16R16_2PLANE_420_UNORM,
	G16_B16_R16_3PLANE_422_UNORM_KHR = G16_B16_R16_3PLANE_422_UNORM,
	G16_B16R16_2PLANE_422_UNORM_KHR = G16_B16R16_2PLANE_422_UNORM,
	G16_B16_R16_3PLANE_444_UNORM_KHR = G16_B16_R16_3PLANE_444_UNORM,
	G8_B8R8_2PLANE_444_UNORM_EXT = G8_B8R8_2PLANE_444_UNORM,
	G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16,
	G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16,
	G16_B16R16_2PLANE_444_UNORM_EXT = G16_B16R16_2PLANE_444_UNORM,
	A4R4G4B4_UNORM_PACK16_EXT = A4R4G4B4_UNORM_PACK16,
	A4B4G4R4_UNORM_PACK16_EXT = A4B4G4R4_UNORM_PACK16,
	R8_BOOL_ARM = 1000460000,
	R16G16_SFIXED5_NV = 1000464000,
	R16G16_S10_5_NV = R16G16_SFIXED5_NV,
	A1B5G5R5_UNORM_PACK16_KHR = A1B5G5R5_UNORM_PACK16,
	A8_UNORM_KHR = A8_UNORM,
	R10X6_UINT_PACK16_ARM = 1000609000,
	R10X6G10X6_UINT_2PACK16_ARM = 1000609001,
	R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM = 1000609002,
	R12X4_UINT_PACK16_ARM = 1000609003,
	R12X4G12X4_UINT_2PACK16_ARM = 1000609004,
	R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM = 1000609005,
	R14X2_UINT_PACK16_ARM = 1000609006,
	R14X2G14X2_UINT_2PACK16_ARM = 1000609007,
	R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM = 1000609008,
	R14X2_UNORM_PACK16_ARM = 1000609009,
	R14X2G14X2_UNORM_2PACK16_ARM = 1000609010,
	R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM = 1000609011,
	G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM = 1000609012,
	G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM = 1000609013,
}

[AllowDuplicates] enum VkFormatFeatureFlagBits : int32
{
	SampledImage = 1 << 0, // Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
	StorageImage = 1 << 1, // Format can be used for storage images (STORAGE_IMAGE descriptor type)
	StorageImageAtomic = 1 << 2, // Format supports atomic operations in case it is used for storage images
	UniformTexelBuffer = 1 << 3, // Format can be used for uniform texel buffers (TBOs)
	StorageTexelBuffer = 1 << 4, // Format can be used for storage texel buffers (IBOs)
	StorageTexelBufferAtomic = 1 << 5, // Format supports atomic operations in case it is used for storage texel buffers
	VertexBuffer = 1 << 6, // Format can be used for vertex buffers (VBOs)
	ColorAttachment = 1 << 7, // Format can be used for color attachment images
	ColorAttachmentBlend = 1 << 8, // Format supports blending in case it is used for color attachment images
	DepthStencilAttachment = 1 << 9, // Format can be used for depth/stencil attachment images
	BlitSrc = 1 << 10, // Format can be used as the source image of blits with vkCmdBlitImage
	BlitDst = 1 << 11, // Format can be used as the destination image of blits with vkCmdBlitImage
	SampledImageFilterLinear = 1 << 12, // Format can be filtered with VK_FILTER_LINEAR when being sampled
	TransferSrc = 1 << 14, // Format can be used as the source image of image transfer commands
	TransferDst = 1 << 15, // Format can be used as the destination image of image transfer commands
	MidpointChromaSamples = 1 << 17, // Format can have midpoint rather than cosited chroma samples
	SampledImageYcbcrConversionLinearFilter = 1 << 18, // Format can be used with linear filtering whilst color conversion is enabled
	SampledImageYcbcrConversionSeparateReconstructionFilter = 1 << 19, // Format can have different chroma, min and mag filters
	SampledImageYcbcrConversionChromaReconstructionExplicit = 1 << 20,
	SampledImageYcbcrConversionChromaReconstructionExplicitForceable = 1 << 21,
	Disjoint = 1 << 22, // Format supports disjoint planes
	CositedChromaSamples = 1 << 23, // Format can have cosited rather than midpoint chroma samples
	SampledImageFilterMinmax = 1 << 16, // Format can be used with min/max reduction filtering
	SampledImageFilterCubicIMG = SampledImageFilterCubicEXT, // Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled
	VideoDecodeOutputKHR = 1 << 25,
	VideoDecodeDpbKHR = 1 << 26,
	TransferSrcKHR = TransferSrc,
	TransferDstKHR = TransferDst,
	SampledImageFilterMinmaxEXT = SampledImageFilterMinmax,
	AccelerationStructureVertexBufferKHR = 1 << 29,
	MidpointChromaSamplesKHR = MidpointChromaSamples,
	SampledImageYcbcrConversionLinearFilterKHR = SampledImageYcbcrConversionLinearFilter,
	SampledImageYcbcrConversionSeparateReconstructionFilterKHR = SampledImageYcbcrConversionSeparateReconstructionFilter,
	SampledImageYcbcrConversionChromaReconstructionExplicitKHR = SampledImageYcbcrConversionChromaReconstructionExplicit,
	SampledImageYcbcrConversionChromaReconstructionExplicitForceableKHR = SampledImageYcbcrConversionChromaReconstructionExplicitForceable,
	DisjointKHR = Disjoint,
	CositedChromaSamplesKHR = CositedChromaSamples,
	SampledImageFilterCubicEXT = 1 << 13,
	FragmentDensityMapEXT = 1 << 24,
	FragmentShadingRateAttachmentKHR = 1 << 30,
	VideoEncodeInputKHR = 1 << 27,
	VideoEncodeDpbKHR = 1 << 28,
}

typealias VkFormatFeatureFlags = VkFormatFeatureFlagBits;

[CRepr] struct VkFormatProperties
{
	public VkFormatFeatureFlags linearTilingFeatures; // Format features in case of linear tiling
	public VkFormatFeatureFlags optimalTilingFeatures; // Format features in case of optimal tiling
	public VkFormatFeatureFlags bufferFeatures; // Format features supported by buffers
}

[AllowDuplicates] enum VkImageCreateFlagBits : int32
{
	SparseBinding = 1 << 0, // Image should support sparse backing
	SparseResidency = 1 << 1, // Image should support sparse backing with partial residency
	SparseAliased = 1 << 2, // Image should support constant data access to physical memory ranges mapped into multiple locations of sparse images
	MutableFormat = 1 << 3, // Allows image views to have different format than the base image
	CubeCompatible = 1 << 4, // Allows creating image views with cube type from the created image
	Alias = 1 << 10,
	SplitInstanceBindRegions = 1 << 6, // Allows using VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions when binding memory to the image
	VK_2dArrayCompatible = 1 << 5, // The 3D image can be viewed as a 2D or 2D array image
	BlockTexelViewCompatible = 1 << 7,
	ExtendedUsage = 1 << 8,
	Protected = 1 << 11, // Image requires protected memory
	Disjoint = 1 << 9,
	CornerSampledNV = 1 << 13,
	SplitInstanceBindRegionsKHR = SplitInstanceBindRegions,
	VK_2dArrayCompatibleKHR = VK_2dArrayCompatible,
	BlockTexelViewCompatibleKHR = BlockTexelViewCompatible,
	ExtendedUsageKHR = ExtendedUsage,
	SampleLocationsCompatibleDepthEXT = 1 << 12,
	DisjointKHR = Disjoint,
	AliasKHR = Alias,
	SubsampledEXT = 1 << 14,
	DescriptorBufferCaptureReplayEXT = 1 << 16,
	MultisampledRenderToSingleSampledEXT = 1 << 18,
	VK_2dViewCompatibleEXT = 1 << 17, // Image is created with a layout where individual slices are capable of being used as 2D images
	FragmentDensityMapOffsetQCOM = FragmentDensityMapOffsetEXT,
	VideoProfileIndependentKHR = 1 << 20,
	FragmentDensityMapOffsetEXT = 1 << 15,
}

typealias VkImageCreateFlags = VkImageCreateFlagBits;

[CRepr] struct VkImageFormatProperties
{
	public VkExtent3D maxExtent; // max image dimensions for this resource type
	public uint32 maxMipLevels; // max number of mipmap levels for this resource type
	public uint32 maxArrayLayers; // max array size for this resource type
	public VkSampleCountFlags sampleCounts; // supported sample counts for this resource type
	public VkDeviceSize maxResourceSize; // max size (in bytes) of this resource type
}

[AllowDuplicates] enum VkImageTiling : int32
{
	Optimal = 0,
	Linear = 1,
	DrmFormatModifierEXT = 1000158000,
}

[AllowDuplicates] enum VkImageType : int32
{
	VK_1d = 0,
	VK_2d = 1,
	VK_3d = 2,
}

[AllowDuplicates] enum VkImageUsageFlagBits : int32
{
	TransferSrc = 1 << 0, // Can be used as a source of transfer operations
	TransferDst = 1 << 1, // Can be used as a destination of transfer operations
	Sampled = 1 << 2, // Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
	Storage = 1 << 3, // Can be used as storage image (STORAGE_IMAGE descriptor type)
	ColorAttachment = 1 << 4, // Can be used as framebuffer color attachment
	DepthStencilAttachment = 1 << 5, // Can be used as framebuffer depth/stencil attachment
	TransientAttachment = 1 << 6, // Image data not needed outside of rendering
	InputAttachment = 1 << 7, // Can be used as framebuffer input attachment
	HostTransfer = 1 << 22,
	VideoDecodeDstKHR = 1 << 10,
	VideoDecodeSrcKHR = 1 << 11,
	VideoDecodeDpbKHR = 1 << 12,
	ShadingRateImageNV = FragmentShadingRateAttachmentKHR,
	FragmentDensityMapEXT = 1 << 9,
	FragmentShadingRateAttachmentKHR = 1 << 8,
	HostTransferEXT = HostTransfer, // Can be used with host image copies
	VideoEncodeDstKHR = 1 << 13,
	VideoEncodeSrcKHR = 1 << 14,
	VideoEncodeDpbKHR = 1 << 15,
	AttachmentFeedbackLoopEXT = 1 << 19,
	InvocationMaskHUAWEI = 1 << 18,
	SampleWeightQCOM = 1 << 20,
	SampleBlockMatchQCOM = 1 << 21,
	TensorAliasingARM = 1 << 23,
	TileMemoryQCOM = 1 << 27,
	VideoEncodeQuantizationDeltaMapKHR = 1 << 25,
	VideoEncodeEmphasisMapKHR = 1 << 26,
}

typealias VkImageUsageFlags = VkImageUsageFlagBits;

class VkInstance { private this() { } }

typealias VkInstanceCreateFlags = VkInstanceCreateFlagBits;

[AllowDuplicates] enum VkInstanceCreateFlagBits : int32
{
	EnumeratePortabilityKHR = 1 << 0,
}

[CRepr] struct VkInstanceCreateInfo
{
	public const VkStructureType SType = .VkInstanceCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkInstanceCreateFlags flags;
	public VkApplicationInfo* pApplicationInfo;
	public uint32 enabledLayerCount;
	public c_char** ppEnabledLayerNames; // Ordered list of layer names to be enabled
	public VulkanSpan<c_char*> enabledLayerNames
	{
		[Inline] get => .(enabledLayerCount, ppEnabledLayerNames);
		[Inline] set mut { enabledLayerCount = value.count; ppEnabledLayerNames = value.ptr; }
	} // Ordered list of layer names to be enabled
	public uint32 enabledExtensionCount;
	public c_char** ppEnabledExtensionNames; // Extension names to be enabled
	public VulkanSpan<c_char*> enabledExtensionNames
	{
		[Inline] get => .(enabledExtensionCount, ppEnabledExtensionNames);
		[Inline] set mut { enabledExtensionCount = value.count; ppEnabledExtensionNames = value.ptr; }
	} // Extension names to be enabled

	public this(void* pNext = null, VkInstanceCreateFlags flags = 0, VkApplicationInfo* pApplicationInfo = null, VulkanSpan<c_char*> enabledLayerNames = .(), VulkanSpan<c_char*> enabledExtensionNames = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.pApplicationInfo = pApplicationInfo;
		this.enabledLayerNames = enabledLayerNames;
		this.enabledExtensionNames = enabledExtensionNames;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkInternalAllocationType : int32
{
	Executable = 0,
}

[CRepr] struct VkMemoryHeap
{
	public VkDeviceSize size; // Available memory in the heap
	public VkMemoryHeapFlags flags; // Flags for the heap
}

[AllowDuplicates] enum VkMemoryHeapFlagBits : int32
{
	DeviceLocal = 1 << 0, // If set, heap represents device memory
	MultiInstance = 1 << 1, // If set, heap allocations allocate multiple instances by default
	MultiInstanceKHR = MultiInstance,
	TileMemoryQCOM = 1 << 3,
}

typealias VkMemoryHeapFlags = VkMemoryHeapFlagBits;

[AllowDuplicates] enum VkMemoryPropertyFlagBits : int32
{
	DeviceLocal = 1 << 0, // If otherwise stated, then allocate memory on device
	HostVisible = 1 << 1, // Memory is mappable by host
	HostCoherent = 1 << 2, // Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache
	HostCached = 1 << 3, // Memory will be cached by the host
	LazilyAllocated = 1 << 4, // Memory may be allocated by the driver when it is required
	Protected = 1 << 5, // Memory is protected
	DeviceCoherentAMD = 1 << 6,
	DeviceUncachedAMD = 1 << 7,
	RdmaCapableNV = 1 << 8,
}

typealias VkMemoryPropertyFlags = VkMemoryPropertyFlagBits;

[CRepr] struct VkMemoryType
{
	public VkMemoryPropertyFlags propertyFlags; // Memory properties of this memory type
	public uint32 heapIndex; // Index of the memory heap allocations of this memory type are taken from
}

class VkPhysicalDevice { private this() { } }

[CRepr] struct VkPhysicalDeviceFeatures
{
	public VkBool32 robustBufferAccess; // out of bounds buffer accesses are well defined
	public VkBool32 fullDrawIndexUint32; // full 32-bit range of indices for indexed draw calls
	public VkBool32 imageCubeArray; // image views which are arrays of cube maps
	public VkBool32 independentBlend; // blending operations are controlled per-attachment
	public VkBool32 geometryShader; // geometry stage
	public VkBool32 tessellationShader; // tessellation control and evaluation stage
	public VkBool32 sampleRateShading; // per-sample shading and interpolation
	public VkBool32 dualSrcBlend; // blend operations which take two sources
	public VkBool32 logicOp; // logic operations
	public VkBool32 multiDrawIndirect; // multi draw indirect
	public VkBool32 drawIndirectFirstInstance; // indirect drawing can use non-zero firstInstance
	public VkBool32 depthClamp; // depth clamping
	public VkBool32 depthBiasClamp; // depth bias clamping
	public VkBool32 fillModeNonSolid; // point and wireframe fill modes
	public VkBool32 depthBounds; // depth bounds test
	public VkBool32 wideLines; // lines with width greater than 1
	public VkBool32 largePoints; // points with size greater than 1
	public VkBool32 alphaToOne; // the fragment alpha component can be forced to maximum representable alpha value
	public VkBool32 multiViewport; // viewport arrays
	public VkBool32 samplerAnisotropy; // anisotropic sampler filtering
	public VkBool32 textureCompressionETC2; // ETC texture compression formats
	public VkBool32 textureCompressionASTC_LDR; // ASTC LDR texture compression formats
	public VkBool32 textureCompressionBC; // BC1-7 texture compressed formats
	public VkBool32 occlusionQueryPrecise; // precise occlusion queries returning actual sample counts
	public VkBool32 pipelineStatisticsQuery; // pipeline statistics query
	public VkBool32 vertexPipelineStoresAndAtomics; // stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages
	public VkBool32 fragmentStoresAndAtomics; // stores and atomic ops on storage buffers and images are supported in the fragment stage
	public VkBool32 shaderTessellationAndGeometryPointSize; // tessellation and geometry stages can export point size
	public VkBool32 shaderImageGatherExtended; // image gather with runtime values and independent offsets
	public VkBool32 shaderStorageImageExtendedFormats; // the extended set of formats can be used for storage images
	public VkBool32 shaderStorageImageMultisample; // multisample images can be used for storage images
	public VkBool32 shaderStorageImageReadWithoutFormat; // read from storage image does not require format qualifier
	public VkBool32 shaderStorageImageWriteWithoutFormat; // write to storage image does not require format qualifier
	public VkBool32 shaderUniformBufferArrayDynamicIndexing; // arrays of uniform buffers can be accessed with dynamically uniform indices
	public VkBool32 shaderSampledImageArrayDynamicIndexing; // arrays of sampled images can be accessed with dynamically uniform indices
	public VkBool32 shaderStorageBufferArrayDynamicIndexing; // arrays of storage buffers can be accessed with dynamically uniform indices
	public VkBool32 shaderStorageImageArrayDynamicIndexing; // arrays of storage images can be accessed with dynamically uniform indices
	public VkBool32 shaderClipDistance; // clip distance in shaders
	public VkBool32 shaderCullDistance; // cull distance in shaders
	public VkBool32 shaderFloat64; // 64-bit floats (doubles) in shaders
	public VkBool32 shaderInt64; // 64-bit integers in shaders
	public VkBool32 shaderInt16; // 16-bit integers in shaders
	public VkBool32 shaderResourceResidency; // shader can use texture operations that return resource residency information (requires sparseNonResident support)
	public VkBool32 shaderResourceMinLod; // shader can use texture operations that specify minimum resource LOD
	public VkBool32 sparseBinding; // Sparse resources support: Resource memory can be managed at opaque page level rather than object level
	public VkBool32 sparseResidencyBuffer; // Sparse resources support: GPU can access partially resident buffers
	public VkBool32 sparseResidencyImage2D; // Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images
	public VkBool32 sparseResidencyImage3D; // Sparse resources support: GPU can access partially resident 3D images
	public VkBool32 sparseResidency2Samples; // Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
	public VkBool32 sparseResidency4Samples; // Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
	public VkBool32 sparseResidency8Samples; // Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
	public VkBool32 sparseResidency16Samples; // Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
	public VkBool32 sparseResidencyAliased; // Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
	public VkBool32 variableMultisampleRate; // multisample rate must be the same for all pipelines in a subpass
	public VkBool32 inheritedQueries; // Queries may be inherited from primary to secondary command buffers

	public this(VkBool32 robustBufferAccess, VkBool32 fullDrawIndexUint32, VkBool32 imageCubeArray, VkBool32 independentBlend, VkBool32 geometryShader, VkBool32 tessellationShader, VkBool32 sampleRateShading, VkBool32 dualSrcBlend, VkBool32 logicOp, VkBool32 multiDrawIndirect, VkBool32 drawIndirectFirstInstance, VkBool32 depthClamp, VkBool32 depthBiasClamp, VkBool32 fillModeNonSolid, VkBool32 depthBounds, VkBool32 wideLines, VkBool32 largePoints, VkBool32 alphaToOne, VkBool32 multiViewport, VkBool32 samplerAnisotropy, VkBool32 textureCompressionETC2, VkBool32 textureCompressionASTC_LDR, VkBool32 textureCompressionBC, VkBool32 occlusionQueryPrecise, VkBool32 pipelineStatisticsQuery, VkBool32 vertexPipelineStoresAndAtomics, VkBool32 fragmentStoresAndAtomics, VkBool32 shaderTessellationAndGeometryPointSize, VkBool32 shaderImageGatherExtended, VkBool32 shaderStorageImageExtendedFormats, VkBool32 shaderStorageImageMultisample, VkBool32 shaderStorageImageReadWithoutFormat, VkBool32 shaderStorageImageWriteWithoutFormat, VkBool32 shaderUniformBufferArrayDynamicIndexing, VkBool32 shaderSampledImageArrayDynamicIndexing, VkBool32 shaderStorageBufferArrayDynamicIndexing, VkBool32 shaderStorageImageArrayDynamicIndexing, VkBool32 shaderClipDistance, VkBool32 shaderCullDistance, VkBool32 shaderFloat64, VkBool32 shaderInt64, VkBool32 shaderInt16, VkBool32 shaderResourceResidency, VkBool32 shaderResourceMinLod, VkBool32 sparseBinding, VkBool32 sparseResidencyBuffer, VkBool32 sparseResidencyImage2D, VkBool32 sparseResidencyImage3D, VkBool32 sparseResidency2Samples, VkBool32 sparseResidency4Samples, VkBool32 sparseResidency8Samples, VkBool32 sparseResidency16Samples, VkBool32 sparseResidencyAliased, VkBool32 variableMultisampleRate, VkBool32 inheritedQueries)
	{
		this.robustBufferAccess = robustBufferAccess;
		this.fullDrawIndexUint32 = fullDrawIndexUint32;
		this.imageCubeArray = imageCubeArray;
		this.independentBlend = independentBlend;
		this.geometryShader = geometryShader;
		this.tessellationShader = tessellationShader;
		this.sampleRateShading = sampleRateShading;
		this.dualSrcBlend = dualSrcBlend;
		this.logicOp = logicOp;
		this.multiDrawIndirect = multiDrawIndirect;
		this.drawIndirectFirstInstance = drawIndirectFirstInstance;
		this.depthClamp = depthClamp;
		this.depthBiasClamp = depthBiasClamp;
		this.fillModeNonSolid = fillModeNonSolid;
		this.depthBounds = depthBounds;
		this.wideLines = wideLines;
		this.largePoints = largePoints;
		this.alphaToOne = alphaToOne;
		this.multiViewport = multiViewport;
		this.samplerAnisotropy = samplerAnisotropy;
		this.textureCompressionETC2 = textureCompressionETC2;
		this.textureCompressionASTC_LDR = textureCompressionASTC_LDR;
		this.textureCompressionBC = textureCompressionBC;
		this.occlusionQueryPrecise = occlusionQueryPrecise;
		this.pipelineStatisticsQuery = pipelineStatisticsQuery;
		this.vertexPipelineStoresAndAtomics = vertexPipelineStoresAndAtomics;
		this.fragmentStoresAndAtomics = fragmentStoresAndAtomics;
		this.shaderTessellationAndGeometryPointSize = shaderTessellationAndGeometryPointSize;
		this.shaderImageGatherExtended = shaderImageGatherExtended;
		this.shaderStorageImageExtendedFormats = shaderStorageImageExtendedFormats;
		this.shaderStorageImageMultisample = shaderStorageImageMultisample;
		this.shaderStorageImageReadWithoutFormat = shaderStorageImageReadWithoutFormat;
		this.shaderStorageImageWriteWithoutFormat = shaderStorageImageWriteWithoutFormat;
		this.shaderUniformBufferArrayDynamicIndexing = shaderUniformBufferArrayDynamicIndexing;
		this.shaderSampledImageArrayDynamicIndexing = shaderSampledImageArrayDynamicIndexing;
		this.shaderStorageBufferArrayDynamicIndexing = shaderStorageBufferArrayDynamicIndexing;
		this.shaderStorageImageArrayDynamicIndexing = shaderStorageImageArrayDynamicIndexing;
		this.shaderClipDistance = shaderClipDistance;
		this.shaderCullDistance = shaderCullDistance;
		this.shaderFloat64 = shaderFloat64;
		this.shaderInt64 = shaderInt64;
		this.shaderInt16 = shaderInt16;
		this.shaderResourceResidency = shaderResourceResidency;
		this.shaderResourceMinLod = shaderResourceMinLod;
		this.sparseBinding = sparseBinding;
		this.sparseResidencyBuffer = sparseResidencyBuffer;
		this.sparseResidencyImage2D = sparseResidencyImage2D;
		this.sparseResidencyImage3D = sparseResidencyImage3D;
		this.sparseResidency2Samples = sparseResidency2Samples;
		this.sparseResidency4Samples = sparseResidency4Samples;
		this.sparseResidency8Samples = sparseResidency8Samples;
		this.sparseResidency16Samples = sparseResidency16Samples;
		this.sparseResidencyAliased = sparseResidencyAliased;
		this.variableMultisampleRate = variableMultisampleRate;
		this.inheritedQueries = inheritedQueries;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkPhysicalDeviceLimits
{
	// resource maximum sizes
	public uint32 maxImageDimension1D; // max 1D image dimension
	public uint32 maxImageDimension2D; // max 2D image dimension
	public uint32 maxImageDimension3D; // max 3D image dimension
	public uint32 maxImageDimensionCube; // max cube map image dimension
	public uint32 maxImageArrayLayers; // max layers for image arrays
	public uint32 maxTexelBufferElements; // max texel buffer size (fstexels)
	public uint32 maxUniformBufferRange; // max uniform buffer range (bytes)
	public uint32 maxStorageBufferRange; // max storage buffer range (bytes)
	public uint32 maxPushConstantsSize; // max size of the push constants pool (bytes)
	// memory limits
	public uint32 maxMemoryAllocationCount; // max number of device memory allocations supported
	public uint32 maxSamplerAllocationCount; // max number of samplers that can be allocated on a device
	public VkDeviceSize bufferImageGranularity; // Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
	public VkDeviceSize sparseAddressSpaceSize; // Total address space available for sparse allocations (bytes)
	// descriptor set limits
	public uint32 maxBoundDescriptorSets; // max number of descriptors sets that can be bound to a pipeline
	public uint32 maxPerStageDescriptorSamplers; // max number of samplers allowed per-stage in a descriptor set
	public uint32 maxPerStageDescriptorUniformBuffers; // max number of uniform buffers allowed per-stage in a descriptor set
	public uint32 maxPerStageDescriptorStorageBuffers; // max number of storage buffers allowed per-stage in a descriptor set
	public uint32 maxPerStageDescriptorSampledImages; // max number of sampled images allowed per-stage in a descriptor set
	public uint32 maxPerStageDescriptorStorageImages; // max number of storage images allowed per-stage in a descriptor set
	public uint32 maxPerStageDescriptorInputAttachments; // max number of input attachments allowed per-stage in a descriptor set
	public uint32 maxPerStageResources; // max number of resources allowed by a single stage
	public uint32 maxDescriptorSetSamplers; // max number of samplers allowed in all stages in a descriptor set
	public uint32 maxDescriptorSetUniformBuffers; // max number of uniform buffers allowed in all stages in a descriptor set
	public uint32 maxDescriptorSetUniformBuffersDynamic; // max number of dynamic uniform buffers allowed in all stages in a descriptor set
	public uint32 maxDescriptorSetStorageBuffers; // max number of storage buffers allowed in all stages in a descriptor set
	public uint32 maxDescriptorSetStorageBuffersDynamic; // max number of dynamic storage buffers allowed in all stages in a descriptor set
	public uint32 maxDescriptorSetSampledImages; // max number of sampled images allowed in all stages in a descriptor set
	public uint32 maxDescriptorSetStorageImages; // max number of storage images allowed in all stages in a descriptor set
	public uint32 maxDescriptorSetInputAttachments; // max number of input attachments allowed in all stages in a descriptor set
	// vertex stage limits
	public uint32 maxVertexInputAttributes; // max number of vertex input attribute slots
	public uint32 maxVertexInputBindings; // max number of vertex input binding slots
	public uint32 maxVertexInputAttributeOffset; // max vertex input attribute offset added to vertex buffer offset
	public uint32 maxVertexInputBindingStride; // max vertex input binding stride
	public uint32 maxVertexOutputComponents; // max number of output components written by vertex shader
	// tessellation control stage limits
	public uint32 maxTessellationGenerationLevel; // max level supported by tessellation primitive generator
	public uint32 maxTessellationPatchSize; // max patch size (vertices)
	public uint32 maxTessellationControlPerVertexInputComponents; // max number of input components per-vertex in TCS
	public uint32 maxTessellationControlPerVertexOutputComponents; // max number of output components per-vertex in TCS
	public uint32 maxTessellationControlPerPatchOutputComponents; // max number of output components per-patch in TCS
	public uint32 maxTessellationControlTotalOutputComponents; // max total number of per-vertex and per-patch output components in TCS
	// tessellation evaluation stage limits
	public uint32 maxTessellationEvaluationInputComponents; // max number of input components per vertex in TES
	public uint32 maxTessellationEvaluationOutputComponents; // max number of output components per vertex in TES
	// geometry stage limits
	public uint32 maxGeometryShaderInvocations; // max invocation count supported in geometry shader
	public uint32 maxGeometryInputComponents; // max number of input components read in geometry stage
	public uint32 maxGeometryOutputComponents; // max number of output components written in geometry stage
	public uint32 maxGeometryOutputVertices; // max number of vertices that can be emitted in geometry stage
	public uint32 maxGeometryTotalOutputComponents; // max total number of components (all vertices) written in geometry stage
	// fragment stage limits
	public uint32 maxFragmentInputComponents; // max number of input components read in fragment stage
	public uint32 maxFragmentOutputAttachments; // max number of output attachments written in fragment stage
	public uint32 maxFragmentDualSrcAttachments; // max number of output attachments written when using dual source blending
	public uint32 maxFragmentCombinedOutputResources; // max total number of storage buffers, storage images and output buffers
	// compute stage limits
	public uint32 maxComputeSharedMemorySize; // max total storage size of work group local storage (bytes)
	public uint32[3] maxComputeWorkGroupCount; // max num of compute work groups that may be dispatched by a single command (x,y,z)
	public uint32 maxComputeWorkGroupInvocations; // max total compute invocations in a single local work group
	public uint32[3] maxComputeWorkGroupSize; // max local size of a compute work group (x,y,z)
	public uint32 subPixelPrecisionBits; // number bits of subpixel precision in screen x and y
	public uint32 subTexelPrecisionBits; // number bits of precision for selecting texel weights
	public uint32 mipmapPrecisionBits; // number bits of precision for selecting mipmap weights
	public uint32 maxDrawIndexedIndexValue; // max index value for indexed draw calls (for 32-bit indices)
	public uint32 maxDrawIndirectCount; // max draw count for indirect drawing calls
	public float maxSamplerLodBias; // max absolute sampler LOD bias
	public float maxSamplerAnisotropy; // max degree of sampler anisotropy
	public uint32 maxViewports; // max number of active viewports
	public uint32[2] maxViewportDimensions; // max viewport dimensions (x,y)
	public float[2] viewportBoundsRange; // viewport bounds range (min,max)
	public uint32 viewportSubPixelBits; // number bits of subpixel precision for viewport
	public c_size minMemoryMapAlignment; // min required alignment of pointers returned by MapMemory (bytes)
	public VkDeviceSize minTexelBufferOffsetAlignment; // min required alignment for texel buffer offsets (bytes)
	public VkDeviceSize minUniformBufferOffsetAlignment; // min required alignment for uniform buffer sizes and offsets (bytes)
	public VkDeviceSize minStorageBufferOffsetAlignment; // min required alignment for storage buffer offsets (bytes)
	public int32 minTexelOffset; // min texel offset for OpTextureSampleOffset
	public uint32 maxTexelOffset; // max texel offset for OpTextureSampleOffset
	public int32 minTexelGatherOffset; // min texel offset for OpTextureGatherOffset
	public uint32 maxTexelGatherOffset; // max texel offset for OpTextureGatherOffset
	public float minInterpolationOffset; // furthest negative offset for interpolateAtOffset
	public float maxInterpolationOffset; // furthest positive offset for interpolateAtOffset
	public uint32 subPixelInterpolationOffsetBits; // number of subpixel bits for interpolateAtOffset
	public uint32 maxFramebufferWidth; // max width for a framebuffer
	public uint32 maxFramebufferHeight; // max height for a framebuffer
	public uint32 maxFramebufferLayers; // max layer count for a layered framebuffer
	public VkSampleCountFlags framebufferColorSampleCounts; // supported color sample counts for a framebuffer
	public VkSampleCountFlags framebufferDepthSampleCounts; // supported depth sample counts for a framebuffer
	public VkSampleCountFlags framebufferStencilSampleCounts; // supported stencil sample counts for a framebuffer
	public VkSampleCountFlags framebufferNoAttachmentsSampleCounts; // supported sample counts for a subpass which uses no attachments
	public uint32 maxColorAttachments; // max number of color attachments per subpass
	public VkSampleCountFlags sampledImageColorSampleCounts; // supported color sample counts for a non-integer sampled image
	public VkSampleCountFlags sampledImageIntegerSampleCounts; // supported sample counts for an integer image
	public VkSampleCountFlags sampledImageDepthSampleCounts; // supported depth sample counts for a sampled image
	public VkSampleCountFlags sampledImageStencilSampleCounts; // supported stencil sample counts for a sampled image
	public VkSampleCountFlags storageImageSampleCounts; // supported sample counts for a storage image
	public uint32 maxSampleMaskWords; // max number of sample mask words
	public VkBool32 timestampComputeAndGraphics; // timestamps on graphics and compute queues
	public float timestampPeriod; // number of nanoseconds it takes for timestamp query value to increment by 1
	public uint32 maxClipDistances; // max number of clip distances
	public uint32 maxCullDistances; // max number of cull distances
	public uint32 maxCombinedClipAndCullDistances; // max combined number of user clipping
	public uint32 discreteQueuePriorities; // distinct queue priorities available
	public float[2] pointSizeRange; // range (min,max) of supported point sizes
	public float[2] lineWidthRange; // range (min,max) of supported line widths
	public float pointSizeGranularity; // granularity of supported point sizes
	public float lineWidthGranularity; // granularity of supported line widths
	public VkBool32 strictLines; // line rasterization follows preferred rules
	public VkBool32 standardSampleLocations; // supports standard sample locations for all supported sample counts
	public VkDeviceSize optimalBufferCopyOffsetAlignment; // optimal offset of buffer copies
	public VkDeviceSize optimalBufferCopyRowPitchAlignment; // optimal pitch of buffer copies
	public VkDeviceSize nonCoherentAtomSize; // minimum size and alignment for non-coherent host-mapped device memory access
}

[CRepr] struct VkPhysicalDeviceMemoryProperties
{
	public uint32 memoryTypeCount;
	public VkMemoryType[VK_MAX_MEMORY_TYPES] memoryTypes;
	public uint32 memoryHeapCount;
	public VkMemoryHeap[VK_MAX_MEMORY_HEAPS] memoryHeaps;
}

[CRepr] struct VkPhysicalDeviceProperties
{
	public uint32 apiVersion;
	public uint32 driverVersion;
	public uint32 vendorID;
	public uint32 deviceID;
	public VkPhysicalDeviceType deviceType;
	public c_char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] deviceName;
	public uint8[VK_UUID_SIZE] pipelineCacheUUID;
	public VkPhysicalDeviceLimits limits;
	public VkPhysicalDeviceSparseProperties sparseProperties;
}

[CRepr] struct VkPhysicalDeviceSparseProperties
{
	public VkBool32 residencyStandard2DBlockShape; // Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format)
	public VkBool32 residencyStandard2DMultisampleBlockShape; // Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format)
	public VkBool32 residencyStandard3DBlockShape; // Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format)
	public VkBool32 residencyAlignedMipSize; // Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail
	public VkBool32 residencyNonResidentStrict; // Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
}

[AllowDuplicates] enum VkPhysicalDeviceType : int32
{
	Other = 0,
	IntegratedGpu = 1,
	DiscreteGpu = 2,
	VirtualGpu = 3,
	Cpu = 4,
}

[CRepr] struct VkQueueFamilyProperties
{
	public VkQueueFlags queueFlags; // Queue flags
	public uint32 queueCount;
	public uint32 timestampValidBits;
	public VkExtent3D minImageTransferGranularity; // Minimum alignment requirement for image transfers
}

[AllowDuplicates] enum VkQueueFlagBits : int32
{
	Graphics = 1 << 0, // Queue supports graphics operations
	Compute = 1 << 1, // Queue supports compute operations
	Transfer = 1 << 2, // Queue supports transfer operations
	SparseBinding = 1 << 3, // Queue supports sparse resource memory management operations
	Protected = 1 << 4, // Queues may support protected operations
	VideoDecodeKHR = 1 << 5,
	VideoEncodeKHR = 1 << 6,
	OpticalFlowNV = 1 << 8,
	DataGraphARM = 1 << 10,
}

typealias VkQueueFlags = VkQueueFlagBits;

[AllowDuplicates] enum VkSampleCountFlagBits : int32
{
	VK_1 = 1 << 0, // Sample count 1 supported
	VK_2 = 1 << 1, // Sample count 2 supported
	VK_4 = 1 << 2, // Sample count 4 supported
	VK_8 = 1 << 3, // Sample count 8 supported
	VK_16 = 1 << 4, // Sample count 16 supported
	VK_32 = 1 << 5, // Sample count 32 supported
	VK_64 = 1 << 6, // Sample count 64 supported
}

typealias VkSampleCountFlags = VkSampleCountFlagBits;

[AllowDuplicates] enum VkSystemAllocationScope : int32
{
	Command = 0,
	Object = 1,
	Cache = 2,
	Device = 3,
	Instance = 4,
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateInstance(VkInstanceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkInstance pInstance);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyInstance(VkInstance instance = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkEnumeratePhysicalDevices(VkInstance instance, out uint32 pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, out VkPhysicalDeviceFeatures pFeatures);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, out VkFormatProperties pFormatProperties);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, out VkImageFormatProperties pImageFormatProperties);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, out VkPhysicalDeviceProperties pProperties);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, out uint32 pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, out VkPhysicalDeviceMemoryProperties pMemoryProperties);
[CallingConvention(VKAPI_PTR)] function PFN_vkVoidFunction PFN_vkGetInstanceProcAddr(VkInstance instance, c_char* pName);
[CallingConvention(VKAPI_PTR)] function PFN_vkVoidFunction PFN_vkGetDeviceProcAddr(VkDevice device, c_char* pName);

// Device commands
class VkDevice { private this() { } }

typealias VkDeviceCreateFlags = VkFlags;

[CRepr] struct VkDeviceCreateInfo
{
	public const VkStructureType SType = .VkDeviceCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceCreateFlags flags;
	public uint32 queueCreateInfoCount;
	public VkDeviceQueueCreateInfo* pQueueCreateInfos;
	public VulkanSpan<VkDeviceQueueCreateInfo> queueCreateInfos
	{
		[Inline] get => .(queueCreateInfoCount, pQueueCreateInfos);
		[Inline] set mut { queueCreateInfoCount = value.count; pQueueCreateInfos = value.ptr; }
	}
	public uint32 enabledLayerCount;
	public c_char** ppEnabledLayerNames; // Ordered list of layer names to be enabled
	public VulkanSpan<c_char*> enabledLayerNames
	{
		[Inline] get => .(enabledLayerCount, ppEnabledLayerNames);
		[Inline] set mut { enabledLayerCount = value.count; ppEnabledLayerNames = value.ptr; }
	} // Ordered list of layer names to be enabled
	public uint32 enabledExtensionCount;
	public c_char** ppEnabledExtensionNames;
	public VulkanSpan<c_char*> enabledExtensionNames
	{
		[Inline] get => .(enabledExtensionCount, ppEnabledExtensionNames);
		[Inline] set mut { enabledExtensionCount = value.count; ppEnabledExtensionNames = value.ptr; }
	}
	public VkPhysicalDeviceFeatures* pEnabledFeatures;

	public this(void* pNext = null, VkDeviceCreateFlags flags = 0, VulkanSpan<VkDeviceQueueCreateInfo> queueCreateInfos = .(), VulkanSpan<c_char*> enabledLayerNames = .(), VulkanSpan<c_char*> enabledExtensionNames = .(), VkPhysicalDeviceFeatures* pEnabledFeatures = null) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.queueCreateInfos = queueCreateInfos;
		this.enabledLayerNames = enabledLayerNames;
		this.enabledExtensionNames = enabledExtensionNames;
		this.pEnabledFeatures = pEnabledFeatures;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkDeviceQueueCreateFlags = VkDeviceQueueCreateFlagBits;

[CRepr] struct VkDeviceQueueCreateInfo
{
	public const VkStructureType SType = .VkDeviceQueueCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceQueueCreateFlags flags;
	public uint32 queueFamilyIndex;
	public uint32 queueCount;
	public float* pQueuePriorities;
	public VulkanSpan<float> queuePriorities
	{
		[Inline] get => .(queueCount, pQueuePriorities);
		[Inline] set mut { queueCount = value.count; pQueuePriorities = value.ptr; }
	}

	public this(void* pNext, VkDeviceQueueCreateFlags flags, uint32 queueFamilyIndex, VulkanSpan<float> queuePriorities) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.queueFamilyIndex = queueFamilyIndex;
		this.queuePriorities = queuePriorities;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateDevice(VkPhysicalDevice physicalDevice, VkDeviceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkDevice pDevice);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyDevice(VkDevice device = null, VkAllocationCallbacks* pAllocator = null);

// Extension discovery commands
[CRepr] struct VkExtensionProperties
{
	public c_char[VK_MAX_EXTENSION_NAME_SIZE] extensionName; // extension name
	public uint32 specVersion; // version of the extension specification implemented
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkEnumerateInstanceExtensionProperties(c_char* pLayerName, out uint32 pPropertyCount, VkExtensionProperties* pProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkEnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, c_char* pLayerName, out uint32 pPropertyCount, VkExtensionProperties* pProperties = null);

// Layer discovery commands
[CRepr] struct VkLayerProperties
{
	public c_char[VK_MAX_EXTENSION_NAME_SIZE] layerName; // layer name
	public uint32 specVersion; // version of the layer specification implemented
	public uint32 implementationVersion; // build or release version of the layer's library
	public c_char[VK_MAX_DESCRIPTION_SIZE] description; // Free-form description of the layer
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkEnumerateInstanceLayerProperties(out uint32 pPropertyCount, VkLayerProperties* pProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkEnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, out uint32 pPropertyCount, VkLayerProperties* pProperties = null);

// Queue commands
[AllowDuplicates] enum VkPipelineStageFlagBits : int32
{
	TopOfPipe = 1 << 0, // Before subsequent commands are processed
	DrawIndirect = 1 << 1, // Draw/DispatchIndirect command fetch
	VertexInput = 1 << 2, // Vertex/index fetch
	VertexShader = 1 << 3, // Vertex shading
	TessellationControlShader = 1 << 4, // Tessellation control shading
	TessellationEvaluationShader = 1 << 5, // Tessellation evaluation shading
	GeometryShader = 1 << 6, // Geometry shading
	FragmentShader = 1 << 7, // Fragment shading
	EarlyFragmentTests = 1 << 8, // Early fragment (depth and stencil) tests
	LateFragmentTests = 1 << 9, // Late fragment (depth and stencil) tests
	ColorAttachmentOutput = 1 << 10, // Color attachment writes
	ComputeShader = 1 << 11, // Compute shading
	Transfer = 1 << 12, // Transfer/copy operations
	BottomOfPipe = 1 << 13, // After previous commands have completed
	Host = 1 << 14, // Indicates host (CPU) is a source/sink of the dependency
	AllGraphics = 1 << 15, // All stages of the graphics pipeline
	AllCommands = 1 << 16, // All stages supported on the queue
	None = 0,
	TransformFeedbackEXT = 1 << 24,
	ConditionalRenderingEXT = 1 << 18, // A pipeline stage for conditional rendering predicate fetch
	AccelerationStructureBuildKHR = 1 << 25,
	RayTracingShaderKHR = 1 << 21,
	ShadingRateImageNV = FragmentShadingRateAttachmentKHR,
	RayTracingShaderNV = RayTracingShaderKHR,
	AccelerationStructureBuildNV = AccelerationStructureBuildKHR,
	TaskShaderNV = TaskShaderEXT,
	MeshShaderNV = MeshShaderEXT,
	FragmentDensityProcessEXT = 1 << 23,
	FragmentShadingRateAttachmentKHR = 1 << 22,
	CommandPreprocessNV = CommandPreprocessEXT,
	NoneKHR = None,
	TaskShaderEXT = 1 << 19,
	MeshShaderEXT = 1 << 20,
	CommandPreprocessEXT = 1 << 17,
}

typealias VkPipelineStageFlags = VkPipelineStageFlagBits;

class VkQueue { private this() { } }

[CRepr] struct VkSubmitInfo
{
	public const VkStructureType SType = .VkSubmitInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 waitSemaphoreCount;
	public VkSemaphore* pWaitSemaphores;
	public VkPipelineStageFlags* pWaitDstStageMask;
	public VulkanDuoSpan<VkSemaphore, VkPipelineStageFlags> waitSemaphores_waitDstStageMask
	{
		[Inline] get => .(waitSemaphoreCount, pWaitSemaphores, pWaitDstStageMask);
		[Inline] set mut { waitSemaphoreCount = value.count; pWaitSemaphores = value.ptr1; pWaitDstStageMask = value.ptr2; }
	}
	public uint32 commandBufferCount;
	public VkCommandBuffer* pCommandBuffers;
	public VulkanSpan<VkCommandBuffer> commandBuffers
	{
		[Inline] get => .(commandBufferCount, pCommandBuffers);
		[Inline] set mut { commandBufferCount = value.count; pCommandBuffers = value.ptr; }
	}
	public uint32 signalSemaphoreCount;
	public VkSemaphore* pSignalSemaphores;
	public VulkanSpan<VkSemaphore> signalSemaphores
	{
		[Inline] get => .(signalSemaphoreCount, pSignalSemaphores);
		[Inline] set mut { signalSemaphoreCount = value.count; pSignalSemaphores = value.ptr; }
	}

	public this(void* pNext = null, VulkanDuoSpan<VkSemaphore, VkPipelineStageFlags> waitSemaphores_waitDstStageMask = .(), VulkanSpan<VkCommandBuffer> commandBuffers = .(), VulkanSpan<VkSemaphore> signalSemaphores = .()) : this()
	{
		this.pNext = pNext;
		this.waitSemaphores_waitDstStageMask = waitSemaphores_waitDstStageMask;
		this.commandBuffers = commandBuffers;
		this.signalSemaphores = signalSemaphores;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDeviceQueue(VkDevice device, uint32 queueFamilyIndex, uint32 queueIndex, out VkQueue pQueue);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkQueueSubmit(VkQueue queue, uint32 submitCount = 0, VkSubmitInfo* pSubmits = null, VkFence fence = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkQueueWaitIdle(VkQueue queue);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkDeviceWaitIdle(VkDevice device);

// Memory commands
[CRepr] struct VkMappedMemoryRange
{
	public const VkStructureType SType = .VkMappedMemoryRange;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceMemory memory; // Mapped memory object
	public VkDeviceSize offset; // Offset within the memory object where the range starts
	public VkDeviceSize size; // Size of the range within the memory object

	public this(void* pNext, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size)
	{
		this.pNext = pNext;
		this.memory = memory;
		this.offset = offset;
		this.size = size;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryAllocateInfo
{
	public const VkStructureType SType = .VkMemoryAllocateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize allocationSize; // Size of memory allocation
	public uint32 memoryTypeIndex; // Index of the of the memory type to allocate from

	public this(void* pNext, VkDeviceSize allocationSize, uint32 memoryTypeIndex)
	{
		this.pNext = pNext;
		this.allocationSize = allocationSize;
		this.memoryTypeIndex = memoryTypeIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkMemoryMapFlagBits : int32
{
	PlacedEXT = 1 << 0,
}

typealias VkMemoryMapFlags = VkMemoryMapFlagBits;

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkAllocateMemory(VkDevice device, VkMemoryAllocateInfo* pAllocateInfo, VkAllocationCallbacks* pAllocator, out VkDeviceMemory pMemory);
[CallingConvention(VKAPI_PTR)] function void PFN_vkFreeMemory(VkDevice device, VkDeviceMemory memory = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, out void* ppData);
[CallingConvention(VKAPI_PTR)] function void PFN_vkUnmapMemory(VkDevice device, VkDeviceMemory memory);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkFlushMappedMemoryRanges(VkDevice device, uint32 memoryRangeCount, VkMappedMemoryRange* pMemoryRanges);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkInvalidateMappedMemoryRanges(VkDevice device, uint32 memoryRangeCount, VkMappedMemoryRange* pMemoryRanges);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, out VkDeviceSize pCommittedMemoryInBytes);

// Memory management API commands
class VkDeviceMemory { private this() { } }

[CRepr] struct VkMemoryRequirements
{
	public VkDeviceSize size; // Specified in bytes
	public VkDeviceSize alignment; // Specified in bytes
	public uint32 memoryTypeBits; // Bitmask of the allowed memory type indices into memoryTypes[] for this object
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkBindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkBindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, out VkMemoryRequirements pMemoryRequirements);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetImageMemoryRequirements(VkDevice device, VkImage image, out VkMemoryRequirements pMemoryRequirements);

// Sparse resource memory management API commands
[CRepr] struct VkBindSparseInfo
{
	public const VkStructureType SType = .VkBindSparseInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 waitSemaphoreCount;
	public VkSemaphore* pWaitSemaphores;
	public VulkanSpan<VkSemaphore> waitSemaphores
	{
		[Inline] get => .(waitSemaphoreCount, pWaitSemaphores);
		[Inline] set mut { waitSemaphoreCount = value.count; pWaitSemaphores = value.ptr; }
	}
	public uint32 bufferBindCount;
	public VkSparseBufferMemoryBindInfo* pBufferBinds;
	public VulkanSpan<VkSparseBufferMemoryBindInfo> bufferBinds
	{
		[Inline] get => .(bufferBindCount, pBufferBinds);
		[Inline] set mut { bufferBindCount = value.count; pBufferBinds = value.ptr; }
	}
	public uint32 imageOpaqueBindCount;
	public VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds;
	public VulkanSpan<VkSparseImageOpaqueMemoryBindInfo> imageOpaqueBinds
	{
		[Inline] get => .(imageOpaqueBindCount, pImageOpaqueBinds);
		[Inline] set mut { imageOpaqueBindCount = value.count; pImageOpaqueBinds = value.ptr; }
	}
	public uint32 imageBindCount;
	public VkSparseImageMemoryBindInfo* pImageBinds;
	public VulkanSpan<VkSparseImageMemoryBindInfo> imageBinds
	{
		[Inline] get => .(imageBindCount, pImageBinds);
		[Inline] set mut { imageBindCount = value.count; pImageBinds = value.ptr; }
	}
	public uint32 signalSemaphoreCount;
	public VkSemaphore* pSignalSemaphores;
	public VulkanSpan<VkSemaphore> signalSemaphores
	{
		[Inline] get => .(signalSemaphoreCount, pSignalSemaphores);
		[Inline] set mut { signalSemaphoreCount = value.count; pSignalSemaphores = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkSemaphore> waitSemaphores = .(), VulkanSpan<VkSparseBufferMemoryBindInfo> bufferBinds = .(), VulkanSpan<VkSparseImageOpaqueMemoryBindInfo> imageOpaqueBinds = .(), VulkanSpan<VkSparseImageMemoryBindInfo> imageBinds = .(), VulkanSpan<VkSemaphore> signalSemaphores = .()) : this()
	{
		this.pNext = pNext;
		this.waitSemaphores = waitSemaphores;
		this.bufferBinds = bufferBinds;
		this.imageOpaqueBinds = imageOpaqueBinds;
		this.imageBinds = imageBinds;
		this.signalSemaphores = signalSemaphores;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkImageAspectFlagBits : int32
{
	Color = 1 << 0,
	Depth = 1 << 1,
	Stencil = 1 << 2,
	Metadata = 1 << 3,
	Plane0 = 1 << 4,
	Plane1 = 1 << 5,
	Plane2 = 1 << 6,
	None = 0,
	Plane0KHR = Plane0,
	Plane1KHR = Plane1,
	Plane2KHR = Plane2,
	MemoryPlane0EXT = 1 << 7,
	MemoryPlane1EXT = 1 << 8,
	MemoryPlane2EXT = 1 << 9,
	MemoryPlane3EXT = 1 << 10,
	NoneKHR = None,
}

typealias VkImageAspectFlags = VkImageAspectFlagBits;

[CRepr] struct VkImageSubresource
{
	public VkImageAspectFlags aspectMask;
	public uint32 mipLevel;
	public uint32 arrayLayer;

	public this(VkImageAspectFlags aspectMask, uint32 mipLevel, uint32 arrayLayer)
	{
		this.aspectMask = aspectMask;
		this.mipLevel = mipLevel;
		this.arrayLayer = arrayLayer;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkSparseBufferMemoryBindInfo
{
	public VkBuffer buffer;
	public uint32 bindCount;
	public VkSparseMemoryBind* pBinds;
	public VulkanSpan<VkSparseMemoryBind> binds
	{
		[Inline] get => .(bindCount, pBinds);
		[Inline] set mut { bindCount = value.count; pBinds = value.ptr; }
	}

	public this(VkBuffer buffer, VulkanSpan<VkSparseMemoryBind> binds) : this()
	{
		this.buffer = buffer;
		this.binds = binds;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkSparseImageFormatFlagBits : int32
{
	SingleMiptail = 1 << 0, // Image uses a single mip tail region for all array layers
	AlignedMipSize = 1 << 1, // Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels.
	NonstandardBlockSize = 1 << 2, // Image uses a non-standard sparse image block dimensions
}

typealias VkSparseImageFormatFlags = VkSparseImageFormatFlagBits;

[CRepr] struct VkSparseImageFormatProperties
{
	public VkImageAspectFlags aspectMask;
	public VkExtent3D imageGranularity;
	public VkSparseImageFormatFlags flags;
}

[CRepr] struct VkSparseImageMemoryBind
{
	public VkImageSubresource subresource;
	public VkOffset3D offset;
	public VkExtent3D extent;
	public VkDeviceMemory memory;
	public VkDeviceSize memoryOffset; // Specified in bytes
	public VkSparseMemoryBindFlags flags;

	public this(VkImageSubresource subresource, VkOffset3D offset, VkExtent3D extent, VkDeviceMemory memory, VkDeviceSize memoryOffset, VkSparseMemoryBindFlags flags = 0)
	{
		this.subresource = subresource;
		this.offset = offset;
		this.extent = extent;
		this.memory = memory;
		this.memoryOffset = memoryOffset;
		this.flags = flags;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkSparseImageMemoryBindInfo
{
	public VkImage image;
	public uint32 bindCount;
	public VkSparseImageMemoryBind* pBinds;
	public VulkanSpan<VkSparseImageMemoryBind> binds
	{
		[Inline] get => .(bindCount, pBinds);
		[Inline] set mut { bindCount = value.count; pBinds = value.ptr; }
	}

	public this(VkImage image, VulkanSpan<VkSparseImageMemoryBind> binds) : this()
	{
		this.image = image;
		this.binds = binds;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkSparseImageMemoryRequirements
{
	public VkSparseImageFormatProperties formatProperties;
	public uint32 imageMipTailFirstLod;
	public VkDeviceSize imageMipTailSize; // Specified in bytes, must be a multiple of sparse block size in bytes / alignment
	public VkDeviceSize imageMipTailOffset; // Specified in bytes, must be a multiple of sparse block size in bytes / alignment
	public VkDeviceSize imageMipTailStride; // Specified in bytes, must be a multiple of sparse block size in bytes / alignment
}

[CRepr] struct VkSparseImageOpaqueMemoryBindInfo
{
	public VkImage image;
	public uint32 bindCount;
	public VkSparseMemoryBind* pBinds;
	public VulkanSpan<VkSparseMemoryBind> binds
	{
		[Inline] get => .(bindCount, pBinds);
		[Inline] set mut { bindCount = value.count; pBinds = value.ptr; }
	}

	public this(VkImage image, VulkanSpan<VkSparseMemoryBind> binds) : this()
	{
		this.image = image;
		this.binds = binds;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkSparseMemoryBind
{
	public VkDeviceSize resourceOffset; // Specified in bytes
	public VkDeviceSize size; // Specified in bytes
	public VkDeviceMemory memory;
	public VkDeviceSize memoryOffset; // Specified in bytes
	public VkSparseMemoryBindFlags flags;

	public this(VkDeviceSize resourceOffset, VkDeviceSize size, VkDeviceMemory memory, VkDeviceSize memoryOffset, VkSparseMemoryBindFlags flags = 0)
	{
		this.resourceOffset = resourceOffset;
		this.size = size;
		this.memory = memory;
		this.memoryOffset = memoryOffset;
		this.flags = flags;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkSparseMemoryBindFlagBits : int32
{
	Metadata = 1 << 0, // Operation binds resource metadata to memory
}

typealias VkSparseMemoryBindFlags = VkSparseMemoryBindFlagBits;

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetImageSparseMemoryRequirements(VkDevice device, VkImage image, out uint32 pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, out uint32 pPropertyCount, VkSparseImageFormatProperties* pProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkQueueBindSparse(VkQueue queue, uint32 bindInfoCount = 0, VkBindSparseInfo* pBindInfo = null, VkFence fence = null);

// Fence commands
class VkFence { private this() { } }

[AllowDuplicates] enum VkFenceCreateFlagBits : int32
{
	Signaled = 1 << 0,
}

typealias VkFenceCreateFlags = VkFenceCreateFlagBits;

[CRepr] struct VkFenceCreateInfo
{
	public const VkStructureType SType = .VkFenceCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFenceCreateFlags flags; // Fence creation flags

	public this(void* pNext = null, VkFenceCreateFlags flags = 0)
	{
		this.pNext = pNext;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateFence(VkDevice device, VkFenceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkFence pFence);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyFence(VkDevice device, VkFence fence = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkResetFences(VkDevice device, uint32 fenceCount, VkFence* pFences);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetFenceStatus(VkDevice device, VkFence fence);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkWaitForFences(VkDevice device, uint32 fenceCount, VkFence* pFences, VkBool32 waitAll, uint64 timeout);

// Queue semaphore commands
class VkSemaphore { private this() { } }

typealias VkSemaphoreCreateFlags = VkFlags;

[CRepr] struct VkSemaphoreCreateInfo
{
	public const VkStructureType SType = .VkSemaphoreCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSemaphoreCreateFlags flags; // Semaphore creation flags

	public this(void* pNext = null, VkSemaphoreCreateFlags flags = 0)
	{
		this.pNext = pNext;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateSemaphore(VkDevice device, VkSemaphoreCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSemaphore pSemaphore);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroySemaphore(VkDevice device, VkSemaphore semaphore = null, VkAllocationCallbacks* pAllocator = null);

// Event commands
class VkEvent { private this() { } }

typealias VkEventCreateFlags = VkEventCreateFlagBits;

[AllowDuplicates] enum VkEventCreateFlagBits : int32
{
	DeviceOnly = 1 << 0,
	DeviceOnlyKHR = DeviceOnly,
}

[CRepr] struct VkEventCreateInfo
{
	public const VkStructureType SType = .VkEventCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkEventCreateFlags flags; // Event creation flags

	public this(void* pNext = null, VkEventCreateFlags flags = 0)
	{
		this.pNext = pNext;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateEvent(VkDevice device, VkEventCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkEvent pEvent);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyEvent(VkDevice device, VkEvent event = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetEventStatus(VkDevice device, VkEvent event);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkSetEvent(VkDevice device, VkEvent event);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkResetEvent(VkDevice device, VkEvent event);

// Query commands
[AllowDuplicates] enum VkQueryPipelineStatisticFlagBits : int32
{
	InputAssemblyVertices = 1 << 0, // Optional
	InputAssemblyPrimitives = 1 << 1, // Optional
	VertexShaderInvocations = 1 << 2, // Optional
	GeometryShaderInvocations = 1 << 3, // Optional
	GeometryShaderPrimitives = 1 << 4, // Optional
	ClippingInvocations = 1 << 5, // Optional
	ClippingPrimitives = 1 << 6, // Optional
	FragmentShaderInvocations = 1 << 7, // Optional
	TessellationControlShaderPatches = 1 << 8, // Optional
	TessellationEvaluationShaderInvocations = 1 << 9, // Optional
	ComputeShaderInvocations = 1 << 10, // Optional
	TaskShaderInvocationsEXT = 1 << 11,
	MeshShaderInvocationsEXT = 1 << 12,
	ClusterCullingShaderInvocationsHUAWEI = 1 << 13,
}

typealias VkQueryPipelineStatisticFlags = VkQueryPipelineStatisticFlagBits;

class VkQueryPool { private this() { } }

[AllowDuplicates] enum VkQueryPoolCreateFlagBits : int32
{
	ResetKHR = 1 << 0,
}

typealias VkQueryPoolCreateFlags = VkQueryPoolCreateFlagBits;

[CRepr] struct VkQueryPoolCreateInfo
{
	public const VkStructureType SType = .VkQueryPoolCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkQueryPoolCreateFlags flags;
	public VkQueryType queryType;
	public uint32 queryCount;
	public VkQueryPipelineStatisticFlags pipelineStatistics; // Optional

	public this(void* pNext, VkQueryPoolCreateFlags flags, VkQueryType queryType, uint32 queryCount, VkQueryPipelineStatisticFlags pipelineStatistics = 0)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.queryType = queryType;
		this.queryCount = queryCount;
		this.pipelineStatistics = pipelineStatistics;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkQueryResultFlagBits : int32
{
	VK_64 = 1 << 0, // Results of the queries are written to the destination buffer as 64-bit values
	Wait = 1 << 1, // Results of the queries are waited on before proceeding with the result copy
	WithAvailability = 1 << 2, // Besides the results of the query, the availability of the results is also written
	Partial = 1 << 3, // Copy the partial results of the query even if the final results are not available
	WithStatusKHR = 1 << 4,
}

typealias VkQueryResultFlags = VkQueryResultFlagBits;

[AllowDuplicates] enum VkQueryType : int32
{
	Occlusion = 0,
	PipelineStatistics = 1, // Optional
	Timestamp = 2,
	ResultStatusOnlyKHR = 1000023000,
	TransformFeedbackStreamEXT = 1000028004,
	PerformanceQueryKHR = 1000116000,
	AccelerationStructureCompactedSizeKHR = 1000150000,
	AccelerationStructureSerializationSizeKHR = 1000150001,
	AccelerationStructureCompactedSizeNV = 1000165000,
	PerformanceQueryINTEL = 1000210000,
	VideoEncodeFeedbackKHR = 1000299000,
	MeshPrimitivesGeneratedEXT = 1000328000,
	PrimitivesGeneratedEXT = 1000382000,
	AccelerationStructureSerializationBottomLevelPointersKHR = 1000386000,
	AccelerationStructureSizeKHR = 1000386001,
	MicromapSerializationSizeEXT = 1000396000,
	MicromapCompactedSizeEXT = 1000396001,
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateQueryPool(VkDevice device, VkQueryPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkQueryPool pQueryPool);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyQueryPool(VkDevice device, VkQueryPool queryPool = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32 firstQuery, uint32 queryCount, c_size dataSize, out void pData, VkDeviceSize stride, VkQueryResultFlags flags = 0);

// Buffer commands
class VkBuffer { private this() { } }

[AllowDuplicates] enum VkBufferCreateFlagBits : int32
{
	SparseBinding = 1 << 0, // Buffer should support sparse backing
	SparseResidency = 1 << 1, // Buffer should support sparse backing with partial residency
	SparseAliased = 1 << 2, // Buffer should support constant data access to physical memory ranges mapped into multiple locations of sparse buffers
	Protected = 1 << 3, // Buffer requires protected memory
	DeviceAddressCaptureReplay = 1 << 4,
	DeviceAddressCaptureReplayEXT = DeviceAddressCaptureReplay,
	DeviceAddressCaptureReplayKHR = DeviceAddressCaptureReplay,
	DescriptorBufferCaptureReplayEXT = 1 << 5,
	VideoProfileIndependentKHR = 1 << 6,
}

typealias VkBufferCreateFlags = VkBufferCreateFlagBits;

[CRepr] struct VkBufferCreateInfo
{
	public const VkStructureType SType = .VkBufferCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBufferCreateFlags flags; // Buffer creation flags
	public VkDeviceSize size; // Specified in bytes
	public VkBufferUsageFlags usage; // Buffer usage flags
	public VkSharingMode sharingMode;
	public uint32 queueFamilyIndexCount;
	public uint32* pQueueFamilyIndices;
	public VulkanSpan<uint32> queueFamilyIndices
	{
		[Inline] get => .(queueFamilyIndexCount, pQueueFamilyIndices);
		[Inline] set mut { queueFamilyIndexCount = value.count; pQueueFamilyIndices = value.ptr; }
	}

	public this(void* pNext, VkBufferCreateFlags flags, VkDeviceSize size, VkBufferUsageFlags usage, VkSharingMode sharingMode, VulkanSpan<uint32> queueFamilyIndices = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.size = size;
		this.usage = usage;
		this.sharingMode = sharingMode;
		this.queueFamilyIndices = queueFamilyIndices;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkBufferUsageFlagBits : int32
{
	TransferSrc = 1 << 0, // Can be used as a source of transfer operations
	TransferDst = 1 << 1, // Can be used as a destination of transfer operations
	UniformTexelBuffer = 1 << 2, // Can be used as TBO
	StorageTexelBuffer = 1 << 3, // Can be used as IBO
	UniformBuffer = 1 << 4, // Can be used as UBO
	StorageBuffer = 1 << 5, // Can be used as SSBO
	IndexBuffer = 1 << 6, // Can be used as source of fixed-function index fetch (index buffer)
	VertexBuffer = 1 << 7, // Can be used as source of fixed-function vertex fetch (VBO)
	IndirectBuffer = 1 << 8, // Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)
	ShaderDeviceAddress = 1 << 17,
	VideoDecodeSrcKHR = 1 << 13,
	VideoDecodeDstKHR = 1 << 14,
	TransformFeedbackBufferEXT = 1 << 11,
	TransformFeedbackCounterBufferEXT = 1 << 12,
	ConditionalRenderingEXT = 1 << 9, // Specifies the buffer can be used as predicate in conditional rendering
	ExecutionGraphScratchAMDX = 1 << 25,
	AccelerationStructureBuildInputReadOnlyKHR = 1 << 19,
	AccelerationStructureStorageKHR = 1 << 20,
	ShaderBindingTableKHR = 1 << 10,
	RayTracingNV = ShaderBindingTableKHR,
	ShaderDeviceAddressEXT = ShaderDeviceAddress,
	ShaderDeviceAddressKHR = ShaderDeviceAddress,
	VideoEncodeDstKHR = 1 << 15,
	VideoEncodeSrcKHR = 1 << 16,
	SamplerDescriptorBufferEXT = 1 << 21,
	ResourceDescriptorBufferEXT = 1 << 22,
	PushDescriptorsDescriptorBufferEXT = 1 << 26,
	MicromapBuildInputReadOnlyEXT = 1 << 23,
	MicromapStorageEXT = 1 << 24,
	TileMemoryQCOM = 1 << 27,
}

typealias VkBufferUsageFlags = VkBufferUsageFlagBits;

[AllowDuplicates] enum VkSharingMode : int32
{
	Exclusive = 0,
	Concurrent = 1,
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateBuffer(VkDevice device, VkBufferCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkBuffer pBuffer);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyBuffer(VkDevice device, VkBuffer buffer = null, VkAllocationCallbacks* pAllocator = null);

// Buffer view commands
class VkBufferView { private this() { } }

typealias VkBufferViewCreateFlags = VkFlags;

[CRepr] struct VkBufferViewCreateInfo
{
	public const VkStructureType SType = .VkBufferViewCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBufferViewCreateFlags flags;
	public VkBuffer buffer;
	public VkFormat format; // Optionally specifies format of elements
	public VkDeviceSize offset; // Specified in bytes
	public VkDeviceSize range; // View size specified in bytes

	public this(void* pNext, VkBufferViewCreateFlags flags, VkBuffer buffer, VkFormat format, VkDeviceSize offset, VkDeviceSize range)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.buffer = buffer;
		this.format = format;
		this.offset = offset;
		this.range = range;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateBufferView(VkDevice device, VkBufferViewCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkBufferView pView);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyBufferView(VkDevice device, VkBufferView bufferView = null, VkAllocationCallbacks* pAllocator = null);

// Image commands
class VkImage { private this() { } }

[CRepr] struct VkImageCreateInfo
{
	public const VkStructureType SType = .VkImageCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageCreateFlags flags; // Image creation flags
	public VkImageType imageType;
	public VkFormat format;
	public VkExtent3D extent;
	public uint32 mipLevels;
	public uint32 arrayLayers;
	public VkSampleCountFlagBits samples;
	public VkImageTiling tiling;
	public VkImageUsageFlags usage; // Image usage flags
	public VkSharingMode sharingMode; // Cross-queue-family sharing mode
	public uint32 queueFamilyIndexCount; // Number of queue families to share across
	public uint32* pQueueFamilyIndices; // Array of queue family indices to share across
	public VulkanSpan<uint32> queueFamilyIndices
	{
		[Inline] get => .(queueFamilyIndexCount, pQueueFamilyIndices);
		[Inline] set mut { queueFamilyIndexCount = value.count; pQueueFamilyIndices = value.ptr; }
	} // Array of queue family indices to share across
	public VkImageLayout initialLayout; // Initial image layout for all subresources

	public this(void* pNext, VkImageCreateFlags flags, VkImageType imageType, VkFormat format, VkExtent3D extent, uint32 mipLevels, uint32 arrayLayers, VkSampleCountFlagBits samples, VkImageTiling tiling, VkImageUsageFlags usage, VkSharingMode sharingMode, VulkanSpan<uint32> queueFamilyIndices, VkImageLayout initialLayout) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.imageType = imageType;
		this.format = format;
		this.extent = extent;
		this.mipLevels = mipLevels;
		this.arrayLayers = arrayLayers;
		this.samples = samples;
		this.tiling = tiling;
		this.usage = usage;
		this.sharingMode = sharingMode;
		this.queueFamilyIndices = queueFamilyIndices;
		this.initialLayout = initialLayout;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkImageLayout : int32
{
	Undefined = 0, // Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)
	General = 1, // General layout when image can be used for any kind of access
	ColorAttachmentOptimal = 2, // Optimal layout when image is only used for color attachment read/write
	DepthStencilAttachmentOptimal = 3, // Optimal layout when image is only used for depth/stencil attachment read/write
	DepthStencilReadOnlyOptimal = 4, // Optimal layout when image is used for read only depth/stencil attachment and shader access
	ShaderReadOnlyOptimal = 5, // Optimal layout when image is used for read only shader access
	TransferSrcOptimal = 6, // Optimal layout when image is used only as source of transfer operations
	TransferDstOptimal = 7, // Optimal layout when image is used only as destination of transfer operations
	Preinitialized = 8, // Initial layout used when the data is populated by the CPU
	DepthReadOnlyStencilAttachmentOptimal = 1000117000,
	DepthAttachmentStencilReadOnlyOptimal = 1000117001,
	DepthAttachmentOptimal = 1000241000,
	DepthReadOnlyOptimal = 1000241001,
	StencilAttachmentOptimal = 1000241002,
	StencilReadOnlyOptimal = 1000241003,
	ReadOnlyOptimal = 1000314000,
	AttachmentOptimal = 1000314001,
	RenderingLocalRead = 1000232000,
	PresentSrcKHR = 1000001002,
	VideoDecodeDstKHR = 1000024000,
	VideoDecodeSrcKHR = 1000024001,
	VideoDecodeDpbKHR = 1000024002,
	SharedPresentKHR = 1000111000,
	DepthReadOnlyStencilAttachmentOptimalKHR = DepthReadOnlyStencilAttachmentOptimal,
	DepthAttachmentStencilReadOnlyOptimalKHR = DepthAttachmentStencilReadOnlyOptimal,
	ShadingRateOptimalNV = FragmentShadingRateAttachmentOptimalKHR,
	FragmentDensityMapOptimalEXT = 1000218000,
	FragmentShadingRateAttachmentOptimalKHR = 1000164003,
	RenderingLocalReadKHR = RenderingLocalRead,
	DepthAttachmentOptimalKHR = DepthAttachmentOptimal,
	DepthReadOnlyOptimalKHR = DepthReadOnlyOptimal,
	StencilAttachmentOptimalKHR = StencilAttachmentOptimal,
	StencilReadOnlyOptimalKHR = StencilReadOnlyOptimal,
	VideoEncodeDstKHR = 1000299000,
	VideoEncodeSrcKHR = 1000299001,
	VideoEncodeDpbKHR = 1000299002,
	ReadOnlyOptimalKHR = ReadOnlyOptimal,
	AttachmentOptimalKHR = AttachmentOptimal,
	AttachmentFeedbackLoopOptimalEXT = 1000339000,
	TensorAliasingARM = 1000460000,
	VideoEncodeQuantizationMapKHR = 1000553000,
	ZeroInitializedEXT = 1000620000,
}

[CRepr] struct VkSubresourceLayout
{
	public VkDeviceSize offset; // Specified in bytes
	public VkDeviceSize size; // Specified in bytes
	public VkDeviceSize rowPitch; // Specified in bytes
	public VkDeviceSize arrayPitch; // Specified in bytes
	public VkDeviceSize depthPitch; // Specified in bytes

	public this(VkDeviceSize offset, VkDeviceSize size, VkDeviceSize rowPitch, VkDeviceSize arrayPitch, VkDeviceSize depthPitch)
	{
		this.offset = offset;
		this.size = size;
		this.rowPitch = rowPitch;
		this.arrayPitch = arrayPitch;
		this.depthPitch = depthPitch;
	}

	public this()
	{
		this = default;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateImage(VkDevice device, VkImageCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkImage pImage);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyImage(VkDevice device, VkImage image = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetImageSubresourceLayout(VkDevice device, VkImage image, VkImageSubresource* pSubresource, out VkSubresourceLayout pLayout);

// Image view commands
[CRepr] struct VkComponentMapping
{
	public VkComponentSwizzle r;
	public VkComponentSwizzle g;
	public VkComponentSwizzle b;
	public VkComponentSwizzle a;

	public this(VkComponentSwizzle r, VkComponentSwizzle g, VkComponentSwizzle b, VkComponentSwizzle a)
	{
		this.r = r;
		this.g = g;
		this.b = b;
		this.a = a;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkComponentSwizzle : int32
{
	Identity = 0,
	Zero = 1,
	One = 2,
	R = 3,
	G = 4,
	B = 5,
	A = 6,
}

[CRepr] struct VkImageSubresourceRange
{
	public VkImageAspectFlags aspectMask;
	public uint32 baseMipLevel;
	public uint32 levelCount;
	public uint32 baseArrayLayer;
	public uint32 layerCount;

	public this(VkImageAspectFlags aspectMask, uint32 baseMipLevel, uint32 levelCount, uint32 baseArrayLayer, uint32 layerCount)
	{
		this.aspectMask = aspectMask;
		this.baseMipLevel = baseMipLevel;
		this.levelCount = levelCount;
		this.baseArrayLayer = baseArrayLayer;
		this.layerCount = layerCount;
	}

	public this()
	{
		this = default;
	}
}

class VkImageView { private this() { } }

[AllowDuplicates] enum VkImageViewCreateFlagBits : int32
{
	FragmentDensityMapDynamicEXT = 1 << 0,
	DescriptorBufferCaptureReplayEXT = 1 << 2,
	FragmentDensityMapDeferredEXT = 1 << 1,
}

typealias VkImageViewCreateFlags = VkImageViewCreateFlagBits;

[CRepr] struct VkImageViewCreateInfo
{
	public const VkStructureType SType = .VkImageViewCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageViewCreateFlags flags;
	public VkImage image;
	public VkImageViewType viewType;
	public VkFormat format;
	public VkComponentMapping components;
	public VkImageSubresourceRange subresourceRange;

	public this(void* pNext, VkImageViewCreateFlags flags, VkImage image, VkImageViewType viewType, VkFormat format, VkComponentMapping components, VkImageSubresourceRange subresourceRange)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.image = image;
		this.viewType = viewType;
		this.format = format;
		this.components = components;
		this.subresourceRange = subresourceRange;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkImageViewType : int32
{
	VK_1d = 0,
	VK_2d = 1,
	VK_3d = 2,
	Cube = 3,
	VK_1dArray = 4,
	VK_2dArray = 5,
	CubeArray = 6,
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateImageView(VkDevice device, VkImageViewCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkImageView pView);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyImageView(VkDevice device, VkImageView imageView = null, VkAllocationCallbacks* pAllocator = null);

// Shader commands
class VkShaderModule { private this() { } }

typealias VkShaderModuleCreateFlags = VkFlags;

[CRepr] struct VkShaderModuleCreateInfo
{
	public const VkStructureType SType = .VkShaderModuleCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext; // noautovalidity because this structure can be either an explicit parameter, or passed in a pNext chain
	public VkShaderModuleCreateFlags flags;
	public c_size codeSize; // Specified in bytes
	public uint32* pCode; // Binary code of size codeSize

	public this(void* pNext, VkShaderModuleCreateFlags flags, c_size codeSize, uint32* pCode)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.codeSize = codeSize;
		this.pCode = pCode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateShaderModule(VkDevice device, VkShaderModuleCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkShaderModule pShaderModule);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyShaderModule(VkDevice device, VkShaderModule shaderModule = null, VkAllocationCallbacks* pAllocator = null);

// Pipeline Cache commands
class VkPipelineCache { private this() { } }

typealias VkPipelineCacheCreateFlags = VkPipelineCacheCreateFlagBits;

[CRepr] struct VkPipelineCacheCreateInfo
{
	public const VkStructureType SType = .VkPipelineCacheCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineCacheCreateFlags flags;
	public c_size initialDataSize; // Size of initial data to populate cache, in bytes
	public void* pInitialData; // Initial data to populate cache

	public this(void* pNext, VkPipelineCacheCreateFlags flags, c_size initialDataSize, void* pInitialData)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.initialDataSize = initialDataSize;
		this.pInitialData = pInitialData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreatePipelineCache(VkDevice device, VkPipelineCacheCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkPipelineCache pPipelineCache);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, out c_size pDataSize, out void pData);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkMergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32 srcCacheCount, VkPipelineCache* pSrcCaches);

// Pipeline commands
[AllowDuplicates] enum VkBlendFactor : int32
{
	Zero = 0,
	One = 1,
	SrcColor = 2,
	OneMinusSrcColor = 3,
	DstColor = 4,
	OneMinusDstColor = 5,
	SrcAlpha = 6,
	OneMinusSrcAlpha = 7,
	DstAlpha = 8,
	OneMinusDstAlpha = 9,
	ConstantColor = 10,
	OneMinusConstantColor = 11,
	ConstantAlpha = 12,
	OneMinusConstantAlpha = 13,
	SrcAlphaSaturate = 14,
	Src1Color = 15,
	OneMinusSrc1Color = 16,
	Src1Alpha = 17,
	OneMinusSrc1Alpha = 18,
}

[AllowDuplicates] enum VkBlendOp : int32
{
	Add = 0,
	Subtract = 1,
	ReverseSubtract = 2,
	Min = 3,
	Max = 4,
	ZeroEXT = 1000148000,
	SrcEXT = 1000148001,
	DstEXT = 1000148002,
	SrcOverEXT = 1000148003,
	DstOverEXT = 1000148004,
	SrcInEXT = 1000148005,
	DstInEXT = 1000148006,
	SrcOutEXT = 1000148007,
	DstOutEXT = 1000148008,
	SrcAtopEXT = 1000148009,
	DstAtopEXT = 1000148010,
	XorEXT = 1000148011,
	MultiplyEXT = 1000148012,
	ScreenEXT = 1000148013,
	OverlayEXT = 1000148014,
	DarkenEXT = 1000148015,
	LightenEXT = 1000148016,
	ColordodgeEXT = 1000148017,
	ColorburnEXT = 1000148018,
	HardlightEXT = 1000148019,
	SoftlightEXT = 1000148020,
	DifferenceEXT = 1000148021,
	ExclusionEXT = 1000148022,
	InvertEXT = 1000148023,
	InvertRgbEXT = 1000148024,
	LineardodgeEXT = 1000148025,
	LinearburnEXT = 1000148026,
	VividlightEXT = 1000148027,
	LinearlightEXT = 1000148028,
	PinlightEXT = 1000148029,
	HardmixEXT = 1000148030,
	HslHueEXT = 1000148031,
	HslSaturationEXT = 1000148032,
	HslColorEXT = 1000148033,
	HslLuminosityEXT = 1000148034,
	PlusEXT = 1000148035,
	PlusClampedEXT = 1000148036,
	PlusClampedAlphaEXT = 1000148037,
	PlusDarkerEXT = 1000148038,
	MinusEXT = 1000148039,
	MinusClampedEXT = 1000148040,
	ContrastEXT = 1000148041,
	InvertOvgEXT = 1000148042,
	RedEXT = 1000148043,
	GreenEXT = 1000148044,
	BlueEXT = 1000148045,
}

[AllowDuplicates] enum VkColorComponentFlagBits : int32
{
	R = 1 << 0,
	G = 1 << 1,
	B = 1 << 2,
	A = 1 << 3,
}

typealias VkColorComponentFlags = VkColorComponentFlagBits;

[AllowDuplicates] enum VkCompareOp : int32
{
	Never = 0,
	Less = 1,
	Equal = 2,
	LessOrEqual = 3,
	Greater = 4,
	NotEqual = 5,
	GreaterOrEqual = 6,
	Always = 7,
}

[CRepr] struct VkComputePipelineCreateInfo
{
	public const VkStructureType SType = .VkComputePipelineCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineCreateFlags flags; // Pipeline creation flags
	public VkPipelineShaderStageCreateInfo stage;
	public VkPipelineLayout layout; // Interface layout of the pipeline
	public VkPipeline basePipelineHandle; // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
	public int32 basePipelineIndex; // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of

	public this(void* pNext, VkPipelineCreateFlags flags, VkPipelineShaderStageCreateInfo stage, VkPipelineLayout layout, VkPipeline basePipelineHandle, int32 basePipelineIndex)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.stage = stage;
		this.layout = layout;
		this.basePipelineHandle = basePipelineHandle;
		this.basePipelineIndex = basePipelineIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkCullModeFlagBits : int32
{
	None = 0,
	Front = 1 << 0,
	Back = 1 << 1,
	FrontAndBack = 0x00000003,
}

typealias VkCullModeFlags = VkCullModeFlagBits;

[AllowDuplicates] enum VkDynamicState : int32
{
	Viewport = 0,
	Scissor = 1,
	LineWidth = 2,
	DepthBias = 3,
	BlendConstants = 4,
	DepthBounds = 5,
	StencilCompareMask = 6,
	StencilWriteMask = 7,
	StencilReference = 8,
	CullMode = 1000267000,
	FrontFace = 1000267001,
	PrimitiveTopology = 1000267002,
	ViewportWithCount = 1000267003,
	ScissorWithCount = 1000267004,
	VertexInputBindingStride = 1000267005,
	DepthTestEnable = 1000267006,
	DepthWriteEnable = 1000267007,
	DepthCompareOp = 1000267008,
	DepthBoundsTestEnable = 1000267009,
	StencilTestEnable = 1000267010,
	StencilOp = 1000267011,
	RasterizerDiscardEnable = 1000377001,
	DepthBiasEnable = 1000377002,
	PrimitiveRestartEnable = 1000377004,
	LineStipple = 1000259000,
	ViewportWScalingNV = 1000087000,
	DiscardRectangleEXT = 1000099000,
	DiscardRectangleEnableEXT = 1000099001,
	DiscardRectangleModeEXT = 1000099002,
	SampleLocationsEXT = 1000143000,
	RayTracingPipelineStackSizeKHR = 1000347000,
	ViewportShadingRatePaletteNV = 1000164004,
	ViewportCoarseSampleOrderNV = 1000164006,
	ExclusiveScissorEnableNV = 1000205000,
	ExclusiveScissorNV = 1000205001,
	FragmentShadingRateKHR = 1000226000,
	LineStippleEXT = LineStipple,
	CullModeEXT = CullMode,
	FrontFaceEXT = FrontFace,
	PrimitiveTopologyEXT = PrimitiveTopology,
	ViewportWithCountEXT = ViewportWithCount,
	ScissorWithCountEXT = ScissorWithCount,
	VertexInputBindingStrideEXT = VertexInputBindingStride,
	DepthTestEnableEXT = DepthTestEnable,
	DepthWriteEnableEXT = DepthWriteEnable,
	DepthCompareOpEXT = DepthCompareOp,
	DepthBoundsTestEnableEXT = DepthBoundsTestEnable,
	StencilTestEnableEXT = StencilTestEnable,
	StencilOpEXT = StencilOp,
	VertexInputEXT = 1000352000,
	PatchControlPointsEXT = 1000377000, // Not promoted to 1.3
	RasterizerDiscardEnableEXT = RasterizerDiscardEnable,
	DepthBiasEnableEXT = DepthBiasEnable,
	LogicOpEXT = 1000377003, // Not promoted to 1.3
	PrimitiveRestartEnableEXT = PrimitiveRestartEnable,
	ColorWriteEnableEXT = 1000381000,
	DepthClampEnableEXT = 1000455003,
	PolygonModeEXT = 1000455004,
	RasterizationSamplesEXT = 1000455005,
	SampleMaskEXT = 1000455006,
	AlphaToCoverageEnableEXT = 1000455007,
	AlphaToOneEnableEXT = 1000455008,
	LogicOpEnableEXT = 1000455009,
	ColorBlendEnableEXT = 1000455010,
	ColorBlendEquationEXT = 1000455011,
	ColorWriteMaskEXT = 1000455012,
	TessellationDomainOriginEXT = 1000455002,
	RasterizationStreamEXT = 1000455013,
	ConservativeRasterizationModeEXT = 1000455014,
	ExtraPrimitiveOverestimationSizeEXT = 1000455015,
	DepthClipEnableEXT = 1000455016,
	SampleLocationsEnableEXT = 1000455017,
	ColorBlendAdvancedEXT = 1000455018,
	ProvokingVertexModeEXT = 1000455019,
	LineRasterizationModeEXT = 1000455020,
	LineStippleEnableEXT = 1000455021,
	DepthClipNegativeOneToOneEXT = 1000455022,
	ViewportWScalingEnableNV = 1000455023,
	ViewportSwizzleNV = 1000455024,
	CoverageToColorEnableNV = 1000455025,
	CoverageToColorLocationNV = 1000455026,
	CoverageModulationModeNV = 1000455027,
	CoverageModulationTableEnableNV = 1000455028,
	CoverageModulationTableNV = 1000455029,
	ShadingRateImageEnableNV = 1000455030,
	RepresentativeFragmentTestEnableNV = 1000455031,
	CoverageReductionModeNV = 1000455032,
	AttachmentFeedbackLoopEnableEXT = 1000524000,
	LineStippleKHR = LineStipple,
	DepthClampRangeEXT = 1000582000,
}

[AllowDuplicates] enum VkFrontFace : int32
{
	CounterClockwise = 0,
	Clockwise = 1,
}

[CRepr] struct VkGraphicsPipelineCreateInfo
{
	public const VkStructureType SType = .VkGraphicsPipelineCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineCreateFlags flags; // Pipeline creation flags
	public uint32 stageCount;
	public VkPipelineShaderStageCreateInfo* pStages; // One entry for each active shader stage
	public VulkanSpan<VkPipelineShaderStageCreateInfo> stages
	{
		[Inline] get => .(stageCount, pStages);
		[Inline] set mut { stageCount = value.count; pStages = value.ptr; }
	} // One entry for each active shader stage
	public VkPipelineVertexInputStateCreateInfo* pVertexInputState;
	public VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState;
	public VkPipelineTessellationStateCreateInfo* pTessellationState;
	public VkPipelineViewportStateCreateInfo* pViewportState;
	public VkPipelineRasterizationStateCreateInfo* pRasterizationState;
	public VkPipelineMultisampleStateCreateInfo* pMultisampleState;
	public VkPipelineDepthStencilStateCreateInfo* pDepthStencilState;
	public VkPipelineColorBlendStateCreateInfo* pColorBlendState;
	public VkPipelineDynamicStateCreateInfo* pDynamicState;
	public VkPipelineLayout layout; // Interface layout of the pipeline
	public VkRenderPass renderPass;
	public uint32 subpass;
	public VkPipeline basePipelineHandle; // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
	public int32 basePipelineIndex; // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of

	public this(void* pNext, VkPipelineCreateFlags flags, VulkanSpan<VkPipelineShaderStageCreateInfo> stages, VkPipelineVertexInputStateCreateInfo* pVertexInputState, VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState, VkPipelineTessellationStateCreateInfo* pTessellationState, VkPipelineViewportStateCreateInfo* pViewportState, VkPipelineRasterizationStateCreateInfo* pRasterizationState, VkPipelineMultisampleStateCreateInfo* pMultisampleState, VkPipelineDepthStencilStateCreateInfo* pDepthStencilState, VkPipelineColorBlendStateCreateInfo* pColorBlendState, VkPipelineDynamicStateCreateInfo* pDynamicState, VkPipelineLayout layout, VkRenderPass renderPass, uint32 subpass, VkPipeline basePipelineHandle, int32 basePipelineIndex) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.stages = stages;
		this.pVertexInputState = pVertexInputState;
		this.pInputAssemblyState = pInputAssemblyState;
		this.pTessellationState = pTessellationState;
		this.pViewportState = pViewportState;
		this.pRasterizationState = pRasterizationState;
		this.pMultisampleState = pMultisampleState;
		this.pDepthStencilState = pDepthStencilState;
		this.pColorBlendState = pColorBlendState;
		this.pDynamicState = pDynamicState;
		this.layout = layout;
		this.renderPass = renderPass;
		this.subpass = subpass;
		this.basePipelineHandle = basePipelineHandle;
		this.basePipelineIndex = basePipelineIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkLogicOp : int32
{
	Clear = 0,
	And = 1,
	AndReverse = 2,
	Copy = 3,
	AndInverted = 4,
	NoOp = 5,
	Xor = 6,
	Or = 7,
	Nor = 8,
	Equivalent = 9,
	Invert = 10,
	OrReverse = 11,
	CopyInverted = 12,
	OrInverted = 13,
	Nand = 14,
	Set = 15,
}

class VkPipeline { private this() { } }

[CRepr] struct VkPipelineColorBlendAttachmentState
{
	public VkBool32 blendEnable;
	public VkBlendFactor srcColorBlendFactor;
	public VkBlendFactor dstColorBlendFactor;
	public VkBlendOp colorBlendOp;
	public VkBlendFactor srcAlphaBlendFactor;
	public VkBlendFactor dstAlphaBlendFactor;
	public VkBlendOp alphaBlendOp;
	public VkColorComponentFlags colorWriteMask;

	public this(VkBool32 blendEnable, VkBlendFactor srcColorBlendFactor, VkBlendFactor dstColorBlendFactor, VkBlendOp colorBlendOp, VkBlendFactor srcAlphaBlendFactor, VkBlendFactor dstAlphaBlendFactor, VkBlendOp alphaBlendOp, VkColorComponentFlags colorWriteMask = 0)
	{
		this.blendEnable = blendEnable;
		this.srcColorBlendFactor = srcColorBlendFactor;
		this.dstColorBlendFactor = dstColorBlendFactor;
		this.colorBlendOp = colorBlendOp;
		this.srcAlphaBlendFactor = srcAlphaBlendFactor;
		this.dstAlphaBlendFactor = dstAlphaBlendFactor;
		this.alphaBlendOp = alphaBlendOp;
		this.colorWriteMask = colorWriteMask;
	}

	public this()
	{
		this = default;
	}
}

typealias VkPipelineColorBlendStateCreateFlags = VkPipelineColorBlendStateCreateFlagBits;

[CRepr] struct VkPipelineColorBlendStateCreateInfo
{
	public const VkStructureType SType = .VkPipelineColorBlendStateCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineColorBlendStateCreateFlags flags;
	public VkBool32 logicOpEnable;
	public VkLogicOp logicOp;
	public uint32 attachmentCount; // # of pAttachments
	public VkPipelineColorBlendAttachmentState* pAttachments;
	public VulkanSpan<VkPipelineColorBlendAttachmentState> attachments
	{
		[Inline] get => .(attachmentCount, pAttachments);
		[Inline] set mut { attachmentCount = value.count; pAttachments = value.ptr; }
	}
	public float[4] blendConstants;

	public this(void* pNext, VkPipelineColorBlendStateCreateFlags flags, VkBool32 logicOpEnable, VkLogicOp logicOp, VulkanSpan<VkPipelineColorBlendAttachmentState> attachments, float[4] blendConstants) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.logicOpEnable = logicOpEnable;
		this.logicOp = logicOp;
		this.attachments = attachments;
		this.blendConstants = blendConstants;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkPipelineCreateFlagBits : int32
{
	DisableOptimization = 1 << 0,
	AllowDerivatives = 1 << 1,
	Derivative = 1 << 2,
	ViewIndexFromDeviceIndex = 1 << 3,
	DispatchBase = 1 << 4,
	FailOnPipelineCompileRequired = 1 << 8,
	EarlyReturnOnFailure = 1 << 9,
	NoProtectedAccess = 1 << 27,
	ProtectedAccessOnly = 1 << 30,
	ViewIndexFromDeviceIndexKHR = ViewIndexFromDeviceIndex,
	DispatchBaseKHR = DispatchBase,
	RayTracingNoNullAnyHitShadersKHR = 1 << 14,
	RayTracingNoNullClosestHitShadersKHR = 1 << 15,
	RayTracingNoNullMissShadersKHR = 1 << 16,
	RayTracingNoNullIntersectionShadersKHR = 1 << 17,
	RayTracingSkipTrianglesKHR = 1 << 12,
	RayTracingSkipAabbsKHR = 1 << 13,
	RayTracingShaderGroupHandleCaptureReplayKHR = 1 << 19,
	DeferCompileNV = 1 << 5,
	RenderingFragmentDensityMapAttachmentEXT = 1 << 22,
	VkPipelineRasterizationStateCreateFragmentDensityMapAttachmentEXT = RenderingFragmentDensityMapAttachmentEXT,
	RenderingFragmentShadingRateAttachmentKHR = 1 << 21,
	VkPipelineRasterizationStateCreateFragmentShadingRateAttachmentKHR = RenderingFragmentShadingRateAttachmentKHR,
	CaptureStatisticsKHR = 1 << 6,
	CaptureInternalRepresentationsKHR = 1 << 7,
	IndirectBindableNV = 1 << 18,
	LibraryKHR = 1 << 11,
	FailOnPipelineCompileRequiredEXT = FailOnPipelineCompileRequired,
	EarlyReturnOnFailureEXT = EarlyReturnOnFailure,
	DescriptorBufferEXT = 1 << 29,
	RetainLinkTimeOptimizationInfoEXT = 1 << 23,
	LinkTimeOptimizationEXT = 1 << 10,
	RayTracingAllowMotionNV = 1 << 20,
	ColorAttachmentFeedbackLoopEXT = 1 << 25,
	DepthStencilAttachmentFeedbackLoopEXT = 1 << 26,
	RayTracingOpacityMicromapEXT = 1 << 24,
	RayTracingDisplacementMicromapNV = 1 << 28,
	NoProtectedAccessEXT = NoProtectedAccess,
	ProtectedAccessOnlyEXT = ProtectedAccessOnly,
}

typealias VkPipelineCreateFlags = VkPipelineCreateFlagBits;
typealias VkPipelineDepthStencilStateCreateFlags = VkPipelineDepthStencilStateCreateFlagBits;

[CRepr] struct VkPipelineDepthStencilStateCreateInfo
{
	public const VkStructureType SType = .VkPipelineDepthStencilStateCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineDepthStencilStateCreateFlags flags;
	public VkBool32 depthTestEnable;
	public VkBool32 depthWriteEnable;
	public VkCompareOp depthCompareOp;
	public VkBool32 depthBoundsTestEnable; // optional (depth_bounds_test)
	public VkBool32 stencilTestEnable;
	public VkStencilOpState front;
	public VkStencilOpState back;
	public float minDepthBounds;
	public float maxDepthBounds;

	public this(void* pNext, VkPipelineDepthStencilStateCreateFlags flags, VkBool32 depthTestEnable, VkBool32 depthWriteEnable, VkCompareOp depthCompareOp, VkBool32 depthBoundsTestEnable, VkBool32 stencilTestEnable, VkStencilOpState front, VkStencilOpState back, float minDepthBounds, float maxDepthBounds)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.depthTestEnable = depthTestEnable;
		this.depthWriteEnable = depthWriteEnable;
		this.depthCompareOp = depthCompareOp;
		this.depthBoundsTestEnable = depthBoundsTestEnable;
		this.stencilTestEnable = stencilTestEnable;
		this.front = front;
		this.back = back;
		this.minDepthBounds = minDepthBounds;
		this.maxDepthBounds = maxDepthBounds;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineDynamicStateCreateFlags = VkFlags;

[CRepr] struct VkPipelineDynamicStateCreateInfo
{
	public const VkStructureType SType = .VkPipelineDynamicStateCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineDynamicStateCreateFlags flags;
	public uint32 dynamicStateCount;
	public VkDynamicState* pDynamicStates;
	public VulkanSpan<VkDynamicState> dynamicStates
	{
		[Inline] get => .(dynamicStateCount, pDynamicStates);
		[Inline] set mut { dynamicStateCount = value.count; pDynamicStates = value.ptr; }
	}

	public this(void* pNext = null, VkPipelineDynamicStateCreateFlags flags = 0, VulkanSpan<VkDynamicState> dynamicStates = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.dynamicStates = dynamicStates;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineInputAssemblyStateCreateFlags = VkFlags;

[CRepr] struct VkPipelineInputAssemblyStateCreateInfo
{
	public const VkStructureType SType = .VkPipelineInputAssemblyStateCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineInputAssemblyStateCreateFlags flags;
	public VkPrimitiveTopology topology;
	public VkBool32 primitiveRestartEnable;

	public this(void* pNext, VkPipelineInputAssemblyStateCreateFlags flags, VkPrimitiveTopology topology, VkBool32 primitiveRestartEnable)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.topology = topology;
		this.primitiveRestartEnable = primitiveRestartEnable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineLayoutCreateFlags = VkPipelineLayoutCreateFlagBits;
typealias VkPipelineMultisampleStateCreateFlags = VkFlags;

[CRepr] struct VkPipelineMultisampleStateCreateInfo
{
	public const VkStructureType SType = .VkPipelineMultisampleStateCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineMultisampleStateCreateFlags flags;
	public VkSampleCountFlagBits rasterizationSamples; // Number of samples used for rasterization
	public VkBool32 sampleShadingEnable; // optional (GL45)
	public float minSampleShading; // optional (GL45)
	public VkSampleMask* pSampleMask; // Array of sampleMask words
	public VkBool32 alphaToCoverageEnable;
	public VkBool32 alphaToOneEnable;

	public this(void* pNext, VkPipelineMultisampleStateCreateFlags flags, VkSampleCountFlagBits rasterizationSamples, VkBool32 sampleShadingEnable, float minSampleShading, VkSampleMask* pSampleMask, VkBool32 alphaToCoverageEnable, VkBool32 alphaToOneEnable)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.rasterizationSamples = rasterizationSamples;
		this.sampleShadingEnable = sampleShadingEnable;
		this.minSampleShading = minSampleShading;
		this.pSampleMask = pSampleMask;
		this.alphaToCoverageEnable = alphaToCoverageEnable;
		this.alphaToOneEnable = alphaToOneEnable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineRasterizationStateCreateFlags = VkFlags;

[CRepr] struct VkPipelineRasterizationStateCreateInfo
{
	public const VkStructureType SType = .VkPipelineRasterizationStateCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineRasterizationStateCreateFlags flags;
	public VkBool32 depthClampEnable;
	public VkBool32 rasterizerDiscardEnable;
	public VkPolygonMode polygonMode; // optional (GL45)
	public VkCullModeFlags cullMode;
	public VkFrontFace frontFace;
	public VkBool32 depthBiasEnable;
	public float depthBiasConstantFactor;
	public float depthBiasClamp;
	public float depthBiasSlopeFactor;
	public float lineWidth;

	public this(void* pNext, VkPipelineRasterizationStateCreateFlags flags, VkBool32 depthClampEnable, VkBool32 rasterizerDiscardEnable, VkPolygonMode polygonMode, VkCullModeFlags cullMode, VkFrontFace frontFace, VkBool32 depthBiasEnable, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor, float lineWidth)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.depthClampEnable = depthClampEnable;
		this.rasterizerDiscardEnable = rasterizerDiscardEnable;
		this.polygonMode = polygonMode;
		this.cullMode = cullMode;
		this.frontFace = frontFace;
		this.depthBiasEnable = depthBiasEnable;
		this.depthBiasConstantFactor = depthBiasConstantFactor;
		this.depthBiasClamp = depthBiasClamp;
		this.depthBiasSlopeFactor = depthBiasSlopeFactor;
		this.lineWidth = lineWidth;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkPipelineShaderStageCreateFlagBits : int32
{
	AllowVaryingSubgroupSize = 1 << 0,
	RequireFullSubgroups = 1 << 1,
	AllowVaryingSubgroupSizeEXT = AllowVaryingSubgroupSize,
	RequireFullSubgroupsEXT = RequireFullSubgroups,
}

typealias VkPipelineShaderStageCreateFlags = VkPipelineShaderStageCreateFlagBits;

[CRepr] struct VkPipelineShaderStageCreateInfo
{
	public const VkStructureType SType = .VkPipelineShaderStageCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineShaderStageCreateFlags flags;
	public VkShaderStageFlagBits stage; // Shader stage
	public VkShaderModule module; // Module containing entry point
	public c_char* pName; // Null-terminated entry point name
	public VkSpecializationInfo* pSpecializationInfo;

	public this(void* pNext, VkPipelineShaderStageCreateFlags flags, VkShaderStageFlagBits stage, VkShaderModule module, c_char* pName, VkSpecializationInfo* pSpecializationInfo = null)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.stage = stage;
		this.module = module;
		this.pName = pName;
		this.pSpecializationInfo = pSpecializationInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineTessellationStateCreateFlags = VkFlags;

[CRepr] struct VkPipelineTessellationStateCreateInfo
{
	public const VkStructureType SType = .VkPipelineTessellationStateCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineTessellationStateCreateFlags flags;
	public uint32 patchControlPoints;

	public this(void* pNext, VkPipelineTessellationStateCreateFlags flags, uint32 patchControlPoints)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.patchControlPoints = patchControlPoints;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineVertexInputStateCreateFlags = VkFlags;

[CRepr] struct VkPipelineVertexInputStateCreateInfo
{
	public const VkStructureType SType = .VkPipelineVertexInputStateCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineVertexInputStateCreateFlags flags;
	public uint32 vertexBindingDescriptionCount; // number of bindings
	public VkVertexInputBindingDescription* pVertexBindingDescriptions;
	public VulkanSpan<VkVertexInputBindingDescription> vertexBindingDescriptions
	{
		[Inline] get => .(vertexBindingDescriptionCount, pVertexBindingDescriptions);
		[Inline] set mut { vertexBindingDescriptionCount = value.count; pVertexBindingDescriptions = value.ptr; }
	}
	public uint32 vertexAttributeDescriptionCount; // number of attributes
	public VkVertexInputAttributeDescription* pVertexAttributeDescriptions;
	public VulkanSpan<VkVertexInputAttributeDescription> vertexAttributeDescriptions
	{
		[Inline] get => .(vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
		[Inline] set mut { vertexAttributeDescriptionCount = value.count; pVertexAttributeDescriptions = value.ptr; }
	}

	public this(void* pNext = null, VkPipelineVertexInputStateCreateFlags flags = 0, VulkanSpan<VkVertexInputBindingDescription> vertexBindingDescriptions = .(), VulkanSpan<VkVertexInputAttributeDescription> vertexAttributeDescriptions = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.vertexBindingDescriptions = vertexBindingDescriptions;
		this.vertexAttributeDescriptions = vertexAttributeDescriptions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineViewportStateCreateFlags = VkFlags;

[CRepr] struct VkPipelineViewportStateCreateInfo
{
	public const VkStructureType SType = .VkPipelineViewportStateCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineViewportStateCreateFlags flags;
	public uint32 viewportCount;
	public VkViewport* pViewports;
	public VulkanSpan<VkViewport> viewports
	{
		[Inline] get => .(viewportCount, pViewports);
		[Inline] set mut { viewportCount = value.count; pViewports = value.ptr; }
	}
	public uint32 scissorCount;
	public VkRect2D* pScissors;
	public VulkanSpan<VkRect2D> scissors
	{
		[Inline] get => .(scissorCount, pScissors);
		[Inline] set mut { scissorCount = value.count; pScissors = value.ptr; }
	}

	public this(void* pNext = null, VkPipelineViewportStateCreateFlags flags = 0, VulkanSpan<VkViewport> viewports = .(), VulkanSpan<VkRect2D> scissors = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.viewports = viewports;
		this.scissors = scissors;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkPolygonMode : int32
{
	Fill = 0,
	Line = 1,
	Point = 2,
	FillRectangleNV = 1000153000,
}

[AllowDuplicates] enum VkPrimitiveTopology : int32
{
	PointList = 0,
	LineList = 1,
	LineStrip = 2,
	TriangleList = 3,
	TriangleStrip = 4,
	TriangleFan = 5,
	LineListWithAdjacency = 6,
	LineStripWithAdjacency = 7,
	TriangleListWithAdjacency = 8,
	TriangleStripWithAdjacency = 9,
	PatchList = 10,
}

[AllowDuplicates] enum VkShaderStageFlagBits : int32
{
	Vertex = 1 << 0,
	TessellationControl = 1 << 1,
	TessellationEvaluation = 1 << 2,
	Geometry = 1 << 3,
	Fragment = 1 << 4,
	Compute = 1 << 5,
	AllGraphics = 0x0000001F,
	All = 0x7FFFFFFF,
	RaygenKHR = 1 << 8,
	AnyHitKHR = 1 << 9,
	ClosestHitKHR = 1 << 10,
	MissKHR = 1 << 11,
	IntersectionKHR = 1 << 12,
	CallableKHR = 1 << 13,
	RaygenNV = RaygenKHR,
	AnyHitNV = AnyHitKHR,
	ClosestHitNV = ClosestHitKHR,
	MissNV = MissKHR,
	IntersectionNV = IntersectionKHR,
	CallableNV = CallableKHR,
	TaskNV = TaskEXT,
	MeshNV = MeshEXT,
	TaskEXT = 1 << 6,
	MeshEXT = 1 << 7,
	SubpassShadingHUAWEI = 1 << 14,
	ClusterCullingHUAWEI = 1 << 19,
}

typealias VkShaderStageFlags = VkShaderStageFlagBits;

[CRepr] struct VkSpecializationInfo
{
	public uint32 mapEntryCount; // Number of entries in the map
	public VkSpecializationMapEntry* pMapEntries; // Array of map entries
	public VulkanSpan<VkSpecializationMapEntry> mapEntries
	{
		[Inline] get => .(mapEntryCount, pMapEntries);
		[Inline] set mut { mapEntryCount = value.count; pMapEntries = value.ptr; }
	} // Array of map entries
	public c_size dataSize; // Size in bytes of pData
	public void* pData; // Pointer to SpecConstant data

	public this(VulkanSpan<VkSpecializationMapEntry> mapEntries, c_size dataSize, void* pData) : this()
	{
		this.mapEntries = mapEntries;
		this.dataSize = dataSize;
		this.pData = pData;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkSpecializationMapEntry
{
	public uint32 constantID; // The SpecConstant ID specified in the BIL
	public uint32 offset; // Offset of the value in the data block
	public c_size size; // Size in bytes of the SpecConstant

	public this(uint32 constantID, uint32 offset, c_size size)
	{
		this.constantID = constantID;
		this.offset = offset;
		this.size = size;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkStencilOp : int32
{
	Keep = 0,
	Zero = 1,
	Replace = 2,
	IncrementAndClamp = 3,
	DecrementAndClamp = 4,
	Invert = 5,
	IncrementAndWrap = 6,
	DecrementAndWrap = 7,
}

[CRepr] struct VkStencilOpState
{
	public VkStencilOp failOp;
	public VkStencilOp passOp;
	public VkStencilOp depthFailOp;
	public VkCompareOp compareOp;
	public uint32 compareMask;
	public uint32 writeMask;
	public uint32 reference;

	public this(VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp, uint32 compareMask, uint32 writeMask, uint32 reference)
	{
		this.failOp = failOp;
		this.passOp = passOp;
		this.depthFailOp = depthFailOp;
		this.compareOp = compareOp;
		this.compareMask = compareMask;
		this.writeMask = writeMask;
		this.reference = reference;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkVertexInputAttributeDescription
{
	public uint32 location; // location of the shader vertex attrib
	public uint32 binding; // Vertex buffer binding id
	public VkFormat format; // format of source data
	public uint32 offset; // Offset of first element in bytes from base of vertex

	public this(uint32 location, uint32 binding, VkFormat format, uint32 offset)
	{
		this.location = location;
		this.binding = binding;
		this.format = format;
		this.offset = offset;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkVertexInputBindingDescription
{
	public uint32 binding; // Vertex buffer binding id
	public uint32 stride; // Distance between vertices in bytes (0 = no advancement)
	public VkVertexInputRate inputRate; // The rate at which the vertex data is consumed

	public this(uint32 binding, uint32 stride, VkVertexInputRate inputRate)
	{
		this.binding = binding;
		this.stride = stride;
		this.inputRate = inputRate;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkVertexInputRate : int32
{
	Vertex = 0,
	Instance = 1,
}

[CRepr] struct VkViewport
{
	public float x;
	public float y;
	public float width;
	public float height;
	public float minDepth;
	public float maxDepth;

	public this(float x, float y, float width, float height, float minDepth, float maxDepth)
	{
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		this.minDepth = minDepth;
		this.maxDepth = maxDepth;
	}

	public this()
	{
		this = default;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32 createInfoCount, VkGraphicsPipelineCreateInfo* pCreateInfos, VkAllocationCallbacks* pAllocator, out VkPipeline pPipelines);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32 createInfoCount, VkComputePipelineCreateInfo* pCreateInfos, VkAllocationCallbacks* pAllocator, out VkPipeline pPipelines);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyPipeline(VkDevice device, VkPipeline pipeline = null, VkAllocationCallbacks* pAllocator = null);

// Pipeline layout commands
class VkPipelineLayout { private this() { } }

[CRepr] struct VkPipelineLayoutCreateInfo
{
	public const VkStructureType SType = .VkPipelineLayoutCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineLayoutCreateFlags flags;
	public uint32 setLayoutCount; // Number of descriptor sets interfaced by the pipeline
	public VkDescriptorSetLayout* pSetLayouts; // Array of setCount number of descriptor set layout objects defining the layout of the
	public VulkanSpan<VkDescriptorSetLayout> setLayouts
	{
		[Inline] get => .(setLayoutCount, pSetLayouts);
		[Inline] set mut { setLayoutCount = value.count; pSetLayouts = value.ptr; }
	} // Array of setCount number of descriptor set layout objects defining the layout of the
	public uint32 pushConstantRangeCount; // Number of push-constant ranges used by the pipeline
	public VkPushConstantRange* pPushConstantRanges; // Array of pushConstantRangeCount number of ranges used by various shader stages
	public VulkanSpan<VkPushConstantRange> pushConstantRanges
	{
		[Inline] get => .(pushConstantRangeCount, pPushConstantRanges);
		[Inline] set mut { pushConstantRangeCount = value.count; pPushConstantRanges = value.ptr; }
	} // Array of pushConstantRangeCount number of ranges used by various shader stages

	public this(void* pNext = null, VkPipelineLayoutCreateFlags flags = 0, VulkanSpan<VkDescriptorSetLayout> setLayouts = .(), VulkanSpan<VkPushConstantRange> pushConstantRanges = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.setLayouts = setLayouts;
		this.pushConstantRanges = pushConstantRanges;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPushConstantRange
{
	public VkShaderStageFlags stageFlags; // Which stages use the range
	public uint32 offset; // Start of the range, in bytes
	public uint32 size; // Size of the range, in bytes

	public this(VkShaderStageFlags stageFlags, uint32 offset, uint32 size)
	{
		this.stageFlags = stageFlags;
		this.offset = offset;
		this.size = size;
	}

	public this()
	{
		this = default;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreatePipelineLayout(VkDevice device, VkPipelineLayoutCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkPipelineLayout pPipelineLayout);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout = null, VkAllocationCallbacks* pAllocator = null);

// Sampler commands
[AllowDuplicates] enum VkBorderColor : int32
{
	FloatTransparentBlack = 0,
	IntTransparentBlack = 1,
	FloatOpaqueBlack = 2,
	IntOpaqueBlack = 3,
	FloatOpaqueWhite = 4,
	IntOpaqueWhite = 5,
	FloatCustomEXT = 1000287003,
	IntCustomEXT = 1000287004,
}

[AllowDuplicates] enum VkFilter : int32
{
	Nearest = 0,
	Linear = 1,
	CubicIMG = CubicEXT,
	CubicEXT = 1000015000,
}

class VkSampler { private this() { } }

[AllowDuplicates] enum VkSamplerAddressMode : int32
{
	Repeat = 0,
	MirroredRepeat = 1,
	ClampToEdge = 2,
	ClampToBorder = 3,
	MirrorClampToEdge = 4, // No need to add an extnumber attribute, since this uses a core enum value
	MirrorClampToEdgeKHR = MirrorClampToEdge, // Introduced for consistency with extension suffixing rules
}

[AllowDuplicates] enum VkSamplerCreateFlagBits : int32
{
	SubsampledEXT = 1 << 0,
	SubsampledCoarseReconstructionEXT = 1 << 1,
	DescriptorBufferCaptureReplayEXT = 1 << 3,
	NonSeamlessCubeMapEXT = 1 << 2,
	ImageProcessingQCOM = 1 << 4,
}

typealias VkSamplerCreateFlags = VkSamplerCreateFlagBits;

[CRepr] struct VkSamplerCreateInfo
{
	public const VkStructureType SType = .VkSamplerCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSamplerCreateFlags flags;
	public VkFilter magFilter; // Filter mode for magnification
	public VkFilter minFilter; // Filter mode for minifiation
	public VkSamplerMipmapMode mipmapMode; // Mipmap selection mode
	public VkSamplerAddressMode addressModeU;
	public VkSamplerAddressMode addressModeV;
	public VkSamplerAddressMode addressModeW;
	public float mipLodBias;
	public VkBool32 anisotropyEnable;
	public float maxAnisotropy;
	public VkBool32 compareEnable;
	public VkCompareOp compareOp;
	public float minLod;
	public float maxLod;
	public VkBorderColor borderColor;
	public VkBool32 unnormalizedCoordinates;

	public this(void* pNext, VkSamplerCreateFlags flags, VkFilter magFilter, VkFilter minFilter, VkSamplerMipmapMode mipmapMode, VkSamplerAddressMode addressModeU, VkSamplerAddressMode addressModeV, VkSamplerAddressMode addressModeW, float mipLodBias, VkBool32 anisotropyEnable, float maxAnisotropy, VkBool32 compareEnable, VkCompareOp compareOp, float minLod, float maxLod, VkBorderColor borderColor, VkBool32 unnormalizedCoordinates)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.magFilter = magFilter;
		this.minFilter = minFilter;
		this.mipmapMode = mipmapMode;
		this.addressModeU = addressModeU;
		this.addressModeV = addressModeV;
		this.addressModeW = addressModeW;
		this.mipLodBias = mipLodBias;
		this.anisotropyEnable = anisotropyEnable;
		this.maxAnisotropy = maxAnisotropy;
		this.compareEnable = compareEnable;
		this.compareOp = compareOp;
		this.minLod = minLod;
		this.maxLod = maxLod;
		this.borderColor = borderColor;
		this.unnormalizedCoordinates = unnormalizedCoordinates;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkSamplerMipmapMode : int32
{
	Nearest = 0, // Choose nearest mip level
	Linear = 1, // Linear filter between mip levels
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateSampler(VkDevice device, VkSamplerCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSampler pSampler);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroySampler(VkDevice device, VkSampler sampler = null, VkAllocationCallbacks* pAllocator = null);

// Descriptor set commands
[CRepr] struct VkCopyDescriptorSet
{
	public const VkStructureType SType = .VkCopyDescriptorSet;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDescriptorSet srcSet; // Source descriptor set
	public uint32 srcBinding; // Binding within the source descriptor set to copy from
	public uint32 srcArrayElement; // Array element within the source binding to copy from
	public VkDescriptorSet dstSet; // Destination descriptor set
	public uint32 dstBinding; // Binding within the destination descriptor set to copy to
	public uint32 dstArrayElement; // Array element within the destination binding to copy to
	public uint32 descriptorCount; // Number of descriptors to write (determines the size of the array pointed by pDescriptors)

	public this(void* pNext, VkDescriptorSet srcSet, uint32 srcBinding, uint32 srcArrayElement, VkDescriptorSet dstSet, uint32 dstBinding, uint32 dstArrayElement, uint32 descriptorCount)
	{
		this.pNext = pNext;
		this.srcSet = srcSet;
		this.srcBinding = srcBinding;
		this.srcArrayElement = srcArrayElement;
		this.dstSet = dstSet;
		this.dstBinding = dstBinding;
		this.dstArrayElement = dstArrayElement;
		this.descriptorCount = descriptorCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDescriptorBufferInfo
{
	public VkBuffer buffer; // Buffer used for this descriptor slot.
	public VkDeviceSize offset; // Base offset from buffer start in bytes to update in the descriptor set.
	public VkDeviceSize range; // Size in bytes of the buffer resource for this descriptor update.

	public this(VkBuffer buffer, VkDeviceSize offset, VkDeviceSize range)
	{
		this.buffer = buffer;
		this.offset = offset;
		this.range = range;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkDescriptorImageInfo
{
	public VkSampler sampler; // Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.
	public VkImageView imageView; // Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.
	public VkImageLayout imageLayout; // Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE).

	public this(VkSampler sampler, VkImageView imageView, VkImageLayout imageLayout)
	{
		this.sampler = sampler;
		this.imageView = imageView;
		this.imageLayout = imageLayout;
	}

	public this()
	{
		this = default;
	}
}

class VkDescriptorPool { private this() { } }

[AllowDuplicates] enum VkDescriptorPoolCreateFlagBits : int32
{
	FreeDescriptorSet = 1 << 0, // Descriptor sets may be freed individually
	UpdateAfterBind = 1 << 1,
	UpdateAfterBindEXT = UpdateAfterBind,
	HostOnlyVALVE = HostOnlyEXT,
	HostOnlyEXT = 1 << 2,
	AllowOverallocationSetsNV = 1 << 3,
	AllowOverallocationPoolsNV = 1 << 4,
}

typealias VkDescriptorPoolCreateFlags = VkDescriptorPoolCreateFlagBits;

[CRepr] struct VkDescriptorPoolCreateInfo
{
	public const VkStructureType SType = .VkDescriptorPoolCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDescriptorPoolCreateFlags flags;
	public uint32 maxSets;
	public uint32 poolSizeCount;
	public VkDescriptorPoolSize* pPoolSizes;
	public VulkanSpan<VkDescriptorPoolSize> poolSizes
	{
		[Inline] get => .(poolSizeCount, pPoolSizes);
		[Inline] set mut { poolSizeCount = value.count; pPoolSizes = value.ptr; }
	}

	public this(void* pNext, VkDescriptorPoolCreateFlags flags, uint32 maxSets, VulkanSpan<VkDescriptorPoolSize> poolSizes = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.maxSets = maxSets;
		this.poolSizes = poolSizes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkDescriptorPoolResetFlags = VkFlags;

[CRepr] struct VkDescriptorPoolSize
{
	public VkDescriptorType type;
	public uint32 descriptorCount;

	public this(VkDescriptorType type, uint32 descriptorCount)
	{
		this.type = type;
		this.descriptorCount = descriptorCount;
	}

	public this()
	{
		this = default;
	}
}

class VkDescriptorSet { private this() { } }

[CRepr] struct VkDescriptorSetAllocateInfo
{
	public const VkStructureType SType = .VkDescriptorSetAllocateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDescriptorPool descriptorPool;
	public uint32 descriptorSetCount;
	public VkDescriptorSetLayout* pSetLayouts;
	public VulkanSpan<VkDescriptorSetLayout> setLayouts
	{
		[Inline] get => .(descriptorSetCount, pSetLayouts);
		[Inline] set mut { descriptorSetCount = value.count; pSetLayouts = value.ptr; }
	}

	public this(void* pNext, VkDescriptorPool descriptorPool, VulkanSpan<VkDescriptorSetLayout> setLayouts) : this()
	{
		this.pNext = pNext;
		this.descriptorPool = descriptorPool;
		this.setLayouts = setLayouts;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

class VkDescriptorSetLayout { private this() { } }

[CRepr] struct VkDescriptorSetLayoutBinding
{
	public uint32 binding; // Binding number for this entry
	public VkDescriptorType descriptorType; // Type of the descriptors in this binding
	public uint32 descriptorCount; // Number of descriptors in this binding
	public VkShaderStageFlags stageFlags; // Shader stages this binding is visible to
	public VkSampler* pImmutableSamplers; // Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)

	public this(uint32 binding, VkDescriptorType descriptorType, uint32 descriptorCount, VkShaderStageFlags stageFlags, VkSampler* pImmutableSamplers = null)
	{
		this.binding = binding;
		this.descriptorType = descriptorType;
		this.descriptorCount = descriptorCount;
		this.stageFlags = stageFlags;
		this.pImmutableSamplers = pImmutableSamplers;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkDescriptorSetLayoutCreateFlagBits : int32
{
	UpdateAfterBindPool = 1 << 1,
	PushDescriptor = 1 << 0,
	PushDescriptorKHR = PushDescriptor, // Descriptors are pushed via flink:vkCmdPushDescriptorSet
	UpdateAfterBindPoolEXT = UpdateAfterBindPool,
	DescriptorBufferEXT = 1 << 4,
	EmbeddedImmutableSamplersEXT = 1 << 5,
	HostOnlyPoolVALVE = HostOnlyPoolEXT,
	IndirectBindableNV = 1 << 7,
	HostOnlyPoolEXT = 1 << 2,
	PerStageNV = 1 << 6,
}

typealias VkDescriptorSetLayoutCreateFlags = VkDescriptorSetLayoutCreateFlagBits;

[CRepr] struct VkDescriptorSetLayoutCreateInfo
{
	public const VkStructureType SType = .VkDescriptorSetLayoutCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDescriptorSetLayoutCreateFlags flags;
	public uint32 bindingCount; // Number of bindings in the descriptor set layout
	public VkDescriptorSetLayoutBinding* pBindings; // Array of descriptor set layout bindings
	public VulkanSpan<VkDescriptorSetLayoutBinding> bindings
	{
		[Inline] get => .(bindingCount, pBindings);
		[Inline] set mut { bindingCount = value.count; pBindings = value.ptr; }
	} // Array of descriptor set layout bindings

	public this(void* pNext = null, VkDescriptorSetLayoutCreateFlags flags = 0, VulkanSpan<VkDescriptorSetLayoutBinding> bindings = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.bindings = bindings;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkDescriptorType : int32
{
	Sampler = 0,
	CombinedImageSampler = 1,
	SampledImage = 2,
	StorageImage = 3,
	UniformTexelBuffer = 4,
	StorageTexelBuffer = 5,
	UniformBuffer = 6,
	StorageBuffer = 7,
	UniformBufferDynamic = 8,
	StorageBufferDynamic = 9,
	InputAttachment = 10,
	InlineUniformBlock = 1000138000,
	InlineUniformBlockEXT = InlineUniformBlock,
	AccelerationStructureKHR = 1000150000,
	AccelerationStructureNV = 1000165000,
	MutableVALVE = MutableEXT,
	SampleWeightImageQCOM = 1000440000,
	BlockMatchImageQCOM = 1000440001,
	TensorARM = 1000460000,
	MutableEXT = 1000351000,
	PartitionedAccelerationStructureNV = 1000570000,
}

[CRepr] struct VkWriteDescriptorSet
{
	public const VkStructureType SType = .VkWriteDescriptorSet;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDescriptorSet dstSet; // Destination descriptor set
	public uint32 dstBinding; // Binding within the destination descriptor set to write
	public uint32 dstArrayElement; // Array element within the destination binding to write
	public uint32 descriptorCount; // Number of descriptors to write (determines the size of the array pointed by pDescriptors)
	public VkDescriptorType descriptorType; // Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used)
	public VkDescriptorImageInfo* pImageInfo; // Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.
	public VkDescriptorBufferInfo* pBufferInfo; // Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.
	public VkBufferView* pTexelBufferView; // Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.

	public this(void* pNext, VkDescriptorSet dstSet, uint32 dstBinding, uint32 dstArrayElement, uint32 descriptorCount, VkDescriptorType descriptorType, VkDescriptorImageInfo* pImageInfo, VkDescriptorBufferInfo* pBufferInfo, VkBufferView* pTexelBufferView)
	{
		this.pNext = pNext;
		this.dstSet = dstSet;
		this.dstBinding = dstBinding;
		this.dstArrayElement = dstArrayElement;
		this.descriptorCount = descriptorCount;
		this.descriptorType = descriptorType;
		this.pImageInfo = pImageInfo;
		this.pBufferInfo = pBufferInfo;
		this.pTexelBufferView = pTexelBufferView;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateDescriptorSetLayout(VkDevice device, VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkDescriptorSetLayout pSetLayout);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateDescriptorPool(VkDevice device, VkDescriptorPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkDescriptorPool pDescriptorPool);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags = 0);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkAllocateDescriptorSets(VkDevice device, VkDescriptorSetAllocateInfo* pAllocateInfo, out VkDescriptorSet pDescriptorSets);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkFreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32 descriptorSetCount, VkDescriptorSet* pDescriptorSets);
[CallingConvention(VKAPI_PTR)] function void PFN_vkUpdateDescriptorSets(VkDevice device, uint32 descriptorWriteCount = 0, VkWriteDescriptorSet* pDescriptorWrites = null, uint32 descriptorCopyCount = 0, VkCopyDescriptorSet* pDescriptorCopies = null);

// Pass commands
[AllowDuplicates] enum VkAccessFlagBits : int32
{
	IndirectCommandRead = 1 << 0, // Controls coherency of indirect command reads
	IndexRead = 1 << 1, // Controls coherency of index reads
	VertexAttributeRead = 1 << 2, // Controls coherency of vertex attribute reads
	UniformRead = 1 << 3, // Controls coherency of uniform buffer reads
	InputAttachmentRead = 1 << 4, // Controls coherency of input attachment reads
	ShaderRead = 1 << 5, // Controls coherency of shader reads
	ShaderWrite = 1 << 6, // Controls coherency of shader writes
	ColorAttachmentRead = 1 << 7, // Controls coherency of color attachment reads
	ColorAttachmentWrite = 1 << 8, // Controls coherency of color attachment writes
	DepthStencilAttachmentRead = 1 << 9, // Controls coherency of depth/stencil attachment reads
	DepthStencilAttachmentWrite = 1 << 10, // Controls coherency of depth/stencil attachment writes
	TransferRead = 1 << 11, // Controls coherency of transfer reads
	TransferWrite = 1 << 12, // Controls coherency of transfer writes
	HostRead = 1 << 13, // Controls coherency of host reads
	HostWrite = 1 << 14, // Controls coherency of host writes
	MemoryRead = 1 << 15, // Controls coherency of memory reads
	MemoryWrite = 1 << 16, // Controls coherency of memory writes
	None = 0,
	TransformFeedbackWriteEXT = 1 << 25,
	TransformFeedbackCounterReadEXT = 1 << 26,
	TransformFeedbackCounterWriteEXT = 1 << 27,
	ConditionalRenderingReadEXT = 1 << 20, // read access flag for reading conditional rendering predicate
	ColorAttachmentReadNoncoherentEXT = 1 << 19,
	AccelerationStructureReadKHR = 1 << 21,
	AccelerationStructureWriteKHR = 1 << 22,
	ShadingRateImageReadNV = FragmentShadingRateAttachmentReadKHR,
	AccelerationStructureReadNV = AccelerationStructureReadKHR,
	AccelerationStructureWriteNV = AccelerationStructureWriteKHR,
	FragmentDensityMapReadEXT = 1 << 24,
	FragmentShadingRateAttachmentReadKHR = 1 << 23,
	CommandPreprocessReadNV = CommandPreprocessReadEXT,
	CommandPreprocessWriteNV = CommandPreprocessWriteEXT,
	NoneKHR = None,
	CommandPreprocessReadEXT = 1 << 17,
	CommandPreprocessWriteEXT = 1 << 18,
}

typealias VkAccessFlags = VkAccessFlagBits;

[CRepr] struct VkAttachmentDescription
{
	public VkAttachmentDescriptionFlags flags;
	public VkFormat format;
	public VkSampleCountFlagBits samples;
	public VkAttachmentLoadOp loadOp; // Load operation for color or depth data
	public VkAttachmentStoreOp storeOp; // Store operation for color or depth data
	public VkAttachmentLoadOp stencilLoadOp; // Load operation for stencil data
	public VkAttachmentStoreOp stencilStoreOp; // Store operation for stencil data
	public VkImageLayout initialLayout;
	public VkImageLayout finalLayout;

	public this(VkAttachmentDescriptionFlags flags, VkFormat format, VkSampleCountFlagBits samples, VkAttachmentLoadOp loadOp, VkAttachmentStoreOp storeOp, VkAttachmentLoadOp stencilLoadOp, VkAttachmentStoreOp stencilStoreOp, VkImageLayout initialLayout, VkImageLayout finalLayout)
	{
		this.flags = flags;
		this.format = format;
		this.samples = samples;
		this.loadOp = loadOp;
		this.storeOp = storeOp;
		this.stencilLoadOp = stencilLoadOp;
		this.stencilStoreOp = stencilStoreOp;
		this.initialLayout = initialLayout;
		this.finalLayout = finalLayout;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkAttachmentDescriptionFlagBits : int32
{
	MayAlias = 1 << 0, // The attachment may alias physical memory of another attachment in the same render pass
}

typealias VkAttachmentDescriptionFlags = VkAttachmentDescriptionFlagBits;

[AllowDuplicates] enum VkAttachmentLoadOp : int32
{
	Load = 0,
	Clear = 1,
	DontCare = 2,
	None = 1000400000,
	NoneEXT = None,
	NoneKHR = None,
}

[CRepr] struct VkAttachmentReference
{
	public uint32 attachment;
	public VkImageLayout layout;

	public this(uint32 attachment, VkImageLayout layout)
	{
		this.attachment = attachment;
		this.layout = layout;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkAttachmentStoreOp : int32
{
	Store = 0,
	DontCare = 1,
	None = 1000301000,
	NoneKHR = None,
	NoneQCOM = None,
	NoneEXT = None,
}

[AllowDuplicates] enum VkDependencyFlagBits : int32
{
	ByRegion = 1 << 0, // Dependency is per pixel region
	DeviceGroup = 1 << 2, // Dependency is across devices
	ViewLocal = 1 << 1,
	ViewLocalKHR = ViewLocal,
	DeviceGroupKHR = DeviceGroup,
	FeedbackLoopEXT = 1 << 3, // Dependency may be a feedback loop
	QueueFamilyOwnershipTransferUseAllStagesKHR = 1 << 5,
	AsymmetricEventKHR = 1 << 6,
}

typealias VkDependencyFlags = VkDependencyFlagBits;

class VkFramebuffer { private this() { } }

[AllowDuplicates] enum VkFramebufferCreateFlagBits : int32
{
	Imageless = 1 << 0,
	ImagelessKHR = Imageless,
}

typealias VkFramebufferCreateFlags = VkFramebufferCreateFlagBits;

[CRepr] struct VkFramebufferCreateInfo
{
	public const VkStructureType SType = .VkFramebufferCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFramebufferCreateFlags flags;
	public VkRenderPass renderPass;
	public uint32 attachmentCount;
	public VkImageView* pAttachments;
	public VulkanSpan<VkImageView> attachments
	{
		[Inline] get => .(attachmentCount, pAttachments);
		[Inline] set mut { attachmentCount = value.count; pAttachments = value.ptr; }
	}
	public uint32 width;
	public uint32 height;
	public uint32 layers;

	public this(void* pNext, VkFramebufferCreateFlags flags, VkRenderPass renderPass, VulkanSpan<VkImageView> attachments, uint32 width, uint32 height, uint32 layers) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.renderPass = renderPass;
		this.attachments = attachments;
		this.width = width;
		this.height = height;
		this.layers = layers;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkPipelineBindPoint : int32
{
	Graphics = 0,
	Compute = 1,
	ExecutionGraphAMDX = 1000134000,
	RayTracingKHR = 1000165000,
	RayTracingNV = RayTracingKHR,
	SubpassShadingHUAWEI = 1000369003,
	DataGraphARM = 1000507000,
}

class VkRenderPass { private this() { } }

[AllowDuplicates] enum VkRenderPassCreateFlagBits : int32
{
	TransformQCOM = 1 << 1,
	PerLayerFragmentDensityVALVE = 1 << 2,
}

typealias VkRenderPassCreateFlags = VkRenderPassCreateFlagBits;

[CRepr] struct VkRenderPassCreateInfo
{
	public const VkStructureType SType = .VkRenderPassCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRenderPassCreateFlags flags;
	public uint32 attachmentCount;
	public VkAttachmentDescription* pAttachments;
	public VulkanSpan<VkAttachmentDescription> attachments
	{
		[Inline] get => .(attachmentCount, pAttachments);
		[Inline] set mut { attachmentCount = value.count; pAttachments = value.ptr; }
	}
	public uint32 subpassCount;
	public VkSubpassDescription* pSubpasses;
	public VulkanSpan<VkSubpassDescription> subpasses
	{
		[Inline] get => .(subpassCount, pSubpasses);
		[Inline] set mut { subpassCount = value.count; pSubpasses = value.ptr; }
	}
	public uint32 dependencyCount;
	public VkSubpassDependency* pDependencies;
	public VulkanSpan<VkSubpassDependency> dependencies
	{
		[Inline] get => .(dependencyCount, pDependencies);
		[Inline] set mut { dependencyCount = value.count; pDependencies = value.ptr; }
	}

	public this(void* pNext, VkRenderPassCreateFlags flags, VulkanSpan<VkAttachmentDescription> attachments, VulkanSpan<VkSubpassDescription> subpasses, VulkanSpan<VkSubpassDependency> dependencies = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.attachments = attachments;
		this.subpasses = subpasses;
		this.dependencies = dependencies;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSubpassDependency
{
	public uint32 srcSubpass;
	public uint32 dstSubpass;
	public VkPipelineStageFlags srcStageMask;
	public VkPipelineStageFlags dstStageMask;
	public VkAccessFlags srcAccessMask; // Memory accesses from the source of the dependency to synchronize
	public VkAccessFlags dstAccessMask; // Memory accesses from the destination of the dependency to synchronize
	public VkDependencyFlags dependencyFlags;

	public this(uint32 srcSubpass, uint32 dstSubpass, VkPipelineStageFlags srcStageMask = 0, VkPipelineStageFlags dstStageMask = 0, VkAccessFlags srcAccessMask = 0, VkAccessFlags dstAccessMask = 0, VkDependencyFlags dependencyFlags = 0)
	{
		this.srcSubpass = srcSubpass;
		this.dstSubpass = dstSubpass;
		this.srcStageMask = srcStageMask;
		this.dstStageMask = dstStageMask;
		this.srcAccessMask = srcAccessMask;
		this.dstAccessMask = dstAccessMask;
		this.dependencyFlags = dependencyFlags;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkSubpassDescription
{
	public VkSubpassDescriptionFlags flags;
	public VkPipelineBindPoint pipelineBindPoint; // Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
	public uint32 inputAttachmentCount;
	public VkAttachmentReference* pInputAttachments;
	public VulkanSpan<VkAttachmentReference> inputAttachments
	{
		[Inline] get => .(inputAttachmentCount, pInputAttachments);
		[Inline] set mut { inputAttachmentCount = value.count; pInputAttachments = value.ptr; }
	}
	public uint32 colorAttachmentCount;
	public VkAttachmentReference* pColorAttachments;
	public VkAttachmentReference* pResolveAttachments;
	public VulkanDuoSpan<VkAttachmentReference, VkAttachmentReference> colorAttachments_resolveAttachments
	{
		[Inline] get => .(colorAttachmentCount, pColorAttachments, pResolveAttachments);
		[Inline] set mut { colorAttachmentCount = value.count; pColorAttachments = value.ptr1; pResolveAttachments = value.ptr2; }
	}
	public VkAttachmentReference* pDepthStencilAttachment;
	public uint32 preserveAttachmentCount;
	public uint32* pPreserveAttachments;
	public VulkanSpan<uint32> preserveAttachments
	{
		[Inline] get => .(preserveAttachmentCount, pPreserveAttachments);
		[Inline] set mut { preserveAttachmentCount = value.count; pPreserveAttachments = value.ptr; }
	}

	public this(VkSubpassDescriptionFlags flags, VkPipelineBindPoint pipelineBindPoint, VulkanSpan<VkAttachmentReference> inputAttachments = .(), VulkanDuoSpan<VkAttachmentReference, VkAttachmentReference> colorAttachments_resolveAttachments = .(), VkAttachmentReference* pDepthStencilAttachment = null, VulkanSpan<uint32> preserveAttachments = .()) : this()
	{
		this.flags = flags;
		this.pipelineBindPoint = pipelineBindPoint;
		this.inputAttachments = inputAttachments;
		this.colorAttachments_resolveAttachments = colorAttachments_resolveAttachments;
		this.pDepthStencilAttachment = pDepthStencilAttachment;
		this.preserveAttachments = preserveAttachments;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkSubpassDescriptionFlagBits : int32
{
	PerViewAttributesNVX = 1 << 0,
	PerViewPositionXOnlyNVX = 1 << 1,
	FragmentRegionQCOM = 1 << 2,
	ShaderResolveQCOM = 1 << 3,
	TileShadingApronQCOM = 1 << 8,
	RasterizationOrderAttachmentColorAccessARM = RasterizationOrderAttachmentColorAccessEXT,
	RasterizationOrderAttachmentDepthAccessARM = RasterizationOrderAttachmentDepthAccessEXT,
	RasterizationOrderAttachmentStencilAccessARM = RasterizationOrderAttachmentStencilAccessEXT,
	RasterizationOrderAttachmentColorAccessEXT = 1 << 4,
	RasterizationOrderAttachmentDepthAccessEXT = 1 << 5,
	RasterizationOrderAttachmentStencilAccessEXT = 1 << 6,
	EnableLegacyDitheringEXT = 1 << 7,
}

typealias VkSubpassDescriptionFlags = VkSubpassDescriptionFlagBits;

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateFramebuffer(VkDevice device, VkFramebufferCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkFramebuffer pFramebuffer);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateRenderPass(VkDevice device, VkRenderPassCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkRenderPass pRenderPass);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyRenderPass(VkDevice device, VkRenderPass renderPass = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, out VkExtent2D pGranularity);

// Command pool commands
class VkCommandPool { private this() { } }

[AllowDuplicates] enum VkCommandPoolCreateFlagBits : int32
{
	Transient = 1 << 0, // Command buffers have a short lifetime
	ResetCommandBuffer = 1 << 1, // Command buffers may release their memory individually
	Protected = 1 << 2, // Command buffers allocated from pool are protected command buffers
}

typealias VkCommandPoolCreateFlags = VkCommandPoolCreateFlagBits;

[CRepr] struct VkCommandPoolCreateInfo
{
	public const VkStructureType SType = .VkCommandPoolCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkCommandPoolCreateFlags flags; // Command pool creation flags
	public uint32 queueFamilyIndex;

	public this(void* pNext, VkCommandPoolCreateFlags flags, uint32 queueFamilyIndex)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.queueFamilyIndex = queueFamilyIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkCommandPoolResetFlagBits : int32
{
	ReleaseResources = 1 << 0, // Release resources owned by the pool
}

typealias VkCommandPoolResetFlags = VkCommandPoolResetFlagBits;

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateCommandPool(VkDevice device, VkCommandPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkCommandPool pCommandPool);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags = 0);

// Command buffer commands
class VkCommandBuffer { private this() { } }

[CRepr] struct VkCommandBufferAllocateInfo
{
	public const VkStructureType SType = .VkCommandBufferAllocateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkCommandPool commandPool;
	public VkCommandBufferLevel level;
	public uint32 commandBufferCount;

	public this(void* pNext, VkCommandPool commandPool, VkCommandBufferLevel level, uint32 commandBufferCount)
	{
		this.pNext = pNext;
		this.commandPool = commandPool;
		this.level = level;
		this.commandBufferCount = commandBufferCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCommandBufferBeginInfo
{
	public const VkStructureType SType = .VkCommandBufferBeginInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkCommandBufferUsageFlags flags; // Command buffer usage flags
	public VkCommandBufferInheritanceInfo* pInheritanceInfo; // Pointer to inheritance info for secondary command buffers

	public this(void* pNext = null, VkCommandBufferUsageFlags flags = 0, VkCommandBufferInheritanceInfo* pInheritanceInfo = null)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.pInheritanceInfo = pInheritanceInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCommandBufferInheritanceInfo
{
	public const VkStructureType SType = .VkCommandBufferInheritanceInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRenderPass renderPass; // Render pass for secondary command buffers
	public uint32 subpass;
	public VkFramebuffer framebuffer; // Framebuffer for secondary command buffers
	public VkBool32 occlusionQueryEnable; // Whether this secondary command buffer may be executed during an occlusion query
	public VkQueryControlFlags queryFlags; // Query flags used by this secondary command buffer, if executed during an occlusion query
	public VkQueryPipelineStatisticFlags pipelineStatistics; // Pipeline statistics that may be counted for this secondary command buffer

	public this(void* pNext, VkRenderPass renderPass, uint32 subpass, VkFramebuffer framebuffer, VkBool32 occlusionQueryEnable, VkQueryControlFlags queryFlags = 0, VkQueryPipelineStatisticFlags pipelineStatistics = 0)
	{
		this.pNext = pNext;
		this.renderPass = renderPass;
		this.subpass = subpass;
		this.framebuffer = framebuffer;
		this.occlusionQueryEnable = occlusionQueryEnable;
		this.queryFlags = queryFlags;
		this.pipelineStatistics = pipelineStatistics;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkCommandBufferLevel : int32
{
	Primary = 0,
	Secondary = 1,
}

[AllowDuplicates] enum VkCommandBufferResetFlagBits : int32
{
	ReleaseResources = 1 << 0, // Release resources owned by the buffer
}

typealias VkCommandBufferResetFlags = VkCommandBufferResetFlagBits;

[AllowDuplicates] enum VkCommandBufferUsageFlagBits : int32
{
	OneTimeSubmit = 1 << 0,
	RenderPassContinue = 1 << 1,
	SimultaneousUse = 1 << 2, // Command buffer may be submitted/executed more than once simultaneously
}

typealias VkCommandBufferUsageFlags = VkCommandBufferUsageFlagBits;

[AllowDuplicates] enum VkQueryControlFlagBits : int32
{
	Precise = 1 << 0, // Require precise results to be collected by the query
}

typealias VkQueryControlFlags = VkQueryControlFlagBits;

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkAllocateCommandBuffers(VkDevice device, VkCommandBufferAllocateInfo* pAllocateInfo, out VkCommandBuffer pCommandBuffers);
[CallingConvention(VKAPI_PTR)] function void PFN_vkFreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32 commandBufferCount, VkCommandBuffer* pCommandBuffers);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkBeginCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferBeginInfo* pBeginInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkEndCommandBuffer(VkCommandBuffer commandBuffer);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags = 0);

// Command buffer building commands
[CRepr] struct VkBufferCopy
{
	public VkDeviceSize srcOffset; // Specified in bytes
	public VkDeviceSize dstOffset; // Specified in bytes
	public VkDeviceSize size; // Specified in bytes

	public this(VkDeviceSize srcOffset, VkDeviceSize dstOffset, VkDeviceSize size)
	{
		this.srcOffset = srcOffset;
		this.dstOffset = dstOffset;
		this.size = size;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkBufferImageCopy
{
	public VkDeviceSize bufferOffset; // Specified in bytes
	public uint32 bufferRowLength; // Specified in texels
	public uint32 bufferImageHeight;
	public VkImageSubresourceLayers imageSubresource;
	public VkOffset3D imageOffset; // Specified in pixels for both compressed and uncompressed images
	public VkExtent3D imageExtent; // Specified in pixels for both compressed and uncompressed images

	public this(VkDeviceSize bufferOffset, uint32 bufferRowLength, uint32 bufferImageHeight, VkImageSubresourceLayers imageSubresource, VkOffset3D imageOffset, VkExtent3D imageExtent)
	{
		this.bufferOffset = bufferOffset;
		this.bufferRowLength = bufferRowLength;
		this.bufferImageHeight = bufferImageHeight;
		this.imageSubresource = imageSubresource;
		this.imageOffset = imageOffset;
		this.imageExtent = imageExtent;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkClearAttachment
{
	public VkImageAspectFlags aspectMask;
	public uint32 colorAttachment;
	public VkClearValue clearValue;

	public this(VkImageAspectFlags aspectMask, uint32 colorAttachment, VkClearValue clearValue)
	{
		this.aspectMask = aspectMask;
		this.colorAttachment = colorAttachment;
		this.clearValue = clearValue;
	}

	public this()
	{
		this = default;
	}
}

// Union allowing specification of floating-point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.
[Union, CRepr] struct VkClearColorValue
{
	public float[4] float32;
	public int32[4] int32;
	public uint32[4] uint32;
}

[CRepr] struct VkClearDepthStencilValue
{
	public float depth;
	public uint32 stencil;

	public this(float depth, uint32 stencil)
	{
		this.depth = depth;
		this.stencil = stencil;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkClearRect
{
	public VkRect2D rect;
	public uint32 baseArrayLayer;
	public uint32 layerCount;

	public this(VkRect2D rect, uint32 baseArrayLayer, uint32 layerCount)
	{
		this.rect = rect;
		this.baseArrayLayer = baseArrayLayer;
		this.layerCount = layerCount;
	}

	public this()
	{
		this = default;
	}
}

// Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.
[Union, CRepr] struct VkClearValue
{
	public VkClearColorValue color;
	public VkClearDepthStencilValue depthStencil;
}

[CRepr] struct VkImageBlit
{
	public VkImageSubresourceLayers srcSubresource;
	public VkOffset3D[2] srcOffsets; // Specified in pixels for both compressed and uncompressed images
	public VkImageSubresourceLayers dstSubresource;
	public VkOffset3D[2] dstOffsets; // Specified in pixels for both compressed and uncompressed images

	public this(VkImageSubresourceLayers srcSubresource, VkOffset3D[2] srcOffsets, VkImageSubresourceLayers dstSubresource, VkOffset3D[2] dstOffsets)
	{
		this.srcSubresource = srcSubresource;
		this.srcOffsets = srcOffsets;
		this.dstSubresource = dstSubresource;
		this.dstOffsets = dstOffsets;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkImageCopy
{
	public VkImageSubresourceLayers srcSubresource;
	public VkOffset3D srcOffset; // Specified in pixels for both compressed and uncompressed images
	public VkImageSubresourceLayers dstSubresource;
	public VkOffset3D dstOffset; // Specified in pixels for both compressed and uncompressed images
	public VkExtent3D extent; // Specified in pixels for both compressed and uncompressed images

	public this(VkImageSubresourceLayers srcSubresource, VkOffset3D srcOffset, VkImageSubresourceLayers dstSubresource, VkOffset3D dstOffset, VkExtent3D extent)
	{
		this.srcSubresource = srcSubresource;
		this.srcOffset = srcOffset;
		this.dstSubresource = dstSubresource;
		this.dstOffset = dstOffset;
		this.extent = extent;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkImageResolve
{
	public VkImageSubresourceLayers srcSubresource;
	public VkOffset3D srcOffset;
	public VkImageSubresourceLayers dstSubresource;
	public VkOffset3D dstOffset;
	public VkExtent3D extent;

	public this(VkImageSubresourceLayers srcSubresource, VkOffset3D srcOffset, VkImageSubresourceLayers dstSubresource, VkOffset3D dstOffset, VkExtent3D extent)
	{
		this.srcSubresource = srcSubresource;
		this.srcOffset = srcOffset;
		this.dstSubresource = dstSubresource;
		this.dstOffset = dstOffset;
		this.extent = extent;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkImageSubresourceLayers
{
	public VkImageAspectFlags aspectMask;
	public uint32 mipLevel;
	public uint32 baseArrayLayer;
	public uint32 layerCount;

	public this(VkImageAspectFlags aspectMask, uint32 mipLevel, uint32 baseArrayLayer, uint32 layerCount)
	{
		this.aspectMask = aspectMask;
		this.mipLevel = mipLevel;
		this.baseArrayLayer = baseArrayLayer;
		this.layerCount = layerCount;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkIndexType : int32
{
	Uint16 = 0,
	Uint32 = 1,
	Uint8 = 1000265000,
	NoneKHR = 1000165000,
	NoneNV = NoneKHR,
	Uint8EXT = Uint8,
	Uint8KHR = Uint8,
}

[CRepr] struct VkRenderPassBeginInfo
{
	public const VkStructureType SType = .VkRenderPassBeginInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRenderPass renderPass;
	public VkFramebuffer framebuffer;
	public VkRect2D renderArea;
	public uint32 clearValueCount;
	public VkClearValue* pClearValues;
	public VulkanSpan<VkClearValue> clearValues
	{
		[Inline] get => .(clearValueCount, pClearValues);
		[Inline] set mut { clearValueCount = value.count; pClearValues = value.ptr; }
	}

	public this(void* pNext, VkRenderPass renderPass, VkFramebuffer framebuffer, VkRect2D renderArea, VulkanSpan<VkClearValue> clearValues = .()) : this()
	{
		this.pNext = pNext;
		this.renderPass = renderPass;
		this.framebuffer = framebuffer;
		this.renderArea = renderArea;
		this.clearValues = clearValues;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkStencilFaceFlagBits : int32
{
	Front = 1 << 0, // Front face
	Back = 1 << 1, // Back face
	FrontAndBack = 0x00000003, // Front and back faces
	VkStencilFrontAndBack = FrontAndBack,
}

typealias VkStencilFaceFlags = VkStencilFaceFlagBits;

[AllowDuplicates] enum VkSubpassContents : int32
{
	Inline = 0,
	SecondaryCommandBuffers = 1,
	InlineAndSecondaryCommandBuffersEXT = InlineAndSecondaryCommandBuffersKHR,
	InlineAndSecondaryCommandBuffersKHR = 1000451000,
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetViewport(VkCommandBuffer commandBuffer, uint32 firstViewport, uint32 viewportCount, VkViewport* pViewports);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetScissor(VkCommandBuffer commandBuffer, uint32 firstScissor, uint32 scissorCount, VkRect2D* pScissors);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetBlendConstants(VkCommandBuffer commandBuffer, float[4] blendConstants);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32 compareMask);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32 writeMask);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32 reference);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32 firstSet, uint32 descriptorSetCount, VkDescriptorSet* pDescriptorSets, uint32 dynamicOffsetCount = 0, uint32* pDynamicOffsets = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32 firstBinding, uint32 bindingCount, VkBuffer* pBuffers, VkDeviceSize* pOffsets);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDraw(VkCommandBuffer commandBuffer, uint32 vertexCount, uint32 instanceCount, uint32 firstVertex, uint32 firstInstance);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32 indexCount, uint32 instanceCount, uint32 firstIndex, int32 vertexOffset, uint32 firstInstance);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32 drawCount, uint32 stride);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32 drawCount, uint32 stride);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDispatch(VkCommandBuffer commandBuffer, uint32 groupCountX, uint32 groupCountY, uint32 groupCountZ);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32 regionCount, VkBufferCopy* pRegions);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32 regionCount, VkImageCopy* pRegions);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32 regionCount, VkImageBlit* pRegions, VkFilter filter);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32 regionCount, VkBufferImageCopy* pRegions);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32 regionCount, VkBufferImageCopy* pRegions);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, void* pData);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32 data);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearColorValue* pColor, uint32 rangeCount, VkImageSubresourceRange* pRanges);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearDepthStencilValue* pDepthStencil, uint32 rangeCount, VkImageSubresourceRange* pRanges);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdClearAttachments(VkCommandBuffer commandBuffer, uint32 attachmentCount, VkClearAttachment* pAttachments, uint32 rectCount, VkClearRect* pRects);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32 regionCount, VkImageResolve* pRegions);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask = 0);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask = 0);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdWaitEvents(VkCommandBuffer commandBuffer, uint32 eventCount, VkEvent* pEvents, VkPipelineStageFlags srcStageMask = 0, VkPipelineStageFlags dstStageMask = 0, uint32 memoryBarrierCount = 0, VkMemoryBarrier* pMemoryBarriers = null, uint32 bufferMemoryBarrierCount = 0, VkBufferMemoryBarrier* pBufferMemoryBarriers = null, uint32 imageMemoryBarrierCount = 0, VkImageMemoryBarrier* pImageMemoryBarriers = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask = 0, VkPipelineStageFlags dstStageMask = 0, VkDependencyFlags dependencyFlags = 0, uint32 memoryBarrierCount = 0, VkMemoryBarrier* pMemoryBarriers = null, uint32 bufferMemoryBarrierCount = 0, VkBufferMemoryBarrier* pBufferMemoryBarriers = null, uint32 imageMemoryBarrierCount = 0, VkImageMemoryBarrier* pImageMemoryBarriers = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32 query, VkQueryControlFlags flags = 0);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32 query);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32 firstQuery, uint32 queryCount);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32 query);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32 firstQuery, uint32 queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags = 0);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32 offset, uint32 size, void* pValues);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBeginRenderPass(VkCommandBuffer commandBuffer, VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdEndRenderPass(VkCommandBuffer commandBuffer);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdExecuteCommands(VkCommandBuffer commandBuffer, uint32 commandBufferCount, VkCommandBuffer* pCommandBuffers);

static { public const uint32 VK_API_VERSION_1_1 = VK_MAKE_API_VERSION(0, 1, 1, 0)/* Patch version should always be set to 0 */; }

// Device Initialization
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkEnumerateInstanceVersion(out uint32 pApiVersion);

// Promoted from VK_KHR_relaxed_block_layout, which has no API
// Promoted from VK_KHR_storage_buffer_storage_class, which has no API
// Originally based on VK_KHR_subgroup (extension 94), but the actual enum block used was, incorrectly, that of extension 95
[CRepr] struct VkPhysicalDeviceSubgroupProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceSubgroupProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 subgroupSize; // The size of a subgroup for this queue.
	public VkShaderStageFlags supportedStages; // Bitfield of what shader stages support subgroup operations
	public VkSubgroupFeatureFlags supportedOperations; // Bitfield of what subgroup operations are supported.
	public VkBool32 quadOperationsInAllStages; // Flag to specify whether quad operations are available in all stages.
}

typealias VkSubgroupFeatureFlags = VkSubgroupFeatureFlagBits;

[AllowDuplicates] enum VkSubgroupFeatureFlagBits : int32
{
	Basic = 1 << 0, // Basic subgroup operations
	Vote = 1 << 1, // Vote subgroup operations
	Arithmetic = 1 << 2, // Arithmetic subgroup operations
	Ballot = 1 << 3, // Ballot subgroup operations
	Shuffle = 1 << 4, // Shuffle subgroup operations
	ShuffleRelative = 1 << 5, // Shuffle relative subgroup operations
	Clustered = 1 << 6, // Clustered subgroup operations
	Quad = 1 << 7, // Quad subgroup operations
	Rotate = 1 << 9,
	RotateClustered = 1 << 10,
	PartitionedNV = 1 << 8,
	RotateKHR = Rotate,
	RotateClusteredKHR = RotateClustered,
}

// Promoted from VK_KHR_bind_memory2
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkBindBufferMemory2(VkDevice device, uint32 bindInfoCount, VkBindBufferMemoryInfo* pBindInfos);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkBindImageMemory2(VkDevice device, uint32 bindInfoCount, VkBindImageMemoryInfo* pBindInfos);

[CRepr] struct VkBindBufferMemoryInfo
{
	public const VkStructureType SType = .VkBindBufferMemoryInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBuffer buffer;
	public VkDeviceMemory memory;
	public VkDeviceSize memoryOffset;

	public this(void* pNext, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset)
	{
		this.pNext = pNext;
		this.buffer = buffer;
		this.memory = memory;
		this.memoryOffset = memoryOffset;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBindImageMemoryInfo
{
	public const VkStructureType SType = .VkBindImageMemoryInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImage image;
	public VkDeviceMemory memory;
	public VkDeviceSize memoryOffset;

	public this(void* pNext, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset)
	{
		this.pNext = pNext;
		this.image = image;
		this.memory = memory;
		this.memoryOffset = memoryOffset;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_16bit_storage
[CRepr] struct VkPhysicalDevice16BitStorageFeatures
{
	public const VkStructureType SType = .VkPhysicalDevice16bitStorageFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 storageBuffer16BitAccess; // 16-bit integer/floating-point variables supported in BufferBlock
	public VkBool32 uniformAndStorageBuffer16BitAccess; // 16-bit integer/floating-point variables supported in BufferBlock and Block
	public VkBool32 storagePushConstant16; // 16-bit integer/floating-point variables supported in PushConstant
	public VkBool32 storageInputOutput16; // 16-bit integer/floating-point variables supported in shader inputs and outputs

	public this(void* pNext, VkBool32 storageBuffer16BitAccess, VkBool32 uniformAndStorageBuffer16BitAccess, VkBool32 storagePushConstant16, VkBool32 storageInputOutput16)
	{
		this.pNext = pNext;
		this.storageBuffer16BitAccess = storageBuffer16BitAccess;
		this.uniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess;
		this.storagePushConstant16 = storagePushConstant16;
		this.storageInputOutput16 = storageInputOutput16;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_dedicated_allocation
[CRepr] struct VkMemoryDedicatedRequirements
{
	public const VkStructureType SType = .VkMemoryDedicatedRequirements;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 prefersDedicatedAllocation;
	public VkBool32 requiresDedicatedAllocation;
}

[CRepr] struct VkMemoryDedicatedAllocateInfo
{
	public const VkStructureType SType = .VkMemoryDedicatedAllocateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImage image; // Image that this allocation will be bound to
	public VkBuffer buffer; // Buffer that this allocation will be bound to

	public this(void* pNext = null, VkImage image = null, VkBuffer buffer = null)
	{
		this.pNext = pNext;
		this.image = image;
		this.buffer = buffer;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_device_group
typealias VkPeerMemoryFeatureFlags = VkPeerMemoryFeatureFlagBits;

[AllowDuplicates] enum VkPeerMemoryFeatureFlagBits : int32
{
	CopySrc = 1 << 0, // Can read with vkCmdCopy commands
	CopyDst = 1 << 1, // Can write with vkCmdCopy commands
	GenericSrc = 1 << 2, // Can read with any access type/command
	GenericDst = 1 << 3, // Can write with and access type/command
	CopySrcKHR = CopySrc,
	CopyDstKHR = CopyDst,
	GenericSrcKHR = GenericSrc,
	GenericDstKHR = GenericDst,
}

typealias VkMemoryAllocateFlags = VkMemoryAllocateFlagBits;

[AllowDuplicates] enum VkMemoryAllocateFlagBits : int32
{
	DeviceMask = 1 << 0, // Force allocation on specific devices
	DeviceAddress = 1 << 1,
	DeviceAddressCaptureReplay = 1 << 2,
	DeviceMaskKHR = DeviceMask,
	DeviceAddressKHR = DeviceAddress,
	DeviceAddressCaptureReplayKHR = DeviceAddressCaptureReplay,
	ZeroInitializeEXT = 1 << 3,
}

[CRepr] struct VkMemoryAllocateFlagsInfo
{
	public const VkStructureType SType = .VkMemoryAllocateFlagsInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkMemoryAllocateFlags flags;
	public uint32 deviceMask;

	public this(void* pNext, VkMemoryAllocateFlags flags, uint32 deviceMask)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.deviceMask = deviceMask;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceGroupRenderPassBeginInfo
{
	public const VkStructureType SType = .VkDeviceGroupRenderPassBeginInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 deviceMask;
	public uint32 deviceRenderAreaCount;
	public VkRect2D* pDeviceRenderAreas;
	public VulkanSpan<VkRect2D> deviceRenderAreas
	{
		[Inline] get => .(deviceRenderAreaCount, pDeviceRenderAreas);
		[Inline] set mut { deviceRenderAreaCount = value.count; pDeviceRenderAreas = value.ptr; }
	}

	public this(void* pNext, uint32 deviceMask, VulkanSpan<VkRect2D> deviceRenderAreas = .()) : this()
	{
		this.pNext = pNext;
		this.deviceMask = deviceMask;
		this.deviceRenderAreas = deviceRenderAreas;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceGroupCommandBufferBeginInfo
{
	public const VkStructureType SType = .VkDeviceGroupCommandBufferBeginInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 deviceMask;

	public this(void* pNext, uint32 deviceMask)
	{
		this.pNext = pNext;
		this.deviceMask = deviceMask;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceGroupSubmitInfo
{
	public const VkStructureType SType = .VkDeviceGroupSubmitInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 waitSemaphoreCount;
	public uint32* pWaitSemaphoreDeviceIndices;
	public VulkanSpan<uint32> waitSemaphoreDeviceIndices
	{
		[Inline] get => .(waitSemaphoreCount, pWaitSemaphoreDeviceIndices);
		[Inline] set mut { waitSemaphoreCount = value.count; pWaitSemaphoreDeviceIndices = value.ptr; }
	}
	public uint32 commandBufferCount;
	public uint32* pCommandBufferDeviceMasks;
	public VulkanSpan<uint32> commandBufferDeviceMasks
	{
		[Inline] get => .(commandBufferCount, pCommandBufferDeviceMasks);
		[Inline] set mut { commandBufferCount = value.count; pCommandBufferDeviceMasks = value.ptr; }
	}
	public uint32 signalSemaphoreCount;
	public uint32* pSignalSemaphoreDeviceIndices;
	public VulkanSpan<uint32> signalSemaphoreDeviceIndices
	{
		[Inline] get => .(signalSemaphoreCount, pSignalSemaphoreDeviceIndices);
		[Inline] set mut { signalSemaphoreCount = value.count; pSignalSemaphoreDeviceIndices = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<uint32> waitSemaphoreDeviceIndices = .(), VulkanSpan<uint32> commandBufferDeviceMasks = .(), VulkanSpan<uint32> signalSemaphoreDeviceIndices = .()) : this()
	{
		this.pNext = pNext;
		this.waitSemaphoreDeviceIndices = waitSemaphoreDeviceIndices;
		this.commandBufferDeviceMasks = commandBufferDeviceMasks;
		this.signalSemaphoreDeviceIndices = signalSemaphoreDeviceIndices;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceGroupBindSparseInfo
{
	public const VkStructureType SType = .VkDeviceGroupBindSparseInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 resourceDeviceIndex;
	public uint32 memoryDeviceIndex;

	public this(void* pNext, uint32 resourceDeviceIndex, uint32 memoryDeviceIndex)
	{
		this.pNext = pNext;
		this.resourceDeviceIndex = resourceDeviceIndex;
		this.memoryDeviceIndex = memoryDeviceIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32 heapIndex, uint32 localDeviceIndex, uint32 remoteDeviceIndex, out VkPeerMemoryFeatureFlags pPeerMemoryFeatures);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32 deviceMask);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDispatchBase(VkCommandBuffer commandBuffer, uint32 baseGroupX, uint32 baseGroupY, uint32 baseGroupZ, uint32 groupCountX, uint32 groupCountY, uint32 groupCountZ);

// Promoted from VK_KHR_device_group + VK_KHR_bind_memory2
[CRepr] struct VkBindBufferMemoryDeviceGroupInfo
{
	public const VkStructureType SType = .VkBindBufferMemoryDeviceGroupInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 deviceIndexCount;
	public uint32* pDeviceIndices;
	public VulkanSpan<uint32> deviceIndices
	{
		[Inline] get => .(deviceIndexCount, pDeviceIndices);
		[Inline] set mut { deviceIndexCount = value.count; pDeviceIndices = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<uint32> deviceIndices = .()) : this()
	{
		this.pNext = pNext;
		this.deviceIndices = deviceIndices;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBindImageMemoryDeviceGroupInfo
{
	public const VkStructureType SType = .VkBindImageMemoryDeviceGroupInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 deviceIndexCount;
	public uint32* pDeviceIndices;
	public VulkanSpan<uint32> deviceIndices
	{
		[Inline] get => .(deviceIndexCount, pDeviceIndices);
		[Inline] set mut { deviceIndexCount = value.count; pDeviceIndices = value.ptr; }
	}
	public uint32 splitInstanceBindRegionCount;
	public VkRect2D* pSplitInstanceBindRegions;
	public VulkanSpan<VkRect2D> splitInstanceBindRegions
	{
		[Inline] get => .(splitInstanceBindRegionCount, pSplitInstanceBindRegions);
		[Inline] set mut { splitInstanceBindRegionCount = value.count; pSplitInstanceBindRegions = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<uint32> deviceIndices = .(), VulkanSpan<VkRect2D> splitInstanceBindRegions = .()) : this()
	{
		this.pNext = pNext;
		this.deviceIndices = deviceIndices;
		this.splitInstanceBindRegions = splitInstanceBindRegions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_device_group_creation
static { public const uint32 VK_MAX_DEVICE_GROUP_SIZE = 32; }

[CRepr] struct VkPhysicalDeviceGroupProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceGroupProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 physicalDeviceCount;
	public VkPhysicalDevice[VK_MAX_DEVICE_GROUP_SIZE] physicalDevices;
	public VkBool32 subsetAllocation;
}

[CRepr] struct VkDeviceGroupDeviceCreateInfo
{
	public const VkStructureType SType = .VkDeviceGroupDeviceCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 physicalDeviceCount;
	public VkPhysicalDevice* pPhysicalDevices;
	public VulkanSpan<VkPhysicalDevice> physicalDevices
	{
		[Inline] get => .(physicalDeviceCount, pPhysicalDevices);
		[Inline] set mut { physicalDeviceCount = value.count; pPhysicalDevices = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkPhysicalDevice> physicalDevices = .()) : this()
	{
		this.pNext = pNext;
		this.physicalDevices = physicalDevices;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkEnumeratePhysicalDeviceGroups(VkInstance instance, out uint32 pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = null);

// Promoted from VK_KHR_get_memory_requirements2
[CRepr] struct VkBufferMemoryRequirementsInfo2
{
	public const VkStructureType SType = .VkBufferMemoryRequirementsInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkBuffer buffer;

	public this(void* pNext, VkBuffer buffer)
	{
		this.pNext = pNext;
		this.buffer = buffer;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageMemoryRequirementsInfo2
{
	public const VkStructureType SType = .VkImageMemoryRequirementsInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkImage image;

	public this(void* pNext, VkImage image)
	{
		this.pNext = pNext;
		this.image = image;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageSparseMemoryRequirementsInfo2
{
	public const VkStructureType SType = .VkImageSparseMemoryRequirementsInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkImage image;

	public this(void* pNext, VkImage image)
	{
		this.pNext = pNext;
		this.image = image;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryRequirements2
{
	public const VkStructureType SType = .VkMemoryRequirements2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkMemoryRequirements memoryRequirements;
}

[CRepr] struct VkSparseImageMemoryRequirements2
{
	public const VkStructureType SType = .VkSparseImageMemoryRequirements2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkSparseImageMemoryRequirements memoryRequirements;
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetImageMemoryRequirements2(VkDevice device, VkImageMemoryRequirementsInfo2* pInfo, out VkMemoryRequirements2 pMemoryRequirements);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetBufferMemoryRequirements2(VkDevice device, VkBufferMemoryRequirementsInfo2* pInfo, out VkMemoryRequirements2 pMemoryRequirements);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetImageSparseMemoryRequirements2(VkDevice device, VkImageSparseMemoryRequirementsInfo2* pInfo, out uint32 pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements = null);

// Promoted from VK_KHR_get_physical_device_properties2
[CRepr] struct VkPhysicalDeviceFeatures2
{
	public const VkStructureType SType = .VkPhysicalDeviceFeatures2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkPhysicalDeviceFeatures features;

	public this(void* pNext, VkPhysicalDeviceFeatures features)
	{
		this.pNext = pNext;
		this.features = features;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceProperties2
{
	public const VkStructureType SType = .VkPhysicalDeviceProperties2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkPhysicalDeviceProperties properties;
}

[CRepr] struct VkFormatProperties2
{
	public const VkStructureType SType = .VkFormatProperties2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkFormatProperties formatProperties;
}

[CRepr] struct VkImageFormatProperties2
{
	public const VkStructureType SType = .VkImageFormatProperties2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkImageFormatProperties imageFormatProperties;
}

[CRepr] struct VkPhysicalDeviceImageFormatInfo2
{
	public const VkStructureType SType = .VkPhysicalDeviceImageFormatInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat format;
	public VkImageType type;
	public VkImageTiling tiling;
	public VkImageUsageFlags usage;
	public VkImageCreateFlags flags;

	public this(void* pNext, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags = 0)
	{
		this.pNext = pNext;
		this.format = format;
		this.type = type;
		this.tiling = tiling;
		this.usage = usage;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkQueueFamilyProperties2
{
	public const VkStructureType SType = .VkQueueFamilyProperties2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkQueueFamilyProperties queueFamilyProperties;
}

[CRepr] struct VkPhysicalDeviceMemoryProperties2
{
	public const VkStructureType SType = .VkPhysicalDeviceMemoryProperties2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkPhysicalDeviceMemoryProperties memoryProperties;
}

[CRepr] struct VkSparseImageFormatProperties2
{
	public const VkStructureType SType = .VkSparseImageFormatProperties2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkSparseImageFormatProperties properties;
}

[CRepr] struct VkPhysicalDeviceSparseImageFormatInfo2
{
	public const VkStructureType SType = .VkPhysicalDeviceSparseImageFormatInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat format;
	public VkImageType type;
	public VkSampleCountFlagBits samples;
	public VkImageUsageFlags usage;
	public VkImageTiling tiling;

	public this(void* pNext, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling)
	{
		this.pNext = pNext;
		this.format = format;
		this.type = type;
		this.samples = samples;
		this.usage = usage;
		this.tiling = tiling;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, out VkPhysicalDeviceFeatures2 pFeatures);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, out VkPhysicalDeviceProperties2 pProperties);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, out VkFormatProperties2 pFormatProperties);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, out VkImageFormatProperties2 pImageFormatProperties);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, out uint32 pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, out VkPhysicalDeviceMemoryProperties2 pMemoryProperties);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, out uint32 pPropertyCount, VkSparseImageFormatProperties2* pProperties = null);

// Promoted from VK_KHR_maintenance1
[CallingConvention(VKAPI_PTR)] function void PFN_vkTrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags = 0);

typealias VkCommandPoolTrimFlags = VkFlags;

// Promoted from VK_KHR_maintenance2
[CRepr] struct VkPhysicalDevicePointClippingProperties
{
	public const VkStructureType SType = .VkPhysicalDevicePointClippingProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPointClippingBehavior pointClippingBehavior;
}

[AllowDuplicates] enum VkPointClippingBehavior : int32
{
	AllClipPlanes = 0,
	UserClipPlanesOnly = 1,
	AllClipPlanesKHR = AllClipPlanes,
	UserClipPlanesOnlyKHR = UserClipPlanesOnly,
}

[CRepr] struct VkRenderPassInputAttachmentAspectCreateInfo
{
	public const VkStructureType SType = .VkRenderPassInputAttachmentAspectCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 aspectReferenceCount;
	public VkInputAttachmentAspectReference* pAspectReferences;
	public VulkanSpan<VkInputAttachmentAspectReference> aspectReferences
	{
		[Inline] get => .(aspectReferenceCount, pAspectReferences);
		[Inline] set mut { aspectReferenceCount = value.count; pAspectReferences = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<VkInputAttachmentAspectReference> aspectReferences) : this()
	{
		this.pNext = pNext;
		this.aspectReferences = aspectReferences;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkInputAttachmentAspectReference
{
	public uint32 subpass;
	public uint32 inputAttachmentIndex;
	public VkImageAspectFlags aspectMask;

	public this(uint32 subpass, uint32 inputAttachmentIndex, VkImageAspectFlags aspectMask)
	{
		this.subpass = subpass;
		this.inputAttachmentIndex = inputAttachmentIndex;
		this.aspectMask = aspectMask;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkImageViewUsageCreateInfo
{
	public const VkStructureType SType = .VkImageViewUsageCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageUsageFlags usage;

	public this(void* pNext, VkImageUsageFlags usage)
	{
		this.pNext = pNext;
		this.usage = usage;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkTessellationDomainOrigin : int32
{
	UpperLeft = 0,
	LowerLeft = 1,
	UpperLeftKHR = UpperLeft,
	LowerLeftKHR = LowerLeft,
}

[CRepr] struct VkPipelineTessellationDomainOriginStateCreateInfo
{
	public const VkStructureType SType = .VkPipelineTessellationDomainOriginStateCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTessellationDomainOrigin domainOrigin;

	public this(void* pNext, VkTessellationDomainOrigin domainOrigin)
	{
		this.pNext = pNext;
		this.domainOrigin = domainOrigin;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_multiview
[CRepr] struct VkRenderPassMultiviewCreateInfo
{
	public const VkStructureType SType = .VkRenderPassMultiviewCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 subpassCount;
	public uint32* pViewMasks;
	public VulkanSpan<uint32> viewMasks
	{
		[Inline] get => .(subpassCount, pViewMasks);
		[Inline] set mut { subpassCount = value.count; pViewMasks = value.ptr; }
	}
	public uint32 dependencyCount;
	public int32* pViewOffsets;
	public VulkanSpan<int32> viewOffsets
	{
		[Inline] get => .(dependencyCount, pViewOffsets);
		[Inline] set mut { dependencyCount = value.count; pViewOffsets = value.ptr; }
	}
	public uint32 correlationMaskCount;
	public uint32* pCorrelationMasks;
	public VulkanSpan<uint32> correlationMasks
	{
		[Inline] get => .(correlationMaskCount, pCorrelationMasks);
		[Inline] set mut { correlationMaskCount = value.count; pCorrelationMasks = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<uint32> viewMasks = .(), VulkanSpan<int32> viewOffsets = .(), VulkanSpan<uint32> correlationMasks = .()) : this()
	{
		this.pNext = pNext;
		this.viewMasks = viewMasks;
		this.viewOffsets = viewOffsets;
		this.correlationMasks = correlationMasks;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceMultiviewFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceMultiviewFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 multiview; // Multiple views in a render pass
	public VkBool32 multiviewGeometryShader; // Multiple views in a render pass w/ geometry shader
	public VkBool32 multiviewTessellationShader; // Multiple views in a render pass w/ tessellation shader

	public this(void* pNext, VkBool32 multiview, VkBool32 multiviewGeometryShader, VkBool32 multiviewTessellationShader)
	{
		this.pNext = pNext;
		this.multiview = multiview;
		this.multiviewGeometryShader = multiviewGeometryShader;
		this.multiviewTessellationShader = multiviewTessellationShader;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceMultiviewProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceMultiviewProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxMultiviewViewCount; // max number of views in a subpass
	public uint32 maxMultiviewInstanceIndex; // max instance index for a draw in a multiview subpass
}

// Promoted from VK_KHR_variable_pointers
typealias VkPhysicalDeviceVariablePointerFeatures = VkPhysicalDeviceVariablePointersFeatures;

[CRepr] struct VkPhysicalDeviceVariablePointersFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceVariablePointersFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 variablePointersStorageBuffer;
	public VkBool32 variablePointers;

	public this(void* pNext, VkBool32 variablePointersStorageBuffer, VkBool32 variablePointers)
	{
		this.pNext = pNext;
		this.variablePointersStorageBuffer = variablePointersStorageBuffer;
		this.variablePointers = variablePointers;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Originally based on VK_KHR_protected_memory (extension 146), which was never published; thus the mystifying large value= numbers below. These are not aliased since they were not actually promoted from an extension.
[AllowDuplicates] enum VkDeviceQueueCreateFlagBits : int32
{
	Protected = 1 << 0, // Queue is a protected-capable device queue
}

[CRepr] struct VkPhysicalDeviceProtectedMemoryFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceProtectedMemoryFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 protectedMemory;

	public this(void* pNext, VkBool32 protectedMemory)
	{
		this.pNext = pNext;
		this.protectedMemory = protectedMemory;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceProtectedMemoryProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceProtectedMemoryProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 protectedNoFault;
}

[CRepr] struct VkDeviceQueueInfo2
{
	public const VkStructureType SType = .VkDeviceQueueInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceQueueCreateFlags flags;
	public uint32 queueFamilyIndex;
	public uint32 queueIndex;

	public this(void* pNext, VkDeviceQueueCreateFlags flags, uint32 queueFamilyIndex, uint32 queueIndex)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.queueFamilyIndex = queueFamilyIndex;
		this.queueIndex = queueIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkProtectedSubmitInfo
{
	public const VkStructureType SType = .VkProtectedSubmitInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 protectedSubmit; // Submit protected command buffers

	public this(void* pNext, VkBool32 protectedSubmit)
	{
		this.pNext = pNext;
		this.protectedSubmit = protectedSubmit;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDeviceQueue2(VkDevice device, VkDeviceQueueInfo2* pQueueInfo, out VkQueue pQueue);

// Promoted from VK_KHR_sampler_ycbcr_conversion
[CRepr] struct VkSamplerYcbcrConversionCreateInfo
{
	public const VkStructureType SType = .VkSamplerYcbcrConversionCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat format;
	public VkSamplerYcbcrModelConversion ycbcrModel;
	public VkSamplerYcbcrRange ycbcrRange;
	public VkComponentMapping components;
	public VkChromaLocation xChromaOffset;
	public VkChromaLocation yChromaOffset;
	public VkFilter chromaFilter;
	public VkBool32 forceExplicitReconstruction;

	public this(void* pNext, VkFormat format, VkSamplerYcbcrModelConversion ycbcrModel, VkSamplerYcbcrRange ycbcrRange, VkComponentMapping components, VkChromaLocation xChromaOffset, VkChromaLocation yChromaOffset, VkFilter chromaFilter, VkBool32 forceExplicitReconstruction)
	{
		this.pNext = pNext;
		this.format = format;
		this.ycbcrModel = ycbcrModel;
		this.ycbcrRange = ycbcrRange;
		this.components = components;
		this.xChromaOffset = xChromaOffset;
		this.yChromaOffset = yChromaOffset;
		this.chromaFilter = chromaFilter;
		this.forceExplicitReconstruction = forceExplicitReconstruction;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSamplerYcbcrConversionInfo
{
	public const VkStructureType SType = .VkSamplerYcbcrConversionInfo;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkSamplerYcbcrConversion conversion;

	public this(void* pNext, VkSamplerYcbcrConversion conversion)
	{
		this.pNext = pNext;
		this.conversion = conversion;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBindImagePlaneMemoryInfo
{
	public const VkStructureType SType = .VkBindImagePlaneMemoryInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageAspectFlagBits planeAspect;

	public this(void* pNext, VkImageAspectFlagBits planeAspect)
	{
		this.pNext = pNext;
		this.planeAspect = planeAspect;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImagePlaneMemoryRequirementsInfo
{
	public const VkStructureType SType = .VkImagePlaneMemoryRequirementsInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageAspectFlagBits planeAspect;

	public this(void* pNext, VkImageAspectFlagBits planeAspect)
	{
		this.pNext = pNext;
		this.planeAspect = planeAspect;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceSamplerYcbcrConversionFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceSamplerYcbcrConversionFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 samplerYcbcrConversion; // Sampler color conversion supported

	public this(void* pNext, VkBool32 samplerYcbcrConversion)
	{
		this.pNext = pNext;
		this.samplerYcbcrConversion = samplerYcbcrConversion;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSamplerYcbcrConversionImageFormatProperties
{
	public const VkStructureType SType = .VkSamplerYcbcrConversionImageFormatProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 combinedImageSamplerDescriptorCount;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateSamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversionCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSamplerYcbcrConversion pYcbcrConversion);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion = null, VkAllocationCallbacks* pAllocator = null);

class VkSamplerYcbcrConversion { private this() { } }

[AllowDuplicates] enum VkSamplerYcbcrModelConversion : int32
{
	RgbIdentity = 0,
	YcbcrIdentity = 1, // just range expansion
	Ycbcr709 = 2, // aka HD YUV
	Ycbcr601 = 3, // aka SD YUV
	Ycbcr2020 = 4, // aka UHD YUV
	RgbIdentityKHR = RgbIdentity,
	YcbcrIdentityKHR = YcbcrIdentity,
	Ycbcr709KHR = Ycbcr709,
	Ycbcr601KHR = Ycbcr601,
	Ycbcr2020KHR = Ycbcr2020,
}

[AllowDuplicates] enum VkSamplerYcbcrRange : int32
{
	ItuFull = 0, // Luma 0..1 maps to 0..255, chroma -0.5..0.5 to 1..255 (clamped)
	ItuNarrow = 1, // Luma 0..1 maps to 16..235, chroma -0.5..0.5 to 16..240
	ItuFullKHR = ItuFull,
	ItuNarrowKHR = ItuNarrow,
}

[AllowDuplicates] enum VkChromaLocation : int32
{
	CositedEven = 0,
	Midpoint = 1,
	CositedEvenKHR = CositedEven,
	MidpointKHR = Midpoint,
}

// Promoted from VK_KHR_descriptor_update_template
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkDescriptorUpdateTemplate pDescriptorUpdateTemplate);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkUpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, void* pData);

class VkDescriptorUpdateTemplate { private this() { } }

typealias VkDescriptorUpdateTemplateCreateFlags = VkFlags;

[AllowDuplicates] enum VkDescriptorUpdateTemplateType : int32
{
	DescriptorSet = 0, // Create descriptor update template for descriptor set updates
	PushDescriptors = 1,
	PushDescriptorsKHR = PushDescriptors, // Create descriptor update template for pushed descriptor updates
	DescriptorSetKHR = DescriptorSet,
}

[CRepr] struct VkDescriptorUpdateTemplateEntry
{
	public uint32 dstBinding; // Binding within the destination descriptor set to write
	public uint32 dstArrayElement; // Array element within the destination binding to write
	public uint32 descriptorCount; // Number of descriptors to write
	public VkDescriptorType descriptorType; // Descriptor type to write
	public c_size offset; // Offset into pData where the descriptors to update are stored
	public c_size stride; // Stride between two descriptors in pData when writing more than one descriptor

	public this(uint32 dstBinding, uint32 dstArrayElement, uint32 descriptorCount, VkDescriptorType descriptorType, c_size offset, c_size stride)
	{
		this.dstBinding = dstBinding;
		this.dstArrayElement = dstArrayElement;
		this.descriptorCount = descriptorCount;
		this.descriptorType = descriptorType;
		this.offset = offset;
		this.stride = stride;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkDescriptorUpdateTemplateCreateInfo
{
	public const VkStructureType SType = .VkDescriptorUpdateTemplateCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDescriptorUpdateTemplateCreateFlags flags;
	public uint32 descriptorUpdateEntryCount; // Number of descriptor update entries to use for the update template
	public VkDescriptorUpdateTemplateEntry* pDescriptorUpdateEntries; // Descriptor update entries for the template
	public VulkanSpan<VkDescriptorUpdateTemplateEntry> descriptorUpdateEntries
	{
		[Inline] get => .(descriptorUpdateEntryCount, pDescriptorUpdateEntries);
		[Inline] set mut { descriptorUpdateEntryCount = value.count; pDescriptorUpdateEntries = value.ptr; }
	} // Descriptor update entries for the template
	public VkDescriptorUpdateTemplateType templateType;
	public VkDescriptorSetLayout descriptorSetLayout;
	public VkPipelineBindPoint pipelineBindPoint;
	public VkPipelineLayout pipelineLayout; // If used for push descriptors, this is the only allowed layout
	public uint32 set;

	public this(void* pNext, VkDescriptorUpdateTemplateCreateFlags flags, VulkanSpan<VkDescriptorUpdateTemplateEntry> descriptorUpdateEntries, VkDescriptorUpdateTemplateType templateType, VkDescriptorSetLayout descriptorSetLayout, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout pipelineLayout, uint32 set) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.descriptorUpdateEntries = descriptorUpdateEntries;
		this.templateType = templateType;
		this.descriptorSetLayout = descriptorSetLayout;
		this.pipelineBindPoint = pipelineBindPoint;
		this.pipelineLayout = pipelineLayout;
		this.set = set;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_external_memory_capabilities
static { public const uint32 VK_LUID_SIZE = 8; }

typealias VkExternalMemoryHandleTypeFlags = VkExternalMemoryHandleTypeFlagBits;

[AllowDuplicates] enum VkExternalMemoryHandleTypeFlagBits : int32
{
	OpaqueFd = 1 << 0,
	OpaqueWin32 = 1 << 1,
	OpaqueWin32Kmt = 1 << 2,
	D3d11Texture = 1 << 3,
	D3d11TextureKmt = 1 << 4,
	D3d12Heap = 1 << 5,
	D3d12Resource = 1 << 6,
	OpaqueFdKHR = OpaqueFd,
	OpaqueWin32KHR = OpaqueWin32,
	OpaqueWin32KmtKHR = OpaqueWin32Kmt,
	D3d11TextureKHR = D3d11Texture,
	D3d11TextureKmtKHR = D3d11TextureKmt,
	D3d12HeapKHR = D3d12Heap,
	D3d12ResourceKHR = D3d12Resource,
	DmaBufEXT = 1 << 9,
	AndroidHardwareBufferANDROID = 1 << 10,
	HostAllocationEXT = 1 << 7,
	HostMappedForeignMemoryEXT = 1 << 8,
	ZirconVmoFUCHSIA = 1 << 11,
	RdmaAddressNV = 1 << 12,
	ScreenBufferQNX = 1 << 14,
	MtlbufferEXT = 1 << 16,
	MtltextureEXT = 1 << 17,
	MtlheapEXT = 1 << 18,
}

typealias VkExternalMemoryFeatureFlags = VkExternalMemoryFeatureFlagBits;

[AllowDuplicates] enum VkExternalMemoryFeatureFlagBits : int32
{
	DedicatedOnly = 1 << 0,
	Exportable = 1 << 1,
	Importable = 1 << 2,
	DedicatedOnlyKHR = DedicatedOnly,
	ExportableKHR = Exportable,
	ImportableKHR = Importable,
}

[CRepr] struct VkExternalMemoryProperties
{
	public VkExternalMemoryFeatureFlags externalMemoryFeatures;
	public VkExternalMemoryHandleTypeFlags exportFromImportedHandleTypes;
	public VkExternalMemoryHandleTypeFlags compatibleHandleTypes;
}

[CRepr] struct VkPhysicalDeviceExternalImageFormatInfo
{
	public const VkStructureType SType = .VkPhysicalDeviceExternalImageFormatInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlagBits handleType;

	public this(void* pNext = null, VkExternalMemoryHandleTypeFlagBits handleType = 0)
	{
		this.pNext = pNext;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExternalImageFormatProperties
{
	public const VkStructureType SType = .VkExternalImageFormatProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryProperties externalMemoryProperties;
}

[CRepr] struct VkPhysicalDeviceExternalBufferInfo
{
	public const VkStructureType SType = .VkPhysicalDeviceExternalBufferInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBufferCreateFlags flags;
	public VkBufferUsageFlags usage;
	public VkExternalMemoryHandleTypeFlagBits handleType;

	public this(void* pNext, VkBufferCreateFlags flags, VkBufferUsageFlags usage, VkExternalMemoryHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.usage = usage;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExternalBufferProperties
{
	public const VkStructureType SType = .VkExternalBufferProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryProperties externalMemoryProperties;
}

[CRepr] struct VkPhysicalDeviceIDProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceIdProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint8[VK_UUID_SIZE] deviceUUID;
	public uint8[VK_UUID_SIZE] driverUUID;
	public uint8[VK_LUID_SIZE] deviceLUID;
	public uint32 deviceNodeMask;
	public VkBool32 deviceLUIDValid;
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, out VkExternalBufferProperties pExternalBufferProperties);

// Promoted from VK_KHR_external_memory
static { public const uint32 VK_QUEUE_FAMILY_EXTERNAL = (.)(~1U); }

[CRepr] struct VkExternalMemoryImageCreateInfo
{
	public const VkStructureType SType = .VkExternalMemoryImageCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags handleTypes;

	public this(void* pNext = null, VkExternalMemoryHandleTypeFlags handleTypes = 0)
	{
		this.pNext = pNext;
		this.handleTypes = handleTypes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExternalMemoryBufferCreateInfo
{
	public const VkStructureType SType = .VkExternalMemoryBufferCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags handleTypes;

	public this(void* pNext = null, VkExternalMemoryHandleTypeFlags handleTypes = 0)
	{
		this.pNext = pNext;
		this.handleTypes = handleTypes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExportMemoryAllocateInfo
{
	public const VkStructureType SType = .VkExportMemoryAllocateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags handleTypes;

	public this(void* pNext = null, VkExternalMemoryHandleTypeFlags handleTypes = 0)
	{
		this.pNext = pNext;
		this.handleTypes = handleTypes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_external_fence_capabilities
typealias VkExternalFenceHandleTypeFlags = VkExternalFenceHandleTypeFlagBits;

[AllowDuplicates] enum VkExternalFenceHandleTypeFlagBits : int32
{
	OpaqueFd = 1 << 0,
	OpaqueWin32 = 1 << 1,
	OpaqueWin32Kmt = 1 << 2,
	SyncFd = 1 << 3,
	OpaqueFdKHR = OpaqueFd,
	OpaqueWin32KHR = OpaqueWin32,
	OpaqueWin32KmtKHR = OpaqueWin32Kmt,
	SyncFdKHR = SyncFd,
}

typealias VkExternalFenceFeatureFlags = VkExternalFenceFeatureFlagBits;

[AllowDuplicates] enum VkExternalFenceFeatureFlagBits : int32
{
	Exportable = 1 << 0,
	Importable = 1 << 1,
	ExportableKHR = Exportable,
	ImportableKHR = Importable,
}

[CRepr] struct VkPhysicalDeviceExternalFenceInfo
{
	public const VkStructureType SType = .VkPhysicalDeviceExternalFenceInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalFenceHandleTypeFlagBits handleType;

	public this(void* pNext, VkExternalFenceHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExternalFenceProperties
{
	public const VkStructureType SType = .VkExternalFenceProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalFenceHandleTypeFlags exportFromImportedHandleTypes;
	public VkExternalFenceHandleTypeFlags compatibleHandleTypes;
	public VkExternalFenceFeatureFlags externalFenceFeatures;
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, out VkExternalFenceProperties pExternalFenceProperties);

// Promoted from VK_KHR_external_fence
typealias VkFenceImportFlags = VkFenceImportFlagBits;

[AllowDuplicates] enum VkFenceImportFlagBits : int32
{
	Temporary = 1 << 0,
	TemporaryKHR = Temporary,
}

[CRepr] struct VkExportFenceCreateInfo
{
	public const VkStructureType SType = .VkExportFenceCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalFenceHandleTypeFlags handleTypes;

	public this(void* pNext = null, VkExternalFenceHandleTypeFlags handleTypes = 0)
	{
		this.pNext = pNext;
		this.handleTypes = handleTypes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_external_semaphore
typealias VkSemaphoreImportFlags = VkSemaphoreImportFlagBits;

[AllowDuplicates] enum VkSemaphoreImportFlagBits : int32
{
	Temporary = 1 << 0,
	TemporaryKHR = Temporary,
}

[CRepr] struct VkExportSemaphoreCreateInfo
{
	public const VkStructureType SType = .VkExportSemaphoreCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalSemaphoreHandleTypeFlags handleTypes;

	public this(void* pNext = null, VkExternalSemaphoreHandleTypeFlags handleTypes = 0)
	{
		this.pNext = pNext;
		this.handleTypes = handleTypes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_external_semaphore_capabilities
typealias VkExternalSemaphoreHandleTypeFlags = VkExternalSemaphoreHandleTypeFlagBits;

[AllowDuplicates] enum VkExternalSemaphoreHandleTypeFlagBits : int32
{
	OpaqueFd = 1 << 0,
	OpaqueWin32 = 1 << 1,
	OpaqueWin32Kmt = 1 << 2,
	D3d12Fence = 1 << 3,
	D3d11Fence = D3d12Fence,
	SyncFd = 1 << 4,
	OpaqueFdKHR = OpaqueFd,
	OpaqueWin32KHR = OpaqueWin32,
	OpaqueWin32KmtKHR = OpaqueWin32Kmt,
	D3d12FenceKHR = D3d12Fence,
	SyncFdKHR = SyncFd,
	ZirconEventFUCHSIA = 1 << 7,
}

typealias VkExternalSemaphoreFeatureFlags = VkExternalSemaphoreFeatureFlagBits;

[AllowDuplicates] enum VkExternalSemaphoreFeatureFlagBits : int32
{
	Exportable = 1 << 0,
	Importable = 1 << 1,
	ExportableKHR = Exportable,
	ImportableKHR = Importable,
}

[CRepr] struct VkPhysicalDeviceExternalSemaphoreInfo
{
	public const VkStructureType SType = .VkPhysicalDeviceExternalSemaphoreInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalSemaphoreHandleTypeFlagBits handleType;

	public this(void* pNext, VkExternalSemaphoreHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExternalSemaphoreProperties
{
	public const VkStructureType SType = .VkExternalSemaphoreProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes;
	public VkExternalSemaphoreHandleTypeFlags compatibleHandleTypes;
	public VkExternalSemaphoreFeatureFlags externalSemaphoreFeatures;
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, out VkExternalSemaphoreProperties pExternalSemaphoreProperties);

// Promoted from VK_KHR_maintenance3
[CRepr] struct VkPhysicalDeviceMaintenance3Properties
{
	public const VkStructureType SType = .VkPhysicalDeviceMaintenance3Properties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxPerSetDescriptors;
	public VkDeviceSize maxMemoryAllocationSize;
}

[CRepr] struct VkDescriptorSetLayoutSupport
{
	public const VkStructureType SType = .VkDescriptorSetLayoutSupport;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 supported;
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDescriptorSetLayoutSupport(VkDevice device, VkDescriptorSetLayoutCreateInfo* pCreateInfo, out VkDescriptorSetLayoutSupport pSupport);

// Promoted from VK_KHR_shader_draw_parameters, with a feature support query added
typealias VkPhysicalDeviceShaderDrawParameterFeatures = VkPhysicalDeviceShaderDrawParametersFeatures;

[CRepr] struct VkPhysicalDeviceShaderDrawParametersFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderDrawParametersFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderDrawParameters;

	public this(void* pNext, VkBool32 shaderDrawParameters)
	{
		this.pNext = pNext;
		this.shaderDrawParameters = shaderDrawParameters;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_API_VERSION_1_2 = VK_MAKE_API_VERSION(0, 1, 2, 0)/* Patch version should always be set to 0 */; }

[CRepr] struct VkPhysicalDeviceVulkan11Features
{
	public const VkStructureType SType = .VkPhysicalDeviceVulkan11Features;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 storageBuffer16BitAccess; // 16-bit integer/floating-point variables supported in BufferBlock
	public VkBool32 uniformAndStorageBuffer16BitAccess; // 16-bit integer/floating-point variables supported in BufferBlock and Block
	public VkBool32 storagePushConstant16; // 16-bit integer/floating-point variables supported in PushConstant
	public VkBool32 storageInputOutput16; // 16-bit integer/floating-point variables supported in shader inputs and outputs
	public VkBool32 multiview; // Multiple views in a render pass
	public VkBool32 multiviewGeometryShader; // Multiple views in a render pass w/ geometry shader
	public VkBool32 multiviewTessellationShader; // Multiple views in a render pass w/ tessellation shader
	public VkBool32 variablePointersStorageBuffer;
	public VkBool32 variablePointers;
	public VkBool32 protectedMemory;
	public VkBool32 samplerYcbcrConversion; // Sampler color conversion supported
	public VkBool32 shaderDrawParameters;

	public this(void* pNext, VkBool32 storageBuffer16BitAccess, VkBool32 uniformAndStorageBuffer16BitAccess, VkBool32 storagePushConstant16, VkBool32 storageInputOutput16, VkBool32 multiview, VkBool32 multiviewGeometryShader, VkBool32 multiviewTessellationShader, VkBool32 variablePointersStorageBuffer, VkBool32 variablePointers, VkBool32 protectedMemory, VkBool32 samplerYcbcrConversion, VkBool32 shaderDrawParameters)
	{
		this.pNext = pNext;
		this.storageBuffer16BitAccess = storageBuffer16BitAccess;
		this.uniformAndStorageBuffer16BitAccess = uniformAndStorageBuffer16BitAccess;
		this.storagePushConstant16 = storagePushConstant16;
		this.storageInputOutput16 = storageInputOutput16;
		this.multiview = multiview;
		this.multiviewGeometryShader = multiviewGeometryShader;
		this.multiviewTessellationShader = multiviewTessellationShader;
		this.variablePointersStorageBuffer = variablePointersStorageBuffer;
		this.variablePointers = variablePointers;
		this.protectedMemory = protectedMemory;
		this.samplerYcbcrConversion = samplerYcbcrConversion;
		this.shaderDrawParameters = shaderDrawParameters;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceVulkan11Properties
{
	public const VkStructureType SType = .VkPhysicalDeviceVulkan11Properties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint8[VK_UUID_SIZE] deviceUUID;
	public uint8[VK_UUID_SIZE] driverUUID;
	public uint8[VK_LUID_SIZE] deviceLUID;
	public uint32 deviceNodeMask;
	public VkBool32 deviceLUIDValid;
	public uint32 subgroupSize; // The size of a subgroup for this queue.
	public VkShaderStageFlags subgroupSupportedStages; // Bitfield of what shader stages support subgroup operations
	public VkSubgroupFeatureFlags subgroupSupportedOperations; // Bitfield of what subgroup operations are supported.
	public VkBool32 subgroupQuadOperationsInAllStages; // Flag to specify whether quad operations are available in all stages.
	public VkPointClippingBehavior pointClippingBehavior;
	public uint32 maxMultiviewViewCount; // max number of views in a subpass
	public uint32 maxMultiviewInstanceIndex; // max instance index for a draw in a multiview subpass
	public VkBool32 protectedNoFault;
	public uint32 maxPerSetDescriptors;
	public VkDeviceSize maxMemoryAllocationSize;
}

[CRepr] struct VkPhysicalDeviceVulkan12Features
{
	public const VkStructureType SType = .VkPhysicalDeviceVulkan12Features;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 samplerMirrorClampToEdge;
	public VkBool32 drawIndirectCount;
	public VkBool32 storageBuffer8BitAccess; // 8-bit integer variables supported in StorageBuffer
	public VkBool32 uniformAndStorageBuffer8BitAccess; // 8-bit integer variables supported in StorageBuffer and Uniform
	public VkBool32 storagePushConstant8; // 8-bit integer variables supported in PushConstant
	public VkBool32 shaderBufferInt64Atomics;
	public VkBool32 shaderSharedInt64Atomics;
	public VkBool32 shaderFloat16; // 16-bit floats (halfs) in shaders
	public VkBool32 shaderInt8; // 8-bit integers in shaders
	public VkBool32 descriptorIndexing;
	public VkBool32 shaderInputAttachmentArrayDynamicIndexing;
	public VkBool32 shaderUniformTexelBufferArrayDynamicIndexing;
	public VkBool32 shaderStorageTexelBufferArrayDynamicIndexing;
	public VkBool32 shaderUniformBufferArrayNonUniformIndexing;
	public VkBool32 shaderSampledImageArrayNonUniformIndexing;
	public VkBool32 shaderStorageBufferArrayNonUniformIndexing;
	public VkBool32 shaderStorageImageArrayNonUniformIndexing;
	public VkBool32 shaderInputAttachmentArrayNonUniformIndexing;
	public VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing;
	public VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing;
	public VkBool32 descriptorBindingUniformBufferUpdateAfterBind;
	public VkBool32 descriptorBindingSampledImageUpdateAfterBind;
	public VkBool32 descriptorBindingStorageImageUpdateAfterBind;
	public VkBool32 descriptorBindingStorageBufferUpdateAfterBind;
	public VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind;
	public VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind;
	public VkBool32 descriptorBindingUpdateUnusedWhilePending;
	public VkBool32 descriptorBindingPartiallyBound;
	public VkBool32 descriptorBindingVariableDescriptorCount;
	public VkBool32 runtimeDescriptorArray;
	public VkBool32 samplerFilterMinmax;
	public VkBool32 scalarBlockLayout;
	public VkBool32 imagelessFramebuffer;
	public VkBool32 uniformBufferStandardLayout;
	public VkBool32 shaderSubgroupExtendedTypes;
	public VkBool32 separateDepthStencilLayouts;
	public VkBool32 hostQueryReset;
	public VkBool32 timelineSemaphore;
	public VkBool32 bufferDeviceAddress;
	public VkBool32 bufferDeviceAddressCaptureReplay;
	public VkBool32 bufferDeviceAddressMultiDevice;
	public VkBool32 vulkanMemoryModel;
	public VkBool32 vulkanMemoryModelDeviceScope;
	public VkBool32 vulkanMemoryModelAvailabilityVisibilityChains;
	public VkBool32 shaderOutputViewportIndex;
	public VkBool32 shaderOutputLayer;
	public VkBool32 subgroupBroadcastDynamicId;

	public this(void* pNext, VkBool32 samplerMirrorClampToEdge, VkBool32 drawIndirectCount, VkBool32 storageBuffer8BitAccess, VkBool32 uniformAndStorageBuffer8BitAccess, VkBool32 storagePushConstant8, VkBool32 shaderBufferInt64Atomics, VkBool32 shaderSharedInt64Atomics, VkBool32 shaderFloat16, VkBool32 shaderInt8, VkBool32 descriptorIndexing, VkBool32 shaderInputAttachmentArrayDynamicIndexing, VkBool32 shaderUniformTexelBufferArrayDynamicIndexing, VkBool32 shaderStorageTexelBufferArrayDynamicIndexing, VkBool32 shaderUniformBufferArrayNonUniformIndexing, VkBool32 shaderSampledImageArrayNonUniformIndexing, VkBool32 shaderStorageBufferArrayNonUniformIndexing, VkBool32 shaderStorageImageArrayNonUniformIndexing, VkBool32 shaderInputAttachmentArrayNonUniformIndexing, VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing, VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing, VkBool32 descriptorBindingUniformBufferUpdateAfterBind, VkBool32 descriptorBindingSampledImageUpdateAfterBind, VkBool32 descriptorBindingStorageImageUpdateAfterBind, VkBool32 descriptorBindingStorageBufferUpdateAfterBind, VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind, VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind, VkBool32 descriptorBindingUpdateUnusedWhilePending, VkBool32 descriptorBindingPartiallyBound, VkBool32 descriptorBindingVariableDescriptorCount, VkBool32 runtimeDescriptorArray, VkBool32 samplerFilterMinmax, VkBool32 scalarBlockLayout, VkBool32 imagelessFramebuffer, VkBool32 uniformBufferStandardLayout, VkBool32 shaderSubgroupExtendedTypes, VkBool32 separateDepthStencilLayouts, VkBool32 hostQueryReset, VkBool32 timelineSemaphore, VkBool32 bufferDeviceAddress, VkBool32 bufferDeviceAddressCaptureReplay, VkBool32 bufferDeviceAddressMultiDevice, VkBool32 vulkanMemoryModel, VkBool32 vulkanMemoryModelDeviceScope, VkBool32 vulkanMemoryModelAvailabilityVisibilityChains, VkBool32 shaderOutputViewportIndex, VkBool32 shaderOutputLayer, VkBool32 subgroupBroadcastDynamicId)
	{
		this.pNext = pNext;
		this.samplerMirrorClampToEdge = samplerMirrorClampToEdge;
		this.drawIndirectCount = drawIndirectCount;
		this.storageBuffer8BitAccess = storageBuffer8BitAccess;
		this.uniformAndStorageBuffer8BitAccess = uniformAndStorageBuffer8BitAccess;
		this.storagePushConstant8 = storagePushConstant8;
		this.shaderBufferInt64Atomics = shaderBufferInt64Atomics;
		this.shaderSharedInt64Atomics = shaderSharedInt64Atomics;
		this.shaderFloat16 = shaderFloat16;
		this.shaderInt8 = shaderInt8;
		this.descriptorIndexing = descriptorIndexing;
		this.shaderInputAttachmentArrayDynamicIndexing = shaderInputAttachmentArrayDynamicIndexing;
		this.shaderUniformTexelBufferArrayDynamicIndexing = shaderUniformTexelBufferArrayDynamicIndexing;
		this.shaderStorageTexelBufferArrayDynamicIndexing = shaderStorageTexelBufferArrayDynamicIndexing;
		this.shaderUniformBufferArrayNonUniformIndexing = shaderUniformBufferArrayNonUniformIndexing;
		this.shaderSampledImageArrayNonUniformIndexing = shaderSampledImageArrayNonUniformIndexing;
		this.shaderStorageBufferArrayNonUniformIndexing = shaderStorageBufferArrayNonUniformIndexing;
		this.shaderStorageImageArrayNonUniformIndexing = shaderStorageImageArrayNonUniformIndexing;
		this.shaderInputAttachmentArrayNonUniformIndexing = shaderInputAttachmentArrayNonUniformIndexing;
		this.shaderUniformTexelBufferArrayNonUniformIndexing = shaderUniformTexelBufferArrayNonUniformIndexing;
		this.shaderStorageTexelBufferArrayNonUniformIndexing = shaderStorageTexelBufferArrayNonUniformIndexing;
		this.descriptorBindingUniformBufferUpdateAfterBind = descriptorBindingUniformBufferUpdateAfterBind;
		this.descriptorBindingSampledImageUpdateAfterBind = descriptorBindingSampledImageUpdateAfterBind;
		this.descriptorBindingStorageImageUpdateAfterBind = descriptorBindingStorageImageUpdateAfterBind;
		this.descriptorBindingStorageBufferUpdateAfterBind = descriptorBindingStorageBufferUpdateAfterBind;
		this.descriptorBindingUniformTexelBufferUpdateAfterBind = descriptorBindingUniformTexelBufferUpdateAfterBind;
		this.descriptorBindingStorageTexelBufferUpdateAfterBind = descriptorBindingStorageTexelBufferUpdateAfterBind;
		this.descriptorBindingUpdateUnusedWhilePending = descriptorBindingUpdateUnusedWhilePending;
		this.descriptorBindingPartiallyBound = descriptorBindingPartiallyBound;
		this.descriptorBindingVariableDescriptorCount = descriptorBindingVariableDescriptorCount;
		this.runtimeDescriptorArray = runtimeDescriptorArray;
		this.samplerFilterMinmax = samplerFilterMinmax;
		this.scalarBlockLayout = scalarBlockLayout;
		this.imagelessFramebuffer = imagelessFramebuffer;
		this.uniformBufferStandardLayout = uniformBufferStandardLayout;
		this.shaderSubgroupExtendedTypes = shaderSubgroupExtendedTypes;
		this.separateDepthStencilLayouts = separateDepthStencilLayouts;
		this.hostQueryReset = hostQueryReset;
		this.timelineSemaphore = timelineSemaphore;
		this.bufferDeviceAddress = bufferDeviceAddress;
		this.bufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay;
		this.bufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice;
		this.vulkanMemoryModel = vulkanMemoryModel;
		this.vulkanMemoryModelDeviceScope = vulkanMemoryModelDeviceScope;
		this.vulkanMemoryModelAvailabilityVisibilityChains = vulkanMemoryModelAvailabilityVisibilityChains;
		this.shaderOutputViewportIndex = shaderOutputViewportIndex;
		this.shaderOutputLayer = shaderOutputLayer;
		this.subgroupBroadcastDynamicId = subgroupBroadcastDynamicId;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceVulkan12Properties
{
	public const VkStructureType SType = .VkPhysicalDeviceVulkan12Properties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDriverId driverID;
	public c_char[VK_MAX_DRIVER_NAME_SIZE] driverName;
	public c_char[VK_MAX_DRIVER_INFO_SIZE] driverInfo;
	public VkConformanceVersion conformanceVersion;
	public VkShaderFloatControlsIndependence denormBehaviorIndependence;
	public VkShaderFloatControlsIndependence roundingModeIndependence;
	public VkBool32 shaderSignedZeroInfNanPreserveFloat16; // An implementation can preserve signed zero, nan, inf
	public VkBool32 shaderSignedZeroInfNanPreserveFloat32; // An implementation can preserve signed zero, nan, inf
	public VkBool32 shaderSignedZeroInfNanPreserveFloat64; // An implementation can preserve signed zero, nan, inf
	public VkBool32 shaderDenormPreserveFloat16; // An implementation can preserve  denormals
	public VkBool32 shaderDenormPreserveFloat32; // An implementation can preserve  denormals
	public VkBool32 shaderDenormPreserveFloat64; // An implementation can preserve  denormals
	public VkBool32 shaderDenormFlushToZeroFloat16; // An implementation can flush to zero  denormals
	public VkBool32 shaderDenormFlushToZeroFloat32; // An implementation can flush to zero  denormals
	public VkBool32 shaderDenormFlushToZeroFloat64; // An implementation can flush to zero  denormals
	public VkBool32 shaderRoundingModeRTEFloat16; // An implementation can support RTE
	public VkBool32 shaderRoundingModeRTEFloat32; // An implementation can support RTE
	public VkBool32 shaderRoundingModeRTEFloat64; // An implementation can support RTE
	public VkBool32 shaderRoundingModeRTZFloat16; // An implementation can support RTZ
	public VkBool32 shaderRoundingModeRTZFloat32; // An implementation can support RTZ
	public VkBool32 shaderRoundingModeRTZFloat64; // An implementation can support RTZ
	public uint32 maxUpdateAfterBindDescriptorsInAllPools;
	public VkBool32 shaderUniformBufferArrayNonUniformIndexingNative;
	public VkBool32 shaderSampledImageArrayNonUniformIndexingNative;
	public VkBool32 shaderStorageBufferArrayNonUniformIndexingNative;
	public VkBool32 shaderStorageImageArrayNonUniformIndexingNative;
	public VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative;
	public VkBool32 robustBufferAccessUpdateAfterBind;
	public VkBool32 quadDivergentImplicitLod;
	public uint32 maxPerStageDescriptorUpdateAfterBindSamplers;
	public uint32 maxPerStageDescriptorUpdateAfterBindUniformBuffers;
	public uint32 maxPerStageDescriptorUpdateAfterBindStorageBuffers;
	public uint32 maxPerStageDescriptorUpdateAfterBindSampledImages;
	public uint32 maxPerStageDescriptorUpdateAfterBindStorageImages;
	public uint32 maxPerStageDescriptorUpdateAfterBindInputAttachments;
	public uint32 maxPerStageUpdateAfterBindResources;
	public uint32 maxDescriptorSetUpdateAfterBindSamplers;
	public uint32 maxDescriptorSetUpdateAfterBindUniformBuffers;
	public uint32 maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
	public uint32 maxDescriptorSetUpdateAfterBindStorageBuffers;
	public uint32 maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
	public uint32 maxDescriptorSetUpdateAfterBindSampledImages;
	public uint32 maxDescriptorSetUpdateAfterBindStorageImages;
	public uint32 maxDescriptorSetUpdateAfterBindInputAttachments;
	public VkResolveModeFlags supportedDepthResolveModes; // supported depth resolve modes
	public VkResolveModeFlags supportedStencilResolveModes; // supported stencil resolve modes
	public VkBool32 independentResolveNone; // depth and stencil resolve modes can be set independently if one of them is none
	public VkBool32 independentResolve; // depth and stencil resolve modes can be set independently
	public VkBool32 filterMinmaxSingleComponentFormats;
	public VkBool32 filterMinmaxImageComponentMapping;
	public uint64 maxTimelineSemaphoreValueDifference;
	public VkSampleCountFlags framebufferIntegerColorSampleCounts;
}

// Promoted from VK_KHR_image_format_list (extension 148)
[CRepr] struct VkImageFormatListCreateInfo
{
	public const VkStructureType SType = .VkImageFormatListCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 viewFormatCount;
	public VkFormat* pViewFormats;
	public VulkanSpan<VkFormat> viewFormats
	{
		[Inline] get => .(viewFormatCount, pViewFormats);
		[Inline] set mut { viewFormatCount = value.count; pViewFormats = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkFormat> viewFormats = .()) : this()
	{
		this.pNext = pNext;
		this.viewFormats = viewFormats;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_sampler_mirror_clamp_to_edge (extension 15)
// Promoted from VK_KHR_draw_indirect_count (extension 170)
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32 maxDrawCount, uint32 stride);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32 maxDrawCount, uint32 stride);

// Promoted from VK_KHR_create_renderpass2 (extension 110)
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateRenderPass2(VkDevice device, VkRenderPassCreateInfo2* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkRenderPass pRenderPass);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBeginRenderPass2(VkCommandBuffer commandBuffer, VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassBeginInfo* pSubpassBeginInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdNextSubpass2(VkCommandBuffer commandBuffer, VkSubpassBeginInfo* pSubpassBeginInfo, VkSubpassEndInfo* pSubpassEndInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdEndRenderPass2(VkCommandBuffer commandBuffer, VkSubpassEndInfo* pSubpassEndInfo);

[CRepr] struct VkRenderPassCreateInfo2
{
	public const VkStructureType SType = .VkRenderPassCreateInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRenderPassCreateFlags flags;
	public uint32 attachmentCount;
	public VkAttachmentDescription2* pAttachments;
	public VulkanSpan<VkAttachmentDescription2> attachments
	{
		[Inline] get => .(attachmentCount, pAttachments);
		[Inline] set mut { attachmentCount = value.count; pAttachments = value.ptr; }
	}
	public uint32 subpassCount;
	public VkSubpassDescription2* pSubpasses;
	public VulkanSpan<VkSubpassDescription2> subpasses
	{
		[Inline] get => .(subpassCount, pSubpasses);
		[Inline] set mut { subpassCount = value.count; pSubpasses = value.ptr; }
	}
	public uint32 dependencyCount;
	public VkSubpassDependency2* pDependencies;
	public VulkanSpan<VkSubpassDependency2> dependencies
	{
		[Inline] get => .(dependencyCount, pDependencies);
		[Inline] set mut { dependencyCount = value.count; pDependencies = value.ptr; }
	}
	public uint32 correlatedViewMaskCount;
	public uint32* pCorrelatedViewMasks;
	public VulkanSpan<uint32> correlatedViewMasks
	{
		[Inline] get => .(correlatedViewMaskCount, pCorrelatedViewMasks);
		[Inline] set mut { correlatedViewMaskCount = value.count; pCorrelatedViewMasks = value.ptr; }
	}

	public this(void* pNext, VkRenderPassCreateFlags flags, VulkanSpan<VkAttachmentDescription2> attachments, VulkanSpan<VkSubpassDescription2> subpasses, VulkanSpan<VkSubpassDependency2> dependencies = .(), VulkanSpan<uint32> correlatedViewMasks = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.attachments = attachments;
		this.subpasses = subpasses;
		this.dependencies = dependencies;
		this.correlatedViewMasks = correlatedViewMasks;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAttachmentDescription2
{
	public const VkStructureType SType = .VkAttachmentDescription2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAttachmentDescriptionFlags flags;
	public VkFormat format;
	public VkSampleCountFlagBits samples;
	public VkAttachmentLoadOp loadOp; // Load operation for color or depth data
	public VkAttachmentStoreOp storeOp; // Store operation for color or depth data
	public VkAttachmentLoadOp stencilLoadOp; // Load operation for stencil data
	public VkAttachmentStoreOp stencilStoreOp; // Store operation for stencil data
	public VkImageLayout initialLayout;
	public VkImageLayout finalLayout;

	public this(void* pNext, VkAttachmentDescriptionFlags flags, VkFormat format, VkSampleCountFlagBits samples, VkAttachmentLoadOp loadOp, VkAttachmentStoreOp storeOp, VkAttachmentLoadOp stencilLoadOp, VkAttachmentStoreOp stencilStoreOp, VkImageLayout initialLayout, VkImageLayout finalLayout)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.format = format;
		this.samples = samples;
		this.loadOp = loadOp;
		this.storeOp = storeOp;
		this.stencilLoadOp = stencilLoadOp;
		this.stencilStoreOp = stencilStoreOp;
		this.initialLayout = initialLayout;
		this.finalLayout = finalLayout;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAttachmentReference2
{
	public const VkStructureType SType = .VkAttachmentReference2;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 attachment;
	public VkImageLayout layout;
	public VkImageAspectFlags aspectMask;

	public this(void* pNext, uint32 attachment, VkImageLayout layout, VkImageAspectFlags aspectMask)
	{
		this.pNext = pNext;
		this.attachment = attachment;
		this.layout = layout;
		this.aspectMask = aspectMask;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSubpassDescription2
{
	public const VkStructureType SType = .VkSubpassDescription2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSubpassDescriptionFlags flags;
	public VkPipelineBindPoint pipelineBindPoint;
	public uint32 viewMask;
	public uint32 inputAttachmentCount;
	public VkAttachmentReference2* pInputAttachments;
	public VulkanSpan<VkAttachmentReference2> inputAttachments
	{
		[Inline] get => .(inputAttachmentCount, pInputAttachments);
		[Inline] set mut { inputAttachmentCount = value.count; pInputAttachments = value.ptr; }
	}
	public uint32 colorAttachmentCount;
	public VkAttachmentReference2* pColorAttachments;
	public VkAttachmentReference2* pResolveAttachments;
	public VulkanDuoSpan<VkAttachmentReference2, VkAttachmentReference2> colorAttachments_resolveAttachments
	{
		[Inline] get => .(colorAttachmentCount, pColorAttachments, pResolveAttachments);
		[Inline] set mut { colorAttachmentCount = value.count; pColorAttachments = value.ptr1; pResolveAttachments = value.ptr2; }
	}
	public VkAttachmentReference2* pDepthStencilAttachment;
	public uint32 preserveAttachmentCount;
	public uint32* pPreserveAttachments;
	public VulkanSpan<uint32> preserveAttachments
	{
		[Inline] get => .(preserveAttachmentCount, pPreserveAttachments);
		[Inline] set mut { preserveAttachmentCount = value.count; pPreserveAttachments = value.ptr; }
	}

	public this(void* pNext, VkSubpassDescriptionFlags flags, VkPipelineBindPoint pipelineBindPoint, uint32 viewMask, VulkanSpan<VkAttachmentReference2> inputAttachments = .(), VulkanDuoSpan<VkAttachmentReference2, VkAttachmentReference2> colorAttachments_resolveAttachments = .(), VkAttachmentReference2* pDepthStencilAttachment = null, VulkanSpan<uint32> preserveAttachments = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.pipelineBindPoint = pipelineBindPoint;
		this.viewMask = viewMask;
		this.inputAttachments = inputAttachments;
		this.colorAttachments_resolveAttachments = colorAttachments_resolveAttachments;
		this.pDepthStencilAttachment = pDepthStencilAttachment;
		this.preserveAttachments = preserveAttachments;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSubpassDependency2
{
	public const VkStructureType SType = .VkSubpassDependency2;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 srcSubpass;
	public uint32 dstSubpass;
	public VkPipelineStageFlags srcStageMask;
	public VkPipelineStageFlags dstStageMask;
	public VkAccessFlags srcAccessMask;
	public VkAccessFlags dstAccessMask;
	public VkDependencyFlags dependencyFlags;
	public int32 viewOffset;

	public this(void* pNext, uint32 srcSubpass, uint32 dstSubpass, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkAccessFlags srcAccessMask, VkAccessFlags dstAccessMask, VkDependencyFlags dependencyFlags, int32 viewOffset)
	{
		this.pNext = pNext;
		this.srcSubpass = srcSubpass;
		this.dstSubpass = dstSubpass;
		this.srcStageMask = srcStageMask;
		this.dstStageMask = dstStageMask;
		this.srcAccessMask = srcAccessMask;
		this.dstAccessMask = dstAccessMask;
		this.dependencyFlags = dependencyFlags;
		this.viewOffset = viewOffset;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSubpassBeginInfo
{
	public const VkStructureType SType = .VkSubpassBeginInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSubpassContents contents;

	public this(void* pNext, VkSubpassContents contents)
	{
		this.pNext = pNext;
		this.contents = contents;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSubpassEndInfo
{
	public const VkStructureType SType = .VkSubpassEndInfo;
	public VkStructureType sType = SType;
	public void* pNext;

	public this(void* pNext = null)
	{
		this.pNext = pNext;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_8bit_storage (extension 178)
[CRepr] struct VkPhysicalDevice8BitStorageFeatures
{
	public const VkStructureType SType = .VkPhysicalDevice8bitStorageFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 storageBuffer8BitAccess; // 8-bit integer variables supported in StorageBuffer
	public VkBool32 uniformAndStorageBuffer8BitAccess; // 8-bit integer variables supported in StorageBuffer and Uniform
	public VkBool32 storagePushConstant8; // 8-bit integer variables supported in PushConstant

	public this(void* pNext, VkBool32 storageBuffer8BitAccess, VkBool32 uniformAndStorageBuffer8BitAccess, VkBool32 storagePushConstant8)
	{
		this.pNext = pNext;
		this.storageBuffer8BitAccess = storageBuffer8BitAccess;
		this.uniformAndStorageBuffer8BitAccess = uniformAndStorageBuffer8BitAccess;
		this.storagePushConstant8 = storagePushConstant8;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_driver_properties (extension 197)
static { public const uint32 VK_MAX_DRIVER_NAME_SIZE = 256; }
static { public const uint32 VK_MAX_DRIVER_INFO_SIZE = 256; }

[AllowDuplicates] enum VkDriverId : int32
{
	AmdProprietary = 1, // Advanced Micro Devices, Inc.
	AmdOpenSource = 2, // Advanced Micro Devices, Inc.
	MesaRadv = 3, // Mesa open source project
	NvidiaProprietary = 4, // NVIDIA Corporation
	IntelProprietaryWindows = 5, // Intel Corporation
	IntelOpenSourceMESA = 6, // Intel Corporation
	ImaginationProprietary = 7, // Imagination Technologies
	QualcommProprietary = 8, // Qualcomm Technologies, Inc.
	ArmProprietary = 9, // Arm Limited
	GoogleSwiftshader = 10, // Google LLC
	GgpProprietary = 11, // Google LLC
	BroadcomProprietary = 12, // Broadcom Inc.
	MesaLlvmpipe = 13, // Mesa
	Moltenvk = 14, // MoltenVK
	CoreaviProprietary = 15, // Core Avionics & Industrial Inc.
	JuiceProprietary = 16, // Juice Technologies, Inc.
	VerisiliconProprietary = 17, // Verisilicon, Inc.
	MesaTurnip = 18, // Mesa open source project
	MesaV3dv = 19, // Mesa open source project
	MesaPanvk = 20, // Mesa open source project
	SamsungProprietary = 21, // Samsung Electronics Co., Ltd.
	MesaVenus = 22, // Mesa open source project
	MesaDozen = 23, // Mesa open source project
	MesaNvk = 24, // Mesa open source project
	ImaginationOpenSourceMESA = 25, // Imagination Technologies
	MesaHoneykrisp = 26, // Mesa open source project
	VulkanScEmulationOnVulkan = 27, // Vulkan SC Emulation on Vulkan
	AmdProprietaryKHR = AmdProprietary,
	AmdOpenSourceKHR = AmdOpenSource,
	MesaRadvKHR = MesaRadv,
	NvidiaProprietaryKHR = NvidiaProprietary,
	IntelProprietaryWindowsKHR = IntelProprietaryWindows,
	IntelOpenSourceMesaKHR = IntelOpenSourceMESA,
	ImaginationProprietaryKHR = ImaginationProprietary,
	QualcommProprietaryKHR = QualcommProprietary,
	ArmProprietaryKHR = ArmProprietary,
	GoogleSwiftshaderKHR = GoogleSwiftshader,
	GgpProprietaryKHR = GgpProprietary,
	BroadcomProprietaryKHR = BroadcomProprietary,
}

[CRepr] struct VkConformanceVersion
{
	public uint8 major;
	public uint8 minor;
	public uint8 subminor;
	public uint8 patch;

	public this(uint8 major, uint8 minor, uint8 subminor, uint8 patch)
	{
		this.major = major;
		this.minor = minor;
		this.subminor = subminor;
		this.patch = patch;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkPhysicalDeviceDriverProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceDriverProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDriverId driverID;
	public c_char[VK_MAX_DRIVER_NAME_SIZE] driverName;
	public c_char[VK_MAX_DRIVER_INFO_SIZE] driverInfo;
	public VkConformanceVersion conformanceVersion;
}

// Promoted from VK_KHR_shader_atomic_int64 (extension 181)
[CRepr] struct VkPhysicalDeviceShaderAtomicInt64Features
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderAtomicInt64Features;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderBufferInt64Atomics;
	public VkBool32 shaderSharedInt64Atomics;

	public this(void* pNext, VkBool32 shaderBufferInt64Atomics, VkBool32 shaderSharedInt64Atomics)
	{
		this.pNext = pNext;
		this.shaderBufferInt64Atomics = shaderBufferInt64Atomics;
		this.shaderSharedInt64Atomics = shaderSharedInt64Atomics;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_shader_float16_int8 (extension 83)
[CRepr] struct VkPhysicalDeviceShaderFloat16Int8Features
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderFloat16Int8Features;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderFloat16; // 16-bit floats (halfs) in shaders
	public VkBool32 shaderInt8; // 8-bit integers in shaders

	public this(void* pNext, VkBool32 shaderFloat16, VkBool32 shaderInt8)
	{
		this.pNext = pNext;
		this.shaderFloat16 = shaderFloat16;
		this.shaderInt8 = shaderInt8;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_shader_float_controls (extension 198)
[CRepr] struct VkPhysicalDeviceFloatControlsProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceFloatControlsProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkShaderFloatControlsIndependence denormBehaviorIndependence;
	public VkShaderFloatControlsIndependence roundingModeIndependence;
	public VkBool32 shaderSignedZeroInfNanPreserveFloat16; // An implementation can preserve signed zero, nan, inf
	public VkBool32 shaderSignedZeroInfNanPreserveFloat32; // An implementation can preserve signed zero, nan, inf
	public VkBool32 shaderSignedZeroInfNanPreserveFloat64; // An implementation can preserve signed zero, nan, inf
	public VkBool32 shaderDenormPreserveFloat16; // An implementation can preserve  denormals
	public VkBool32 shaderDenormPreserveFloat32; // An implementation can preserve  denormals
	public VkBool32 shaderDenormPreserveFloat64; // An implementation can preserve  denormals
	public VkBool32 shaderDenormFlushToZeroFloat16; // An implementation can flush to zero  denormals
	public VkBool32 shaderDenormFlushToZeroFloat32; // An implementation can flush to zero  denormals
	public VkBool32 shaderDenormFlushToZeroFloat64; // An implementation can flush to zero  denormals
	public VkBool32 shaderRoundingModeRTEFloat16; // An implementation can support RTE
	public VkBool32 shaderRoundingModeRTEFloat32; // An implementation can support RTE
	public VkBool32 shaderRoundingModeRTEFloat64; // An implementation can support RTE
	public VkBool32 shaderRoundingModeRTZFloat16; // An implementation can support RTZ
	public VkBool32 shaderRoundingModeRTZFloat32; // An implementation can support RTZ
	public VkBool32 shaderRoundingModeRTZFloat64; // An implementation can support RTZ
}

[AllowDuplicates] enum VkShaderFloatControlsIndependence : int32
{
	VK_32BitOnly = 0,
	All = 1,
	None = 2,
	VK_32BitOnlyKHR = VK_32BitOnly,
	AllKHR = All,
	NoneKHR = None,
}

// Promoted from VK_EXT_descriptor_indexing (extension 162)
[CRepr] struct VkDescriptorSetLayoutBindingFlagsCreateInfo
{
	public const VkStructureType SType = .VkDescriptorSetLayoutBindingFlagsCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 bindingCount;
	public VkDescriptorBindingFlags* pBindingFlags;
	public VulkanSpan<VkDescriptorBindingFlags> bindingFlags
	{
		[Inline] get => .(bindingCount, pBindingFlags);
		[Inline] set mut { bindingCount = value.count; pBindingFlags = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkDescriptorBindingFlags> bindingFlags = .()) : this()
	{
		this.pNext = pNext;
		this.bindingFlags = bindingFlags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceDescriptorIndexingFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceDescriptorIndexingFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderInputAttachmentArrayDynamicIndexing;
	public VkBool32 shaderUniformTexelBufferArrayDynamicIndexing;
	public VkBool32 shaderStorageTexelBufferArrayDynamicIndexing;
	public VkBool32 shaderUniformBufferArrayNonUniformIndexing;
	public VkBool32 shaderSampledImageArrayNonUniformIndexing;
	public VkBool32 shaderStorageBufferArrayNonUniformIndexing;
	public VkBool32 shaderStorageImageArrayNonUniformIndexing;
	public VkBool32 shaderInputAttachmentArrayNonUniformIndexing;
	public VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing;
	public VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing;
	public VkBool32 descriptorBindingUniformBufferUpdateAfterBind;
	public VkBool32 descriptorBindingSampledImageUpdateAfterBind;
	public VkBool32 descriptorBindingStorageImageUpdateAfterBind;
	public VkBool32 descriptorBindingStorageBufferUpdateAfterBind;
	public VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind;
	public VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind;
	public VkBool32 descriptorBindingUpdateUnusedWhilePending;
	public VkBool32 descriptorBindingPartiallyBound;
	public VkBool32 descriptorBindingVariableDescriptorCount;
	public VkBool32 runtimeDescriptorArray;

	public this(void* pNext, VkBool32 shaderInputAttachmentArrayDynamicIndexing, VkBool32 shaderUniformTexelBufferArrayDynamicIndexing, VkBool32 shaderStorageTexelBufferArrayDynamicIndexing, VkBool32 shaderUniformBufferArrayNonUniformIndexing, VkBool32 shaderSampledImageArrayNonUniformIndexing, VkBool32 shaderStorageBufferArrayNonUniformIndexing, VkBool32 shaderStorageImageArrayNonUniformIndexing, VkBool32 shaderInputAttachmentArrayNonUniformIndexing, VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing, VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing, VkBool32 descriptorBindingUniformBufferUpdateAfterBind, VkBool32 descriptorBindingSampledImageUpdateAfterBind, VkBool32 descriptorBindingStorageImageUpdateAfterBind, VkBool32 descriptorBindingStorageBufferUpdateAfterBind, VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind, VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind, VkBool32 descriptorBindingUpdateUnusedWhilePending, VkBool32 descriptorBindingPartiallyBound, VkBool32 descriptorBindingVariableDescriptorCount, VkBool32 runtimeDescriptorArray)
	{
		this.pNext = pNext;
		this.shaderInputAttachmentArrayDynamicIndexing = shaderInputAttachmentArrayDynamicIndexing;
		this.shaderUniformTexelBufferArrayDynamicIndexing = shaderUniformTexelBufferArrayDynamicIndexing;
		this.shaderStorageTexelBufferArrayDynamicIndexing = shaderStorageTexelBufferArrayDynamicIndexing;
		this.shaderUniformBufferArrayNonUniformIndexing = shaderUniformBufferArrayNonUniformIndexing;
		this.shaderSampledImageArrayNonUniformIndexing = shaderSampledImageArrayNonUniformIndexing;
		this.shaderStorageBufferArrayNonUniformIndexing = shaderStorageBufferArrayNonUniformIndexing;
		this.shaderStorageImageArrayNonUniformIndexing = shaderStorageImageArrayNonUniformIndexing;
		this.shaderInputAttachmentArrayNonUniformIndexing = shaderInputAttachmentArrayNonUniformIndexing;
		this.shaderUniformTexelBufferArrayNonUniformIndexing = shaderUniformTexelBufferArrayNonUniformIndexing;
		this.shaderStorageTexelBufferArrayNonUniformIndexing = shaderStorageTexelBufferArrayNonUniformIndexing;
		this.descriptorBindingUniformBufferUpdateAfterBind = descriptorBindingUniformBufferUpdateAfterBind;
		this.descriptorBindingSampledImageUpdateAfterBind = descriptorBindingSampledImageUpdateAfterBind;
		this.descriptorBindingStorageImageUpdateAfterBind = descriptorBindingStorageImageUpdateAfterBind;
		this.descriptorBindingStorageBufferUpdateAfterBind = descriptorBindingStorageBufferUpdateAfterBind;
		this.descriptorBindingUniformTexelBufferUpdateAfterBind = descriptorBindingUniformTexelBufferUpdateAfterBind;
		this.descriptorBindingStorageTexelBufferUpdateAfterBind = descriptorBindingStorageTexelBufferUpdateAfterBind;
		this.descriptorBindingUpdateUnusedWhilePending = descriptorBindingUpdateUnusedWhilePending;
		this.descriptorBindingPartiallyBound = descriptorBindingPartiallyBound;
		this.descriptorBindingVariableDescriptorCount = descriptorBindingVariableDescriptorCount;
		this.runtimeDescriptorArray = runtimeDescriptorArray;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceDescriptorIndexingProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceDescriptorIndexingProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxUpdateAfterBindDescriptorsInAllPools;
	public VkBool32 shaderUniformBufferArrayNonUniformIndexingNative;
	public VkBool32 shaderSampledImageArrayNonUniformIndexingNative;
	public VkBool32 shaderStorageBufferArrayNonUniformIndexingNative;
	public VkBool32 shaderStorageImageArrayNonUniformIndexingNative;
	public VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative;
	public VkBool32 robustBufferAccessUpdateAfterBind;
	public VkBool32 quadDivergentImplicitLod;
	public uint32 maxPerStageDescriptorUpdateAfterBindSamplers;
	public uint32 maxPerStageDescriptorUpdateAfterBindUniformBuffers;
	public uint32 maxPerStageDescriptorUpdateAfterBindStorageBuffers;
	public uint32 maxPerStageDescriptorUpdateAfterBindSampledImages;
	public uint32 maxPerStageDescriptorUpdateAfterBindStorageImages;
	public uint32 maxPerStageDescriptorUpdateAfterBindInputAttachments;
	public uint32 maxPerStageUpdateAfterBindResources;
	public uint32 maxDescriptorSetUpdateAfterBindSamplers;
	public uint32 maxDescriptorSetUpdateAfterBindUniformBuffers;
	public uint32 maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
	public uint32 maxDescriptorSetUpdateAfterBindStorageBuffers;
	public uint32 maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
	public uint32 maxDescriptorSetUpdateAfterBindSampledImages;
	public uint32 maxDescriptorSetUpdateAfterBindStorageImages;
	public uint32 maxDescriptorSetUpdateAfterBindInputAttachments;
}

[CRepr] struct VkDescriptorSetVariableDescriptorCountAllocateInfo
{
	public const VkStructureType SType = .VkDescriptorSetVariableDescriptorCountAllocateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 descriptorSetCount;
	public uint32* pDescriptorCounts;
	public VulkanSpan<uint32> descriptorCounts
	{
		[Inline] get => .(descriptorSetCount, pDescriptorCounts);
		[Inline] set mut { descriptorSetCount = value.count; pDescriptorCounts = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<uint32> descriptorCounts = .()) : this()
	{
		this.pNext = pNext;
		this.descriptorCounts = descriptorCounts;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDescriptorSetVariableDescriptorCountLayoutSupport
{
	public const VkStructureType SType = .VkDescriptorSetVariableDescriptorCountLayoutSupport;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxVariableDescriptorCount;
}

[AllowDuplicates] enum VkDescriptorBindingFlagBits : int32
{
	UpdateAfterBind = 1 << 0,
	UpdateUnusedWhilePending = 1 << 1,
	PartiallyBound = 1 << 2,
	VariableDescriptorCount = 1 << 3,
	UpdateAfterBindEXT = UpdateAfterBind,
	UpdateUnusedWhilePendingEXT = UpdateUnusedWhilePending,
	PartiallyBoundEXT = PartiallyBound,
	VariableDescriptorCountEXT = VariableDescriptorCount,
}

typealias VkDescriptorBindingFlags = VkDescriptorBindingFlagBits;

// Promoted from VK_KHR_depth_stencil_resolve (extension 200)
[CRepr] struct VkSubpassDescriptionDepthStencilResolve
{
	public const VkStructureType SType = .VkSubpassDescriptionDepthStencilResolve;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkResolveModeFlagBits depthResolveMode; // depth resolve mode
	public VkResolveModeFlagBits stencilResolveMode; // stencil resolve mode
	public VkAttachmentReference2* pDepthStencilResolveAttachment; // depth/stencil resolve attachment

	public this(void* pNext, VkResolveModeFlagBits depthResolveMode, VkResolveModeFlagBits stencilResolveMode, VkAttachmentReference2* pDepthStencilResolveAttachment = null)
	{
		this.pNext = pNext;
		this.depthResolveMode = depthResolveMode;
		this.stencilResolveMode = stencilResolveMode;
		this.pDepthStencilResolveAttachment = pDepthStencilResolveAttachment;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceDepthStencilResolveProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceDepthStencilResolveProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkResolveModeFlags supportedDepthResolveModes; // supported depth resolve modes
	public VkResolveModeFlags supportedStencilResolveModes; // supported stencil resolve modes
	public VkBool32 independentResolveNone; // depth and stencil resolve modes can be set independently if one of them is none
	public VkBool32 independentResolve; // depth and stencil resolve modes can be set independently
}

[AllowDuplicates] enum VkResolveModeFlagBits : int32
{
	None = 0,
	SampleZero = 1 << 0,
	Average = 1 << 1,
	Min = 1 << 2,
	Max = 1 << 3,
	NoneKHR = None,
	SampleZeroKHR = SampleZero,
	AverageKHR = Average,
	MinKHR = Min,
	MaxKHR = Max,
	ExternalFormatDownsampleANDROID = 1 << 4,
}

typealias VkResolveModeFlags = VkResolveModeFlagBits;

// Promoted from VK_EXT_scalar_block_layout (extension 222))
[CRepr] struct VkPhysicalDeviceScalarBlockLayoutFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceScalarBlockLayoutFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 scalarBlockLayout;

	public this(void* pNext, VkBool32 scalarBlockLayout)
	{
		this.pNext = pNext;
		this.scalarBlockLayout = scalarBlockLayout;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_EXT_shader_viewport_index_layer, which has no API (extension 163)
// Promoted from VK_EXT_separate_stencil_usage (extension 247)
[CRepr] struct VkImageStencilUsageCreateInfo
{
	public const VkStructureType SType = .VkImageStencilUsageCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageUsageFlags stencilUsage;

	public this(void* pNext, VkImageUsageFlags stencilUsage)
	{
		this.pNext = pNext;
		this.stencilUsage = stencilUsage;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_EXT_sampler_filter_minmax (extension 131)
[AllowDuplicates] enum VkSamplerReductionMode : int32
{
	WeightedAverage = 0,
	Min = 1,
	Max = 2,
	WeightedAverageEXT = WeightedAverage,
	MinEXT = Min,
	MaxEXT = Max,
	WeightedAverageRangeclampQCOM = 1000521000,
}

[CRepr] struct VkSamplerReductionModeCreateInfo
{
	public const VkStructureType SType = .VkSamplerReductionModeCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkSamplerReductionMode reductionMode;

	public this(void* pNext, VkSamplerReductionMode reductionMode)
	{
		this.pNext = pNext;
		this.reductionMode = reductionMode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceSamplerFilterMinmaxProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceSamplerFilterMinmaxProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 filterMinmaxSingleComponentFormats;
	public VkBool32 filterMinmaxImageComponentMapping;
}

// Promoted from VK_KHR_vulkan_memory_model (extension 212)
[CRepr] struct VkPhysicalDeviceVulkanMemoryModelFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceVulkanMemoryModelFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 vulkanMemoryModel;
	public VkBool32 vulkanMemoryModelDeviceScope;
	public VkBool32 vulkanMemoryModelAvailabilityVisibilityChains;

	public this(void* pNext, VkBool32 vulkanMemoryModel, VkBool32 vulkanMemoryModelDeviceScope, VkBool32 vulkanMemoryModelAvailabilityVisibilityChains)
	{
		this.pNext = pNext;
		this.vulkanMemoryModel = vulkanMemoryModel;
		this.vulkanMemoryModelDeviceScope = vulkanMemoryModelDeviceScope;
		this.vulkanMemoryModelAvailabilityVisibilityChains = vulkanMemoryModelAvailabilityVisibilityChains;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_imageless_framebuffer (extension 109)
[CRepr] struct VkPhysicalDeviceImagelessFramebufferFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceImagelessFramebufferFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 imagelessFramebuffer;

	public this(void* pNext, VkBool32 imagelessFramebuffer)
	{
		this.pNext = pNext;
		this.imagelessFramebuffer = imagelessFramebuffer;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkFramebufferAttachmentsCreateInfo
{
	public const VkStructureType SType = .VkFramebufferAttachmentsCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 attachmentImageInfoCount;
	public VkFramebufferAttachmentImageInfo* pAttachmentImageInfos;
	public VulkanSpan<VkFramebufferAttachmentImageInfo> attachmentImageInfos
	{
		[Inline] get => .(attachmentImageInfoCount, pAttachmentImageInfos);
		[Inline] set mut { attachmentImageInfoCount = value.count; pAttachmentImageInfos = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkFramebufferAttachmentImageInfo> attachmentImageInfos = .()) : this()
	{
		this.pNext = pNext;
		this.attachmentImageInfos = attachmentImageInfos;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkFramebufferAttachmentImageInfo
{
	public const VkStructureType SType = .VkFramebufferAttachmentImageInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageCreateFlags flags; // Image creation flags
	public VkImageUsageFlags usage; // Image usage flags
	public uint32 width;
	public uint32 height;
	public uint32 layerCount;
	public uint32 viewFormatCount;
	public VkFormat* pViewFormats;
	public VulkanSpan<VkFormat> viewFormats
	{
		[Inline] get => .(viewFormatCount, pViewFormats);
		[Inline] set mut { viewFormatCount = value.count; pViewFormats = value.ptr; }
	}

	public this(void* pNext, VkImageCreateFlags flags, VkImageUsageFlags usage, uint32 width, uint32 height, uint32 layerCount, VulkanSpan<VkFormat> viewFormats = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.usage = usage;
		this.width = width;
		this.height = height;
		this.layerCount = layerCount;
		this.viewFormats = viewFormats;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkRenderPassAttachmentBeginInfo
{
	public const VkStructureType SType = .VkRenderPassAttachmentBeginInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 attachmentCount;
	public VkImageView* pAttachments;
	public VulkanSpan<VkImageView> attachments
	{
		[Inline] get => .(attachmentCount, pAttachments);
		[Inline] set mut { attachmentCount = value.count; pAttachments = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkImageView> attachments = .()) : this()
	{
		this.pNext = pNext;
		this.attachments = attachments;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_uniform_buffer_standard_layout (extension 254)
[CRepr] struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceUniformBufferStandardLayoutFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 uniformBufferStandardLayout;

	public this(void* pNext, VkBool32 uniformBufferStandardLayout)
	{
		this.pNext = pNext;
		this.uniformBufferStandardLayout = uniformBufferStandardLayout;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_shader_subgroup_extended_types (extension 176)
[CRepr] struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderSubgroupExtendedTypes; // Flag to specify whether subgroup operations with extended types are supported

	public this(void* pNext, VkBool32 shaderSubgroupExtendedTypes)
	{
		this.pNext = pNext;
		this.shaderSubgroupExtendedTypes = shaderSubgroupExtendedTypes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_spirv_1_4 (extension 237)
// Promoted from VK_KHR_separate_depth_stencil_layouts (extension 242)
[CRepr] struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 separateDepthStencilLayouts;

	public this(void* pNext, VkBool32 separateDepthStencilLayouts)
	{
		this.pNext = pNext;
		this.separateDepthStencilLayouts = separateDepthStencilLayouts;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAttachmentReferenceStencilLayout
{
	public const VkStructureType SType = .VkAttachmentReferenceStencilLayout;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageLayout stencilLayout;

	public this(void* pNext, VkImageLayout stencilLayout)
	{
		this.pNext = pNext;
		this.stencilLayout = stencilLayout;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAttachmentDescriptionStencilLayout
{
	public const VkStructureType SType = .VkAttachmentDescriptionStencilLayout;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageLayout stencilInitialLayout;
	public VkImageLayout stencilFinalLayout;

	public this(void* pNext, VkImageLayout stencilInitialLayout, VkImageLayout stencilFinalLayout)
	{
		this.pNext = pNext;
		this.stencilInitialLayout = stencilInitialLayout;
		this.stencilFinalLayout = stencilFinalLayout;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_EXT_host_query_reset (extension 262)
[CRepr] struct VkPhysicalDeviceHostQueryResetFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceHostQueryResetFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 hostQueryReset;

	public this(void* pNext, VkBool32 hostQueryReset)
	{
		this.pNext = pNext;
		this.hostQueryReset = hostQueryReset;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32 firstQuery, uint32 queryCount);

// Promoted from VK_KHR_timeline_semaphore (extension 208)
[AllowDuplicates] enum VkSemaphoreType : int32
{
	Binary = 0,
	Timeline = 1,
	BinaryKHR = Binary,
	TimelineKHR = Timeline,
}

[CRepr] struct VkPhysicalDeviceTimelineSemaphoreFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceTimelineSemaphoreFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 timelineSemaphore;

	public this(void* pNext, VkBool32 timelineSemaphore)
	{
		this.pNext = pNext;
		this.timelineSemaphore = timelineSemaphore;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceTimelineSemaphoreProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceTimelineSemaphoreProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 maxTimelineSemaphoreValueDifference;
}

[CRepr] struct VkSemaphoreTypeCreateInfo
{
	public const VkStructureType SType = .VkSemaphoreTypeCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSemaphoreType semaphoreType;
	public uint64 initialValue;

	public this(void* pNext, VkSemaphoreType semaphoreType, uint64 initialValue)
	{
		this.pNext = pNext;
		this.semaphoreType = semaphoreType;
		this.initialValue = initialValue;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkTimelineSemaphoreSubmitInfo
{
	public const VkStructureType SType = .VkTimelineSemaphoreSubmitInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 waitSemaphoreValueCount;
	public uint64* pWaitSemaphoreValues;
	public VulkanSpan<uint64> waitSemaphoreValues
	{
		[Inline] get => .(waitSemaphoreValueCount, pWaitSemaphoreValues);
		[Inline] set mut { waitSemaphoreValueCount = value.count; pWaitSemaphoreValues = value.ptr; }
	}
	public uint32 signalSemaphoreValueCount;
	public uint64* pSignalSemaphoreValues;
	public VulkanSpan<uint64> signalSemaphoreValues
	{
		[Inline] get => .(signalSemaphoreValueCount, pSignalSemaphoreValues);
		[Inline] set mut { signalSemaphoreValueCount = value.count; pSignalSemaphoreValues = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<uint64> waitSemaphoreValues = .(), VulkanSpan<uint64> signalSemaphoreValues = .()) : this()
	{
		this.pNext = pNext;
		this.waitSemaphoreValues = waitSemaphoreValues;
		this.signalSemaphoreValues = signalSemaphoreValues;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkSemaphoreWaitFlagBits : int32
{
	Any = 1 << 0,
	AnyKHR = Any,
}

typealias VkSemaphoreWaitFlags = VkSemaphoreWaitFlagBits;

[CRepr] struct VkSemaphoreWaitInfo
{
	public const VkStructureType SType = .VkSemaphoreWaitInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSemaphoreWaitFlags flags;
	public uint32 semaphoreCount;
	public VkSemaphore* pSemaphores;
	public uint64* pValues;
	public VulkanDuoSpan<VkSemaphore, uint64> semaphores_values
	{
		[Inline] get => .(semaphoreCount, pSemaphores, pValues);
		[Inline] set mut { semaphoreCount = value.count; pSemaphores = value.ptr1; pValues = value.ptr2; }
	}

	public this(void* pNext, VkSemaphoreWaitFlags flags, VulkanDuoSpan<VkSemaphore, uint64> semaphores_values) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.semaphores_values = semaphores_values;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSemaphoreSignalInfo
{
	public const VkStructureType SType = .VkSemaphoreSignalInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSemaphore semaphore;
	public uint64 value;

	public this(void* pNext, VkSemaphore semaphore, uint64 value)
	{
		this.pNext = pNext;
		this.semaphore = semaphore;
		this.value = value;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, out uint64 pValue);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkWaitSemaphores(VkDevice device, VkSemaphoreWaitInfo* pWaitInfo, uint64 timeout);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkSignalSemaphore(VkDevice device, VkSemaphoreSignalInfo* pSignalInfo);

// Promoted from VK_KHR_buffer_device_address (extension 258)
[CRepr] struct VkPhysicalDeviceBufferDeviceAddressFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceBufferDeviceAddressFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 bufferDeviceAddress;
	public VkBool32 bufferDeviceAddressCaptureReplay;
	public VkBool32 bufferDeviceAddressMultiDevice;

	public this(void* pNext, VkBool32 bufferDeviceAddress, VkBool32 bufferDeviceAddressCaptureReplay, VkBool32 bufferDeviceAddressMultiDevice)
	{
		this.pNext = pNext;
		this.bufferDeviceAddress = bufferDeviceAddress;
		this.bufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay;
		this.bufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBufferDeviceAddressInfo
{
	public const VkStructureType SType = .VkBufferDeviceAddressInfo;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkBuffer buffer;

	public this(void* pNext, VkBuffer buffer)
	{
		this.pNext = pNext;
		this.buffer = buffer;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBufferOpaqueCaptureAddressCreateInfo
{
	public const VkStructureType SType = .VkBufferOpaqueCaptureAddressCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 opaqueCaptureAddress;

	public this(void* pNext, uint64 opaqueCaptureAddress)
	{
		this.pNext = pNext;
		this.opaqueCaptureAddress = opaqueCaptureAddress;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryOpaqueCaptureAddressAllocateInfo
{
	public const VkStructureType SType = .VkMemoryOpaqueCaptureAddressAllocateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 opaqueCaptureAddress;

	public this(void* pNext, uint64 opaqueCaptureAddress)
	{
		this.pNext = pNext;
		this.opaqueCaptureAddress = opaqueCaptureAddress;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceMemoryOpaqueCaptureAddressInfo
{
	public const VkStructureType SType = .VkDeviceMemoryOpaqueCaptureAddressInfo;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkDeviceMemory memory;

	public this(void* pNext, VkDeviceMemory memory)
	{
		this.pNext = pNext;
		this.memory = memory;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkDeviceAddress PFN_vkGetBufferDeviceAddress(VkDevice device, VkBufferDeviceAddressInfo* pInfo);
[CallingConvention(VKAPI_PTR)] function uint64 PFN_vkGetBufferOpaqueCaptureAddress(VkDevice device, VkBufferDeviceAddressInfo* pInfo);
[CallingConvention(VKAPI_PTR)] function uint64 PFN_vkGetDeviceMemoryOpaqueCaptureAddress(VkDevice device, VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo);

static { public const uint32 VK_API_VERSION_1_3 = VK_MAKE_API_VERSION(0, 1, 3, 0)/* Patch version should always be set to 0 */; }

[CRepr] struct VkPhysicalDeviceVulkan13Features
{
	public const VkStructureType SType = .VkPhysicalDeviceVulkan13Features;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 robustImageAccess;
	public VkBool32 inlineUniformBlock;
	public VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind;
	public VkBool32 pipelineCreationCacheControl;
	public VkBool32 privateData;
	public VkBool32 shaderDemoteToHelperInvocation;
	public VkBool32 shaderTerminateInvocation;
	public VkBool32 subgroupSizeControl;
	public VkBool32 computeFullSubgroups;
	public VkBool32 synchronization2;
	public VkBool32 textureCompressionASTC_HDR;
	public VkBool32 shaderZeroInitializeWorkgroupMemory;
	public VkBool32 dynamicRendering;
	public VkBool32 shaderIntegerDotProduct;
	public VkBool32 maintenance4;

	public this(void* pNext, VkBool32 robustImageAccess, VkBool32 inlineUniformBlock, VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind, VkBool32 pipelineCreationCacheControl, VkBool32 privateData, VkBool32 shaderDemoteToHelperInvocation, VkBool32 shaderTerminateInvocation, VkBool32 subgroupSizeControl, VkBool32 computeFullSubgroups, VkBool32 synchronization2, VkBool32 textureCompressionASTC_HDR, VkBool32 shaderZeroInitializeWorkgroupMemory, VkBool32 dynamicRendering, VkBool32 shaderIntegerDotProduct, VkBool32 maintenance4)
	{
		this.pNext = pNext;
		this.robustImageAccess = robustImageAccess;
		this.inlineUniformBlock = inlineUniformBlock;
		this.descriptorBindingInlineUniformBlockUpdateAfterBind = descriptorBindingInlineUniformBlockUpdateAfterBind;
		this.pipelineCreationCacheControl = pipelineCreationCacheControl;
		this.privateData = privateData;
		this.shaderDemoteToHelperInvocation = shaderDemoteToHelperInvocation;
		this.shaderTerminateInvocation = shaderTerminateInvocation;
		this.subgroupSizeControl = subgroupSizeControl;
		this.computeFullSubgroups = computeFullSubgroups;
		this.synchronization2 = synchronization2;
		this.textureCompressionASTC_HDR = textureCompressionASTC_HDR;
		this.shaderZeroInitializeWorkgroupMemory = shaderZeroInitializeWorkgroupMemory;
		this.dynamicRendering = dynamicRendering;
		this.shaderIntegerDotProduct = shaderIntegerDotProduct;
		this.maintenance4 = maintenance4;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceVulkan13Properties
{
	public const VkStructureType SType = .VkPhysicalDeviceVulkan13Properties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 minSubgroupSize; // The minimum subgroup size supported by this device
	public uint32 maxSubgroupSize; // The maximum subgroup size supported by this device
	public uint32 maxComputeWorkgroupSubgroups; // The maximum number of subgroups supported in a workgroup
	public VkShaderStageFlags requiredSubgroupSizeStages; // The shader stages that support specifying a subgroup size
	public uint32 maxInlineUniformBlockSize;
	public uint32 maxPerStageDescriptorInlineUniformBlocks;
	public uint32 maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
	public uint32 maxDescriptorSetInlineUniformBlocks;
	public uint32 maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
	public uint32 maxInlineUniformTotalSize;
	public VkBool32 integerDotProduct8BitUnsignedAccelerated;
	public VkBool32 integerDotProduct8BitSignedAccelerated;
	public VkBool32 integerDotProduct8BitMixedSignednessAccelerated;
	public VkBool32 integerDotProduct4x8BitPackedUnsignedAccelerated;
	public VkBool32 integerDotProduct4x8BitPackedSignedAccelerated;
	public VkBool32 integerDotProduct4x8BitPackedMixedSignednessAccelerated;
	public VkBool32 integerDotProduct16BitUnsignedAccelerated;
	public VkBool32 integerDotProduct16BitSignedAccelerated;
	public VkBool32 integerDotProduct16BitMixedSignednessAccelerated;
	public VkBool32 integerDotProduct32BitUnsignedAccelerated;
	public VkBool32 integerDotProduct32BitSignedAccelerated;
	public VkBool32 integerDotProduct32BitMixedSignednessAccelerated;
	public VkBool32 integerDotProduct64BitUnsignedAccelerated;
	public VkBool32 integerDotProduct64BitSignedAccelerated;
	public VkBool32 integerDotProduct64BitMixedSignednessAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating8BitSignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating16BitSignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating32BitSignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating64BitSignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
	public VkDeviceSize storageTexelBufferOffsetAlignmentBytes;
	public VkBool32 storageTexelBufferOffsetSingleTexelAlignment;
	public VkDeviceSize uniformTexelBufferOffsetAlignmentBytes;
	public VkBool32 uniformTexelBufferOffsetSingleTexelAlignment;
	public VkDeviceSize maxBufferSize;
}

// Promoted from VK_EXT_pipeline_creation_feedback (extension 193)
[AllowDuplicates] enum VkPipelineCreationFeedbackFlagBits : int32
{
	Valid = 1 << 0,
	ApplicationPipelineCacheHit = 1 << 1,
	BasePipelineAcceleration = 1 << 2,
	ValidEXT = Valid,
	ApplicationPipelineCacheHitEXT = ApplicationPipelineCacheHit,
	BasePipelineAccelerationEXT = BasePipelineAcceleration,
}

typealias VkPipelineCreationFeedbackFlags = VkPipelineCreationFeedbackFlagBits;

[CRepr] struct VkPipelineCreationFeedbackCreateInfo
{
	public const VkStructureType SType = .VkPipelineCreationFeedbackCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineCreationFeedback* pPipelineCreationFeedback; // Output pipeline creation feedback.
	public uint32 pipelineStageCreationFeedbackCount;
	public VkPipelineCreationFeedback* pPipelineStageCreationFeedbacks; // One entry for each shader stage specified in the parent Vk*PipelineCreateInfo struct
	public VulkanSpan<VkPipelineCreationFeedback> pipelineStageCreationFeedbacks
	{
		[Inline] get => .(pipelineStageCreationFeedbackCount, pPipelineStageCreationFeedbacks);
		[Inline] set mut { pipelineStageCreationFeedbackCount = value.count; pPipelineStageCreationFeedbacks = value.ptr; }
	} // One entry for each shader stage specified in the parent Vk*PipelineCreateInfo struct

	public this(void* pNext, VkPipelineCreationFeedback* pPipelineCreationFeedback, VulkanSpan<VkPipelineCreationFeedback> pipelineStageCreationFeedbacks = .()) : this()
	{
		this.pNext = pNext;
		this.pPipelineCreationFeedback = pPipelineCreationFeedback;
		this.pipelineStageCreationFeedbacks = pipelineStageCreationFeedbacks;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineCreationFeedback
{
	public VkPipelineCreationFeedbackFlags flags;
	public uint64 duration;
}

// Promoted from VK_KHR_shader_terminate_invocation (extension 216)
[CRepr] struct VkPhysicalDeviceShaderTerminateInvocationFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderTerminateInvocationFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderTerminateInvocation;

	public this(void* pNext, VkBool32 shaderTerminateInvocation)
	{
		this.pNext = pNext;
		this.shaderTerminateInvocation = shaderTerminateInvocation;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_EXT_tooling_info (extension 246)
[AllowDuplicates] enum VkToolPurposeFlagBits : int32
{
	Validation = 1 << 0,
	Profiling = 1 << 1,
	Tracing = 1 << 2,
	AdditionalFeatures = 1 << 3,
	ModifyingFeatures = 1 << 4,
	ValidationEXT = Validation,
	ProfilingEXT = Profiling,
	TracingEXT = Tracing,
	AdditionalFeaturesEXT = AdditionalFeatures,
	ModifyingFeaturesEXT = ModifyingFeatures,
	DebugReportingEXT = 1 << 5,
	DebugMarkersEXT = 1 << 6,
}

typealias VkToolPurposeFlags = VkToolPurposeFlagBits;

[CRepr] struct VkPhysicalDeviceToolProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceToolProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_char[VK_MAX_EXTENSION_NAME_SIZE] name;
	public c_char[VK_MAX_EXTENSION_NAME_SIZE] version;
	public VkToolPurposeFlags purposes;
	public c_char[VK_MAX_DESCRIPTION_SIZE] description;
	public c_char[VK_MAX_EXTENSION_NAME_SIZE] layer;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, out uint32 pToolCount, VkPhysicalDeviceToolProperties* pToolProperties = null);

// Promoted from VK_EXT_shader_demote_to_helper_invocation (extension 277)
[CRepr] struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderDemoteToHelperInvocation;

	public this(void* pNext, VkBool32 shaderDemoteToHelperInvocation)
	{
		this.pNext = pNext;
		this.shaderDemoteToHelperInvocation = shaderDemoteToHelperInvocation;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_shader_non_semantic_info (extension 294)
// Promoted from VK_EXT_private_data (extension 296)
[CRepr] struct VkPhysicalDevicePrivateDataFeatures
{
	public const VkStructureType SType = .VkPhysicalDevicePrivateDataFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 privateData;

	public this(void* pNext, VkBool32 privateData)
	{
		this.pNext = pNext;
		this.privateData = privateData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDevicePrivateDataCreateInfo
{
	public const VkStructureType SType = .VkDevicePrivateDataCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 privateDataSlotRequestCount;

	public this(void* pNext, uint32 privateDataSlotRequestCount)
	{
		this.pNext = pNext;
		this.privateDataSlotRequestCount = privateDataSlotRequestCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPrivateDataSlotCreateInfo
{
	public const VkStructureType SType = .VkPrivateDataSlotCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPrivateDataSlotCreateFlags flags;

	public this(void* pNext, VkPrivateDataSlotCreateFlags flags)
	{
		this.pNext = pNext;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

class VkPrivateDataSlot { private this() { } }

typealias VkPrivateDataSlotCreateFlags = VkFlags;

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreatePrivateDataSlot(VkDevice device, VkPrivateDataSlotCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkPrivateDataSlot pPrivateDataSlot);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkSetPrivateData(VkDevice device, VkObjectType objectType, uint64 objectHandle, VkPrivateDataSlot privateDataSlot, uint64 data);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPrivateData(VkDevice device, VkObjectType objectType, uint64 objectHandle, VkPrivateDataSlot privateDataSlot, out uint64 pData);

// Promoted from VK_EXT_pipeline_creation_cache_control (extension 298)
[CRepr] struct VkPhysicalDevicePipelineCreationCacheControlFeatures
{
	public const VkStructureType SType = .VkPhysicalDevicePipelineCreationCacheControlFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 pipelineCreationCacheControl;

	public this(void* pNext, VkBool32 pipelineCreationCacheControl)
	{
		this.pNext = pNext;
		this.pipelineCreationCacheControl = pipelineCreationCacheControl;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_synchronization2 (extension 315)
typealias VkPipelineStageFlags2 = VkPipelineStageFlagBits2;

[AllowDuplicates] enum VkPipelineStageFlagBits2 : int64
{
	None = 0,
	TopOfPipe = 1 << 0,
	DrawIndirect = 1 << 1,
	VertexInput = 1 << 2,
	VertexShader = 1 << 3,
	TessellationControlShader = 1 << 4,
	TessellationEvaluationShader = 1 << 5,
	GeometryShader = 1 << 6,
	FragmentShader = 1 << 7,
	EarlyFragmentTests = 1 << 8,
	LateFragmentTests = 1 << 9,
	ColorAttachmentOutput = 1 << 10,
	ComputeShader = 1 << 11,
	AllTransfer = 1 << 12,
	Transfer = AllTransfer,
	BottomOfPipe = 1 << 13,
	Host = 1 << 14,
	AllGraphics = 1 << 15,
	AllCommands = 1 << 16,
	Copy = 1 << 32,
	Resolve = 1 << 33,
	Blit = 1 << 34,
	Clear = 1 << 35,
	IndexInput = 1 << 36,
	VertexAttributeInput = 1 << 37,
	PreRasterizationShaders = 1 << 38,
	VideoDecodeKHR = 1 << 26,
	VideoEncodeKHR = 1 << 27,
	NoneKHR = None,
	TopOfPipeKHR = TopOfPipe,
	DrawIndirectKHR = DrawIndirect,
	VertexInputKHR = VertexInput,
	VertexShaderKHR = VertexShader,
	TessellationControlShaderKHR = TessellationControlShader,
	TessellationEvaluationShaderKHR = TessellationEvaluationShader,
	GeometryShaderKHR = GeometryShader,
	FragmentShaderKHR = FragmentShader,
	EarlyFragmentTestsKHR = EarlyFragmentTests,
	LateFragmentTestsKHR = LateFragmentTests,
	ColorAttachmentOutputKHR = ColorAttachmentOutput,
	ComputeShaderKHR = ComputeShader,
	AllTransferKHR = AllTransfer,
	TransferKHR = AllTransfer,
	BottomOfPipeKHR = BottomOfPipe,
	HostKHR = Host,
	AllGraphicsKHR = AllGraphics,
	AllCommandsKHR = AllCommands,
	CopyKHR = Copy,
	ResolveKHR = Resolve,
	BlitKHR = Blit,
	ClearKHR = Clear,
	IndexInputKHR = IndexInput,
	VertexAttributeInputKHR = VertexAttributeInput,
	PreRasterizationShadersKHR = PreRasterizationShaders,
	TransformFeedbackEXT = 1 << 24,
	ConditionalRenderingEXT = 1 << 18, // A pipeline stage for conditional rendering predicate fetch
	CommandPreprocessNV = CommandPreprocessEXT,
	CommandPreprocessEXT = 1 << 17,
	FragmentShadingRateAttachmentKHR = 1 << 22,
	ShadingRateImageNV = FragmentShadingRateAttachmentKHR,
	AccelerationStructureBuildKHR = 1 << 25,
	RayTracingShaderKHR = 1 << 21,
	RayTracingShaderNV = RayTracingShaderKHR,
	AccelerationStructureBuildNV = AccelerationStructureBuildKHR,
	FragmentDensityProcessEXT = 1 << 23,
	TaskShaderNV = TaskShaderEXT,
	MeshShaderNV = MeshShaderEXT,
	TaskShaderEXT = 1 << 19,
	MeshShaderEXT = 1 << 20,
	SubpassShaderHUAWEI = 1 << 39,
	SubpassShadingHUAWEI = SubpassShaderHUAWEI,
	InvocationMaskHUAWEI = 1 << 40,
	AccelerationStructureCopyKHR = 1 << 28,
	MicromapBuildEXT = 1 << 30,
	ClusterCullingShaderHUAWEI = 1 << 41,
	OpticalFlowNV = 1 << 29,
	ConvertCooperativeVectorMatrixNV = 1 << 44,
	DataGraphARM = 1 << 42,
}

typealias VkAccessFlags2 = VkAccessFlagBits2;

[AllowDuplicates] enum VkAccessFlagBits2 : int64
{
	None = 0,
	IndirectCommandRead = 1 << 0,
	IndexRead = 1 << 1,
	VertexAttributeRead = 1 << 2,
	UniformRead = 1 << 3,
	InputAttachmentRead = 1 << 4,
	ShaderRead = 1 << 5,
	ShaderWrite = 1 << 6,
	ColorAttachmentRead = 1 << 7,
	ColorAttachmentWrite = 1 << 8,
	DepthStencilAttachmentRead = 1 << 9,
	DepthStencilAttachmentWrite = 1 << 10,
	TransferRead = 1 << 11,
	TransferWrite = 1 << 12,
	HostRead = 1 << 13,
	HostWrite = 1 << 14,
	MemoryRead = 1 << 15,
	MemoryWrite = 1 << 16,
	ShaderSampledRead = 1 << 32,
	ShaderStorageRead = 1 << 33,
	ShaderStorageWrite = 1 << 34,
	VideoDecodeReadKHR = 1 << 35,
	VideoDecodeWriteKHR = 1 << 36,
	VideoEncodeReadKHR = 1 << 37,
	VideoEncodeWriteKHR = 1 << 38,
	ShaderTileAttachmentReadQCOM = 1 << 51,
	ShaderTileAttachmentWriteQCOM = 1 << 52,
	NoneKHR = None,
	IndirectCommandReadKHR = IndirectCommandRead,
	IndexReadKHR = IndexRead,
	VertexAttributeReadKHR = VertexAttributeRead,
	UniformReadKHR = UniformRead,
	InputAttachmentReadKHR = InputAttachmentRead,
	ShaderReadKHR = ShaderRead,
	ShaderWriteKHR = ShaderWrite,
	ColorAttachmentReadKHR = ColorAttachmentRead,
	ColorAttachmentWriteKHR = ColorAttachmentWrite,
	DepthStencilAttachmentReadKHR = DepthStencilAttachmentRead,
	DepthStencilAttachmentWriteKHR = DepthStencilAttachmentWrite,
	TransferReadKHR = TransferRead,
	TransferWriteKHR = TransferWrite,
	HostReadKHR = HostRead,
	HostWriteKHR = HostWrite,
	MemoryReadKHR = MemoryRead,
	MemoryWriteKHR = MemoryWrite,
	ShaderSampledReadKHR = ShaderSampledRead,
	ShaderStorageReadKHR = ShaderStorageRead,
	ShaderStorageWriteKHR = ShaderStorageWrite,
	TransformFeedbackWriteEXT = 1 << 25,
	TransformFeedbackCounterReadEXT = 1 << 26,
	TransformFeedbackCounterWriteEXT = 1 << 27,
	ConditionalRenderingReadEXT = 1 << 20, // read access flag for reading conditional rendering predicate
	CommandPreprocessReadNV = CommandPreprocessReadEXT,
	CommandPreprocessWriteNV = CommandPreprocessWriteEXT,
	CommandPreprocessReadEXT = 1 << 17,
	CommandPreprocessWriteEXT = 1 << 18,
	FragmentShadingRateAttachmentReadKHR = 1 << 23,
	ShadingRateImageReadNV = FragmentShadingRateAttachmentReadKHR,
	AccelerationStructureReadKHR = 1 << 21,
	AccelerationStructureWriteKHR = 1 << 22,
	AccelerationStructureReadNV = AccelerationStructureReadKHR,
	AccelerationStructureWriteNV = AccelerationStructureWriteKHR,
	FragmentDensityMapReadEXT = 1 << 24,
	ColorAttachmentReadNoncoherentEXT = 1 << 19,
	DescriptorBufferReadEXT = 1 << 41,
	InvocationMaskReadHUAWEI = 1 << 39,
	ShaderBindingTableReadKHR = 1 << 40,
	MicromapReadEXT = 1 << 44,
	MicromapWriteEXT = 1 << 45,
	OpticalFlowReadNV = 1 << 42,
	OpticalFlowWriteNV = 1 << 43,
	DataGraphReadARM = 1 << 47,
	DataGraphWriteARM = 1 << 48,
}

[CRepr] struct VkMemoryBarrier2
{
	public const VkStructureType SType = .VkMemoryBarrier2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineStageFlags2 srcStageMask;
	public VkAccessFlags2 srcAccessMask;
	public VkPipelineStageFlags2 dstStageMask;
	public VkAccessFlags2 dstAccessMask;

	public this(void* pNext = null, VkPipelineStageFlags2 srcStageMask = 0, VkAccessFlags2 srcAccessMask = 0, VkPipelineStageFlags2 dstStageMask = 0, VkAccessFlags2 dstAccessMask = 0)
	{
		this.pNext = pNext;
		this.srcStageMask = srcStageMask;
		this.srcAccessMask = srcAccessMask;
		this.dstStageMask = dstStageMask;
		this.dstAccessMask = dstAccessMask;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBufferMemoryBarrier2
{
	public const VkStructureType SType = .VkBufferMemoryBarrier2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineStageFlags2 srcStageMask;
	public VkAccessFlags2 srcAccessMask;
	public VkPipelineStageFlags2 dstStageMask;
	public VkAccessFlags2 dstAccessMask;
	public uint32 srcQueueFamilyIndex;
	public uint32 dstQueueFamilyIndex;
	public VkBuffer buffer;
	public VkDeviceSize offset;
	public VkDeviceSize size;

	public this(void* pNext, VkPipelineStageFlags2 srcStageMask, VkAccessFlags2 srcAccessMask, VkPipelineStageFlags2 dstStageMask, VkAccessFlags2 dstAccessMask, uint32 srcQueueFamilyIndex, uint32 dstQueueFamilyIndex, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size)
	{
		this.pNext = pNext;
		this.srcStageMask = srcStageMask;
		this.srcAccessMask = srcAccessMask;
		this.dstStageMask = dstStageMask;
		this.dstAccessMask = dstAccessMask;
		this.srcQueueFamilyIndex = srcQueueFamilyIndex;
		this.dstQueueFamilyIndex = dstQueueFamilyIndex;
		this.buffer = buffer;
		this.offset = offset;
		this.size = size;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageMemoryBarrier2
{
	public const VkStructureType SType = .VkImageMemoryBarrier2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineStageFlags2 srcStageMask;
	public VkAccessFlags2 srcAccessMask;
	public VkPipelineStageFlags2 dstStageMask;
	public VkAccessFlags2 dstAccessMask;
	public VkImageLayout oldLayout;
	public VkImageLayout newLayout;
	public uint32 srcQueueFamilyIndex;
	public uint32 dstQueueFamilyIndex;
	public VkImage image;
	public VkImageSubresourceRange subresourceRange;

	public this(void* pNext, VkPipelineStageFlags2 srcStageMask, VkAccessFlags2 srcAccessMask, VkPipelineStageFlags2 dstStageMask, VkAccessFlags2 dstAccessMask, VkImageLayout oldLayout, VkImageLayout newLayout, uint32 srcQueueFamilyIndex, uint32 dstQueueFamilyIndex, VkImage image, VkImageSubresourceRange subresourceRange)
	{
		this.pNext = pNext;
		this.srcStageMask = srcStageMask;
		this.srcAccessMask = srcAccessMask;
		this.dstStageMask = dstStageMask;
		this.dstAccessMask = dstAccessMask;
		this.oldLayout = oldLayout;
		this.newLayout = newLayout;
		this.srcQueueFamilyIndex = srcQueueFamilyIndex;
		this.dstQueueFamilyIndex = dstQueueFamilyIndex;
		this.image = image;
		this.subresourceRange = subresourceRange;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDependencyInfo
{
	public const VkStructureType SType = .VkDependencyInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDependencyFlags dependencyFlags;
	public uint32 memoryBarrierCount;
	public VkMemoryBarrier2* pMemoryBarriers;
	public VulkanSpan<VkMemoryBarrier2> memoryBarriers
	{
		[Inline] get => .(memoryBarrierCount, pMemoryBarriers);
		[Inline] set mut { memoryBarrierCount = value.count; pMemoryBarriers = value.ptr; }
	}
	public uint32 bufferMemoryBarrierCount;
	public VkBufferMemoryBarrier2* pBufferMemoryBarriers;
	public VulkanSpan<VkBufferMemoryBarrier2> bufferMemoryBarriers
	{
		[Inline] get => .(bufferMemoryBarrierCount, pBufferMemoryBarriers);
		[Inline] set mut { bufferMemoryBarrierCount = value.count; pBufferMemoryBarriers = value.ptr; }
	}
	public uint32 imageMemoryBarrierCount;
	public VkImageMemoryBarrier2* pImageMemoryBarriers;
	public VulkanSpan<VkImageMemoryBarrier2> imageMemoryBarriers
	{
		[Inline] get => .(imageMemoryBarrierCount, pImageMemoryBarriers);
		[Inline] set mut { imageMemoryBarrierCount = value.count; pImageMemoryBarriers = value.ptr; }
	}

	public this(void* pNext = null, VkDependencyFlags dependencyFlags = 0, VulkanSpan<VkMemoryBarrier2> memoryBarriers = .(), VulkanSpan<VkBufferMemoryBarrier2> bufferMemoryBarriers = .(), VulkanSpan<VkImageMemoryBarrier2> imageMemoryBarriers = .()) : this()
	{
		this.pNext = pNext;
		this.dependencyFlags = dependencyFlags;
		this.memoryBarriers = memoryBarriers;
		this.bufferMemoryBarriers = bufferMemoryBarriers;
		this.imageMemoryBarriers = imageMemoryBarriers;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSubmitInfo2
{
	public const VkStructureType SType = .VkSubmitInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSubmitFlags flags;
	public uint32 waitSemaphoreInfoCount;
	public VkSemaphoreSubmitInfo* pWaitSemaphoreInfos;
	public VulkanSpan<VkSemaphoreSubmitInfo> waitSemaphoreInfos
	{
		[Inline] get => .(waitSemaphoreInfoCount, pWaitSemaphoreInfos);
		[Inline] set mut { waitSemaphoreInfoCount = value.count; pWaitSemaphoreInfos = value.ptr; }
	}
	public uint32 commandBufferInfoCount;
	public VkCommandBufferSubmitInfo* pCommandBufferInfos;
	public VulkanSpan<VkCommandBufferSubmitInfo> commandBufferInfos
	{
		[Inline] get => .(commandBufferInfoCount, pCommandBufferInfos);
		[Inline] set mut { commandBufferInfoCount = value.count; pCommandBufferInfos = value.ptr; }
	}
	public uint32 signalSemaphoreInfoCount;
	public VkSemaphoreSubmitInfo* pSignalSemaphoreInfos;
	public VulkanSpan<VkSemaphoreSubmitInfo> signalSemaphoreInfos
	{
		[Inline] get => .(signalSemaphoreInfoCount, pSignalSemaphoreInfos);
		[Inline] set mut { signalSemaphoreInfoCount = value.count; pSignalSemaphoreInfos = value.ptr; }
	}

	public this(void* pNext = null, VkSubmitFlags flags = 0, VulkanSpan<VkSemaphoreSubmitInfo> waitSemaphoreInfos = .(), VulkanSpan<VkCommandBufferSubmitInfo> commandBufferInfos = .(), VulkanSpan<VkSemaphoreSubmitInfo> signalSemaphoreInfos = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.waitSemaphoreInfos = waitSemaphoreInfos;
		this.commandBufferInfos = commandBufferInfos;
		this.signalSemaphoreInfos = signalSemaphoreInfos;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSemaphoreSubmitInfo
{
	public const VkStructureType SType = .VkSemaphoreSubmitInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSemaphore semaphore;
	public uint64 value;
	public VkPipelineStageFlags2 stageMask;
	public uint32 deviceIndex;

	public this(void* pNext, VkSemaphore semaphore, uint64 value, VkPipelineStageFlags2 stageMask, uint32 deviceIndex)
	{
		this.pNext = pNext;
		this.semaphore = semaphore;
		this.value = value;
		this.stageMask = stageMask;
		this.deviceIndex = deviceIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCommandBufferSubmitInfo
{
	public const VkStructureType SType = .VkCommandBufferSubmitInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkCommandBuffer commandBuffer;
	public uint32 deviceMask;

	public this(void* pNext, VkCommandBuffer commandBuffer, uint32 deviceMask)
	{
		this.pNext = pNext;
		this.commandBuffer = commandBuffer;
		this.deviceMask = deviceMask;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkSubmitFlagBits : int32
{
	Protected = 1 << 0,
	ProtectedKHR = Protected,
}

typealias VkSubmitFlags = VkSubmitFlagBits;

[CRepr] struct VkPhysicalDeviceSynchronization2Features
{
	public const VkStructureType SType = .VkPhysicalDeviceSynchronization2Features;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 synchronization2;

	public this(void* pNext, VkBool32 synchronization2)
	{
		this.pNext = pNext;
		this.synchronization2 = synchronization2;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event, VkDependencyInfo* pDependencyInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask = 0);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdWaitEvents2(VkCommandBuffer commandBuffer, uint32 eventCount, VkEvent* pEvents, VkDependencyInfo* pDependencyInfos);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdPipelineBarrier2(VkCommandBuffer commandBuffer, VkDependencyInfo* pDependencyInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32 query);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkQueueSubmit2(VkQueue queue, uint32 submitCount = 0, VkSubmitInfo2* pSubmits = null, VkFence fence = null);

// Promoted from VK_KHR_zero_initialize_workgroup_memory (extension 326)
[CRepr] struct VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderZeroInitializeWorkgroupMemory;

	public this(void* pNext, VkBool32 shaderZeroInitializeWorkgroupMemory)
	{
		this.pNext = pNext;
		this.shaderZeroInitializeWorkgroupMemory = shaderZeroInitializeWorkgroupMemory;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_EXT_image_robustness (extension 336)
[CRepr] struct VkPhysicalDeviceImageRobustnessFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceImageRobustnessFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 robustImageAccess;

	public this(void* pNext, VkBool32 robustImageAccess)
	{
		this.pNext = pNext;
		this.robustImageAccess = robustImageAccess;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_copy_commands2 (extension 338)
[CRepr] struct VkCopyBufferInfo2
{
	public const VkStructureType SType = .VkCopyBufferInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBuffer srcBuffer;
	public VkBuffer dstBuffer;
	public uint32 regionCount;
	public VkBufferCopy2* pRegions;
	public VulkanSpan<VkBufferCopy2> regions
	{
		[Inline] get => .(regionCount, pRegions);
		[Inline] set mut { regionCount = value.count; pRegions = value.ptr; }
	}

	public this(void* pNext, VkBuffer srcBuffer, VkBuffer dstBuffer, VulkanSpan<VkBufferCopy2> regions) : this()
	{
		this.pNext = pNext;
		this.srcBuffer = srcBuffer;
		this.dstBuffer = dstBuffer;
		this.regions = regions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCopyImageInfo2
{
	public const VkStructureType SType = .VkCopyImageInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImage srcImage;
	public VkImageLayout srcImageLayout;
	public VkImage dstImage;
	public VkImageLayout dstImageLayout;
	public uint32 regionCount;
	public VkImageCopy2* pRegions;
	public VulkanSpan<VkImageCopy2> regions
	{
		[Inline] get => .(regionCount, pRegions);
		[Inline] set mut { regionCount = value.count; pRegions = value.ptr; }
	}

	public this(void* pNext, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, VulkanSpan<VkImageCopy2> regions) : this()
	{
		this.pNext = pNext;
		this.srcImage = srcImage;
		this.srcImageLayout = srcImageLayout;
		this.dstImage = dstImage;
		this.dstImageLayout = dstImageLayout;
		this.regions = regions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCopyBufferToImageInfo2
{
	public const VkStructureType SType = .VkCopyBufferToImageInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBuffer srcBuffer;
	public VkImage dstImage;
	public VkImageLayout dstImageLayout;
	public uint32 regionCount;
	public VkBufferImageCopy2* pRegions;
	public VulkanSpan<VkBufferImageCopy2> regions
	{
		[Inline] get => .(regionCount, pRegions);
		[Inline] set mut { regionCount = value.count; pRegions = value.ptr; }
	}

	public this(void* pNext, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, VulkanSpan<VkBufferImageCopy2> regions) : this()
	{
		this.pNext = pNext;
		this.srcBuffer = srcBuffer;
		this.dstImage = dstImage;
		this.dstImageLayout = dstImageLayout;
		this.regions = regions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCopyImageToBufferInfo2
{
	public const VkStructureType SType = .VkCopyImageToBufferInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImage srcImage;
	public VkImageLayout srcImageLayout;
	public VkBuffer dstBuffer;
	public uint32 regionCount;
	public VkBufferImageCopy2* pRegions;
	public VulkanSpan<VkBufferImageCopy2> regions
	{
		[Inline] get => .(regionCount, pRegions);
		[Inline] set mut { regionCount = value.count; pRegions = value.ptr; }
	}

	public this(void* pNext, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, VulkanSpan<VkBufferImageCopy2> regions) : this()
	{
		this.pNext = pNext;
		this.srcImage = srcImage;
		this.srcImageLayout = srcImageLayout;
		this.dstBuffer = dstBuffer;
		this.regions = regions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBlitImageInfo2
{
	public const VkStructureType SType = .VkBlitImageInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImage srcImage;
	public VkImageLayout srcImageLayout;
	public VkImage dstImage;
	public VkImageLayout dstImageLayout;
	public uint32 regionCount;
	public VkImageBlit2* pRegions;
	public VulkanSpan<VkImageBlit2> regions
	{
		[Inline] get => .(regionCount, pRegions);
		[Inline] set mut { regionCount = value.count; pRegions = value.ptr; }
	}
	public VkFilter filter;

	public this(void* pNext, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, VulkanSpan<VkImageBlit2> regions, VkFilter filter) : this()
	{
		this.pNext = pNext;
		this.srcImage = srcImage;
		this.srcImageLayout = srcImageLayout;
		this.dstImage = dstImage;
		this.dstImageLayout = dstImageLayout;
		this.regions = regions;
		this.filter = filter;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkResolveImageInfo2
{
	public const VkStructureType SType = .VkResolveImageInfo2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImage srcImage;
	public VkImageLayout srcImageLayout;
	public VkImage dstImage;
	public VkImageLayout dstImageLayout;
	public uint32 regionCount;
	public VkImageResolve2* pRegions;
	public VulkanSpan<VkImageResolve2> regions
	{
		[Inline] get => .(regionCount, pRegions);
		[Inline] set mut { regionCount = value.count; pRegions = value.ptr; }
	}

	public this(void* pNext, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, VulkanSpan<VkImageResolve2> regions) : this()
	{
		this.pNext = pNext;
		this.srcImage = srcImage;
		this.srcImageLayout = srcImageLayout;
		this.dstImage = dstImage;
		this.dstImageLayout = dstImageLayout;
		this.regions = regions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBufferCopy2
{
	public const VkStructureType SType = .VkBufferCopy2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize srcOffset; // Specified in bytes
	public VkDeviceSize dstOffset; // Specified in bytes
	public VkDeviceSize size; // Specified in bytes

	public this(void* pNext, VkDeviceSize srcOffset, VkDeviceSize dstOffset, VkDeviceSize size)
	{
		this.pNext = pNext;
		this.srcOffset = srcOffset;
		this.dstOffset = dstOffset;
		this.size = size;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageCopy2
{
	public const VkStructureType SType = .VkImageCopy2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageSubresourceLayers srcSubresource;
	public VkOffset3D srcOffset; // Specified in pixels for both compressed and uncompressed images
	public VkImageSubresourceLayers dstSubresource;
	public VkOffset3D dstOffset; // Specified in pixels for both compressed and uncompressed images
	public VkExtent3D extent; // Specified in pixels for both compressed and uncompressed images

	public this(void* pNext, VkImageSubresourceLayers srcSubresource, VkOffset3D srcOffset, VkImageSubresourceLayers dstSubresource, VkOffset3D dstOffset, VkExtent3D extent)
	{
		this.pNext = pNext;
		this.srcSubresource = srcSubresource;
		this.srcOffset = srcOffset;
		this.dstSubresource = dstSubresource;
		this.dstOffset = dstOffset;
		this.extent = extent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageBlit2
{
	public const VkStructureType SType = .VkImageBlit2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageSubresourceLayers srcSubresource;
	public VkOffset3D[2] srcOffsets; // Specified in pixels for both compressed and uncompressed images
	public VkImageSubresourceLayers dstSubresource;
	public VkOffset3D[2] dstOffsets; // Specified in pixels for both compressed and uncompressed images

	public this(void* pNext, VkImageSubresourceLayers srcSubresource, VkOffset3D[2] srcOffsets, VkImageSubresourceLayers dstSubresource, VkOffset3D[2] dstOffsets)
	{
		this.pNext = pNext;
		this.srcSubresource = srcSubresource;
		this.srcOffsets = srcOffsets;
		this.dstSubresource = dstSubresource;
		this.dstOffsets = dstOffsets;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBufferImageCopy2
{
	public const VkStructureType SType = .VkBufferImageCopy2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize bufferOffset; // Specified in bytes
	public uint32 bufferRowLength; // Specified in texels
	public uint32 bufferImageHeight;
	public VkImageSubresourceLayers imageSubresource;
	public VkOffset3D imageOffset; // Specified in pixels for both compressed and uncompressed images
	public VkExtent3D imageExtent; // Specified in pixels for both compressed and uncompressed images

	public this(void* pNext, VkDeviceSize bufferOffset, uint32 bufferRowLength, uint32 bufferImageHeight, VkImageSubresourceLayers imageSubresource, VkOffset3D imageOffset, VkExtent3D imageExtent)
	{
		this.pNext = pNext;
		this.bufferOffset = bufferOffset;
		this.bufferRowLength = bufferRowLength;
		this.bufferImageHeight = bufferImageHeight;
		this.imageSubresource = imageSubresource;
		this.imageOffset = imageOffset;
		this.imageExtent = imageExtent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageResolve2
{
	public const VkStructureType SType = .VkImageResolve2;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageSubresourceLayers srcSubresource;
	public VkOffset3D srcOffset;
	public VkImageSubresourceLayers dstSubresource;
	public VkOffset3D dstOffset;
	public VkExtent3D extent;

	public this(void* pNext, VkImageSubresourceLayers srcSubresource, VkOffset3D srcOffset, VkImageSubresourceLayers dstSubresource, VkOffset3D dstOffset, VkExtent3D extent)
	{
		this.pNext = pNext;
		this.srcSubresource = srcSubresource;
		this.srcOffset = srcOffset;
		this.dstSubresource = dstSubresource;
		this.dstOffset = dstOffset;
		this.extent = extent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyBuffer2(VkCommandBuffer commandBuffer, VkCopyBufferInfo2* pCopyBufferInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyImage2(VkCommandBuffer commandBuffer, VkCopyImageInfo2* pCopyImageInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyBufferToImage2(VkCommandBuffer commandBuffer, VkCopyBufferToImageInfo2* pCopyBufferToImageInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyImageToBuffer2(VkCommandBuffer commandBuffer, VkCopyImageToBufferInfo2* pCopyImageToBufferInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBlitImage2(VkCommandBuffer commandBuffer, VkBlitImageInfo2* pBlitImageInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdResolveImage2(VkCommandBuffer commandBuffer, VkResolveImageInfo2* pResolveImageInfo);

// Promoted from VK_EXT_subgroup_size_control (STDPROMOTE/PROPLIMCHANGE) (extension 226)
[CRepr] struct VkPhysicalDeviceSubgroupSizeControlFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceSubgroupSizeControlFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 subgroupSizeControl;
	public VkBool32 computeFullSubgroups;

	public this(void* pNext, VkBool32 subgroupSizeControl, VkBool32 computeFullSubgroups)
	{
		this.pNext = pNext;
		this.subgroupSizeControl = subgroupSizeControl;
		this.computeFullSubgroups = computeFullSubgroups;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceSubgroupSizeControlProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceSubgroupSizeControlProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 minSubgroupSize; // The minimum subgroup size supported by this device
	public uint32 maxSubgroupSize; // The maximum subgroup size supported by this device
	public uint32 maxComputeWorkgroupSubgroups; // The maximum number of subgroups supported in a workgroup
	public VkShaderStageFlags requiredSubgroupSizeStages; // The shader stages that support specifying a subgroup size
}

[CRepr] struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfo
{
	public const VkStructureType SType = .VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 requiredSubgroupSize;
}

// Promoted from VK_EXT_inline_uniform_block (STDPROMOTE/PROPLIMCHANGE) (extension 139)
[CRepr] struct VkPhysicalDeviceInlineUniformBlockFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceInlineUniformBlockFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 inlineUniformBlock;
	public VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind;

	public this(void* pNext, VkBool32 inlineUniformBlock, VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind)
	{
		this.pNext = pNext;
		this.inlineUniformBlock = inlineUniformBlock;
		this.descriptorBindingInlineUniformBlockUpdateAfterBind = descriptorBindingInlineUniformBlockUpdateAfterBind;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceInlineUniformBlockProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceInlineUniformBlockProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxInlineUniformBlockSize;
	public uint32 maxPerStageDescriptorInlineUniformBlocks;
	public uint32 maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
	public uint32 maxDescriptorSetInlineUniformBlocks;
	public uint32 maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
}

[CRepr] struct VkWriteDescriptorSetInlineUniformBlock
{
	public const VkStructureType SType = .VkWriteDescriptorSetInlineUniformBlock;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 dataSize;
	public void* pData;

	public this(void* pNext, uint32 dataSize, void* pData)
	{
		this.pNext = pNext;
		this.dataSize = dataSize;
		this.pData = pData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDescriptorPoolInlineUniformBlockCreateInfo
{
	public const VkStructureType SType = .VkDescriptorPoolInlineUniformBlockCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxInlineUniformBlockBindings;

	public this(void* pNext, uint32 maxInlineUniformBlockBindings)
	{
		this.pNext = pNext;
		this.maxInlineUniformBlockBindings = maxInlineUniformBlockBindings;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_EXT_ycbcr_2plane_444_formats (does not promote the Feature struct, just the formats) (extension 331)
// Promoted from VK_EXT_4444_formats (does not promote the Feature struct, just the formats) (extension 341)
// Promoted from VK_EXT_texture_compression_astc_hdr (Feature struct is promoted, but becomes optional) (extension 67)
[CRepr] struct VkPhysicalDeviceTextureCompressionASTCHDRFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceTextureCompressionAstcHdrFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 textureCompressionASTC_HDR;

	public this(void* pNext, VkBool32 textureCompressionASTC_HDR)
	{
		this.pNext = pNext;
		this.textureCompressionASTC_HDR = textureCompressionASTC_HDR;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_dynamic_rendering (extension 45)
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBeginRendering(VkCommandBuffer commandBuffer, VkRenderingInfo* pRenderingInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdEndRendering(VkCommandBuffer commandBuffer);

[CRepr] struct VkRenderingInfo
{
	public const VkStructureType SType = .VkRenderingInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRenderingFlags flags;
	public VkRect2D renderArea;
	public uint32 layerCount;
	public uint32 viewMask;
	public uint32 colorAttachmentCount;
	public VkRenderingAttachmentInfo* pColorAttachments;
	public VulkanSpan<VkRenderingAttachmentInfo> colorAttachments
	{
		[Inline] get => .(colorAttachmentCount, pColorAttachments);
		[Inline] set mut { colorAttachmentCount = value.count; pColorAttachments = value.ptr; }
	}
	public VkRenderingAttachmentInfo* pDepthAttachment;
	public VkRenderingAttachmentInfo* pStencilAttachment;

	public this(void* pNext, VkRenderingFlags flags, VkRect2D renderArea, uint32 layerCount, uint32 viewMask, VulkanSpan<VkRenderingAttachmentInfo> colorAttachments = .(), VkRenderingAttachmentInfo* pDepthAttachment = null, VkRenderingAttachmentInfo* pStencilAttachment = null) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.renderArea = renderArea;
		this.layerCount = layerCount;
		this.viewMask = viewMask;
		this.colorAttachments = colorAttachments;
		this.pDepthAttachment = pDepthAttachment;
		this.pStencilAttachment = pStencilAttachment;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkRenderingAttachmentInfo
{
	public const VkStructureType SType = .VkRenderingAttachmentInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageView imageView;
	public VkImageLayout imageLayout;
	public VkResolveModeFlagBits resolveMode;
	public VkImageView resolveImageView;
	public VkImageLayout resolveImageLayout;
	public VkAttachmentLoadOp loadOp;
	public VkAttachmentStoreOp storeOp;
	public VkClearValue clearValue;

	public this(void* pNext, VkImageView imageView, VkImageLayout imageLayout, VkResolveModeFlagBits resolveMode, VkImageView resolveImageView, VkImageLayout resolveImageLayout, VkAttachmentLoadOp loadOp, VkAttachmentStoreOp storeOp, VkClearValue clearValue)
	{
		this.pNext = pNext;
		this.imageView = imageView;
		this.imageLayout = imageLayout;
		this.resolveMode = resolveMode;
		this.resolveImageView = resolveImageView;
		this.resolveImageLayout = resolveImageLayout;
		this.loadOp = loadOp;
		this.storeOp = storeOp;
		this.clearValue = clearValue;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineRenderingCreateInfo
{
	public const VkStructureType SType = .VkPipelineRenderingCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 viewMask;
	public uint32 colorAttachmentCount;
	public VkFormat* pColorAttachmentFormats;
	public VulkanSpan<VkFormat> colorAttachmentFormats
	{
		[Inline] get => .(colorAttachmentCount, pColorAttachmentFormats);
		[Inline] set mut { colorAttachmentCount = value.count; pColorAttachmentFormats = value.ptr; }
	}
	public VkFormat depthAttachmentFormat;
	public VkFormat stencilAttachmentFormat;

	public this(void* pNext, uint32 viewMask, VulkanSpan<VkFormat> colorAttachmentFormats, VkFormat depthAttachmentFormat, VkFormat stencilAttachmentFormat) : this()
	{
		this.pNext = pNext;
		this.viewMask = viewMask;
		this.colorAttachmentFormats = colorAttachmentFormats;
		this.depthAttachmentFormat = depthAttachmentFormat;
		this.stencilAttachmentFormat = stencilAttachmentFormat;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceDynamicRenderingFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceDynamicRenderingFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 dynamicRendering;

	public this(void* pNext, VkBool32 dynamicRendering)
	{
		this.pNext = pNext;
		this.dynamicRendering = dynamicRendering;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCommandBufferInheritanceRenderingInfo
{
	public const VkStructureType SType = .VkCommandBufferInheritanceRenderingInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRenderingFlags flags;
	public uint32 viewMask;
	public uint32 colorAttachmentCount;
	public VkFormat* pColorAttachmentFormats;
	public VulkanSpan<VkFormat> colorAttachmentFormats
	{
		[Inline] get => .(colorAttachmentCount, pColorAttachmentFormats);
		[Inline] set mut { colorAttachmentCount = value.count; pColorAttachmentFormats = value.ptr; }
	}
	public VkFormat depthAttachmentFormat;
	public VkFormat stencilAttachmentFormat;
	public VkSampleCountFlagBits rasterizationSamples;

	public this(void* pNext, VkRenderingFlags flags, uint32 viewMask, VulkanSpan<VkFormat> colorAttachmentFormats, VkFormat depthAttachmentFormat, VkFormat stencilAttachmentFormat, VkSampleCountFlagBits rasterizationSamples = 0) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.viewMask = viewMask;
		this.colorAttachmentFormats = colorAttachmentFormats;
		this.depthAttachmentFormat = depthAttachmentFormat;
		this.stencilAttachmentFormat = stencilAttachmentFormat;
		this.rasterizationSamples = rasterizationSamples;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkRenderingFlags = VkRenderingFlagBits;

[AllowDuplicates] enum VkRenderingFlagBits : int32
{
	ContentsSecondaryCommandBuffers = 1 << 0,
	Suspending = 1 << 1,
	Resuming = 1 << 2,
	ContentsSecondaryCommandBuffersKHR = ContentsSecondaryCommandBuffers,
	SuspendingKHR = Suspending,
	ResumingKHR = Resuming,
	ContentsInlineEXT = ContentsInlineKHR,
	EnableLegacyDitheringEXT = 1 << 3,
	ContentsInlineKHR = 1 << 4, // Promoted from extension 452
	PerLayerFragmentDensityVALVE = 1 << 5,
}

// Promoted from VK_EXT_extended_dynamic_state (Feature struct is not promoted) (extension 268)
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode = 0);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetPrimitiveTopology(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32 viewportCount, VkViewport* pViewports);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32 scissorCount, VkRect2D* pScissors);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32 firstBinding, uint32 bindingCount, VkBuffer* pBuffers, VkDeviceSize* pOffsets, VkDeviceSize* pSizes = null, VkDeviceSize* pStrides = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetStencilTestEnable(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp);

// Promoted from VK_KHR_shader_integer_dot_product (extension 281)
[CRepr] struct VkPhysicalDeviceShaderIntegerDotProductFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderIntegerDotProductFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderIntegerDotProduct;

	public this(void* pNext, VkBool32 shaderIntegerDotProduct)
	{
		this.pNext = pNext;
		this.shaderIntegerDotProduct = shaderIntegerDotProduct;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceShaderIntegerDotProductProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderIntegerDotProductProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 integerDotProduct8BitUnsignedAccelerated;
	public VkBool32 integerDotProduct8BitSignedAccelerated;
	public VkBool32 integerDotProduct8BitMixedSignednessAccelerated;
	public VkBool32 integerDotProduct4x8BitPackedUnsignedAccelerated;
	public VkBool32 integerDotProduct4x8BitPackedSignedAccelerated;
	public VkBool32 integerDotProduct4x8BitPackedMixedSignednessAccelerated;
	public VkBool32 integerDotProduct16BitUnsignedAccelerated;
	public VkBool32 integerDotProduct16BitSignedAccelerated;
	public VkBool32 integerDotProduct16BitMixedSignednessAccelerated;
	public VkBool32 integerDotProduct32BitUnsignedAccelerated;
	public VkBool32 integerDotProduct32BitSignedAccelerated;
	public VkBool32 integerDotProduct32BitMixedSignednessAccelerated;
	public VkBool32 integerDotProduct64BitUnsignedAccelerated;
	public VkBool32 integerDotProduct64BitSignedAccelerated;
	public VkBool32 integerDotProduct64BitMixedSignednessAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating8BitSignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating16BitSignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating32BitSignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating64BitSignedAccelerated;
	public VkBool32 integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
}

// Promoted from VK_EXT_texel_buffer_alignment (extension 282)
[CRepr] struct VkPhysicalDeviceTexelBufferAlignmentProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceTexelBufferAlignmentProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize storageTexelBufferOffsetAlignmentBytes;
	public VkBool32 storageTexelBufferOffsetSingleTexelAlignment;
	public VkDeviceSize uniformTexelBufferOffsetAlignmentBytes;
	public VkBool32 uniformTexelBufferOffsetSingleTexelAlignment;
}

// Promoted from VK_KHR_format_feature_flags2 (extension 361)
typealias VkFormatFeatureFlags2 = VkFormatFeatureFlagBits2;

[AllowDuplicates] enum VkFormatFeatureFlagBits2 : int64
{
	SampledImage = 1 << 0,
	StorageImage = 1 << 1,
	StorageImageAtomic = 1 << 2,
	UniformTexelBuffer = 1 << 3,
	StorageTexelBuffer = 1 << 4,
	StorageTexelBufferAtomic = 1 << 5,
	VertexBuffer = 1 << 6,
	ColorAttachment = 1 << 7,
	ColorAttachmentBlend = 1 << 8,
	DepthStencilAttachment = 1 << 9,
	BlitSrc = 1 << 10,
	BlitDst = 1 << 11,
	SampledImageFilterLinear = 1 << 12,
	TransferSrc = 1 << 14,
	TransferDst = 1 << 15,
	SampledImageFilterMinmax = 1 << 16,
	MidpointChromaSamples = 1 << 17,
	SampledImageYcbcrConversionLinearFilter = 1 << 18,
	SampledImageYcbcrConversionSeparateReconstructionFilter = 1 << 19,
	SampledImageYcbcrConversionChromaReconstructionExplicit = 1 << 20,
	SampledImageYcbcrConversionChromaReconstructionExplicitForceable = 1 << 21,
	Disjoint = 1 << 22,
	CositedChromaSamples = 1 << 23,
	StorageReadWithoutFormat = 1 << 31,
	StorageWriteWithoutFormat = 1 << 32,
	SampledImageDepthComparison = 1 << 33,
	SampledImageFilterCubic = 1 << 13, // This is an interaction with EXT_filter_cubic, though not tagged that way
	HostImageTransfer = 1 << 46,
	VideoDecodeOutputKHR = 1 << 25,
	VideoDecodeDpbKHR = 1 << 26,
	AccelerationStructureVertexBufferKHR = 1 << 29,
	FragmentDensityMapEXT = 1 << 24,
	FragmentShadingRateAttachmentKHR = 1 << 30,
	HostImageTransferEXT = HostImageTransfer, // Host image copies are supported
	VideoEncodeInputKHR = 1 << 27,
	VideoEncodeDpbKHR = 1 << 28,
	SampledImageKHR = SampledImage,
	StorageImageKHR = StorageImage,
	StorageImageAtomicKHR = StorageImageAtomic,
	UniformTexelBufferKHR = UniformTexelBuffer,
	StorageTexelBufferKHR = StorageTexelBuffer,
	StorageTexelBufferAtomicKHR = StorageTexelBufferAtomic,
	VertexBufferKHR = VertexBuffer,
	ColorAttachmentKHR = ColorAttachment,
	ColorAttachmentBlendKHR = ColorAttachmentBlend,
	DepthStencilAttachmentKHR = DepthStencilAttachment,
	BlitSrcKHR = BlitSrc,
	BlitDstKHR = BlitDst,
	SampledImageFilterLinearKHR = SampledImageFilterLinear,
	TransferSrcKHR = TransferSrc,
	TransferDstKHR = TransferDst,
	MidpointChromaSamplesKHR = MidpointChromaSamples,
	SampledImageYcbcrConversionLinearFilterKHR = SampledImageYcbcrConversionLinearFilter,
	SampledImageYcbcrConversionSeparateReconstructionFilterKHR = SampledImageYcbcrConversionSeparateReconstructionFilter,
	SampledImageYcbcrConversionChromaReconstructionExplicitKHR = SampledImageYcbcrConversionChromaReconstructionExplicit,
	SampledImageYcbcrConversionChromaReconstructionExplicitForceableKHR = SampledImageYcbcrConversionChromaReconstructionExplicitForceable,
	DisjointKHR = Disjoint,
	CositedChromaSamplesKHR = CositedChromaSamples,
	StorageReadWithoutFormatKHR = StorageReadWithoutFormat,
	StorageWriteWithoutFormatKHR = StorageWriteWithoutFormat,
	SampledImageDepthComparisonKHR = SampledImageDepthComparison,
	SampledImageFilterMinmaxKHR = SampledImageFilterMinmax,
	SampledImageFilterCubicEXT = SampledImageFilterCubic,
	AccelerationStructureRadiusBufferNV = 1 << 51,
	LinearColorAttachmentNV = 1 << 38, // Format support linear image as render target, it cannot be mixed with non linear attachment
	WeightImageQCOM = 1 << 34,
	WeightSampledImageQCOM = 1 << 35,
	BlockMatchingQCOM = 1 << 36,
	BoxFilterSampledQCOM = 1 << 37,
	TensorShaderARM = 1 << 39,
	TensorImageAliasingARM = 1 << 43,
	OpticalFlowImageNV = 1 << 40,
	OpticalFlowVectorNV = 1 << 41,
	OpticalFlowCostNV = 1 << 42,
	TensorDataGraphARM = 1 << 48,
	VideoEncodeQuantizationDeltaMapKHR = 1 << 49,
	VideoEncodeEmphasisMapKHR = 1 << 50,
}

[CRepr] struct VkFormatProperties3
{
	public const VkStructureType SType = .VkFormatProperties3;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormatFeatureFlags2 linearTilingFeatures;
	public VkFormatFeatureFlags2 optimalTilingFeatures;
	public VkFormatFeatureFlags2 bufferFeatures;
}

// Promoted from VK_EXT_extended_dynamic_state2 (Feature struct and optional state are not promoted) (extension 378)
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable);

// Promoted from VK_KHR_maintenance4 (extension 414)
[CRepr] struct VkPhysicalDeviceMaintenance4Features
{
	public const VkStructureType SType = .VkPhysicalDeviceMaintenance4Features;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 maintenance4;

	public this(void* pNext, VkBool32 maintenance4)
	{
		this.pNext = pNext;
		this.maintenance4 = maintenance4;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceMaintenance4Properties
{
	public const VkStructureType SType = .VkPhysicalDeviceMaintenance4Properties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize maxBufferSize;
}

[CRepr] struct VkDeviceBufferMemoryRequirements
{
	public const VkStructureType SType = .VkDeviceBufferMemoryRequirements;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBufferCreateInfo* pCreateInfo;

	public this(void* pNext, VkBufferCreateInfo* pCreateInfo)
	{
		this.pNext = pNext;
		this.pCreateInfo = pCreateInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceImageMemoryRequirements
{
	public const VkStructureType SType = .VkDeviceImageMemoryRequirements;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageCreateInfo* pCreateInfo;
	public VkImageAspectFlagBits planeAspect;

	public this(void* pNext, VkImageCreateInfo* pCreateInfo, VkImageAspectFlagBits planeAspect = 0)
	{
		this.pNext = pNext;
		this.pCreateInfo = pCreateInfo;
		this.planeAspect = planeAspect;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDeviceBufferMemoryRequirements(VkDevice device, VkDeviceBufferMemoryRequirements* pInfo, out VkMemoryRequirements2 pMemoryRequirements);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDeviceImageMemoryRequirements(VkDevice device, VkDeviceImageMemoryRequirements* pInfo, out VkMemoryRequirements2 pMemoryRequirements);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDeviceImageSparseMemoryRequirements(VkDevice device, VkDeviceImageMemoryRequirements* pInfo, out uint32 pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements = null);

static { public const uint32 VK_API_VERSION_1_4 = VK_MAKE_API_VERSION(0, 1, 4, 0)/* Patch version should always be set to 0 */; }

[CRepr] struct VkPhysicalDeviceVulkan14Features
{
	public const VkStructureType SType = .VkPhysicalDeviceVulkan14Features;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 globalPriorityQuery;
	public VkBool32 shaderSubgroupRotate;
	public VkBool32 shaderSubgroupRotateClustered;
	public VkBool32 shaderFloatControls2;
	public VkBool32 shaderExpectAssume;
	public VkBool32 rectangularLines;
	public VkBool32 bresenhamLines;
	public VkBool32 smoothLines;
	public VkBool32 stippledRectangularLines;
	public VkBool32 stippledBresenhamLines;
	public VkBool32 stippledSmoothLines;
	public VkBool32 vertexAttributeInstanceRateDivisor;
	public VkBool32 vertexAttributeInstanceRateZeroDivisor;
	public VkBool32 indexTypeUint8;
	public VkBool32 dynamicRenderingLocalRead;
	public VkBool32 maintenance5;
	public VkBool32 maintenance6;
	public VkBool32 pipelineProtectedAccess;
	public VkBool32 pipelineRobustness;
	public VkBool32 hostImageCopy;
	public VkBool32 pushDescriptor;

	public this(void* pNext, VkBool32 globalPriorityQuery, VkBool32 shaderSubgroupRotate, VkBool32 shaderSubgroupRotateClustered, VkBool32 shaderFloatControls2, VkBool32 shaderExpectAssume, VkBool32 rectangularLines, VkBool32 bresenhamLines, VkBool32 smoothLines, VkBool32 stippledRectangularLines, VkBool32 stippledBresenhamLines, VkBool32 stippledSmoothLines, VkBool32 vertexAttributeInstanceRateDivisor, VkBool32 vertexAttributeInstanceRateZeroDivisor, VkBool32 indexTypeUint8, VkBool32 dynamicRenderingLocalRead, VkBool32 maintenance5, VkBool32 maintenance6, VkBool32 pipelineProtectedAccess, VkBool32 pipelineRobustness, VkBool32 hostImageCopy, VkBool32 pushDescriptor)
	{
		this.pNext = pNext;
		this.globalPriorityQuery = globalPriorityQuery;
		this.shaderSubgroupRotate = shaderSubgroupRotate;
		this.shaderSubgroupRotateClustered = shaderSubgroupRotateClustered;
		this.shaderFloatControls2 = shaderFloatControls2;
		this.shaderExpectAssume = shaderExpectAssume;
		this.rectangularLines = rectangularLines;
		this.bresenhamLines = bresenhamLines;
		this.smoothLines = smoothLines;
		this.stippledRectangularLines = stippledRectangularLines;
		this.stippledBresenhamLines = stippledBresenhamLines;
		this.stippledSmoothLines = stippledSmoothLines;
		this.vertexAttributeInstanceRateDivisor = vertexAttributeInstanceRateDivisor;
		this.vertexAttributeInstanceRateZeroDivisor = vertexAttributeInstanceRateZeroDivisor;
		this.indexTypeUint8 = indexTypeUint8;
		this.dynamicRenderingLocalRead = dynamicRenderingLocalRead;
		this.maintenance5 = maintenance5;
		this.maintenance6 = maintenance6;
		this.pipelineProtectedAccess = pipelineProtectedAccess;
		this.pipelineRobustness = pipelineRobustness;
		this.hostImageCopy = hostImageCopy;
		this.pushDescriptor = pushDescriptor;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceVulkan14Properties
{
	public const VkStructureType SType = .VkPhysicalDeviceVulkan14Properties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 lineSubPixelPrecisionBits;
	public uint32 maxVertexAttribDivisor; // max value of vertex attribute divisor
	public VkBool32 supportsNonZeroFirstInstance;
	public uint32 maxPushDescriptors;
	public VkBool32 dynamicRenderingLocalReadDepthStencilAttachments;
	public VkBool32 dynamicRenderingLocalReadMultisampledAttachments;
	public VkBool32 earlyFragmentMultisampleCoverageAfterSampleCounting;
	public VkBool32 earlyFragmentSampleMaskTestBeforeSampleCounting;
	public VkBool32 depthStencilSwizzleOneSupport;
	public VkBool32 polygonModePointSize;
	public VkBool32 nonStrictSinglePixelWideLinesUseParallelogram;
	public VkBool32 nonStrictWideLinesUseParallelogram;
	public VkBool32 blockTexelViewCompatibleMultipleLayers;
	public uint32 maxCombinedImageSamplerDescriptorCount;
	public VkBool32 fragmentShadingRateClampCombinerInputs;
	public VkPipelineRobustnessBufferBehavior defaultRobustnessStorageBuffers;
	public VkPipelineRobustnessBufferBehavior defaultRobustnessUniformBuffers;
	public VkPipelineRobustnessBufferBehavior defaultRobustnessVertexInputs;
	public VkPipelineRobustnessImageBehavior defaultRobustnessImages;
	public uint32 copySrcLayoutCount;
	public VkImageLayout* pCopySrcLayouts;
	public VulkanSpan<VkImageLayout> copySrcLayouts
	{
		[Inline] get => .(copySrcLayoutCount, pCopySrcLayouts);
		[Inline] set mut { copySrcLayoutCount = value.count; pCopySrcLayouts = value.ptr; }
	}
	public uint32 copyDstLayoutCount;
	public VkImageLayout* pCopyDstLayouts;
	public VulkanSpan<VkImageLayout> copyDstLayouts
	{
		[Inline] get => .(copyDstLayoutCount, pCopyDstLayouts);
		[Inline] set mut { copyDstLayoutCount = value.count; pCopyDstLayouts = value.ptr; }
	}
	public uint8[VK_UUID_SIZE] optimalTilingLayoutUUID;
	public VkBool32 identicalMemoryTypeRequirements;
}

// Features now required from VK_VERSION_1_0
// Features now required from VK_VERSION_1_1
// Features now required from VK_VERSION_1_2
// Promoted from VK_KHR_global_priority (extension 189)
static { public const uint32 VK_MAX_GLOBAL_PRIORITY_SIZE = 16; }

[CRepr] struct VkDeviceQueueGlobalPriorityCreateInfo
{
	public const VkStructureType SType = .VkDeviceQueueGlobalPriorityCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkQueueGlobalPriority globalPriority;

	public this(void* pNext, VkQueueGlobalPriority globalPriority)
	{
		this.pNext = pNext;
		this.globalPriority = globalPriority;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkQueueGlobalPriority : int32
{
	Low = 128,
	Medium = 256,
	High = 512,
	Realtime = 1024,
	LowEXT = Low,
	MediumEXT = Medium,
	HighEXT = High,
	RealtimeEXT = Realtime,
	LowKHR = Low,
	MediumKHR = Medium,
	HighKHR = High,
	RealtimeKHR = Realtime,
}

[CRepr] struct VkPhysicalDeviceGlobalPriorityQueryFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceGlobalPriorityQueryFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 globalPriorityQuery;

	public this(void* pNext, VkBool32 globalPriorityQuery)
	{
		this.pNext = pNext;
		this.globalPriorityQuery = globalPriorityQuery;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkQueueFamilyGlobalPriorityProperties
{
	public const VkStructureType SType = .VkQueueFamilyGlobalPriorityProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 priorityCount;
	public VkQueueGlobalPriority[VK_MAX_GLOBAL_PRIORITY_SIZE] priorities;
}

// Promoted from VK_KHR_load_store_op_none (extension 527) 'Roadmap 2024' (VK_ATTACHMENT_STORE_OP_NONE is defined in Vulkan 1.3)
// Promoted from VK_KHR_shader_subgroup_rotate (extension 417) 'Roadmap 2024'
[CRepr] struct VkPhysicalDeviceShaderSubgroupRotateFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderSubgroupRotateFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderSubgroupRotate;
	public VkBool32 shaderSubgroupRotateClustered;

	public this(void* pNext, VkBool32 shaderSubgroupRotate, VkBool32 shaderSubgroupRotateClustered)
	{
		this.pNext = pNext;
		this.shaderSubgroupRotate = shaderSubgroupRotate;
		this.shaderSubgroupRotateClustered = shaderSubgroupRotateClustered;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_shader_float_controls2 (extension 529) 'Roadmap 2024'
[CRepr] struct VkPhysicalDeviceShaderFloatControls2Features
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderFloatControls2Features;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderFloatControls2;

	public this(void* pNext, VkBool32 shaderFloatControls2)
	{
		this.pNext = pNext;
		this.shaderFloatControls2 = shaderFloatControls2;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_shader_expect_assume (extension 545) 'Roadmap 2024'
[CRepr] struct VkPhysicalDeviceShaderExpectAssumeFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderExpectAssumeFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderExpectAssume;

	public this(void* pNext, VkBool32 shaderExpectAssume)
	{
		this.pNext = pNext;
		this.shaderExpectAssume = shaderExpectAssume;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_line_rasterization (extension 535) 'Roadmap 2024'
[CRepr] struct VkPhysicalDeviceLineRasterizationFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceLineRasterizationFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 rectangularLines;
	public VkBool32 bresenhamLines;
	public VkBool32 smoothLines;
	public VkBool32 stippledRectangularLines;
	public VkBool32 stippledBresenhamLines;
	public VkBool32 stippledSmoothLines;

	public this(void* pNext, VkBool32 rectangularLines, VkBool32 bresenhamLines, VkBool32 smoothLines, VkBool32 stippledRectangularLines, VkBool32 stippledBresenhamLines, VkBool32 stippledSmoothLines)
	{
		this.pNext = pNext;
		this.rectangularLines = rectangularLines;
		this.bresenhamLines = bresenhamLines;
		this.smoothLines = smoothLines;
		this.stippledRectangularLines = stippledRectangularLines;
		this.stippledBresenhamLines = stippledBresenhamLines;
		this.stippledSmoothLines = stippledSmoothLines;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceLineRasterizationProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceLineRasterizationProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 lineSubPixelPrecisionBits;
}

[CRepr] struct VkPipelineRasterizationLineStateCreateInfo
{
	public const VkStructureType SType = .VkPipelineRasterizationLineStateCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkLineRasterizationMode lineRasterizationMode;
	public VkBool32 stippledLineEnable;
	public uint32 lineStippleFactor;
	public uint16 lineStipplePattern;

	public this(void* pNext, VkLineRasterizationMode lineRasterizationMode, VkBool32 stippledLineEnable, uint32 lineStippleFactor, uint16 lineStipplePattern)
	{
		this.pNext = pNext;
		this.lineRasterizationMode = lineRasterizationMode;
		this.stippledLineEnable = stippledLineEnable;
		this.lineStippleFactor = lineStippleFactor;
		this.lineStipplePattern = lineStipplePattern;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkLineRasterizationMode : int32
{
	Default = 0,
	Rectangular = 1,
	Bresenham = 2,
	RectangularSmooth = 3,
	DefaultEXT = Default,
	RectangularEXT = Rectangular,
	BresenhamEXT = Bresenham,
	RectangularSmoothEXT = RectangularSmooth,
	DefaultKHR = Default,
	RectangularKHR = Rectangular,
	BresenhamKHR = Bresenham,
	RectangularSmoothKHR = RectangularSmooth,
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetLineStipple(VkCommandBuffer commandBuffer, uint32 lineStippleFactor, uint16 lineStipplePattern);

// Promoted from VK_KHR_vertex_attribute_divisor (extension 526) 'Roadmap 2024'
[CRepr] struct VkPhysicalDeviceVertexAttributeDivisorProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceVertexAttributeDivisorProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxVertexAttribDivisor; // max value of vertex attribute divisor
	public VkBool32 supportsNonZeroFirstInstance;
}

[CRepr] struct VkVertexInputBindingDivisorDescription
{
	public uint32 binding;
	public uint32 divisor;

	public this(uint32 binding, uint32 divisor)
	{
		this.binding = binding;
		this.divisor = divisor;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkPipelineVertexInputDivisorStateCreateInfo
{
	public const VkStructureType SType = .VkPipelineVertexInputDivisorStateCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 vertexBindingDivisorCount;
	public VkVertexInputBindingDivisorDescription* pVertexBindingDivisors;
	public VulkanSpan<VkVertexInputBindingDivisorDescription> vertexBindingDivisors
	{
		[Inline] get => .(vertexBindingDivisorCount, pVertexBindingDivisors);
		[Inline] set mut { vertexBindingDivisorCount = value.count; pVertexBindingDivisors = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<VkVertexInputBindingDivisorDescription> vertexBindingDivisors) : this()
	{
		this.pNext = pNext;
		this.vertexBindingDivisors = vertexBindingDivisors;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceVertexAttributeDivisorFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceVertexAttributeDivisorFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 vertexAttributeInstanceRateDivisor;
	public VkBool32 vertexAttributeInstanceRateZeroDivisor;

	public this(void* pNext, VkBool32 vertexAttributeInstanceRateDivisor, VkBool32 vertexAttributeInstanceRateZeroDivisor)
	{
		this.pNext = pNext;
		this.vertexAttributeInstanceRateDivisor = vertexAttributeInstanceRateDivisor;
		this.vertexAttributeInstanceRateZeroDivisor = vertexAttributeInstanceRateZeroDivisor;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_index_type_uint8 (extension 534) 'Roadmap 2024'
[CRepr] struct VkPhysicalDeviceIndexTypeUint8Features
{
	public const VkStructureType SType = .VkPhysicalDeviceIndexTypeUint8Features;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 indexTypeUint8;

	public this(void* pNext, VkBool32 indexTypeUint8)
	{
		this.pNext = pNext;
		this.indexTypeUint8 = indexTypeUint8;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_map_memory2 (extension 272) 'Roadmap 2024'
[CRepr] struct VkMemoryMapInfo
{
	public const VkStructureType SType = .VkMemoryMapInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkMemoryMapFlags flags;
	public VkDeviceMemory memory;
	public VkDeviceSize offset;
	public VkDeviceSize size;

	public this(void* pNext, VkMemoryMapFlags flags, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.memory = memory;
		this.offset = offset;
		this.size = size;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryUnmapInfo
{
	public const VkStructureType SType = .VkMemoryUnmapInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkMemoryUnmapFlags flags;
	public VkDeviceMemory memory;

	public this(void* pNext, VkMemoryUnmapFlags flags, VkDeviceMemory memory)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.memory = memory;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkMemoryUnmapFlagBits : int32
{
	ReserveEXT = 1 << 0,
}

typealias VkMemoryUnmapFlags = VkMemoryUnmapFlagBits;

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkMapMemory2(VkDevice device, VkMemoryMapInfo* pMemoryMapInfo, out void* ppData);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkUnmapMemory2(VkDevice device, VkMemoryUnmapInfo* pMemoryUnmapInfo);

// Promoted from VK_KHR_maintenance5 (extension 471) 'Roadmap 2024'
[CRepr] struct VkPhysicalDeviceMaintenance5Features
{
	public const VkStructureType SType = .VkPhysicalDeviceMaintenance5Features;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 maintenance5;

	public this(void* pNext, VkBool32 maintenance5)
	{
		this.pNext = pNext;
		this.maintenance5 = maintenance5;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceMaintenance5Properties
{
	public const VkStructureType SType = .VkPhysicalDeviceMaintenance5Properties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 earlyFragmentMultisampleCoverageAfterSampleCounting;
	public VkBool32 earlyFragmentSampleMaskTestBeforeSampleCounting;
	public VkBool32 depthStencilSwizzleOneSupport;
	public VkBool32 polygonModePointSize;
	public VkBool32 nonStrictSinglePixelWideLinesUseParallelogram;
	public VkBool32 nonStrictWideLinesUseParallelogram;
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindIndexBuffer2(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetRenderingAreaGranularity(VkDevice device, VkRenderingAreaInfo* pRenderingAreaInfo, out VkExtent2D pGranularity);

[CRepr] struct VkRenderingAreaInfo
{
	public const VkStructureType SType = .VkRenderingAreaInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 viewMask;
	public uint32 colorAttachmentCount;
	public VkFormat* pColorAttachmentFormats;
	public VulkanSpan<VkFormat> colorAttachmentFormats
	{
		[Inline] get => .(colorAttachmentCount, pColorAttachmentFormats);
		[Inline] set mut { colorAttachmentCount = value.count; pColorAttachmentFormats = value.ptr; }
	}
	public VkFormat depthAttachmentFormat;
	public VkFormat stencilAttachmentFormat;

	public this(void* pNext, uint32 viewMask, VulkanSpan<VkFormat> colorAttachmentFormats, VkFormat depthAttachmentFormat, VkFormat stencilAttachmentFormat) : this()
	{
		this.pNext = pNext;
		this.viewMask = viewMask;
		this.colorAttachmentFormats = colorAttachmentFormats;
		this.depthAttachmentFormat = depthAttachmentFormat;
		this.stencilAttachmentFormat = stencilAttachmentFormat;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDeviceImageSubresourceLayout(VkDevice device, VkDeviceImageSubresourceInfo* pInfo, out VkSubresourceLayout2 pLayout);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetImageSubresourceLayout2(VkDevice device, VkImage image, VkImageSubresource2* pSubresource, out VkSubresourceLayout2 pLayout);

[CRepr] struct VkDeviceImageSubresourceInfo
{
	public const VkStructureType SType = .VkDeviceImageSubresourceInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageCreateInfo* pCreateInfo;
	public VkImageSubresource2* pSubresource;

	public this(void* pNext, VkImageCreateInfo* pCreateInfo, VkImageSubresource2* pSubresource)
	{
		this.pNext = pNext;
		this.pCreateInfo = pCreateInfo;
		this.pSubresource = pSubresource;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageSubresource2
{
	public const VkStructureType SType = .VkImageSubresource2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkImageSubresource imageSubresource;

	public this(void* pNext, VkImageSubresource imageSubresource)
	{
		this.pNext = pNext;
		this.imageSubresource = imageSubresource;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSubresourceLayout2
{
	public const VkStructureType SType = .VkSubresourceLayout2;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkSubresourceLayout subresourceLayout;
}

typealias VkPipelineCreateFlags2 = VkPipelineCreateFlagBits2;

[AllowDuplicates] enum VkPipelineCreateFlagBits2 : int64
{
	DisableOptimization = 1 << 0,
	AllowDerivatives = 1 << 1,
	Derivative = 1 << 2,
	ViewIndexFromDeviceIndex = 1 << 3,
	DispatchBase = 1 << 4,
	FailOnPipelineCompileRequired = 1 << 8,
	EarlyReturnOnFailure = 1 << 9,
	NoProtectedAccess = 1 << 27,
	ProtectedAccessOnly = 1 << 30,
	ExecutionGraphAMDX = 1 << 32,
	RayTracingSkipBuiltInPrimitivesKHR = RayTracingSkipTrianglesKHR,
	RayTracingAllowSpheresAndLinearSweptSpheresNV = 1 << 33,
	EnableLegacyDitheringEXT = 1 << 34,
	DisableOptimizationKHR = DisableOptimization,
	AllowDerivativesKHR = AllowDerivatives,
	DerivativeKHR = Derivative,
	ViewIndexFromDeviceIndexKHR = ViewIndexFromDeviceIndex,
	DispatchBaseKHR = DispatchBase,
	DeferCompileNV = 1 << 5,
	CaptureStatisticsKHR = 1 << 6,
	CaptureInternalRepresentationsKHR = 1 << 7,
	FailOnPipelineCompileRequiredKHR = FailOnPipelineCompileRequired,
	EarlyReturnOnFailureKHR = EarlyReturnOnFailure,
	LinkTimeOptimizationEXT = 1 << 10,
	RetainLinkTimeOptimizationInfoEXT = 1 << 23,
	LibraryKHR = 1 << 11,
	RayTracingSkipTrianglesKHR = 1 << 12,
	RayTracingSkipAabbsKHR = 1 << 13,
	RayTracingNoNullAnyHitShadersKHR = 1 << 14,
	RayTracingNoNullClosestHitShadersKHR = 1 << 15,
	RayTracingNoNullMissShadersKHR = 1 << 16,
	RayTracingNoNullIntersectionShadersKHR = 1 << 17,
	RayTracingShaderGroupHandleCaptureReplayKHR = 1 << 19,
	IndirectBindableNV = 1 << 18,
	RayTracingAllowMotionNV = 1 << 20,
	RenderingFragmentShadingRateAttachmentKHR = 1 << 21,
	RenderingFragmentDensityMapAttachmentEXT = 1 << 22,
	RayTracingOpacityMicromapEXT = 1 << 24,
	ColorAttachmentFeedbackLoopEXT = 1 << 25,
	DepthStencilAttachmentFeedbackLoopEXT = 1 << 26,
	NoProtectedAccessEXT = NoProtectedAccess,
	ProtectedAccessOnlyEXT = ProtectedAccessOnly,
	RayTracingDisplacementMicromapNV = 1 << 28,
	DescriptorBufferEXT = 1 << 29,
	DisallowOpacityMicromapARM = 1 << 37,
	CaptureDataKHR = 1 << 31,
	IndirectBindableEXT = 1 << 38,
	PerLayerFragmentDensityVALVE = 1 << 40,
}

[CRepr] struct VkPipelineCreateFlags2CreateInfo
{
	public const VkStructureType SType = .VkPipelineCreateFlags2CreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkPipelineCreateFlags2 flags;

	public this(void* pNext, VkPipelineCreateFlags2 flags)
	{
		this.pNext = pNext;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkBufferUsageFlags2 = VkBufferUsageFlagBits2;

[AllowDuplicates] enum VkBufferUsageFlagBits2 : int64
{
	TransferSrc = 1 << 0,
	TransferDst = 1 << 1,
	UniformTexelBuffer = 1 << 2,
	StorageTexelBuffer = 1 << 3,
	UniformBuffer = 1 << 4,
	StorageBuffer = 1 << 5,
	IndexBuffer = 1 << 6,
	VertexBuffer = 1 << 7,
	IndirectBuffer = 1 << 8,
	ShaderDeviceAddress = 1 << 17,
	ExecutionGraphScratchAMDX = 1 << 25,
	TransferSrcKHR = TransferSrc,
	TransferDstKHR = TransferDst,
	UniformTexelBufferKHR = UniformTexelBuffer,
	StorageTexelBufferKHR = StorageTexelBuffer,
	UniformBufferKHR = UniformBuffer,
	StorageBufferKHR = StorageBuffer,
	IndexBufferKHR = IndexBuffer,
	VertexBufferKHR = VertexBuffer,
	IndirectBufferKHR = IndirectBuffer,
	ConditionalRenderingEXT = 1 << 9,
	ShaderBindingTableKHR = 1 << 10,
	RayTracingNV = ShaderBindingTableKHR,
	TransformFeedbackBufferEXT = 1 << 11,
	TransformFeedbackCounterBufferEXT = 1 << 12,
	VideoDecodeSrcKHR = 1 << 13,
	VideoDecodeDstKHR = 1 << 14,
	VideoEncodeDstKHR = 1 << 15,
	VideoEncodeSrcKHR = 1 << 16,
	ShaderDeviceAddressKHR = ShaderDeviceAddress,
	AccelerationStructureBuildInputReadOnlyKHR = 1 << 19,
	AccelerationStructureStorageKHR = 1 << 20,
	SamplerDescriptorBufferEXT = 1 << 21,
	ResourceDescriptorBufferEXT = 1 << 22,
	PushDescriptorsDescriptorBufferEXT = 1 << 26,
	MicromapBuildInputReadOnlyEXT = 1 << 23,
	MicromapStorageEXT = 1 << 24,
	DataGraphForeignDescriptorARM = 1 << 29,
	TileMemoryQCOM = 1 << 27,
	PreprocessBufferEXT = 1 << 31,
}

[CRepr] struct VkBufferUsageFlags2CreateInfo
{
	public const VkStructureType SType = .VkBufferUsageFlags2CreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkBufferUsageFlags2 usage;

	public this(void* pNext, VkBufferUsageFlags2 usage)
	{
		this.pNext = pNext;
		this.usage = usage;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted as an interaction between VK_KHR_maintenance5 (extension 471) 'Roadmap 2024' and VK_EXT_pipeline_protected_access (extension 467) 'additional functionality'
// Promoted from VK_KHR_push_descriptor (extension 81) 'Roadmap 2024'
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdPushDescriptorSet(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32 set, uint32 descriptorWriteCount, VkWriteDescriptorSet* pDescriptorWrites);

[CRepr] struct VkPhysicalDevicePushDescriptorProperties
{
	public const VkStructureType SType = .VkPhysicalDevicePushDescriptorProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxPushDescriptors;
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdPushDescriptorSetWithTemplate(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32 set, void* pData);

// Promoted from VK_KHR_dynamic_rendering_local_read (extension 233) 'Roadmap 2024'
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetRenderingAttachmentLocations(VkCommandBuffer commandBuffer, VkRenderingAttachmentLocationInfo* pLocationInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetRenderingInputAttachmentIndices(VkCommandBuffer commandBuffer, VkRenderingInputAttachmentIndexInfo* pInputAttachmentIndexInfo);

[CRepr] struct VkPhysicalDeviceDynamicRenderingLocalReadFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceDynamicRenderingLocalReadFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 dynamicRenderingLocalRead;

	public this(void* pNext, VkBool32 dynamicRenderingLocalRead)
	{
		this.pNext = pNext;
		this.dynamicRenderingLocalRead = dynamicRenderingLocalRead;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkRenderingAttachmentLocationInfo
{
	public const VkStructureType SType = .VkRenderingAttachmentLocationInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 colorAttachmentCount;
	public uint32* pColorAttachmentLocations;
	public VulkanSpan<uint32> colorAttachmentLocations
	{
		[Inline] get => .(colorAttachmentCount, pColorAttachmentLocations);
		[Inline] set mut { colorAttachmentCount = value.count; pColorAttachmentLocations = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<uint32> colorAttachmentLocations = .()) : this()
	{
		this.pNext = pNext;
		this.colorAttachmentLocations = colorAttachmentLocations;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkRenderingInputAttachmentIndexInfo
{
	public const VkStructureType SType = .VkRenderingInputAttachmentIndexInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 colorAttachmentCount;
	public uint32* pColorAttachmentInputIndices;
	public VulkanSpan<uint32> colorAttachmentInputIndices
	{
		[Inline] get => .(colorAttachmentCount, pColorAttachmentInputIndices);
		[Inline] set mut { colorAttachmentCount = value.count; pColorAttachmentInputIndices = value.ptr; }
	}
	public uint32* pDepthInputAttachmentIndex;
	public uint32* pStencilInputAttachmentIndex;

	public this(void* pNext = null, VulkanSpan<uint32> colorAttachmentInputIndices = .(), uint32* pDepthInputAttachmentIndex = null, uint32* pStencilInputAttachmentIndex = null) : this()
	{
		this.pNext = pNext;
		this.colorAttachmentInputIndices = colorAttachmentInputIndices;
		this.pDepthInputAttachmentIndex = pDepthInputAttachmentIndex;
		this.pStencilInputAttachmentIndex = pStencilInputAttachmentIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_KHR_maintenance6 (extension 546) 'additional functionality'
[CRepr] struct VkPhysicalDeviceMaintenance6Features
{
	public const VkStructureType SType = .VkPhysicalDeviceMaintenance6Features;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 maintenance6;

	public this(void* pNext, VkBool32 maintenance6)
	{
		this.pNext = pNext;
		this.maintenance6 = maintenance6;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceMaintenance6Properties
{
	public const VkStructureType SType = .VkPhysicalDeviceMaintenance6Properties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 blockTexelViewCompatibleMultipleLayers;
	public uint32 maxCombinedImageSamplerDescriptorCount;
	public VkBool32 fragmentShadingRateClampCombinerInputs;
}

[CRepr] struct VkBindMemoryStatus
{
	public const VkStructureType SType = .VkBindMemoryStatus;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkResult* pResult;

	public this(void* pNext, VkResult* pResult)
	{
		this.pNext = pNext;
		this.pResult = pResult;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBindDescriptorSetsInfo
{
	public const VkStructureType SType = .VkBindDescriptorSetsInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkShaderStageFlags stageFlags;
	public VkPipelineLayout layout;
	public uint32 firstSet;
	public uint32 descriptorSetCount;
	public VkDescriptorSet* pDescriptorSets;
	public VulkanSpan<VkDescriptorSet> descriptorSets
	{
		[Inline] get => .(descriptorSetCount, pDescriptorSets);
		[Inline] set mut { descriptorSetCount = value.count; pDescriptorSets = value.ptr; }
	}
	public uint32 dynamicOffsetCount;
	public uint32* pDynamicOffsets;
	public VulkanSpan<uint32> dynamicOffsets
	{
		[Inline] get => .(dynamicOffsetCount, pDynamicOffsets);
		[Inline] set mut { dynamicOffsetCount = value.count; pDynamicOffsets = value.ptr; }
	}

	public this(void* pNext, VkShaderStageFlags stageFlags, VkPipelineLayout layout, uint32 firstSet, VulkanSpan<VkDescriptorSet> descriptorSets, VulkanSpan<uint32> dynamicOffsets = .()) : this()
	{
		this.pNext = pNext;
		this.stageFlags = stageFlags;
		this.layout = layout;
		this.firstSet = firstSet;
		this.descriptorSets = descriptorSets;
		this.dynamicOffsets = dynamicOffsets;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPushConstantsInfo
{
	public const VkStructureType SType = .VkPushConstantsInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineLayout layout;
	public VkShaderStageFlags stageFlags;
	public uint32 offset;
	public uint32 size;
	public void* pValues;

	public this(void* pNext, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32 offset, uint32 size, void* pValues)
	{
		this.pNext = pNext;
		this.layout = layout;
		this.stageFlags = stageFlags;
		this.offset = offset;
		this.size = size;
		this.pValues = pValues;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindDescriptorSets2(VkCommandBuffer commandBuffer, VkBindDescriptorSetsInfo* pBindDescriptorSetsInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdPushConstants2(VkCommandBuffer commandBuffer, VkPushConstantsInfo* pPushConstantsInfo);

[CRepr] struct VkPushDescriptorSetInfo
{
	public const VkStructureType SType = .VkPushDescriptorSetInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkShaderStageFlags stageFlags;
	public VkPipelineLayout layout;
	public uint32 set;
	public uint32 descriptorWriteCount;
	public VkWriteDescriptorSet* pDescriptorWrites;
	public VulkanSpan<VkWriteDescriptorSet> descriptorWrites
	{
		[Inline] get => .(descriptorWriteCount, pDescriptorWrites);
		[Inline] set mut { descriptorWriteCount = value.count; pDescriptorWrites = value.ptr; }
	}

	public this(void* pNext, VkShaderStageFlags stageFlags, VkPipelineLayout layout, uint32 set, VulkanSpan<VkWriteDescriptorSet> descriptorWrites) : this()
	{
		this.pNext = pNext;
		this.stageFlags = stageFlags;
		this.layout = layout;
		this.set = set;
		this.descriptorWrites = descriptorWrites;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPushDescriptorSetWithTemplateInfo
{
	public const VkStructureType SType = .VkPushDescriptorSetWithTemplateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDescriptorUpdateTemplate descriptorUpdateTemplate;
	public VkPipelineLayout layout;
	public uint32 set;
	public void* pData;

	public this(void* pNext, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32 set, void* pData)
	{
		this.pNext = pNext;
		this.descriptorUpdateTemplate = descriptorUpdateTemplate;
		this.layout = layout;
		this.set = set;
		this.pData = pData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdPushDescriptorSet2(VkCommandBuffer commandBuffer, VkPushDescriptorSetInfo* pPushDescriptorSetInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdPushDescriptorSetWithTemplate2(VkCommandBuffer commandBuffer, VkPushDescriptorSetWithTemplateInfo* pPushDescriptorSetWithTemplateInfo);

// Promoted from VK_EXT_pipeline_protected_access (extension 467) 'additional functionality'
[CRepr] struct VkPhysicalDevicePipelineProtectedAccessFeatures
{
	public const VkStructureType SType = .VkPhysicalDevicePipelineProtectedAccessFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 pipelineProtectedAccess;

	public this(void* pNext, VkBool32 pipelineProtectedAccess)
	{
		this.pNext = pNext;
		this.pipelineProtectedAccess = pipelineProtectedAccess;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

// Promoted from VK_EXT_pipeline_robustness (extension 69) 'additional functionality'
[CRepr] struct VkPhysicalDevicePipelineRobustnessFeatures
{
	public const VkStructureType SType = .VkPhysicalDevicePipelineRobustnessFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 pipelineRobustness;

	public this(void* pNext, VkBool32 pipelineRobustness)
	{
		this.pNext = pNext;
		this.pipelineRobustness = pipelineRobustness;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDevicePipelineRobustnessProperties
{
	public const VkStructureType SType = .VkPhysicalDevicePipelineRobustnessProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineRobustnessBufferBehavior defaultRobustnessStorageBuffers;
	public VkPipelineRobustnessBufferBehavior defaultRobustnessUniformBuffers;
	public VkPipelineRobustnessBufferBehavior defaultRobustnessVertexInputs;
	public VkPipelineRobustnessImageBehavior defaultRobustnessImages;
}

[CRepr] struct VkPipelineRobustnessCreateInfo
{
	public const VkStructureType SType = .VkPipelineRobustnessCreateInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineRobustnessBufferBehavior storageBuffers;
	public VkPipelineRobustnessBufferBehavior uniformBuffers;
	public VkPipelineRobustnessBufferBehavior vertexInputs;
	public VkPipelineRobustnessImageBehavior images;

	public this(void* pNext, VkPipelineRobustnessBufferBehavior storageBuffers, VkPipelineRobustnessBufferBehavior uniformBuffers, VkPipelineRobustnessBufferBehavior vertexInputs, VkPipelineRobustnessImageBehavior images)
	{
		this.pNext = pNext;
		this.storageBuffers = storageBuffers;
		this.uniformBuffers = uniformBuffers;
		this.vertexInputs = vertexInputs;
		this.images = images;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkPipelineRobustnessBufferBehavior : int32
{
	DeviceDefault = 0,
	Disabled = 1,
	RobustBufferAccess = 2,
	RobustBufferAccess2 = 3,
	DeviceDefaultEXT = DeviceDefault,
	DisabledEXT = Disabled,
	RobustBufferAccessEXT = RobustBufferAccess,
	RobustBufferAccess2EXT = RobustBufferAccess2,
}

[AllowDuplicates] enum VkPipelineRobustnessImageBehavior : int32
{
	DeviceDefault = 0,
	Disabled = 1,
	RobustImageAccess = 2,
	RobustImageAccess2 = 3,
	DeviceDefaultEXT = DeviceDefault,
	DisabledEXT = Disabled,
	RobustImageAccessEXT = RobustImageAccess,
	RobustImageAccess2EXT = RobustImageAccess2,
}

// Promoted (as optional feature) from VK_EXT_host_image_copy (extension 271) 'streaming transfers'
[CRepr] struct VkPhysicalDeviceHostImageCopyFeatures
{
	public const VkStructureType SType = .VkPhysicalDeviceHostImageCopyFeatures;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 hostImageCopy;

	public this(void* pNext, VkBool32 hostImageCopy)
	{
		this.pNext = pNext;
		this.hostImageCopy = hostImageCopy;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceHostImageCopyProperties
{
	public const VkStructureType SType = .VkPhysicalDeviceHostImageCopyProperties;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 copySrcLayoutCount;
	public VkImageLayout* pCopySrcLayouts;
	public VulkanSpan<VkImageLayout> copySrcLayouts
	{
		[Inline] get => .(copySrcLayoutCount, pCopySrcLayouts);
		[Inline] set mut { copySrcLayoutCount = value.count; pCopySrcLayouts = value.ptr; }
	}
	public uint32 copyDstLayoutCount;
	public VkImageLayout* pCopyDstLayouts;
	public VulkanSpan<VkImageLayout> copyDstLayouts
	{
		[Inline] get => .(copyDstLayoutCount, pCopyDstLayouts);
		[Inline] set mut { copyDstLayoutCount = value.count; pCopyDstLayouts = value.ptr; }
	}
	public uint8[VK_UUID_SIZE] optimalTilingLayoutUUID;
	public VkBool32 identicalMemoryTypeRequirements;

	public this(void* pNext, VulkanSpan<VkImageLayout> copySrcLayouts, VulkanSpan<VkImageLayout> copyDstLayouts, uint8[VK_UUID_SIZE] optimalTilingLayoutUUID, VkBool32 identicalMemoryTypeRequirements) : this()
	{
		this.pNext = pNext;
		this.copySrcLayouts = copySrcLayouts;
		this.copyDstLayouts = copyDstLayouts;
		this.optimalTilingLayoutUUID = optimalTilingLayoutUUID;
		this.identicalMemoryTypeRequirements = identicalMemoryTypeRequirements;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkHostImageCopyFlagBits : int32
{
	Memcpy = 1 << 0,
	MemcpyEXT = Memcpy,
}

typealias VkHostImageCopyFlags = VkHostImageCopyFlagBits;

[CRepr] struct VkMemoryToImageCopy
{
	public const VkStructureType SType = .VkMemoryToImageCopy;
	public VkStructureType sType = SType;
	public void* pNext;
	public void* pHostPointer;
	public uint32 memoryRowLength; // Specified in texels
	public uint32 memoryImageHeight;
	public VkImageSubresourceLayers imageSubresource;
	public VkOffset3D imageOffset;
	public VkExtent3D imageExtent;

	public this(void* pNext, void* pHostPointer, uint32 memoryRowLength, uint32 memoryImageHeight, VkImageSubresourceLayers imageSubresource, VkOffset3D imageOffset, VkExtent3D imageExtent)
	{
		this.pNext = pNext;
		this.pHostPointer = pHostPointer;
		this.memoryRowLength = memoryRowLength;
		this.memoryImageHeight = memoryImageHeight;
		this.imageSubresource = imageSubresource;
		this.imageOffset = imageOffset;
		this.imageExtent = imageExtent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageToMemoryCopy
{
	public const VkStructureType SType = .VkImageToMemoryCopy;
	public VkStructureType sType = SType;
	public void* pNext;
	public void* pHostPointer;
	public uint32 memoryRowLength; // Specified in texels
	public uint32 memoryImageHeight;
	public VkImageSubresourceLayers imageSubresource;
	public VkOffset3D imageOffset;
	public VkExtent3D imageExtent;

	public this(void* pNext, void* pHostPointer, uint32 memoryRowLength, uint32 memoryImageHeight, VkImageSubresourceLayers imageSubresource, VkOffset3D imageOffset, VkExtent3D imageExtent)
	{
		this.pNext = pNext;
		this.pHostPointer = pHostPointer;
		this.memoryRowLength = memoryRowLength;
		this.memoryImageHeight = memoryImageHeight;
		this.imageSubresource = imageSubresource;
		this.imageOffset = imageOffset;
		this.imageExtent = imageExtent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCopyMemoryToImageInfo
{
	public const VkStructureType SType = .VkCopyMemoryToImageInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkHostImageCopyFlags flags;
	public VkImage dstImage;
	public VkImageLayout dstImageLayout;
	public uint32 regionCount;
	public VkMemoryToImageCopy* pRegions;
	public VulkanSpan<VkMemoryToImageCopy> regions
	{
		[Inline] get => .(regionCount, pRegions);
		[Inline] set mut { regionCount = value.count; pRegions = value.ptr; }
	}

	public this(void* pNext, VkHostImageCopyFlags flags, VkImage dstImage, VkImageLayout dstImageLayout, VulkanSpan<VkMemoryToImageCopy> regions) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.dstImage = dstImage;
		this.dstImageLayout = dstImageLayout;
		this.regions = regions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCopyImageToMemoryInfo
{
	public const VkStructureType SType = .VkCopyImageToMemoryInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkHostImageCopyFlags flags;
	public VkImage srcImage;
	public VkImageLayout srcImageLayout;
	public uint32 regionCount;
	public VkImageToMemoryCopy* pRegions;
	public VulkanSpan<VkImageToMemoryCopy> regions
	{
		[Inline] get => .(regionCount, pRegions);
		[Inline] set mut { regionCount = value.count; pRegions = value.ptr; }
	}

	public this(void* pNext, VkHostImageCopyFlags flags, VkImage srcImage, VkImageLayout srcImageLayout, VulkanSpan<VkImageToMemoryCopy> regions) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.srcImage = srcImage;
		this.srcImageLayout = srcImageLayout;
		this.regions = regions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCopyImageToImageInfo
{
	public const VkStructureType SType = .VkCopyImageToImageInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkHostImageCopyFlags flags;
	public VkImage srcImage;
	public VkImageLayout srcImageLayout;
	public VkImage dstImage;
	public VkImageLayout dstImageLayout;
	public uint32 regionCount;
	public VkImageCopy2* pRegions;
	public VulkanSpan<VkImageCopy2> regions
	{
		[Inline] get => .(regionCount, pRegions);
		[Inline] set mut { regionCount = value.count; pRegions = value.ptr; }
	}

	public this(void* pNext, VkHostImageCopyFlags flags, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, VulkanSpan<VkImageCopy2> regions) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.srcImage = srcImage;
		this.srcImageLayout = srcImageLayout;
		this.dstImage = dstImage;
		this.dstImageLayout = dstImageLayout;
		this.regions = regions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkHostImageLayoutTransitionInfo
{
	public const VkStructureType SType = .VkHostImageLayoutTransitionInfo;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImage image;
	public VkImageLayout oldLayout;
	public VkImageLayout newLayout;
	public VkImageSubresourceRange subresourceRange;

	public this(void* pNext, VkImage image, VkImageLayout oldLayout, VkImageLayout newLayout, VkImageSubresourceRange subresourceRange)
	{
		this.pNext = pNext;
		this.image = image;
		this.oldLayout = oldLayout;
		this.newLayout = newLayout;
		this.subresourceRange = subresourceRange;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSubresourceHostMemcpySize
{
	public const VkStructureType SType = .VkSubresourceHostMemcpySize;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize size; // Specified in bytes
}

[CRepr] struct VkHostImageCopyDevicePerformanceQuery
{
	public const VkStructureType SType = .VkHostImageCopyDevicePerformanceQuery;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 optimalDeviceAccess; // Specifies if device access is optimal
	public VkBool32 identicalMemoryLayout; // Specifies if memory layout is identical
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCopyMemoryToImage(VkDevice device, VkCopyMemoryToImageInfo* pCopyMemoryToImageInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCopyImageToMemory(VkDevice device, VkCopyImageToMemoryInfo* pCopyImageToMemoryInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCopyImageToImage(VkDevice device, VkCopyImageToImageInfo* pCopyImageToImageInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkTransitionImageLayout(VkDevice device, uint32 transitionCount, VkHostImageLayoutTransitionInfo* pTransitions);

static { public const uint32 VK_KHR_SURFACE_SPEC_VERSION = 25; }
static { public const c_char* VK_KHR_SURFACE_EXTENSION_NAME = "VK_KHR_surface"; }

class VkSurfaceKHR { private this() { } }

[AllowDuplicates] enum VkSurfaceTransformFlagBitsKHR : int32
{
	IdentityKHR = 1 << 0,
	Rotate90KHR = 1 << 1,
	Rotate180KHR = 1 << 2,
	Rotate270KHR = 1 << 3,
	HorizontalMirrorKHR = 1 << 4,
	HorizontalMirrorRotate90KHR = 1 << 5,
	HorizontalMirrorRotate180KHR = 1 << 6,
	HorizontalMirrorRotate270KHR = 1 << 7,
	InheritKHR = 1 << 8,
}

[AllowDuplicates] enum VkPresentModeKHR : int32
{
	ImmediateKHR = 0,
	MailboxKHR = 1,
	FifoKHR = 2,
	FifoRelaxedKHR = 3,
	SharedDemandRefreshKHR = 1000111000,
	SharedContinuousRefreshKHR = 1000111001,
	VkPresentModeFifoLatestReadyEXT = FifoLatestReadyKHR,
	FifoLatestReadyKHR = 1000361000,
}

[AllowDuplicates] enum VkColorSpaceKHR : int32
{
	SrgbNonlinearKHR = 0,
	VkColorspaceSrgbNonlinearKHR = SrgbNonlinearKHR,
	VkColorSpaceDisplayP3NonlinearEXT = 1000104001,
	VkColorSpaceExtendedSrgbLinearEXT = 1000104002,
	VkColorSpaceDisplayP3LinearEXT = 1000104003,
	VkColorSpaceDciP3NonlinearEXT = 1000104004,
	VkColorSpaceBt709LinearEXT = 1000104005,
	VkColorSpaceBt709NonlinearEXT = 1000104006,
	VkColorSpaceBt2020LinearEXT = 1000104007,
	VkColorSpaceHdr10St2084EXT = 1000104008,
	VkColorSpaceDolbyvisionEXT = 1000104009,
	VkColorSpaceHdr10HlgEXT = 1000104010,
	VkColorSpaceAdobergbLinearEXT = 1000104011,
	VkColorSpaceAdobergbNonlinearEXT = 1000104012,
	VkColorSpacePassThroughEXT = 1000104013,
	VkColorSpaceExtendedSrgbNonlinearEXT = 1000104014,
	VkColorSpaceDciP3LinearEXT = VkColorSpaceDisplayP3LinearEXT,
	VkColorSpaceDisplayNativeAMD = 1000213000,
}

[AllowDuplicates] enum VkCompositeAlphaFlagBitsKHR : int32
{
	OpaqueKHR = 1 << 0,
	PreMultipliedKHR = 1 << 1,
	PostMultipliedKHR = 1 << 2,
	InheritKHR = 1 << 3,
}

typealias VkCompositeAlphaFlagsKHR = VkCompositeAlphaFlagBitsKHR;

[CRepr] struct VkSurfaceCapabilitiesKHR
{
	public uint32 minImageCount; // Supported minimum number of images for the surface
	public uint32 maxImageCount; // Supported maximum number of images for the surface, 0 for unlimited
	public VkExtent2D currentExtent; // Current image width and height for the surface, (0, 0) if undefined
	public VkExtent2D minImageExtent; // Supported minimum image width and height for the surface
	public VkExtent2D maxImageExtent; // Supported maximum image width and height for the surface
	public uint32 maxImageArrayLayers; // Supported maximum number of image layers for the surface
	public VkSurfaceTransformFlagsKHR supportedTransforms; // 1 or more bits representing the transforms supported
	public VkSurfaceTransformFlagBitsKHR currentTransform; // The surface's current transform relative to the device's natural orientation
	public VkCompositeAlphaFlagsKHR supportedCompositeAlpha; // 1 or more bits representing the alpha compositing modes supported
	public VkImageUsageFlags supportedUsageFlags; // Supported image usage flags for the surface
}

[CRepr] struct VkSurfaceFormatKHR
{
	public VkFormat format; // Supported pair of rendering format
	public VkColorSpaceKHR colorSpace; // and color space for the surface
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32 queueFamilyIndex, VkSurfaceKHR surface, out VkBool32 pSupported);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, out VkSurfaceCapabilitiesKHR pSurfaceCapabilities);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, out uint32 pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, out uint32 pPresentModeCount, VkPresentModeKHR* pPresentModes = null);

static { public const uint32 VK_KHR_SWAPCHAIN_SPEC_VERSION = 70; }
static { public const c_char* VK_KHR_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_swapchain"; }

[AllowDuplicates] enum VkSwapchainCreateFlagBitsKHR : int32
{
	SplitInstanceBindRegionsKHR = 1 << 0, // Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
	ProtectedKHR = 1 << 1, // Swapchain is protected
	MutableFormatKHR = 1 << 2,
	VkSwapchainCreateDeferredMemoryAllocationEXT = DeferredMemoryAllocationKHR,
	PresentId2KHR = 1 << 6, // Allow use of VK_KHR_present_id2 with this swapchain
	PresentWait2KHR = 1 << 7, // Allow use of VK_KHR_present_wait2 with this swapchain
	DeferredMemoryAllocationKHR = 1 << 3,
}

typealias VkSwapchainCreateFlagsKHR = VkSwapchainCreateFlagBitsKHR;

[CRepr] struct VkSwapchainCreateInfoKHR
{
	public const VkStructureType SType = .VkSwapchainCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSwapchainCreateFlagsKHR flags;
	public VkSurfaceKHR surface; // The swapchain's target surface
	public uint32 minImageCount; // Minimum number of presentation images the application needs
	public VkFormat imageFormat; // Format of the presentation images
	public VkColorSpaceKHR imageColorSpace; // Colorspace of the presentation images
	public VkExtent2D imageExtent; // Dimensions of the presentation images
	public uint32 imageArrayLayers; // Determines the number of views for multiview/stereo presentation
	public VkImageUsageFlags imageUsage; // Bits indicating how the presentation images will be used
	public VkSharingMode imageSharingMode; // Sharing mode used for the presentation images
	public uint32 queueFamilyIndexCount; // Number of queue families having access to the images in case of concurrent sharing mode
	public uint32* pQueueFamilyIndices; // Array of queue family indices having access to the images in case of concurrent sharing mode
	public VulkanSpan<uint32> queueFamilyIndices
	{
		[Inline] get => .(queueFamilyIndexCount, pQueueFamilyIndices);
		[Inline] set mut { queueFamilyIndexCount = value.count; pQueueFamilyIndices = value.ptr; }
	} // Array of queue family indices having access to the images in case of concurrent sharing mode
	public VkSurfaceTransformFlagBitsKHR preTransform; // The transform, relative to the device's natural orientation, applied to the image content prior to presentation
	public VkCompositeAlphaFlagBitsKHR compositeAlpha; // The alpha blending mode used when compositing this surface with other surfaces in the window system
	public VkPresentModeKHR presentMode; // Which presentation mode to use for presents on this swap chain
	public VkBool32 clipped; // Specifies whether presentable images may be affected by window clip regions
	public VkSwapchainKHR oldSwapchain; // Existing swap chain to replace, if any

	public this(void* pNext, VkSwapchainCreateFlagsKHR flags, VkSurfaceKHR surface, uint32 minImageCount, VkFormat imageFormat, VkColorSpaceKHR imageColorSpace, VkExtent2D imageExtent, uint32 imageArrayLayers, VkImageUsageFlags imageUsage, VkSharingMode imageSharingMode, VulkanSpan<uint32> queueFamilyIndices, VkSurfaceTransformFlagBitsKHR preTransform, VkCompositeAlphaFlagBitsKHR compositeAlpha, VkPresentModeKHR presentMode, VkBool32 clipped, VkSwapchainKHR oldSwapchain = null) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.surface = surface;
		this.minImageCount = minImageCount;
		this.imageFormat = imageFormat;
		this.imageColorSpace = imageColorSpace;
		this.imageExtent = imageExtent;
		this.imageArrayLayers = imageArrayLayers;
		this.imageUsage = imageUsage;
		this.imageSharingMode = imageSharingMode;
		this.queueFamilyIndices = queueFamilyIndices;
		this.preTransform = preTransform;
		this.compositeAlpha = compositeAlpha;
		this.presentMode = presentMode;
		this.clipped = clipped;
		this.oldSwapchain = oldSwapchain;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

class VkSwapchainKHR { private this() { } }

[CRepr] struct VkPresentInfoKHR
{
	public const VkStructureType SType = .VkPresentInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 waitSemaphoreCount; // Number of semaphores to wait for before presenting
	public VkSemaphore* pWaitSemaphores; // Semaphores to wait for before presenting
	public VulkanSpan<VkSemaphore> waitSemaphores
	{
		[Inline] get => .(waitSemaphoreCount, pWaitSemaphores);
		[Inline] set mut { waitSemaphoreCount = value.count; pWaitSemaphores = value.ptr; }
	} // Semaphores to wait for before presenting
	public uint32 swapchainCount; // Number of swapchains to present in this call
	public VkSwapchainKHR* pSwapchains; // Swapchains to present an image from
	public uint32* pImageIndices; // Indices of which presentable images to present
	public VkResult* pResults; // Optional (i.e. if non-NULL) VkResult for each swapchain
	public VulkanTrioSpan<VkSwapchainKHR, uint32, VkResult> swapchains_imageIndices_results
	{
		[Inline] get => .(swapchainCount, pSwapchains, pImageIndices, pResults);
		[Inline] set mut { swapchainCount = value.count; pSwapchains = value.ptr1; pImageIndices = value.ptr2; pResults = value.ptr3; }
	} // Optional (i.e. if non-NULL) VkResult for each swapchain

	public this(void* pNext, VulkanSpan<VkSemaphore> waitSemaphores, VulkanTrioSpan<VkSwapchainKHR, uint32, VkResult> swapchains_imageIndices_results = .()) : this()
	{
		this.pNext = pNext;
		this.waitSemaphores = waitSemaphores;
		this.swapchains_imageIndices_results = swapchains_imageIndices_results;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateSwapchainKHR(VkDevice device, VkSwapchainCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSwapchainKHR pSwapchain);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, out uint32 pSwapchainImageCount, VkImage* pSwapchainImages = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64 timeout, VkSemaphore semaphore, VkFence fence, out uint32 pImageIndex);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkQueuePresentKHR(VkQueue queue, VkPresentInfoKHR* pPresentInfo);

[CRepr] struct VkImageSwapchainCreateInfoKHR
{
	public const VkStructureType SType = .VkImageSwapchainCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSwapchainKHR swapchain;

	public this(void* pNext = null, VkSwapchainKHR swapchain = null)
	{
		this.pNext = pNext;
		this.swapchain = swapchain;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBindImageMemorySwapchainInfoKHR
{
	public const VkStructureType SType = .VkBindImageMemorySwapchainInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSwapchainKHR swapchain;
	public uint32 imageIndex;

	public this(void* pNext, VkSwapchainKHR swapchain, uint32 imageIndex)
	{
		this.pNext = pNext;
		this.swapchain = swapchain;
		this.imageIndex = imageIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAcquireNextImageInfoKHR
{
	public const VkStructureType SType = .VkAcquireNextImageInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSwapchainKHR swapchain;
	public uint64 timeout;
	public VkSemaphore semaphore;
	public VkFence fence;
	public uint32 deviceMask;

	public this(void* pNext, VkSwapchainKHR swapchain, uint64 timeout, VkSemaphore semaphore, VkFence fence, uint32 deviceMask)
	{
		this.pNext = pNext;
		this.swapchain = swapchain;
		this.timeout = timeout;
		this.semaphore = semaphore;
		this.fence = fence;
		this.deviceMask = deviceMask;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkDeviceGroupPresentModeFlagBitsKHR : int32
{
	LocalKHR = 1 << 0, // Present from local memory
	RemoteKHR = 1 << 1, // Present from remote memory
	SumKHR = 1 << 2, // Present sum of local and/or remote memory
	LocalMultiDeviceKHR = 1 << 3, // Each physical device presents from local memory
}

typealias VkDeviceGroupPresentModeFlagsKHR = VkDeviceGroupPresentModeFlagBitsKHR;

[CRepr] struct VkDeviceGroupPresentCapabilitiesKHR
{
	public const VkStructureType SType = .VkDeviceGroupPresentCapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32[VK_MAX_DEVICE_GROUP_SIZE] presentMask;
	public VkDeviceGroupPresentModeFlagsKHR modes;
}

[CRepr] struct VkDeviceGroupPresentInfoKHR
{
	public const VkStructureType SType = .VkDeviceGroupPresentInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 swapchainCount;
	public uint32* pDeviceMasks;
	public VulkanSpan<uint32> deviceMasks
	{
		[Inline] get => .(swapchainCount, pDeviceMasks);
		[Inline] set mut { swapchainCount = value.count; pDeviceMasks = value.ptr; }
	}
	public VkDeviceGroupPresentModeFlagBitsKHR mode;

	public this(void* pNext, VulkanSpan<uint32> deviceMasks, VkDeviceGroupPresentModeFlagBitsKHR mode) : this()
	{
		this.pNext = pNext;
		this.deviceMasks = deviceMasks;
		this.mode = mode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceGroupSwapchainCreateInfoKHR
{
	public const VkStructureType SType = .VkDeviceGroupSwapchainCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceGroupPresentModeFlagsKHR modes;

	public this(void* pNext, VkDeviceGroupPresentModeFlagsKHR modes)
	{
		this.pNext = pNext;
		this.modes = modes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDeviceGroupPresentCapabilitiesKHR(VkDevice device, out VkDeviceGroupPresentCapabilitiesKHR pDeviceGroupPresentCapabilities);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, out VkDeviceGroupPresentModeFlagsKHR pModes);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, out uint32 pRectCount, VkRect2D* pRects = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkAcquireNextImage2KHR(VkDevice device, VkAcquireNextImageInfoKHR* pAcquireInfo, out uint32 pImageIndex);

static { public const uint32 VK_KHR_DISPLAY_SPEC_VERSION = 23; }
static { public const c_char* VK_KHR_DISPLAY_EXTENSION_NAME = "VK_KHR_display"; }

class VkDisplayKHR { private this() { } }

typealias VkDisplayModeCreateFlagsKHR = VkFlags;

[CRepr] struct VkDisplayModeCreateInfoKHR
{
	public const VkStructureType SType = .VkDisplayModeCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDisplayModeCreateFlagsKHR flags;
	public VkDisplayModeParametersKHR parameters; // The parameters this mode uses.

	public this(void* pNext, VkDisplayModeCreateFlagsKHR flags, VkDisplayModeParametersKHR parameters)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.parameters = parameters;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

class VkDisplayModeKHR { private this() { } }

[CRepr] struct VkDisplayModeParametersKHR
{
	public VkExtent2D visibleRegion; // Visible scanout region.
	public uint32 refreshRate; // Number of times per second the display is updated.

	public this(VkExtent2D visibleRegion, uint32 refreshRate)
	{
		this.visibleRegion = visibleRegion;
		this.refreshRate = refreshRate;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkDisplayModePropertiesKHR
{
	public VkDisplayModeKHR displayMode; // Handle of this display mode.
	public VkDisplayModeParametersKHR parameters; // The parameters this mode uses.
}

[AllowDuplicates] enum VkDisplayPlaneAlphaFlagBitsKHR : int32
{
	OpaqueKHR = 1 << 0,
	GlobalKHR = 1 << 1,
	PerPixelKHR = 1 << 2,
	PerPixelPremultipliedKHR = 1 << 3,
}

typealias VkDisplayPlaneAlphaFlagsKHR = VkDisplayPlaneAlphaFlagBitsKHR;

[CRepr] struct VkDisplayPlaneCapabilitiesKHR
{
	public VkDisplayPlaneAlphaFlagsKHR supportedAlpha; // Types of alpha blending supported, if any.
	public VkOffset2D minSrcPosition; // Does the plane have any position and extent restrictions?
	public VkOffset2D maxSrcPosition;
	public VkExtent2D minSrcExtent;
	public VkExtent2D maxSrcExtent;
	public VkOffset2D minDstPosition;
	public VkOffset2D maxDstPosition;
	public VkExtent2D minDstExtent;
	public VkExtent2D maxDstExtent;
}

[CRepr] struct VkDisplayPlanePropertiesKHR
{
	public VkDisplayKHR currentDisplay; // Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.
	public uint32 currentStackIndex; // Current z-order of the plane.
}

[CRepr] struct VkDisplayPropertiesKHR
{
	public VkDisplayKHR display; // Handle of the display object
	public c_char* displayName; // Name of the display
	public VkExtent2D physicalDimensions; // In millimeters?
	public VkExtent2D physicalResolution; // Max resolution for CRT?
	public VkSurfaceTransformFlagsKHR supportedTransforms; // one or more bits from VkSurfaceTransformFlagsKHR
	public VkBool32 planeReorderPossible; // VK_TRUE if the overlay plane's z-order can be changed on this display.
	public VkBool32 persistentContent; // VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.
}

typealias VkDisplaySurfaceCreateFlagsKHR = VkFlags;

[CRepr] struct VkDisplaySurfaceCreateInfoKHR
{
	public const VkStructureType SType = .VkDisplaySurfaceCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDisplaySurfaceCreateFlagsKHR flags;
	public VkDisplayModeKHR displayMode; // The mode to use when displaying this surface
	public uint32 planeIndex; // The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.
	public uint32 planeStackIndex; // The z-order of the plane.
	public VkSurfaceTransformFlagBitsKHR transform; // Transform to apply to the images as part of the scanout operation
	public float globalAlpha; // Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR
	public VkDisplayPlaneAlphaFlagBitsKHR alphaMode; // The type of alpha blending to use. Must be one of the bits from VkDisplayPlaneCapabilitiesKHR::supportedAlpha for this display plane
	public VkExtent2D imageExtent; // size of the images to use with this surface

	public this(void* pNext, VkDisplaySurfaceCreateFlagsKHR flags, VkDisplayModeKHR displayMode, uint32 planeIndex, uint32 planeStackIndex, VkSurfaceTransformFlagBitsKHR transform, float globalAlpha, VkDisplayPlaneAlphaFlagBitsKHR alphaMode, VkExtent2D imageExtent)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.displayMode = displayMode;
		this.planeIndex = planeIndex;
		this.planeStackIndex = planeStackIndex;
		this.transform = transform;
		this.globalAlpha = globalAlpha;
		this.alphaMode = alphaMode;
		this.imageExtent = imageExtent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkSurfaceTransformFlagsKHR = VkSurfaceTransformFlagBitsKHR;

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, out uint32 pPropertyCount, VkDisplayPropertiesKHR* pProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, out uint32 pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32 planeIndex, out uint32 pDisplayCount, VkDisplayKHR* pDisplays = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, out uint32 pPropertyCount, VkDisplayModePropertiesKHR* pProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, VkDisplayModeCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkDisplayModeKHR pMode);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32 planeIndex, out VkDisplayPlaneCapabilitiesKHR pCapabilities);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateDisplayPlaneSurfaceKHR(VkInstance instance, VkDisplaySurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);

static { public const uint32 VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION = 10; }
static { public const c_char* VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_display_swapchain"; }

[CRepr] struct VkDisplayPresentInfoKHR
{
	public const VkStructureType SType = .VkDisplayPresentInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRect2D srcRect; // Rectangle within the presentable image to read pixel data from when presenting to the display.
	public VkRect2D dstRect; // Rectangle within the current display mode's visible region to display srcRectangle in.
	public VkBool32 persistent; // For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.

	public this(void* pNext, VkRect2D srcRect, VkRect2D dstRect, VkBool32 persistent)
	{
		this.pNext = pNext;
		this.srcRect = srcRect;
		this.dstRect = dstRect;
		this.persistent = persistent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateSharedSwapchainsKHR(VkDevice device, uint32 swapchainCount, VkSwapchainCreateInfoKHR* pCreateInfos, VkAllocationCallbacks* pAllocator, out VkSwapchainKHR pSwapchains);

static { public const uint32 VK_KHR_XLIB_SURFACE_SPEC_VERSION = 6; }
static { public const c_char* VK_KHR_XLIB_SURFACE_EXTENSION_NAME = "VK_KHR_xlib_surface"; }

typealias VkXlibSurfaceCreateFlagsKHR = VkFlags;

[CRepr] struct VkXlibSurfaceCreateInfoKHR
{
	public const VkStructureType SType = .VkXlibSurfaceCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkXlibSurfaceCreateFlagsKHR flags;
	public Display* dpy;
	public Window window;

	public this(void* pNext, VkXlibSurfaceCreateFlagsKHR flags, Display* dpy, Window window)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.dpy = dpy;
		this.window = window;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateXlibSurfaceKHR(VkInstance instance, VkXlibSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);
[CallingConvention(VKAPI_PTR)] function VkBool32 PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32 queueFamilyIndex, out Display dpy, VisualID visualID);

static { public const uint32 VK_KHR_XCB_SURFACE_SPEC_VERSION = 6; }
static { public const c_char* VK_KHR_XCB_SURFACE_EXTENSION_NAME = "VK_KHR_xcb_surface"; }

typealias VkXcbSurfaceCreateFlagsKHR = VkFlags;

[CRepr] struct VkXcbSurfaceCreateInfoKHR
{
	public const VkStructureType SType = .VkXcbSurfaceCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkXcbSurfaceCreateFlagsKHR flags;
	public xcb_connection_t* connection;
	public xcb_window_t window;

	public this(void* pNext, VkXcbSurfaceCreateFlagsKHR flags, xcb_connection_t* connection, xcb_window_t window)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.connection = connection;
		this.window = window;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateXcbSurfaceKHR(VkInstance instance, VkXcbSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);
[CallingConvention(VKAPI_PTR)] function VkBool32 PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32 queueFamilyIndex, out xcb_connection_t connection, xcb_visualid_t visual_id);

static { public const uint32 VK_KHR_WAYLAND_SURFACE_SPEC_VERSION = 6; }
static { public const c_char* VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME = "VK_KHR_wayland_surface"; }

typealias VkWaylandSurfaceCreateFlagsKHR = VkFlags;

[CRepr] struct VkWaylandSurfaceCreateInfoKHR
{
	public const VkStructureType SType = .VkWaylandSurfaceCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkWaylandSurfaceCreateFlagsKHR flags;
	public wl_display* display;
	public wl_surface* surface;

	public this(void* pNext, VkWaylandSurfaceCreateFlagsKHR flags, wl_display* display, wl_surface* surface)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.display = display;
		this.surface = surface;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateWaylandSurfaceKHR(VkInstance instance, VkWaylandSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);
[CallingConvention(VKAPI_PTR)] function VkBool32 PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32 queueFamilyIndex, out wl_display display);

static { public const uint32 VK_KHR_ANDROID_SURFACE_SPEC_VERSION = 6; }
static { public const c_char* VK_KHR_ANDROID_SURFACE_EXTENSION_NAME = "VK_KHR_android_surface"; }

typealias VkAndroidSurfaceCreateFlagsKHR = VkFlags;

[CRepr] struct VkAndroidSurfaceCreateInfoKHR
{
	public const VkStructureType SType = .VkAndroidSurfaceCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAndroidSurfaceCreateFlagsKHR flags;
	public ANativeWindow* window;

	public this(void* pNext, VkAndroidSurfaceCreateFlagsKHR flags, ANativeWindow* window)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.window = window;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateAndroidSurfaceKHR(VkInstance instance, VkAndroidSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);

static { public const uint32 VK_KHR_WIN32_SURFACE_SPEC_VERSION = 6; }
static { public const c_char* VK_KHR_WIN32_SURFACE_EXTENSION_NAME = "VK_KHR_win32_surface"; }

typealias VkWin32SurfaceCreateFlagsKHR = VkFlags;

[CRepr] struct VkWin32SurfaceCreateInfoKHR
{
	public const VkStructureType SType = .VkWin32SurfaceCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkWin32SurfaceCreateFlagsKHR flags;
	public HINSTANCE hinstance;
	public HWND hwnd;

	public this(void* pNext, VkWin32SurfaceCreateFlagsKHR flags, HINSTANCE hinstance, HWND hwnd)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.hinstance = hinstance;
		this.hwnd = hwnd;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateWin32SurfaceKHR(VkInstance instance, VkWin32SurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);
[CallingConvention(VKAPI_PTR)] function VkBool32 PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32 queueFamilyIndex);

static { public const uint32 VK_EXT_DEBUG_REPORT_SPEC_VERSION = 10; }
static { public const c_char* VK_EXT_DEBUG_REPORT_EXTENSION_NAME = "VK_EXT_debug_report"; }

class VkDebugReportCallbackEXT { private this() { } }

[CallingConvention(VKAPI_PTR)] function VkBool32 PFN_vkDebugReportCallbackEXT(VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64 object, c_size location, int32 messageCode, c_char* pLayerPrefix, c_char* pMessage, void* pUserData);

[AllowDuplicates] enum VkDebugReportFlagBitsEXT : int32
{
	InformationEXT = 1 << 0,
	WarningEXT = 1 << 1,
	PerformanceWarningEXT = 1 << 2,
	ErrorEXT = 1 << 3,
	DebugEXT = 1 << 4,
}

typealias VkDebugReportFlagsEXT = VkDebugReportFlagBitsEXT;

[AllowDuplicates] enum VkDebugReportObjectTypeEXT : int32
{
	UnknownEXT = 0,
	InstanceEXT = 1,
	PhysicalDeviceEXT = 2,
	DeviceEXT = 3,
	QueueEXT = 4,
	SemaphoreEXT = 5,
	CommandBufferEXT = 6,
	FenceEXT = 7,
	DeviceMemoryEXT = 8,
	BufferEXT = 9,
	ImageEXT = 10,
	EventEXT = 11,
	QueryPoolEXT = 12,
	BufferViewEXT = 13,
	ImageViewEXT = 14,
	ShaderModuleEXT = 15,
	PipelineCacheEXT = 16,
	PipelineLayoutEXT = 17,
	RenderPassEXT = 18,
	PipelineEXT = 19,
	DescriptorSetLayoutEXT = 20,
	SamplerEXT = 21,
	DescriptorPoolEXT = 22,
	DescriptorSetEXT = 23,
	FramebufferEXT = 24,
	CommandPoolEXT = 25,
	SurfaceKhrEXT = 26,
	SwapchainKhrEXT = 27,
	DebugReportCallbackExtEXT = 28,
	DebugReportEXT = DebugReportCallbackExtEXT,
	DisplayKhrEXT = 29,
	DisplayModeKhrEXT = 30,
	ValidationCacheExtEXT = 33,
	ValidationCacheEXT = ValidationCacheExtEXT,
	SamplerYcbcrConversionEXT = 1000156000,
	DescriptorUpdateTemplateEXT = 1000085000,
	CuModuleNvxEXT = 1000029000,
	CuFunctionNvxEXT = 1000029001,
	DescriptorUpdateTemplateKhrEXT = DescriptorUpdateTemplateEXT,
	AccelerationStructureKhrEXT = 1000150000,
	SamplerYcbcrConversionKhrEXT = SamplerYcbcrConversionEXT,
	AccelerationStructureNvEXT = 1000165000,
	CudaModuleNvEXT = 1000307000,
	CudaFunctionNvEXT = 1000307001,
	BufferCollectionFuchsiaEXT = 1000366000,
}

[CRepr] struct VkDebugReportCallbackCreateInfoEXT
{
	public const VkStructureType SType = .VkDebugReportCallbackCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDebugReportFlagsEXT flags; // Indicates which events call this callback
	public PFN_vkDebugReportCallbackEXT pfnCallback; // Function pointer of a callback function
	public void* pUserData; // Data provided to callback function

	public this(void* pNext, VkDebugReportFlagsEXT flags, PFN_vkDebugReportCallbackEXT pfnCallback, void* pUserData = null)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.pfnCallback = pfnCallback;
		this.pUserData = pUserData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkDebugReportCallbackEXT pCallback);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64 object, c_size location, int32 messageCode, c_char* pLayerPrefix, c_char* pMessage);

static { public const uint32 VK_NV_GLSL_SHADER_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_GLSL_SHADER_EXTENSION_NAME = "VK_NV_glsl_shader"; }
static { public const uint32 VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME = "VK_EXT_depth_range_unrestricted"; }
static { public const uint32 VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION = 3; }
static { public const c_char* VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME = "VK_KHR_sampler_mirror_clamp_to_edge"; }
static { public const uint32 VK_IMG_FILTER_CUBIC_SPEC_VERSION = 1; }
static { public const c_char* VK_IMG_FILTER_CUBIC_EXTENSION_NAME = "VK_IMG_filter_cubic"; }
static { public const uint32 VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME = "VK_AMD_rasterization_order"; }

[AllowDuplicates] enum VkRasterizationOrderAMD : int32
{
	StrictAMD = 0,
	RelaxedAMD = 1,
}

[CRepr] struct VkPipelineRasterizationStateRasterizationOrderAMD
{
	public const VkStructureType SType = .VkPipelineRasterizationStateRasterizationOrderAMD;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRasterizationOrderAMD rasterizationOrder; // Rasterization order to use for the pipeline

	public this(void* pNext, VkRasterizationOrderAMD rasterizationOrder)
	{
		this.pNext = pNext;
		this.rasterizationOrder = rasterizationOrder;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME = "VK_AMD_shader_trinary_minmax"; }
static { public const uint32 VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME = "VK_AMD_shader_explicit_vertex_parameter"; }
static { public const uint32 VK_EXT_DEBUG_MARKER_SPEC_VERSION = 4; }
static { public const c_char* VK_EXT_DEBUG_MARKER_EXTENSION_NAME = "VK_EXT_debug_marker"; }

[CRepr] struct VkDebugMarkerObjectNameInfoEXT
{
	public const VkStructureType SType = .VkDebugMarkerObjectNameInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDebugReportObjectTypeEXT objectType; // The type of the object
	public uint64 object; // The handle of the object, cast to uint64_t
	public c_char* pObjectName; // Name to apply to the object

	public this(void* pNext, VkDebugReportObjectTypeEXT objectType, uint64 object, c_char* pObjectName)
	{
		this.pNext = pNext;
		this.objectType = objectType;
		this.object = object;
		this.pObjectName = pObjectName;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDebugMarkerObjectTagInfoEXT
{
	public const VkStructureType SType = .VkDebugMarkerObjectTagInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDebugReportObjectTypeEXT objectType; // The type of the object
	public uint64 object; // The handle of the object, cast to uint64_t
	public uint64 tagName; // The name of the tag to set on the object
	public c_size tagSize; // The length in bytes of the tag data
	public void* pTag; // Tag data to attach to the object

	public this(void* pNext, VkDebugReportObjectTypeEXT objectType, uint64 object, uint64 tagName, c_size tagSize, void* pTag)
	{
		this.pNext = pNext;
		this.objectType = objectType;
		this.object = object;
		this.tagName = tagName;
		this.tagSize = tagSize;
		this.pTag = pTag;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDebugMarkerMarkerInfoEXT
{
	public const VkStructureType SType = .VkDebugMarkerMarkerInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_char* pMarkerName; // Name of the debug marker
	public float[4] color; // Optional color for debug marker

	public this(void* pNext, c_char* pMarkerName, float[4] color)
	{
		this.pNext = pNext;
		this.pMarkerName = pMarkerName;
		this.color = color;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkDebugMarkerSetObjectTagEXT(VkDevice device, VkDebugMarkerObjectTagInfoEXT* pTagInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkDebugMarkerSetObjectNameEXT(VkDevice device, VkDebugMarkerObjectNameInfoEXT* pNameInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo);

static { public const uint32 VK_KHR_VIDEO_QUEUE_SPEC_VERSION = 8; }
static { public const c_char* VK_KHR_VIDEO_QUEUE_EXTENSION_NAME = "VK_KHR_video_queue"; }

class VkVideoSessionKHR { private this() { } }
class VkVideoSessionParametersKHR { private this() { } }

[AllowDuplicates] enum VkVideoCodecOperationFlagBitsKHR : int32
{
	NoneKHR = 0,
	EncodeH264KHR = 1 << 16,
	EncodeH265KHR = 1 << 17,
	DecodeH264KHR = 1 << 0,
	DecodeH265KHR = 1 << 1,
	DecodeAv1KHR = 1 << 2,
	EncodeAv1KHR = 1 << 18,
	DecodeVp9KHR = 1 << 3,
}

typealias VkVideoCodecOperationFlagsKHR = VkVideoCodecOperationFlagBitsKHR;

[AllowDuplicates] enum VkVideoChromaSubsamplingFlagBitsKHR : int32
{
	InvalidKHR = 0,
	MonochromeKHR = 1 << 0,
	VK_420KHR = 1 << 1,
	VK_422KHR = 1 << 2,
	VK_444KHR = 1 << 3,
}

typealias VkVideoChromaSubsamplingFlagsKHR = VkVideoChromaSubsamplingFlagBitsKHR;

[AllowDuplicates] enum VkVideoComponentBitDepthFlagBitsKHR : int32
{
	InvalidKHR = 0,
	VK_8KHR = 1 << 0,
	VK_10KHR = 1 << 2,
	VK_12KHR = 1 << 4,
}

typealias VkVideoComponentBitDepthFlagsKHR = VkVideoComponentBitDepthFlagBitsKHR;

[AllowDuplicates] enum VkVideoCapabilityFlagBitsKHR : int32
{
	ProtectedContentKHR = 1 << 0,
	SeparateReferenceImagesKHR = 1 << 1,
}

typealias VkVideoCapabilityFlagsKHR = VkVideoCapabilityFlagBitsKHR;

[AllowDuplicates] enum VkVideoSessionCreateFlagBitsKHR : int32
{
	ProtectedContentKHR = 1 << 0,
	AllowEncodeParameterOptimizationsKHR = 1 << 1,
	InlineQueriesKHR = 1 << 2,
	AllowEncodeQuantizationDeltaMapKHR = 1 << 3,
	AllowEncodeEmphasisMapKHR = 1 << 4,
	InlineSessionParametersKHR = 1 << 5,
}

typealias VkVideoSessionCreateFlagsKHR = VkVideoSessionCreateFlagBitsKHR;
typealias VkVideoSessionParametersCreateFlagsKHR = VkVideoSessionParametersCreateFlagBitsKHR;
typealias VkVideoBeginCodingFlagsKHR = VkFlags;
typealias VkVideoEndCodingFlagsKHR = VkFlags;

[AllowDuplicates] enum VkVideoCodingControlFlagBitsKHR : int32
{
	ResetKHR = 1 << 0,
	EncodeRateControlKHR = 1 << 1,
	EncodeQualityLevelKHR = 1 << 2,
}

typealias VkVideoCodingControlFlagsKHR = VkVideoCodingControlFlagBitsKHR;

[CRepr] struct VkQueueFamilyQueryResultStatusPropertiesKHR
{
	public const VkStructureType SType = .VkQueueFamilyQueryResultStatusPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 queryResultStatusSupport;
}

[AllowDuplicates] enum VkQueryResultStatusKHR : int32
{
	ErrorKHR = -1,
	NotReadyKHR = 0,
	CompleteKHR = 1,
	InsufficientBitstreamBufferRangeKHR = -1000299000,
}

[CRepr] struct VkQueueFamilyVideoPropertiesKHR
{
	public const VkStructureType SType = .VkQueueFamilyVideoPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoCodecOperationFlagsKHR videoCodecOperations;
}

[CRepr] struct VkVideoProfileInfoKHR
{
	public const VkStructureType SType = .VkVideoProfileInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoCodecOperationFlagBitsKHR videoCodecOperation;
	public VkVideoChromaSubsamplingFlagsKHR chromaSubsampling;
	public VkVideoComponentBitDepthFlagsKHR lumaBitDepth;
	public VkVideoComponentBitDepthFlagsKHR chromaBitDepth;

	public this(void* pNext, VkVideoCodecOperationFlagBitsKHR videoCodecOperation, VkVideoChromaSubsamplingFlagsKHR chromaSubsampling, VkVideoComponentBitDepthFlagsKHR lumaBitDepth, VkVideoComponentBitDepthFlagsKHR chromaBitDepth = 0)
	{
		this.pNext = pNext;
		this.videoCodecOperation = videoCodecOperation;
		this.chromaSubsampling = chromaSubsampling;
		this.lumaBitDepth = lumaBitDepth;
		this.chromaBitDepth = chromaBitDepth;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoProfileListInfoKHR
{
	public const VkStructureType SType = .VkVideoProfileListInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 profileCount;
	public VkVideoProfileInfoKHR* pProfiles;
	public VulkanSpan<VkVideoProfileInfoKHR> profiles
	{
		[Inline] get => .(profileCount, pProfiles);
		[Inline] set mut { profileCount = value.count; pProfiles = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkVideoProfileInfoKHR> profiles = .()) : this()
	{
		this.pNext = pNext;
		this.profiles = profiles;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoCapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoCapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoCapabilityFlagsKHR flags;
	public VkDeviceSize minBitstreamBufferOffsetAlignment;
	public VkDeviceSize minBitstreamBufferSizeAlignment;
	public VkExtent2D pictureAccessGranularity;
	public VkExtent2D minCodedExtent;
	public VkExtent2D maxCodedExtent;
	public uint32 maxDpbSlots;
	public uint32 maxActiveReferencePictures;
	public VkExtensionProperties stdHeaderVersion;
}

[CRepr] struct VkPhysicalDeviceVideoFormatInfoKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceVideoFormatInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageUsageFlags imageUsage;

	public this(void* pNext, VkImageUsageFlags imageUsage)
	{
		this.pNext = pNext;
		this.imageUsage = imageUsage;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoFormatPropertiesKHR
{
	public const VkStructureType SType = .VkVideoFormatPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat format;
	public VkComponentMapping componentMapping;
	public VkImageCreateFlags imageCreateFlags;
	public VkImageType imageType;
	public VkImageTiling imageTiling;
	public VkImageUsageFlags imageUsageFlags;
}

[CRepr] struct VkVideoPictureResourceInfoKHR
{
	public const VkStructureType SType = .VkVideoPictureResourceInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkOffset2D codedOffset; // The offset to be used for the picture resource, currently only used in field mode
	public VkExtent2D codedExtent; // The extent to be used for the picture resource
	public uint32 baseArrayLayer; // The first array layer to be accessed for the Decode or Encode Operations
	public VkImageView imageViewBinding; // The ImageView binding of the resource

	public this(void* pNext, VkOffset2D codedOffset, VkExtent2D codedExtent, uint32 baseArrayLayer, VkImageView imageViewBinding)
	{
		this.pNext = pNext;
		this.codedOffset = codedOffset;
		this.codedExtent = codedExtent;
		this.baseArrayLayer = baseArrayLayer;
		this.imageViewBinding = imageViewBinding;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoReferenceSlotInfoKHR
{
	public const VkStructureType SType = .VkVideoReferenceSlotInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public int32 slotIndex; // The reference slot index
	public VkVideoPictureResourceInfoKHR* pPictureResource; // The reference picture resource

	public this(void* pNext, int32 slotIndex, VkVideoPictureResourceInfoKHR* pPictureResource = null)
	{
		this.pNext = pNext;
		this.slotIndex = slotIndex;
		this.pPictureResource = pPictureResource;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoSessionMemoryRequirementsKHR
{
	public const VkStructureType SType = .VkVideoSessionMemoryRequirementsKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 memoryBindIndex;
	public VkMemoryRequirements memoryRequirements;
}

[CRepr] struct VkBindVideoSessionMemoryInfoKHR
{
	public const VkStructureType SType = .VkBindVideoSessionMemoryInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 memoryBindIndex;
	public VkDeviceMemory memory;
	public VkDeviceSize memoryOffset;
	public VkDeviceSize memorySize;

	public this(void* pNext, uint32 memoryBindIndex, VkDeviceMemory memory, VkDeviceSize memoryOffset, VkDeviceSize memorySize)
	{
		this.pNext = pNext;
		this.memoryBindIndex = memoryBindIndex;
		this.memory = memory;
		this.memoryOffset = memoryOffset;
		this.memorySize = memorySize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoSessionCreateInfoKHR
{
	public const VkStructureType SType = .VkVideoSessionCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 queueFamilyIndex;
	public VkVideoSessionCreateFlagsKHR flags;
	public VkVideoProfileInfoKHR* pVideoProfile;
	public VkFormat pictureFormat;
	public VkExtent2D maxCodedExtent;
	public VkFormat referencePictureFormat;
	public uint32 maxDpbSlots;
	public uint32 maxActiveReferencePictures;
	public VkExtensionProperties* pStdHeaderVersion;

	public this(void* pNext, uint32 queueFamilyIndex, VkVideoSessionCreateFlagsKHR flags, VkVideoProfileInfoKHR* pVideoProfile, VkFormat pictureFormat, VkExtent2D maxCodedExtent, VkFormat referencePictureFormat, uint32 maxDpbSlots, uint32 maxActiveReferencePictures, VkExtensionProperties* pStdHeaderVersion)
	{
		this.pNext = pNext;
		this.queueFamilyIndex = queueFamilyIndex;
		this.flags = flags;
		this.pVideoProfile = pVideoProfile;
		this.pictureFormat = pictureFormat;
		this.maxCodedExtent = maxCodedExtent;
		this.referencePictureFormat = referencePictureFormat;
		this.maxDpbSlots = maxDpbSlots;
		this.maxActiveReferencePictures = maxActiveReferencePictures;
		this.pStdHeaderVersion = pStdHeaderVersion;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoSessionParametersCreateInfoKHR
{
	public const VkStructureType SType = .VkVideoSessionParametersCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoSessionParametersCreateFlagsKHR flags;
	public VkVideoSessionParametersKHR videoSessionParametersTemplate;
	public VkVideoSessionKHR videoSession;

	public this(void* pNext, VkVideoSessionParametersCreateFlagsKHR flags, VkVideoSessionParametersKHR videoSessionParametersTemplate, VkVideoSessionKHR videoSession)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.videoSessionParametersTemplate = videoSessionParametersTemplate;
		this.videoSession = videoSession;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoSessionParametersUpdateInfoKHR
{
	public const VkStructureType SType = .VkVideoSessionParametersUpdateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 updateSequenceCount;

	public this(void* pNext, uint32 updateSequenceCount)
	{
		this.pNext = pNext;
		this.updateSequenceCount = updateSequenceCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoBeginCodingInfoKHR
{
	public const VkStructureType SType = .VkVideoBeginCodingInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoBeginCodingFlagsKHR flags;
	public VkVideoSessionKHR videoSession;
	public VkVideoSessionParametersKHR videoSessionParameters;
	public uint32 referenceSlotCount;
	public VkVideoReferenceSlotInfoKHR* pReferenceSlots;
	public VulkanSpan<VkVideoReferenceSlotInfoKHR> referenceSlots
	{
		[Inline] get => .(referenceSlotCount, pReferenceSlots);
		[Inline] set mut { referenceSlotCount = value.count; pReferenceSlots = value.ptr; }
	}

	public this(void* pNext, VkVideoBeginCodingFlagsKHR flags, VkVideoSessionKHR videoSession, VkVideoSessionParametersKHR videoSessionParameters = null, VulkanSpan<VkVideoReferenceSlotInfoKHR> referenceSlots = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.videoSession = videoSession;
		this.videoSessionParameters = videoSessionParameters;
		this.referenceSlots = referenceSlots;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEndCodingInfoKHR
{
	public const VkStructureType SType = .VkVideoEndCodingInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEndCodingFlagsKHR flags;

	public this(void* pNext = null, VkVideoEndCodingFlagsKHR flags = 0)
	{
		this.pNext = pNext;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoCodingControlInfoKHR
{
	public const VkStructureType SType = .VkVideoCodingControlInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoCodingControlFlagsKHR flags;

	public this(void* pNext, VkVideoCodingControlFlagsKHR flags)
	{
		this.pNext = pNext;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkVideoProfileInfoKHR* pVideoProfile, out VkVideoCapabilitiesKHR pCapabilities);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo, out uint32 pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR* pVideoFormatProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateVideoSessionKHR(VkDevice device, VkVideoSessionCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkVideoSessionKHR pVideoSession);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyVideoSessionKHR(VkDevice device, VkVideoSessionKHR videoSession = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession, out uint32 pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkBindVideoSessionMemoryKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32 bindSessionMemoryInfoCount, VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkVideoSessionParametersKHR pVideoSessionParameters);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkUpdateVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer, VkVideoBeginCodingInfoKHR* pBeginInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdEndVideoCodingKHR(VkCommandBuffer commandBuffer, VkVideoEndCodingInfoKHR* pEndCodingInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdControlVideoCodingKHR(VkCommandBuffer commandBuffer, VkVideoCodingControlInfoKHR* pCodingControlInfo);

static { public const uint32 VK_KHR_VIDEO_DECODE_QUEUE_SPEC_VERSION = 8; }
static { public const c_char* VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME = "VK_KHR_video_decode_queue"; }

[AllowDuplicates] enum VkVideoDecodeCapabilityFlagBitsKHR : int32
{
	DpbAndOutputCoincideKHR = 1 << 0,
	DpbAndOutputDistinctKHR = 1 << 1,
}

typealias VkVideoDecodeCapabilityFlagsKHR = VkVideoDecodeCapabilityFlagBitsKHR;

[CRepr] struct VkVideoDecodeCapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoDecodeCapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoDecodeCapabilityFlagsKHR flags;
}

[AllowDuplicates] enum VkVideoDecodeUsageFlagBitsKHR : int32
{
	DefaultKHR = 0,
	TranscodingKHR = 1 << 0,
	OfflineKHR = 1 << 1,
	StreamingKHR = 1 << 2,
}

typealias VkVideoDecodeUsageFlagsKHR = VkVideoDecodeUsageFlagBitsKHR;

[CRepr] struct VkVideoDecodeUsageInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeUsageInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoDecodeUsageFlagsKHR videoUsageHints;

	public this(void* pNext = null, VkVideoDecodeUsageFlagsKHR videoUsageHints = 0)
	{
		this.pNext = pNext;
		this.videoUsageHints = videoUsageHints;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkVideoDecodeFlagsKHR = VkFlags;

[CRepr] struct VkVideoDecodeInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoDecodeFlagsKHR flags;
	public VkBuffer srcBuffer;
	public VkDeviceSize srcBufferOffset;
	public VkDeviceSize srcBufferRange;
	public VkVideoPictureResourceInfoKHR dstPictureResource;
	public VkVideoReferenceSlotInfoKHR* pSetupReferenceSlot;
	public uint32 referenceSlotCount;
	public VkVideoReferenceSlotInfoKHR* pReferenceSlots;
	public VulkanSpan<VkVideoReferenceSlotInfoKHR> referenceSlots
	{
		[Inline] get => .(referenceSlotCount, pReferenceSlots);
		[Inline] set mut { referenceSlotCount = value.count; pReferenceSlots = value.ptr; }
	}

	public this(void* pNext, VkVideoDecodeFlagsKHR flags, VkBuffer srcBuffer, VkDeviceSize srcBufferOffset, VkDeviceSize srcBufferRange, VkVideoPictureResourceInfoKHR dstPictureResource, VkVideoReferenceSlotInfoKHR* pSetupReferenceSlot = null, VulkanSpan<VkVideoReferenceSlotInfoKHR> referenceSlots = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.srcBuffer = srcBuffer;
		this.srcBufferOffset = srcBufferOffset;
		this.srcBufferRange = srcBufferRange;
		this.dstPictureResource = dstPictureResource;
		this.pSetupReferenceSlot = pSetupReferenceSlot;
		this.referenceSlots = referenceSlots;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDecodeVideoKHR(VkCommandBuffer commandBuffer, VkVideoDecodeInfoKHR* pDecodeInfo);

static { public const uint32 VK_AMD_GCN_SHADER_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_GCN_SHADER_EXTENSION_NAME = "VK_AMD_gcn_shader"; }
static { public const uint32 VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME = "VK_NV_dedicated_allocation"; }

[CRepr] struct VkDedicatedAllocationImageCreateInfoNV
{
	public const VkStructureType SType = .VkDedicatedAllocationImageCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 dedicatedAllocation; // Whether this image uses a dedicated allocation

	public this(void* pNext, VkBool32 dedicatedAllocation)
	{
		this.pNext = pNext;
		this.dedicatedAllocation = dedicatedAllocation;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDedicatedAllocationBufferCreateInfoNV
{
	public const VkStructureType SType = .VkDedicatedAllocationBufferCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 dedicatedAllocation; // Whether this buffer uses a dedicated allocation

	public this(void* pNext, VkBool32 dedicatedAllocation)
	{
		this.pNext = pNext;
		this.dedicatedAllocation = dedicatedAllocation;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDedicatedAllocationMemoryAllocateInfoNV
{
	public const VkStructureType SType = .VkDedicatedAllocationMemoryAllocateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImage image; // Image that this allocation will be bound to
	public VkBuffer buffer; // Buffer that this allocation will be bound to

	public this(void* pNext = null, VkImage image = null, VkBuffer buffer = null)
	{
		this.pNext = pNext;
		this.image = image;
		this.buffer = buffer;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME = "VK_EXT_transform_feedback"; }

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32 firstBinding, uint32 bindingCount, VkBuffer* pBuffers, VkDeviceSize* pOffsets, VkDeviceSize* pSizes = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32 firstCounterBuffer, uint32 counterBufferCount = 0, VkBuffer* pCounterBuffers = null, VkDeviceSize* pCounterBufferOffsets = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32 firstCounterBuffer, uint32 counterBufferCount = 0, VkBuffer* pCounterBuffers = null, VkDeviceSize* pCounterBufferOffsets = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32 query, VkQueryControlFlags flags, uint32 index);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32 query, uint32 index);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32 instanceCount, uint32 firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32 counterOffset, uint32 vertexStride);

[CRepr] struct VkPhysicalDeviceTransformFeedbackFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceTransformFeedbackFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 transformFeedback;
	public VkBool32 geometryStreams;

	public this(void* pNext, VkBool32 transformFeedback, VkBool32 geometryStreams)
	{
		this.pNext = pNext;
		this.transformFeedback = transformFeedback;
		this.geometryStreams = geometryStreams;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceTransformFeedbackPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceTransformFeedbackPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxTransformFeedbackStreams;
	public uint32 maxTransformFeedbackBuffers;
	public VkDeviceSize maxTransformFeedbackBufferSize;
	public uint32 maxTransformFeedbackStreamDataSize;
	public uint32 maxTransformFeedbackBufferDataSize;
	public uint32 maxTransformFeedbackBufferDataStride;
	public VkBool32 transformFeedbackQueries;
	public VkBool32 transformFeedbackStreamsLinesTriangles;
	public VkBool32 transformFeedbackRasterizationStreamSelect;
	public VkBool32 transformFeedbackDraw;
}

[CRepr] struct VkPipelineRasterizationStateStreamCreateInfoEXT
{
	public const VkStructureType SType = .VkPipelineRasterizationStateStreamCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineRasterizationStateStreamCreateFlagsEXT flags;
	public uint32 rasterizationStream;

	public this(void* pNext, VkPipelineRasterizationStateStreamCreateFlagsEXT flags, uint32 rasterizationStream)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.rasterizationStream = rasterizationStream;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineRasterizationStateStreamCreateFlagsEXT = VkFlags;

static { public const uint32 VK_NVX_BINARY_IMPORT_SPEC_VERSION = 2; }
static { public const c_char* VK_NVX_BINARY_IMPORT_EXTENSION_NAME = "VK_NVX_binary_import"; }

class VkCuModuleNVX { private this() { } }
class VkCuFunctionNVX { private this() { } }

[CRepr] struct VkCuModuleCreateInfoNVX
{
	public const VkStructureType SType = .VkCuModuleCreateInfoNVX;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_size dataSize;
	public void* pData;

	public this(void* pNext, c_size dataSize, void* pData)
	{
		this.pNext = pNext;
		this.dataSize = dataSize;
		this.pData = pData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCuModuleTexturingModeCreateInfoNVX
{
	public const VkStructureType SType = .VkCuModuleTexturingModeCreateInfoNVX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 use64bitTexturing;

	public this(void* pNext, VkBool32 use64bitTexturing)
	{
		this.pNext = pNext;
		this.use64bitTexturing = use64bitTexturing;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCuFunctionCreateInfoNVX
{
	public const VkStructureType SType = .VkCuFunctionCreateInfoNVX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkCuModuleNVX module;
	public c_char* pName;

	public this(void* pNext, VkCuModuleNVX module, c_char* pName)
	{
		this.pNext = pNext;
		this.module = module;
		this.pName = pName;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCuLaunchInfoNVX
{
	public const VkStructureType SType = .VkCuLaunchInfoNVX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkCuFunctionNVX @function;
	public uint32 gridDimX;
	public uint32 gridDimY;
	public uint32 gridDimZ;
	public uint32 blockDimX;
	public uint32 blockDimY;
	public uint32 blockDimZ;
	public uint32 sharedMemBytes;
	public c_size paramCount;
	public void** pParams;
	public c_size extraCount;
	public void** pExtras;

	public this(void* pNext, VkCuFunctionNVX @function, uint32 gridDimX, uint32 gridDimY, uint32 gridDimZ, uint32 blockDimX, uint32 blockDimY, uint32 blockDimZ, uint32 sharedMemBytes, c_size paramCount, void** pParams, c_size extraCount, void** pExtras)
	{
		this.pNext = pNext;
		this.@function = @function;
		this.gridDimX = gridDimX;
		this.gridDimY = gridDimY;
		this.gridDimZ = gridDimZ;
		this.blockDimX = blockDimX;
		this.blockDimY = blockDimY;
		this.blockDimZ = blockDimZ;
		this.sharedMemBytes = sharedMemBytes;
		this.paramCount = paramCount;
		this.pParams = pParams;
		this.extraCount = extraCount;
		this.pExtras = pExtras;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateCuModuleNVX(VkDevice device, VkCuModuleCreateInfoNVX* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkCuModuleNVX pModule);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateCuFunctionNVX(VkDevice device, VkCuFunctionCreateInfoNVX* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkCuFunctionNVX pFunction);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyCuModuleNVX(VkDevice device, VkCuModuleNVX module, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyCuFunctionNVX(VkDevice device, VkCuFunctionNVX @function, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCuLaunchKernelNVX(VkCommandBuffer commandBuffer, VkCuLaunchInfoNVX* pLaunchInfo);

static { public const uint32 VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION = 3; }
static { public const c_char* VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME = "VK_NVX_image_view_handle"; }

[CRepr] struct VkImageViewHandleInfoNVX
{
	public const VkStructureType SType = .VkImageViewHandleInfoNVX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageView imageView;
	public VkDescriptorType descriptorType;
	public VkSampler sampler;

	public this(void* pNext, VkImageView imageView, VkDescriptorType descriptorType, VkSampler sampler = null)
	{
		this.pNext = pNext;
		this.imageView = imageView;
		this.descriptorType = descriptorType;
		this.sampler = sampler;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageViewAddressPropertiesNVX
{
	public const VkStructureType SType = .VkImageViewAddressPropertiesNVX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceAddress deviceAddress;
	public VkDeviceSize size;
}

[CallingConvention(VKAPI_PTR)] function uint32 PFN_vkGetImageViewHandleNVX(VkDevice device, VkImageViewHandleInfoNVX* pInfo);
[CallingConvention(VKAPI_PTR)] function uint64 PFN_vkGetImageViewHandle64NVX(VkDevice device, VkImageViewHandleInfoNVX* pInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetImageViewAddressNVX(VkDevice device, VkImageView imageView, out VkImageViewAddressPropertiesNVX pProperties);

static { public const uint32 VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION = 2; }
static { public const c_char* VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME = "VK_AMD_draw_indirect_count"; }
static { public const uint32 VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME = "VK_AMD_negative_viewport_height"; }
static { public const uint32 VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION = 2; }
static { public const c_char* VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME = "VK_AMD_gpu_shader_half_float"; }
static { public const uint32 VK_AMD_SHADER_BALLOT_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_SHADER_BALLOT_EXTENSION_NAME = "VK_AMD_shader_ballot"; }
static { public const uint32 VK_KHR_VIDEO_ENCODE_H264_SPEC_VERSION = 14; }
static { public const c_char* VK_KHR_VIDEO_ENCODE_H264_EXTENSION_NAME = "VK_KHR_video_encode_h264"; }

[AllowDuplicates] enum VkVideoEncodeH264CapabilityFlagBitsKHR : int32
{
	HrdComplianceKHR = 1 << 0,
	PredictionWeightTableGeneratedKHR = 1 << 1,
	RowUnalignedSliceKHR = 1 << 2,
	DifferentSliceTypeKHR = 1 << 3,
	BFrameInL0ListKHR = 1 << 4,
	BFrameInL1ListKHR = 1 << 5,
	PerPictureTypeMinMaxQpKHR = 1 << 6,
	PerSliceConstantQpKHR = 1 << 7,
	GeneratePrefixNaluKHR = 1 << 8,
	BPictureIntraRefreshKHR = 1 << 10,
	MbQpDiffWraparoundKHR = 1 << 9,
}

typealias VkVideoEncodeH264CapabilityFlagsKHR = VkVideoEncodeH264CapabilityFlagBitsKHR;

[AllowDuplicates] enum VkVideoEncodeH264StdFlagBitsKHR : int32
{
	SeparateColorPlaneFlagSetKHR = 1 << 0,
	QpprimeYZeroTransformBypassFlagSetKHR = 1 << 1,
	ScalingMatrixPresentFlagSetKHR = 1 << 2,
	ChromaQpIndexOffsetKHR = 1 << 3,
	SecondChromaQpIndexOffsetKHR = 1 << 4,
	PicInitQpMinus26KHR = 1 << 5,
	WeightedPredFlagSetKHR = 1 << 6,
	WeightedBipredIdcExplicitKHR = 1 << 7,
	WeightedBipredIdcImplicitKHR = 1 << 8,
	Transform8x8ModeFlagSetKHR = 1 << 9,
	DirectSpatialMvPredFlagUnsetKHR = 1 << 10,
	EntropyCodingModeFlagUnsetKHR = 1 << 11,
	EntropyCodingModeFlagSetKHR = 1 << 12,
	Direct8x8InferenceFlagUnsetKHR = 1 << 13,
	ConstrainedIntraPredFlagSetKHR = 1 << 14,
	DeblockingFilterDisabledKHR = 1 << 15,
	DeblockingFilterEnabledKHR = 1 << 16,
	DeblockingFilterPartialKHR = 1 << 17,
	SliceQpDeltaKHR = 1 << 19,
	DifferentSliceQpDeltaKHR = 1 << 20,
}

typealias VkVideoEncodeH264StdFlagsKHR = VkVideoEncodeH264StdFlagBitsKHR;

[CRepr] struct VkVideoEncodeH264CapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264CapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeH264CapabilityFlagsKHR flags;
	public StdVideoH264LevelIdc maxLevelIdc;
	public uint32 maxSliceCount;
	public uint32 maxPPictureL0ReferenceCount;
	public uint32 maxBPictureL0ReferenceCount;
	public uint32 maxL1ReferenceCount;
	public uint32 maxTemporalLayerCount;
	public VkBool32 expectDyadicTemporalLayerPattern;
	public int32 minQp;
	public int32 maxQp;
	public VkBool32 prefersGopRemainingFrames;
	public VkBool32 requiresGopRemainingFrames;
	public VkVideoEncodeH264StdFlagsKHR stdSyntaxFlags;
}

[CRepr] struct VkVideoEncodeH264QualityLevelPropertiesKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264QualityLevelPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeH264RateControlFlagsKHR preferredRateControlFlags;
	public uint32 preferredGopFrameCount;
	public uint32 preferredIdrPeriod;
	public uint32 preferredConsecutiveBFrameCount;
	public uint32 preferredTemporalLayerCount;
	public VkVideoEncodeH264QpKHR preferredConstantQp;
	public uint32 preferredMaxL0ReferenceCount;
	public uint32 preferredMaxL1ReferenceCount;
	public VkBool32 preferredStdEntropyCodingModeFlag;
}

[CRepr] struct VkVideoEncodeH264SessionCreateInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264SessionCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 useMaxLevelIdc;
	public StdVideoH264LevelIdc maxLevelIdc;

	public this(void* pNext, VkBool32 useMaxLevelIdc, StdVideoH264LevelIdc maxLevelIdc)
	{
		this.pNext = pNext;
		this.useMaxLevelIdc = useMaxLevelIdc;
		this.maxLevelIdc = maxLevelIdc;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH264SessionParametersCreateInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264SessionParametersCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxStdSPSCount;
	public uint32 maxStdPPSCount;
	public VkVideoEncodeH264SessionParametersAddInfoKHR* pParametersAddInfo;

	public this(void* pNext, uint32 maxStdSPSCount, uint32 maxStdPPSCount, VkVideoEncodeH264SessionParametersAddInfoKHR* pParametersAddInfo = null)
	{
		this.pNext = pNext;
		this.maxStdSPSCount = maxStdSPSCount;
		this.maxStdPPSCount = maxStdPPSCount;
		this.pParametersAddInfo = pParametersAddInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH264SessionParametersAddInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264SessionParametersAddInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 stdSPSCount;
	public StdVideoH264SequenceParameterSet* pStdSPSs;
	public VulkanSpan<StdVideoH264SequenceParameterSet> stdSPSs
	{
		[Inline] get => .(stdSPSCount, pStdSPSs);
		[Inline] set mut { stdSPSCount = value.count; pStdSPSs = value.ptr; }
	}
	public uint32 stdPPSCount;
	public StdVideoH264PictureParameterSet* pStdPPSs; // List of Picture Parameters associated with the spsStd, above
	public VulkanSpan<StdVideoH264PictureParameterSet> stdPPSs
	{
		[Inline] get => .(stdPPSCount, pStdPPSs);
		[Inline] set mut { stdPPSCount = value.count; pStdPPSs = value.ptr; }
	} // List of Picture Parameters associated with the spsStd, above

	public this(void* pNext = null, VulkanSpan<StdVideoH264SequenceParameterSet> stdSPSs = .(), VulkanSpan<StdVideoH264PictureParameterSet> stdPPSs = .()) : this()
	{
		this.pNext = pNext;
		this.stdSPSs = stdSPSs;
		this.stdPPSs = stdPPSs;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH264SessionParametersGetInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264SessionParametersGetInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 writeStdSPS;
	public VkBool32 writeStdPPS;
	public uint32 stdSPSId;
	public uint32 stdPPSId;

	public this(void* pNext, VkBool32 writeStdSPS, VkBool32 writeStdPPS, uint32 stdSPSId, uint32 stdPPSId)
	{
		this.pNext = pNext;
		this.writeStdSPS = writeStdSPS;
		this.writeStdPPS = writeStdPPS;
		this.stdSPSId = stdSPSId;
		this.stdPPSId = stdPPSId;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH264SessionParametersFeedbackInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264SessionParametersFeedbackInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 hasStdSPSOverrides;
	public VkBool32 hasStdPPSOverrides;
}

[CRepr] struct VkVideoEncodeH264PictureInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264PictureInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 naluSliceEntryCount;
	public VkVideoEncodeH264NaluSliceInfoKHR* pNaluSliceEntries;
	public VulkanSpan<VkVideoEncodeH264NaluSliceInfoKHR> naluSliceEntries
	{
		[Inline] get => .(naluSliceEntryCount, pNaluSliceEntries);
		[Inline] set mut { naluSliceEntryCount = value.count; pNaluSliceEntries = value.ptr; }
	}
	public StdVideoEncodeH264PictureInfo* pStdPictureInfo;
	public VkBool32 generatePrefixNalu;

	public this(void* pNext, VulkanSpan<VkVideoEncodeH264NaluSliceInfoKHR> naluSliceEntries, StdVideoEncodeH264PictureInfo* pStdPictureInfo, VkBool32 generatePrefixNalu) : this()
	{
		this.pNext = pNext;
		this.naluSliceEntries = naluSliceEntries;
		this.pStdPictureInfo = pStdPictureInfo;
		this.generatePrefixNalu = generatePrefixNalu;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH264DpbSlotInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264DpbSlotInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoEncodeH264ReferenceInfo* pStdReferenceInfo;

	public this(void* pNext, StdVideoEncodeH264ReferenceInfo* pStdReferenceInfo)
	{
		this.pNext = pNext;
		this.pStdReferenceInfo = pStdReferenceInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH264NaluSliceInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264NaluSliceInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public int32 constantQp;
	public StdVideoEncodeH264SliceHeader* pStdSliceHeader;

	public this(void* pNext, int32 constantQp, StdVideoEncodeH264SliceHeader* pStdSliceHeader)
	{
		this.pNext = pNext;
		this.constantQp = constantQp;
		this.pStdSliceHeader = pStdSliceHeader;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH264ProfileInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264ProfileInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoH264ProfileIdc stdProfileIdc;

	public this(void* pNext, StdVideoH264ProfileIdc stdProfileIdc)
	{
		this.pNext = pNext;
		this.stdProfileIdc = stdProfileIdc;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH264RateControlInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264RateControlInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeH264RateControlFlagsKHR flags;
	public uint32 gopFrameCount;
	public uint32 idrPeriod;
	public uint32 consecutiveBFrameCount;
	public uint32 temporalLayerCount;

	public this(void* pNext, VkVideoEncodeH264RateControlFlagsKHR flags, uint32 gopFrameCount, uint32 idrPeriod, uint32 consecutiveBFrameCount, uint32 temporalLayerCount)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.gopFrameCount = gopFrameCount;
		this.idrPeriod = idrPeriod;
		this.consecutiveBFrameCount = consecutiveBFrameCount;
		this.temporalLayerCount = temporalLayerCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkVideoEncodeH264RateControlFlagBitsKHR : int32
{
	AttemptHrdComplianceKHR = 1 << 0,
	RegularGopKHR = 1 << 1,
	ReferencePatternFlatKHR = 1 << 2,
	ReferencePatternDyadicKHR = 1 << 3,
	TemporalLayerPatternDyadicKHR = 1 << 4,
}

typealias VkVideoEncodeH264RateControlFlagsKHR = VkVideoEncodeH264RateControlFlagBitsKHR;

[CRepr] struct VkVideoEncodeH264RateControlLayerInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264RateControlLayerInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 useMinQp;
	public VkVideoEncodeH264QpKHR minQp;
	public VkBool32 useMaxQp;
	public VkVideoEncodeH264QpKHR maxQp;
	public VkBool32 useMaxFrameSize;
	public VkVideoEncodeH264FrameSizeKHR maxFrameSize;

	public this(void* pNext, VkBool32 useMinQp, VkVideoEncodeH264QpKHR minQp, VkBool32 useMaxQp, VkVideoEncodeH264QpKHR maxQp, VkBool32 useMaxFrameSize, VkVideoEncodeH264FrameSizeKHR maxFrameSize)
	{
		this.pNext = pNext;
		this.useMinQp = useMinQp;
		this.minQp = minQp;
		this.useMaxQp = useMaxQp;
		this.maxQp = maxQp;
		this.useMaxFrameSize = useMaxFrameSize;
		this.maxFrameSize = maxFrameSize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH264QpKHR
{
	public int32 qpI;
	public int32 qpP;
	public int32 qpB;

	public this(int32 qpI, int32 qpP, int32 qpB)
	{
		this.qpI = qpI;
		this.qpP = qpP;
		this.qpB = qpB;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkVideoEncodeH264FrameSizeKHR
{
	public uint32 frameISize;
	public uint32 framePSize;
	public uint32 frameBSize;

	public this(uint32 frameISize, uint32 framePSize, uint32 frameBSize)
	{
		this.frameISize = frameISize;
		this.framePSize = framePSize;
		this.frameBSize = frameBSize;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkVideoEncodeH264GopRemainingFrameInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264GopRemainingFrameInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 useGopRemainingFrames;
	public uint32 gopRemainingI;
	public uint32 gopRemainingP;
	public uint32 gopRemainingB;

	public this(void* pNext, VkBool32 useGopRemainingFrames, uint32 gopRemainingI, uint32 gopRemainingP, uint32 gopRemainingB)
	{
		this.pNext = pNext;
		this.useGopRemainingFrames = useGopRemainingFrames;
		this.gopRemainingI = gopRemainingI;
		this.gopRemainingP = gopRemainingP;
		this.gopRemainingB = gopRemainingB;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_VIDEO_ENCODE_H265_SPEC_VERSION = 14; }
static { public const c_char* VK_KHR_VIDEO_ENCODE_H265_EXTENSION_NAME = "VK_KHR_video_encode_h265"; }

[AllowDuplicates] enum VkVideoEncodeH265CapabilityFlagBitsKHR : int32
{
	HrdComplianceKHR = 1 << 0,
	PredictionWeightTableGeneratedKHR = 1 << 1,
	RowUnalignedSliceSegmentKHR = 1 << 2,
	DifferentSliceSegmentTypeKHR = 1 << 3,
	BFrameInL0ListKHR = 1 << 4,
	BFrameInL1ListKHR = 1 << 5,
	PerPictureTypeMinMaxQpKHR = 1 << 6,
	PerSliceSegmentConstantQpKHR = 1 << 7,
	MultipleTilesPerSliceSegmentKHR = 1 << 8,
	MultipleSliceSegmentsPerTileKHR = 1 << 9,
	BPictureIntraRefreshKHR = 1 << 11,
	CuQpDiffWraparoundKHR = 1 << 10,
}

typealias VkVideoEncodeH265CapabilityFlagsKHR = VkVideoEncodeH265CapabilityFlagBitsKHR;

[AllowDuplicates] enum VkVideoEncodeH265StdFlagBitsKHR : int32
{
	SeparateColorPlaneFlagSetKHR = 1 << 0,
	SampleAdaptiveOffsetEnabledFlagSetKHR = 1 << 1,
	ScalingListDataPresentFlagSetKHR = 1 << 2,
	PcmEnabledFlagSetKHR = 1 << 3,
	SpsTemporalMvpEnabledFlagSetKHR = 1 << 4,
	InitQpMinus26KHR = 1 << 5,
	WeightedPredFlagSetKHR = 1 << 6,
	WeightedBipredFlagSetKHR = 1 << 7,
	Log2ParallelMergeLevelMinus2KHR = 1 << 8,
	SignDataHidingEnabledFlagSetKHR = 1 << 9,
	TransformSkipEnabledFlagSetKHR = 1 << 10,
	TransformSkipEnabledFlagUnsetKHR = 1 << 11,
	PpsSliceChromaQpOffsetsPresentFlagSetKHR = 1 << 12,
	TransquantBypassEnabledFlagSetKHR = 1 << 13,
	ConstrainedIntraPredFlagSetKHR = 1 << 14,
	EntropyCodingSyncEnabledFlagSetKHR = 1 << 15,
	DeblockingFilterOverrideEnabledFlagSetKHR = 1 << 16,
	DependentSliceSegmentsEnabledFlagSetKHR = 1 << 17,
	DependentSliceSegmentFlagSetKHR = 1 << 18,
	SliceQpDeltaKHR = 1 << 19,
	DifferentSliceQpDeltaKHR = 1 << 20,
}

typealias VkVideoEncodeH265StdFlagsKHR = VkVideoEncodeH265StdFlagBitsKHR;

[AllowDuplicates] enum VkVideoEncodeH265CtbSizeFlagBitsKHR : int32
{
	VK_16KHR = 1 << 0,
	VK_32KHR = 1 << 1,
	VK_64KHR = 1 << 2,
}

typealias VkVideoEncodeH265CtbSizeFlagsKHR = VkVideoEncodeH265CtbSizeFlagBitsKHR;

[AllowDuplicates] enum VkVideoEncodeH265TransformBlockSizeFlagBitsKHR : int32
{
	VK_4KHR = 1 << 0,
	VK_8KHR = 1 << 1,
	VK_16KHR = 1 << 2,
	VK_32KHR = 1 << 3,
}

typealias VkVideoEncodeH265TransformBlockSizeFlagsKHR = VkVideoEncodeH265TransformBlockSizeFlagBitsKHR;

[CRepr] struct VkVideoEncodeH265CapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265CapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeH265CapabilityFlagsKHR flags;
	public StdVideoH265LevelIdc maxLevelIdc;
	public uint32 maxSliceSegmentCount;
	public VkExtent2D maxTiles;
	public VkVideoEncodeH265CtbSizeFlagsKHR ctbSizes;
	public VkVideoEncodeH265TransformBlockSizeFlagsKHR transformBlockSizes;
	public uint32 maxPPictureL0ReferenceCount;
	public uint32 maxBPictureL0ReferenceCount;
	public uint32 maxL1ReferenceCount;
	public uint32 maxSubLayerCount;
	public VkBool32 expectDyadicTemporalSubLayerPattern;
	public int32 minQp;
	public int32 maxQp;
	public VkBool32 prefersGopRemainingFrames;
	public VkBool32 requiresGopRemainingFrames;
	public VkVideoEncodeH265StdFlagsKHR stdSyntaxFlags;
}

[CRepr] struct VkVideoEncodeH265SessionCreateInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265SessionCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 useMaxLevelIdc;
	public StdVideoH265LevelIdc maxLevelIdc;

	public this(void* pNext, VkBool32 useMaxLevelIdc, StdVideoH265LevelIdc maxLevelIdc)
	{
		this.pNext = pNext;
		this.useMaxLevelIdc = useMaxLevelIdc;
		this.maxLevelIdc = maxLevelIdc;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH265QualityLevelPropertiesKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265QualityLevelPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeH265RateControlFlagsKHR preferredRateControlFlags;
	public uint32 preferredGopFrameCount;
	public uint32 preferredIdrPeriod;
	public uint32 preferredConsecutiveBFrameCount;
	public uint32 preferredSubLayerCount;
	public VkVideoEncodeH265QpKHR preferredConstantQp;
	public uint32 preferredMaxL0ReferenceCount;
	public uint32 preferredMaxL1ReferenceCount;
}

[CRepr] struct VkVideoEncodeH265SessionParametersCreateInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265SessionParametersCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxStdVPSCount;
	public uint32 maxStdSPSCount;
	public uint32 maxStdPPSCount;
	public VkVideoEncodeH265SessionParametersAddInfoKHR* pParametersAddInfo;

	public this(void* pNext, uint32 maxStdVPSCount, uint32 maxStdSPSCount, uint32 maxStdPPSCount, VkVideoEncodeH265SessionParametersAddInfoKHR* pParametersAddInfo = null)
	{
		this.pNext = pNext;
		this.maxStdVPSCount = maxStdVPSCount;
		this.maxStdSPSCount = maxStdSPSCount;
		this.maxStdPPSCount = maxStdPPSCount;
		this.pParametersAddInfo = pParametersAddInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH265SessionParametersAddInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265SessionParametersAddInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 stdVPSCount;
	public StdVideoH265VideoParameterSet* pStdVPSs;
	public VulkanSpan<StdVideoH265VideoParameterSet> stdVPSs
	{
		[Inline] get => .(stdVPSCount, pStdVPSs);
		[Inline] set mut { stdVPSCount = value.count; pStdVPSs = value.ptr; }
	}
	public uint32 stdSPSCount;
	public StdVideoH265SequenceParameterSet* pStdSPSs;
	public VulkanSpan<StdVideoH265SequenceParameterSet> stdSPSs
	{
		[Inline] get => .(stdSPSCount, pStdSPSs);
		[Inline] set mut { stdSPSCount = value.count; pStdSPSs = value.ptr; }
	}
	public uint32 stdPPSCount;
	public StdVideoH265PictureParameterSet* pStdPPSs; // List of Picture Parameters associated with the spsStd, above
	public VulkanSpan<StdVideoH265PictureParameterSet> stdPPSs
	{
		[Inline] get => .(stdPPSCount, pStdPPSs);
		[Inline] set mut { stdPPSCount = value.count; pStdPPSs = value.ptr; }
	} // List of Picture Parameters associated with the spsStd, above

	public this(void* pNext = null, VulkanSpan<StdVideoH265VideoParameterSet> stdVPSs = .(), VulkanSpan<StdVideoH265SequenceParameterSet> stdSPSs = .(), VulkanSpan<StdVideoH265PictureParameterSet> stdPPSs = .()) : this()
	{
		this.pNext = pNext;
		this.stdVPSs = stdVPSs;
		this.stdSPSs = stdSPSs;
		this.stdPPSs = stdPPSs;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH265SessionParametersGetInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265SessionParametersGetInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 writeStdVPS;
	public VkBool32 writeStdSPS;
	public VkBool32 writeStdPPS;
	public uint32 stdVPSId;
	public uint32 stdSPSId;
	public uint32 stdPPSId;

	public this(void* pNext, VkBool32 writeStdVPS, VkBool32 writeStdSPS, VkBool32 writeStdPPS, uint32 stdVPSId, uint32 stdSPSId, uint32 stdPPSId)
	{
		this.pNext = pNext;
		this.writeStdVPS = writeStdVPS;
		this.writeStdSPS = writeStdSPS;
		this.writeStdPPS = writeStdPPS;
		this.stdVPSId = stdVPSId;
		this.stdSPSId = stdSPSId;
		this.stdPPSId = stdPPSId;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH265SessionParametersFeedbackInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265SessionParametersFeedbackInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 hasStdVPSOverrides;
	public VkBool32 hasStdSPSOverrides;
	public VkBool32 hasStdPPSOverrides;
}

[CRepr] struct VkVideoEncodeH265PictureInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265PictureInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 naluSliceSegmentEntryCount;
	public VkVideoEncodeH265NaluSliceSegmentInfoKHR* pNaluSliceSegmentEntries;
	public VulkanSpan<VkVideoEncodeH265NaluSliceSegmentInfoKHR> naluSliceSegmentEntries
	{
		[Inline] get => .(naluSliceSegmentEntryCount, pNaluSliceSegmentEntries);
		[Inline] set mut { naluSliceSegmentEntryCount = value.count; pNaluSliceSegmentEntries = value.ptr; }
	}
	public StdVideoEncodeH265PictureInfo* pStdPictureInfo;

	public this(void* pNext, VulkanSpan<VkVideoEncodeH265NaluSliceSegmentInfoKHR> naluSliceSegmentEntries, StdVideoEncodeH265PictureInfo* pStdPictureInfo) : this()
	{
		this.pNext = pNext;
		this.naluSliceSegmentEntries = naluSliceSegmentEntries;
		this.pStdPictureInfo = pStdPictureInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH265DpbSlotInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265DpbSlotInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoEncodeH265ReferenceInfo* pStdReferenceInfo;

	public this(void* pNext, StdVideoEncodeH265ReferenceInfo* pStdReferenceInfo)
	{
		this.pNext = pNext;
		this.pStdReferenceInfo = pStdReferenceInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH265NaluSliceSegmentInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265NaluSliceSegmentInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public int32 constantQp;
	public StdVideoEncodeH265SliceSegmentHeader* pStdSliceSegmentHeader;

	public this(void* pNext, int32 constantQp, StdVideoEncodeH265SliceSegmentHeader* pStdSliceSegmentHeader)
	{
		this.pNext = pNext;
		this.constantQp = constantQp;
		this.pStdSliceSegmentHeader = pStdSliceSegmentHeader;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH265ProfileInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265ProfileInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoH265ProfileIdc stdProfileIdc;

	public this(void* pNext, StdVideoH265ProfileIdc stdProfileIdc)
	{
		this.pNext = pNext;
		this.stdProfileIdc = stdProfileIdc;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH265RateControlInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265RateControlInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeH265RateControlFlagsKHR flags;
	public uint32 gopFrameCount;
	public uint32 idrPeriod;
	public uint32 consecutiveBFrameCount;
	public uint32 subLayerCount;

	public this(void* pNext, VkVideoEncodeH265RateControlFlagsKHR flags, uint32 gopFrameCount, uint32 idrPeriod, uint32 consecutiveBFrameCount, uint32 subLayerCount)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.gopFrameCount = gopFrameCount;
		this.idrPeriod = idrPeriod;
		this.consecutiveBFrameCount = consecutiveBFrameCount;
		this.subLayerCount = subLayerCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkVideoEncodeH265RateControlFlagBitsKHR : int32
{
	AttemptHrdComplianceKHR = 1 << 0,
	RegularGopKHR = 1 << 1,
	ReferencePatternFlatKHR = 1 << 2,
	ReferencePatternDyadicKHR = 1 << 3,
	TemporalSubLayerPatternDyadicKHR = 1 << 4,
}

typealias VkVideoEncodeH265RateControlFlagsKHR = VkVideoEncodeH265RateControlFlagBitsKHR;

[CRepr] struct VkVideoEncodeH265RateControlLayerInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265RateControlLayerInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 useMinQp;
	public VkVideoEncodeH265QpKHR minQp;
	public VkBool32 useMaxQp;
	public VkVideoEncodeH265QpKHR maxQp;
	public VkBool32 useMaxFrameSize;
	public VkVideoEncodeH265FrameSizeKHR maxFrameSize;

	public this(void* pNext, VkBool32 useMinQp, VkVideoEncodeH265QpKHR minQp, VkBool32 useMaxQp, VkVideoEncodeH265QpKHR maxQp, VkBool32 useMaxFrameSize, VkVideoEncodeH265FrameSizeKHR maxFrameSize)
	{
		this.pNext = pNext;
		this.useMinQp = useMinQp;
		this.minQp = minQp;
		this.useMaxQp = useMaxQp;
		this.maxQp = maxQp;
		this.useMaxFrameSize = useMaxFrameSize;
		this.maxFrameSize = maxFrameSize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH265QpKHR
{
	public int32 qpI;
	public int32 qpP;
	public int32 qpB;

	public this(int32 qpI, int32 qpP, int32 qpB)
	{
		this.qpI = qpI;
		this.qpP = qpP;
		this.qpB = qpB;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkVideoEncodeH265FrameSizeKHR
{
	public uint32 frameISize;
	public uint32 framePSize;
	public uint32 frameBSize;

	public this(uint32 frameISize, uint32 framePSize, uint32 frameBSize)
	{
		this.frameISize = frameISize;
		this.framePSize = framePSize;
		this.frameBSize = frameBSize;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkVideoEncodeH265GopRemainingFrameInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265GopRemainingFrameInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 useGopRemainingFrames;
	public uint32 gopRemainingI;
	public uint32 gopRemainingP;
	public uint32 gopRemainingB;

	public this(void* pNext, VkBool32 useGopRemainingFrames, uint32 gopRemainingI, uint32 gopRemainingP, uint32 gopRemainingB)
	{
		this.pNext = pNext;
		this.useGopRemainingFrames = useGopRemainingFrames;
		this.gopRemainingI = gopRemainingI;
		this.gopRemainingP = gopRemainingP;
		this.gopRemainingB = gopRemainingB;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_VIDEO_DECODE_H264_SPEC_VERSION = 9; }
static { public const c_char* VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME = "VK_KHR_video_decode_h264"; }

[AllowDuplicates] enum VkVideoDecodeH264PictureLayoutFlagBitsKHR : int32
{
	ProgressiveKHR = 0,
	InterlacedInterleavedLinesKHR = 1 << 0,
	InterlacedSeparatePlanesKHR = 1 << 1,
}

typealias VkVideoDecodeH264PictureLayoutFlagsKHR = VkVideoDecodeH264PictureLayoutFlagBitsKHR;

[CRepr] struct VkVideoDecodeH264ProfileInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeH264ProfileInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoH264ProfileIdc stdProfileIdc;
	public VkVideoDecodeH264PictureLayoutFlagBitsKHR pictureLayout;

	public this(void* pNext, StdVideoH264ProfileIdc stdProfileIdc, VkVideoDecodeH264PictureLayoutFlagBitsKHR pictureLayout = 0)
	{
		this.pNext = pNext;
		this.stdProfileIdc = stdProfileIdc;
		this.pictureLayout = pictureLayout;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeH264CapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoDecodeH264CapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoH264LevelIdc maxLevelIdc;
	public VkOffset2D fieldOffsetGranularity;
}

[CRepr] struct VkVideoDecodeH264SessionParametersCreateInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeH264SessionParametersCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxStdSPSCount;
	public uint32 maxStdPPSCount;
	public VkVideoDecodeH264SessionParametersAddInfoKHR* pParametersAddInfo;

	public this(void* pNext, uint32 maxStdSPSCount, uint32 maxStdPPSCount, VkVideoDecodeH264SessionParametersAddInfoKHR* pParametersAddInfo = null)
	{
		this.pNext = pNext;
		this.maxStdSPSCount = maxStdSPSCount;
		this.maxStdPPSCount = maxStdPPSCount;
		this.pParametersAddInfo = pParametersAddInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeH264SessionParametersAddInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeH264SessionParametersAddInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 stdSPSCount;
	public StdVideoH264SequenceParameterSet* pStdSPSs;
	public VulkanSpan<StdVideoH264SequenceParameterSet> stdSPSs
	{
		[Inline] get => .(stdSPSCount, pStdSPSs);
		[Inline] set mut { stdSPSCount = value.count; pStdSPSs = value.ptr; }
	}
	public uint32 stdPPSCount;
	public StdVideoH264PictureParameterSet* pStdPPSs; // List of Picture Parameters associated with the spsStd, above
	public VulkanSpan<StdVideoH264PictureParameterSet> stdPPSs
	{
		[Inline] get => .(stdPPSCount, pStdPPSs);
		[Inline] set mut { stdPPSCount = value.count; pStdPPSs = value.ptr; }
	} // List of Picture Parameters associated with the spsStd, above

	public this(void* pNext = null, VulkanSpan<StdVideoH264SequenceParameterSet> stdSPSs = .(), VulkanSpan<StdVideoH264PictureParameterSet> stdPPSs = .()) : this()
	{
		this.pNext = pNext;
		this.stdSPSs = stdSPSs;
		this.stdPPSs = stdPPSs;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeH264PictureInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeH264PictureInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoDecodeH264PictureInfo* pStdPictureInfo;
	public uint32 sliceCount;
	public uint32* pSliceOffsets;
	public VulkanSpan<uint32> sliceOffsets
	{
		[Inline] get => .(sliceCount, pSliceOffsets);
		[Inline] set mut { sliceCount = value.count; pSliceOffsets = value.ptr; }
	}

	public this(void* pNext, StdVideoDecodeH264PictureInfo* pStdPictureInfo, VulkanSpan<uint32> sliceOffsets) : this()
	{
		this.pNext = pNext;
		this.pStdPictureInfo = pStdPictureInfo;
		this.sliceOffsets = sliceOffsets;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeH264DpbSlotInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeH264DpbSlotInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoDecodeH264ReferenceInfo* pStdReferenceInfo;

	public this(void* pNext, StdVideoDecodeH264ReferenceInfo* pStdReferenceInfo)
	{
		this.pNext = pNext;
		this.pStdReferenceInfo = pStdReferenceInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME = "VK_AMD_texture_gather_bias_lod"; }

[CRepr] struct VkTextureLODGatherFormatPropertiesAMD
{
	public const VkStructureType SType = .VkTextureLodGatherFormatPropertiesAMD;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 supportsTextureGatherLODBiasAMD;
}

static { public const uint32 VK_AMD_SHADER_INFO_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_SHADER_INFO_EXTENSION_NAME = "VK_AMD_shader_info"; }

[AllowDuplicates] enum VkShaderInfoTypeAMD : int32
{
	StatisticsAMD = 0,
	BinaryAMD = 1,
	DisassemblyAMD = 2,
}

[CRepr] struct VkShaderResourceUsageAMD
{
	public uint32 numUsedVgprs;
	public uint32 numUsedSgprs;
	public uint32 ldsSizePerLocalWorkGroup;
	public c_size ldsUsageSizeInBytes;
	public c_size scratchMemUsageInBytes;
}

[CRepr] struct VkShaderStatisticsInfoAMD
{
	public VkShaderStageFlags shaderStageMask;
	public VkShaderResourceUsageAMD resourceUsage;
	public uint32 numPhysicalVgprs;
	public uint32 numPhysicalSgprs;
	public uint32 numAvailableVgprs;
	public uint32 numAvailableSgprs;
	public uint32[3] computeWorkGroupSize;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, out c_size pInfoSize, out void pInfo);

static { public const uint32 VK_KHR_DYNAMIC_RENDERING_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME = "VK_KHR_dynamic_rendering"; }

typealias VkRenderingInfoKHR = VkRenderingInfo;
typealias VkRenderingAttachmentInfoKHR = VkRenderingAttachmentInfo;
typealias VkPipelineRenderingCreateInfoKHR = VkPipelineRenderingCreateInfo;
typealias VkPhysicalDeviceDynamicRenderingFeaturesKHR = VkPhysicalDeviceDynamicRenderingFeatures;
typealias VkCommandBufferInheritanceRenderingInfoKHR = VkCommandBufferInheritanceRenderingInfo;
typealias VkRenderingFlagsKHR = VkRenderingFlags;
typealias VkRenderingFlagBitsKHR = VkRenderingFlagBits;

static { public const uint32 VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME = "VK_AMD_shader_image_load_store_lod"; }
static { public const uint32 VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION = 1; }
static { public const c_char* VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME = "VK_GGP_stream_descriptor_surface"; }

typealias VkStreamDescriptorSurfaceCreateFlagsGGP = VkFlags;

[CRepr] struct VkStreamDescriptorSurfaceCreateInfoGGP
{
	public const VkStructureType SType = .VkStreamDescriptorSurfaceCreateInfoGGP;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkStreamDescriptorSurfaceCreateFlagsGGP flags;
	public GgpStreamDescriptor streamDescriptor;

	public this(void* pNext, VkStreamDescriptorSurfaceCreateFlagsGGP flags, GgpStreamDescriptor streamDescriptor)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.streamDescriptor = streamDescriptor;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateStreamDescriptorSurfaceGGP(VkInstance instance, VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);

static { public const uint32 VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION = 2; }
static { public const c_char* VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME = "VK_NV_corner_sampled_image"; }

[CRepr] struct VkPhysicalDeviceCornerSampledImageFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceCornerSampledImageFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 cornerSampledImage;

	public this(void* pNext, VkBool32 cornerSampledImage)
	{
		this.pNext = pNext;
		this.cornerSampledImage = cornerSampledImage;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_MULTIVIEW_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_MULTIVIEW_EXTENSION_NAME = "VK_KHR_multiview"; }

typealias VkRenderPassMultiviewCreateInfoKHR = VkRenderPassMultiviewCreateInfo;
typealias VkPhysicalDeviceMultiviewFeaturesKHR = VkPhysicalDeviceMultiviewFeatures;
typealias VkPhysicalDeviceMultiviewPropertiesKHR = VkPhysicalDeviceMultiviewProperties;

static { public const uint32 VK_IMG_FORMAT_PVRTC_SPEC_VERSION = 1; }
static { public const c_char* VK_IMG_FORMAT_PVRTC_EXTENSION_NAME = "VK_IMG_format_pvrtc"; }
static { public const uint32 VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = "VK_NV_external_memory_capabilities"; }

typealias VkExternalMemoryHandleTypeFlagsNV = VkExternalMemoryHandleTypeFlagBitsNV;

[AllowDuplicates] enum VkExternalMemoryHandleTypeFlagBitsNV : int32
{
	OpaqueWin32NV = 1 << 0,
	OpaqueWin32KmtNV = 1 << 1,
	D3d11ImageNV = 1 << 2,
	D3d11ImageKmtNV = 1 << 3,
}

typealias VkExternalMemoryFeatureFlagsNV = VkExternalMemoryFeatureFlagBitsNV;

[AllowDuplicates] enum VkExternalMemoryFeatureFlagBitsNV : int32
{
	DedicatedOnlyNV = 1 << 0,
	ExportableNV = 1 << 1,
	ImportableNV = 1 << 2,
}

[CRepr] struct VkExternalImageFormatPropertiesNV
{
	public VkImageFormatProperties imageFormatProperties;
	public VkExternalMemoryFeatureFlagsNV externalMemoryFeatures;
	public VkExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes;
	public VkExternalMemoryHandleTypeFlagsNV compatibleHandleTypes;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, out VkExternalImageFormatPropertiesNV pExternalImageFormatProperties);

static { public const uint32 VK_NV_EXTERNAL_MEMORY_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_NV_external_memory"; }

[CRepr] struct VkExternalMemoryImageCreateInfoNV
{
	public const VkStructureType SType = .VkExternalMemoryImageCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlagsNV handleTypes;

	public this(void* pNext = null, VkExternalMemoryHandleTypeFlagsNV handleTypes = 0)
	{
		this.pNext = pNext;
		this.handleTypes = handleTypes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExportMemoryAllocateInfoNV
{
	public const VkStructureType SType = .VkExportMemoryAllocateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlagsNV handleTypes;

	public this(void* pNext = null, VkExternalMemoryHandleTypeFlagsNV handleTypes = 0)
	{
		this.pNext = pNext;
		this.handleTypes = handleTypes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME = "VK_NV_external_memory_win32"; }

[CRepr] struct VkImportMemoryWin32HandleInfoNV
{
	public const VkStructureType SType = .VkImportMemoryWin32HandleInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlagsNV handleType;
	public HANDLE handle;

	public this(void* pNext = null, VkExternalMemoryHandleTypeFlagsNV handleType = 0, HANDLE handle = null)
	{
		this.pNext = pNext;
		this.handleType = handleType;
		this.handle = handle;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExportMemoryWin32HandleInfoNV
{
	public const VkStructureType SType = .VkExportMemoryWin32HandleInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public SECURITY_ATTRIBUTES* pAttributes;
	public DWORD dwAccess;

	public this(void* pNext = null, SECURITY_ATTRIBUTES* pAttributes = null, DWORD dwAccess = 0)
	{
		this.pNext = pNext;
		this.pAttributes = pAttributes;
		this.dwAccess = dwAccess;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetMemoryWin32HandleNV(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, out HANDLE pHandle);

static { public const uint32 VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION = 2; }
static { public const c_char* VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME = "VK_NV_win32_keyed_mutex"; }

[CRepr] struct VkWin32KeyedMutexAcquireReleaseInfoNV
{
	public const VkStructureType SType = .VkWin32KeyedMutexAcquireReleaseInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 acquireCount;
	public VkDeviceMemory* pAcquireSyncs;
	public uint64* pAcquireKeys;
	public uint32* pAcquireTimeoutMilliseconds;
	public VulkanTrioSpan<VkDeviceMemory, uint64, uint32> acquireSyncs_acquireKeys_acquireTimeoutMilliseconds
	{
		[Inline] get => .(acquireCount, pAcquireSyncs, pAcquireKeys, pAcquireTimeoutMilliseconds);
		[Inline] set mut { acquireCount = value.count; pAcquireSyncs = value.ptr1; pAcquireKeys = value.ptr2; pAcquireTimeoutMilliseconds = value.ptr3; }
	}
	public uint32 releaseCount;
	public VkDeviceMemory* pReleaseSyncs;
	public uint64* pReleaseKeys;
	public VulkanDuoSpan<VkDeviceMemory, uint64> releaseSyncs_releaseKeys
	{
		[Inline] get => .(releaseCount, pReleaseSyncs, pReleaseKeys);
		[Inline] set mut { releaseCount = value.count; pReleaseSyncs = value.ptr1; pReleaseKeys = value.ptr2; }
	}

	public this(void* pNext = null, VulkanTrioSpan<VkDeviceMemory, uint64, uint32> acquireSyncs_acquireKeys_acquireTimeoutMilliseconds = .(), VulkanDuoSpan<VkDeviceMemory, uint64> releaseSyncs_releaseKeys = .()) : this()
	{
		this.pNext = pNext;
		this.acquireSyncs_acquireKeys_acquireTimeoutMilliseconds = acquireSyncs_acquireKeys_acquireTimeoutMilliseconds;
		this.releaseSyncs_releaseKeys = releaseSyncs_releaseKeys;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION = 2; }
static { public const c_char* VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_physical_device_properties2"; }

typealias VkPhysicalDeviceFeatures2KHR = VkPhysicalDeviceFeatures2;
typealias VkPhysicalDeviceProperties2KHR = VkPhysicalDeviceProperties2;
typealias VkFormatProperties2KHR = VkFormatProperties2;
typealias VkImageFormatProperties2KHR = VkImageFormatProperties2;
typealias VkPhysicalDeviceImageFormatInfo2KHR = VkPhysicalDeviceImageFormatInfo2;
typealias VkQueueFamilyProperties2KHR = VkQueueFamilyProperties2;
typealias VkPhysicalDeviceMemoryProperties2KHR = VkPhysicalDeviceMemoryProperties2;
typealias VkSparseImageFormatProperties2KHR = VkSparseImageFormatProperties2;
typealias VkPhysicalDeviceSparseImageFormatInfo2KHR = VkPhysicalDeviceSparseImageFormatInfo2;

static { public const uint32 VK_KHR_DEVICE_GROUP_SPEC_VERSION = 4; }
static { public const c_char* VK_KHR_DEVICE_GROUP_EXTENSION_NAME = "VK_KHR_device_group"; }

typealias VkPeerMemoryFeatureFlagsKHR = VkPeerMemoryFeatureFlags;
typealias VkPeerMemoryFeatureFlagBitsKHR = VkPeerMemoryFeatureFlagBits;
typealias VkMemoryAllocateFlagsKHR = VkMemoryAllocateFlags;
typealias VkMemoryAllocateFlagBitsKHR = VkMemoryAllocateFlagBits;
typealias VkMemoryAllocateFlagsInfoKHR = VkMemoryAllocateFlagsInfo;
typealias VkDeviceGroupRenderPassBeginInfoKHR = VkDeviceGroupRenderPassBeginInfo;
typealias VkDeviceGroupCommandBufferBeginInfoKHR = VkDeviceGroupCommandBufferBeginInfo;
typealias VkDeviceGroupSubmitInfoKHR = VkDeviceGroupSubmitInfo;
typealias VkDeviceGroupBindSparseInfoKHR = VkDeviceGroupBindSparseInfo;
typealias VkBindBufferMemoryDeviceGroupInfoKHR = VkBindBufferMemoryDeviceGroupInfo;
typealias VkBindImageMemoryDeviceGroupInfoKHR = VkBindImageMemoryDeviceGroupInfo;

static { public const uint32 VK_EXT_VALIDATION_FLAGS_SPEC_VERSION = 3; }
static { public const c_char* VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME = "VK_EXT_validation_flags"; }

[CRepr] struct VkValidationFlagsEXT
{
	public const VkStructureType SType = .VkValidationFlagsEXT;
	public VkStructureType sType = SType; // Must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
	public void* pNext;
	public uint32 disabledValidationCheckCount; // Number of validation checks to disable
	public VkValidationCheckEXT* pDisabledValidationChecks; // Validation checks to disable
	public VulkanSpan<VkValidationCheckEXT> disabledValidationChecks
	{
		[Inline] get => .(disabledValidationCheckCount, pDisabledValidationChecks);
		[Inline] set mut { disabledValidationCheckCount = value.count; pDisabledValidationChecks = value.ptr; }
	} // Validation checks to disable

	public this(void* pNext, VulkanSpan<VkValidationCheckEXT> disabledValidationChecks) : this()
	{
		this.pNext = pNext;
		this.disabledValidationChecks = disabledValidationChecks;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkValidationCheckEXT : int32
{
	AllEXT = 0,
	ShadersEXT = 1,
}

static { public const uint32 VK_NN_VI_SURFACE_SPEC_VERSION = 1; }
static { public const c_char* VK_NN_VI_SURFACE_EXTENSION_NAME = "VK_NN_vi_surface"; }

typealias VkViSurfaceCreateFlagsNN = VkFlags;

[CRepr] struct VkViSurfaceCreateInfoNN
{
	public const VkStructureType SType = .VkViSurfaceCreateInfoNN;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkViSurfaceCreateFlagsNN flags;
	public void* window;

	public this(void* pNext, VkViSurfaceCreateFlagsNN flags, void* window)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.window = window;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateViSurfaceNN(VkInstance instance, VkViSurfaceCreateInfoNN* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);

static { public const uint32 VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME = "VK_KHR_shader_draw_parameters"; }
static { public const uint32 VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME = "VK_EXT_shader_subgroup_ballot"; }
static { public const uint32 VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME = "VK_EXT_shader_subgroup_vote"; }
static { public const uint32 VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME = "VK_EXT_texture_compression_astc_hdr"; }

typealias VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = VkPhysicalDeviceTextureCompressionASTCHDRFeatures;

static { public const uint32 VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME = "VK_EXT_astc_decode_mode"; }

[CRepr] struct VkImageViewASTCDecodeModeEXT
{
	public const VkStructureType SType = .VkImageViewAstcDecodeModeEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat decodeMode;

	public this(void* pNext, VkFormat decodeMode)
	{
		this.pNext = pNext;
		this.decodeMode = decodeMode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceASTCDecodeFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceAstcDecodeFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 decodeModeSharedExponent;

	public this(void* pNext, VkBool32 decodeModeSharedExponent)
	{
		this.pNext = pNext;
		this.decodeModeSharedExponent = decodeModeSharedExponent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_PIPELINE_ROBUSTNESS_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME = "VK_EXT_pipeline_robustness"; }

typealias VkPhysicalDevicePipelineRobustnessFeaturesEXT = VkPhysicalDevicePipelineRobustnessFeatures;
typealias VkPhysicalDevicePipelineRobustnessPropertiesEXT = VkPhysicalDevicePipelineRobustnessProperties;
typealias VkPipelineRobustnessCreateInfoEXT = VkPipelineRobustnessCreateInfo;
typealias VkPipelineRobustnessBufferBehaviorEXT = VkPipelineRobustnessBufferBehavior;
typealias VkPipelineRobustnessImageBehaviorEXT = VkPipelineRobustnessImageBehavior;

static { public const uint32 VK_KHR_MAINTENANCE_1_SPEC_VERSION = 2; }
static { public const c_char* VK_KHR_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_maintenance1"; }
static { [Obsolete("aliased")] public const let VK_KHR_MAINTENANCE1_SPEC_VERSION = VK_KHR_MAINTENANCE_1_SPEC_VERSION; }
static { [Obsolete("aliased")] public const let VK_KHR_MAINTENANCE1_EXTENSION_NAME = VK_KHR_MAINTENANCE_1_EXTENSION_NAME; }

typealias VkCommandPoolTrimFlagsKHR = VkCommandPoolTrimFlags;

static { public const uint32 VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME = "VK_KHR_device_group_creation"; }
static { public const let VK_MAX_DEVICE_GROUP_SIZE_KHR = VK_MAX_DEVICE_GROUP_SIZE; }

typealias VkPhysicalDeviceGroupPropertiesKHR = VkPhysicalDeviceGroupProperties;
typealias VkDeviceGroupDeviceCreateInfoKHR = VkDeviceGroupDeviceCreateInfo;

static { public const uint32 VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_memory_capabilities"; }
static { public const let VK_LUID_SIZE_KHR = VK_LUID_SIZE; }

typealias VkExternalMemoryHandleTypeFlagsKHR = VkExternalMemoryHandleTypeFlags;
typealias VkExternalMemoryHandleTypeFlagBitsKHR = VkExternalMemoryHandleTypeFlagBits;
typealias VkExternalMemoryFeatureFlagsKHR = VkExternalMemoryFeatureFlags;
typealias VkExternalMemoryFeatureFlagBitsKHR = VkExternalMemoryFeatureFlagBits;
typealias VkExternalMemoryPropertiesKHR = VkExternalMemoryProperties;
typealias VkPhysicalDeviceExternalImageFormatInfoKHR = VkPhysicalDeviceExternalImageFormatInfo;
typealias VkExternalImageFormatPropertiesKHR = VkExternalImageFormatProperties;
typealias VkPhysicalDeviceExternalBufferInfoKHR = VkPhysicalDeviceExternalBufferInfo;
typealias VkExternalBufferPropertiesKHR = VkExternalBufferProperties;
typealias VkPhysicalDeviceIDPropertiesKHR = VkPhysicalDeviceIDProperties;

static { public const uint32 VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_KHR_external_memory"; }
static { public const let VK_QUEUE_FAMILY_EXTERNAL_KHR = VK_QUEUE_FAMILY_EXTERNAL; }

typealias VkExternalMemoryImageCreateInfoKHR = VkExternalMemoryImageCreateInfo;
typealias VkExternalMemoryBufferCreateInfoKHR = VkExternalMemoryBufferCreateInfo;
typealias VkExportMemoryAllocateInfoKHR = VkExportMemoryAllocateInfo;

static { public const uint32 VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME = "VK_KHR_external_memory_win32"; }

[CRepr] struct VkImportMemoryWin32HandleInfoKHR
{
	public const VkStructureType SType = .VkImportMemoryWin32HandleInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlagBits handleType;
	public HANDLE handle;
	public LPCWSTR name;

	public this(void* pNext = null, VkExternalMemoryHandleTypeFlagBits handleType = 0, HANDLE handle = null, LPCWSTR name = null)
	{
		this.pNext = pNext;
		this.handleType = handleType;
		this.handle = handle;
		this.name = name;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExportMemoryWin32HandleInfoKHR
{
	public const VkStructureType SType = .VkExportMemoryWin32HandleInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public SECURITY_ATTRIBUTES* pAttributes;
	public DWORD dwAccess;
	public LPCWSTR name;

	public this(void* pNext, SECURITY_ATTRIBUTES* pAttributes, DWORD dwAccess, LPCWSTR name)
	{
		this.pNext = pNext;
		this.pAttributes = pAttributes;
		this.dwAccess = dwAccess;
		this.name = name;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryWin32HandlePropertiesKHR
{
	public const VkStructureType SType = .VkMemoryWin32HandlePropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 memoryTypeBits;
}

[CRepr] struct VkMemoryGetWin32HandleInfoKHR
{
	public const VkStructureType SType = .VkMemoryGetWin32HandleInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceMemory memory;
	public VkExternalMemoryHandleTypeFlagBits handleType;

	public this(void* pNext, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.memory = memory;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetMemoryWin32HandleKHR(VkDevice device, VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, out HANDLE pHandle);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, out VkMemoryWin32HandlePropertiesKHR pMemoryWin32HandleProperties);

static { public const uint32 VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME = "VK_KHR_external_memory_fd"; }

[CRepr] struct VkImportMemoryFdInfoKHR
{
	public const VkStructureType SType = .VkImportMemoryFdInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlagBits handleType;
	public c_int fd;

	public this(void* pNext, VkExternalMemoryHandleTypeFlagBits handleType, c_int fd)
	{
		this.pNext = pNext;
		this.handleType = handleType;
		this.fd = fd;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryFdPropertiesKHR
{
	public const VkStructureType SType = .VkMemoryFdPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 memoryTypeBits;
}

[CRepr] struct VkMemoryGetFdInfoKHR
{
	public const VkStructureType SType = .VkMemoryGetFdInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceMemory memory;
	public VkExternalMemoryHandleTypeFlagBits handleType;

	public this(void* pNext, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.memory = memory;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetMemoryFdKHR(VkDevice device, VkMemoryGetFdInfoKHR* pGetFdInfo, out c_int pFd);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, c_int fd, out VkMemoryFdPropertiesKHR pMemoryFdProperties);

static { public const uint32 VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME = "VK_KHR_win32_keyed_mutex"; }

[CRepr] struct VkWin32KeyedMutexAcquireReleaseInfoKHR
{
	public const VkStructureType SType = .VkWin32KeyedMutexAcquireReleaseInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 acquireCount;
	public VkDeviceMemory* pAcquireSyncs;
	public uint64* pAcquireKeys;
	public uint32* pAcquireTimeouts;
	public VulkanTrioSpan<VkDeviceMemory, uint64, uint32> acquireSyncs_acquireKeys_acquireTimeouts
	{
		[Inline] get => .(acquireCount, pAcquireSyncs, pAcquireKeys, pAcquireTimeouts);
		[Inline] set mut { acquireCount = value.count; pAcquireSyncs = value.ptr1; pAcquireKeys = value.ptr2; pAcquireTimeouts = value.ptr3; }
	}
	public uint32 releaseCount;
	public VkDeviceMemory* pReleaseSyncs;
	public uint64* pReleaseKeys;
	public VulkanDuoSpan<VkDeviceMemory, uint64> releaseSyncs_releaseKeys
	{
		[Inline] get => .(releaseCount, pReleaseSyncs, pReleaseKeys);
		[Inline] set mut { releaseCount = value.count; pReleaseSyncs = value.ptr1; pReleaseKeys = value.ptr2; }
	}

	public this(void* pNext = null, VulkanTrioSpan<VkDeviceMemory, uint64, uint32> acquireSyncs_acquireKeys_acquireTimeouts = .(), VulkanDuoSpan<VkDeviceMemory, uint64> releaseSyncs_releaseKeys = .()) : this()
	{
		this.pNext = pNext;
		this.acquireSyncs_acquireKeys_acquireTimeouts = acquireSyncs_acquireKeys_acquireTimeouts;
		this.releaseSyncs_releaseKeys = releaseSyncs_releaseKeys;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_semaphore_capabilities"; }
typealias VkExternalSemaphoreHandleTypeFlagsKHR = VkExternalSemaphoreHandleTypeFlags;
typealias VkExternalSemaphoreHandleTypeFlagBitsKHR = VkExternalSemaphoreHandleTypeFlagBits;
typealias VkExternalSemaphoreFeatureFlagsKHR = VkExternalSemaphoreFeatureFlags;
typealias VkExternalSemaphoreFeatureFlagBitsKHR = VkExternalSemaphoreFeatureFlagBits;
typealias VkPhysicalDeviceExternalSemaphoreInfoKHR = VkPhysicalDeviceExternalSemaphoreInfo;
typealias VkExternalSemaphorePropertiesKHR = VkExternalSemaphoreProperties;
static { public const uint32 VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME = "VK_KHR_external_semaphore"; }

typealias VkSemaphoreImportFlagsKHR = VkSemaphoreImportFlags;
typealias VkSemaphoreImportFlagBitsKHR = VkSemaphoreImportFlagBits;
typealias VkExportSemaphoreCreateInfoKHR = VkExportSemaphoreCreateInfo;

static { public const uint32 VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME = "VK_KHR_external_semaphore_win32"; }

[CRepr] struct VkImportSemaphoreWin32HandleInfoKHR
{
	public const VkStructureType SType = .VkImportSemaphoreWin32HandleInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSemaphore semaphore;
	public VkSemaphoreImportFlags flags;
	public VkExternalSemaphoreHandleTypeFlagBits handleType;
	public HANDLE handle;
	public LPCWSTR name;

	public this(void* pNext, VkSemaphore semaphore, VkSemaphoreImportFlags flags, VkExternalSemaphoreHandleTypeFlagBits handleType, HANDLE handle = null, LPCWSTR name = null)
	{
		this.pNext = pNext;
		this.semaphore = semaphore;
		this.flags = flags;
		this.handleType = handleType;
		this.handle = handle;
		this.name = name;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExportSemaphoreWin32HandleInfoKHR
{
	public const VkStructureType SType = .VkExportSemaphoreWin32HandleInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public SECURITY_ATTRIBUTES* pAttributes;
	public DWORD dwAccess;
	public LPCWSTR name;

	public this(void* pNext, SECURITY_ATTRIBUTES* pAttributes, DWORD dwAccess, LPCWSTR name)
	{
		this.pNext = pNext;
		this.pAttributes = pAttributes;
		this.dwAccess = dwAccess;
		this.name = name;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkD3D12FenceSubmitInfoKHR
{
	public const VkStructureType SType = .VkD3d12FenceSubmitInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 waitSemaphoreValuesCount;
	public uint64* pWaitSemaphoreValues;
	public VulkanSpan<uint64> waitSemaphoreValues
	{
		[Inline] get => .(waitSemaphoreValuesCount, pWaitSemaphoreValues);
		[Inline] set mut { waitSemaphoreValuesCount = value.count; pWaitSemaphoreValues = value.ptr; }
	}
	public uint32 signalSemaphoreValuesCount;
	public uint64* pSignalSemaphoreValues;
	public VulkanSpan<uint64> signalSemaphoreValues
	{
		[Inline] get => .(signalSemaphoreValuesCount, pSignalSemaphoreValues);
		[Inline] set mut { signalSemaphoreValuesCount = value.count; pSignalSemaphoreValues = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<uint64> waitSemaphoreValues = .(), VulkanSpan<uint64> signalSemaphoreValues = .()) : this()
	{
		this.pNext = pNext;
		this.waitSemaphoreValues = waitSemaphoreValues;
		this.signalSemaphoreValues = signalSemaphoreValues;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSemaphoreGetWin32HandleInfoKHR
{
	public const VkStructureType SType = .VkSemaphoreGetWin32HandleInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSemaphore semaphore;
	public VkExternalSemaphoreHandleTypeFlagBits handleType;

	public this(void* pNext, VkSemaphore semaphore, VkExternalSemaphoreHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.semaphore = semaphore;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkImportSemaphoreWin32HandleKHR(VkDevice device, VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetSemaphoreWin32HandleKHR(VkDevice device, VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, out HANDLE pHandle);

static { public const uint32 VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME = "VK_KHR_external_semaphore_fd"; }

[CRepr] struct VkImportSemaphoreFdInfoKHR
{
	public const VkStructureType SType = .VkImportSemaphoreFdInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSemaphore semaphore;
	public VkSemaphoreImportFlags flags;
	public VkExternalSemaphoreHandleTypeFlagBits handleType;
	public c_int fd;

	public this(void* pNext, VkSemaphore semaphore, VkSemaphoreImportFlags flags, VkExternalSemaphoreHandleTypeFlagBits handleType, c_int fd)
	{
		this.pNext = pNext;
		this.semaphore = semaphore;
		this.flags = flags;
		this.handleType = handleType;
		this.fd = fd;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSemaphoreGetFdInfoKHR
{
	public const VkStructureType SType = .VkSemaphoreGetFdInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSemaphore semaphore;
	public VkExternalSemaphoreHandleTypeFlagBits handleType;

	public this(void* pNext, VkSemaphore semaphore, VkExternalSemaphoreHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.semaphore = semaphore;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkImportSemaphoreFdKHR(VkDevice device, VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetSemaphoreFdKHR(VkDevice device, VkSemaphoreGetFdInfoKHR* pGetFdInfo, out c_int pFd);

static { public const uint32 VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION = 2; }
static { public const c_char* VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME = "VK_KHR_push_descriptor"; }

typealias VkPhysicalDevicePushDescriptorPropertiesKHR = VkPhysicalDevicePushDescriptorProperties;

static { public const uint32 VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME = "VK_EXT_conditional_rendering"; }

typealias VkConditionalRenderingFlagsEXT = VkConditionalRenderingFlagBitsEXT;

[AllowDuplicates] enum VkConditionalRenderingFlagBitsEXT : int32
{
	InvertedEXT = 1 << 0,
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer);

[CRepr] struct VkConditionalRenderingBeginInfoEXT
{
	public const VkStructureType SType = .VkConditionalRenderingBeginInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBuffer buffer;
	public VkDeviceSize offset;
	public VkConditionalRenderingFlagsEXT flags;

	public this(void* pNext, VkBuffer buffer, VkDeviceSize offset, VkConditionalRenderingFlagsEXT flags = 0)
	{
		this.pNext = pNext;
		this.buffer = buffer;
		this.offset = offset;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceConditionalRenderingFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceConditionalRenderingFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 conditionalRendering;
	public VkBool32 inheritedConditionalRendering;

	public this(void* pNext, VkBool32 conditionalRendering, VkBool32 inheritedConditionalRendering)
	{
		this.pNext = pNext;
		this.conditionalRendering = conditionalRendering;
		this.inheritedConditionalRendering = inheritedConditionalRendering;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCommandBufferInheritanceConditionalRenderingInfoEXT
{
	public const VkStructureType SType = .VkCommandBufferInheritanceConditionalRenderingInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 conditionalRenderingEnable; // Whether this secondary command buffer may be executed during an active conditional rendering

	public this(void* pNext, VkBool32 conditionalRenderingEnable)
	{
		this.pNext = pNext;
		this.conditionalRenderingEnable = conditionalRenderingEnable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME = "VK_KHR_shader_float16_int8"; }

typealias VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;
typealias VkPhysicalDeviceFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;

static { public const uint32 VK_KHR_16BIT_STORAGE_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_16BIT_STORAGE_EXTENSION_NAME = "VK_KHR_16bit_storage"; }

typealias VkPhysicalDevice16BitStorageFeaturesKHR = VkPhysicalDevice16BitStorageFeatures;

static { public const uint32 VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION = 2; }
static { public const c_char* VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME = "VK_KHR_incremental_present"; }

[CRepr] struct VkPresentRegionsKHR
{
	public const VkStructureType SType = .VkPresentRegionsKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 swapchainCount; // Copy of VkPresentInfoKHR::swapchainCount
	public VkPresentRegionKHR* pRegions; // The regions that have changed
	public VulkanSpan<VkPresentRegionKHR> regions
	{
		[Inline] get => .(swapchainCount, pRegions);
		[Inline] set mut { swapchainCount = value.count; pRegions = value.ptr; }
	} // The regions that have changed

	public this(void* pNext, VulkanSpan<VkPresentRegionKHR> regions = .()) : this()
	{
		this.pNext = pNext;
		this.regions = regions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPresentRegionKHR
{
	public uint32 rectangleCount; // Number of rectangles in pRectangles
	public VkRectLayerKHR* pRectangles; // Array of rectangles that have changed in a swapchain's image(s)
	public VulkanSpan<VkRectLayerKHR> rectangles
	{
		[Inline] get => .(rectangleCount, pRectangles);
		[Inline] set mut { rectangleCount = value.count; pRectangles = value.ptr; }
	} // Array of rectangles that have changed in a swapchain's image(s)

	public this(VulkanSpan<VkRectLayerKHR> rectangles = .()) : this()
	{
		this.rectangles = rectangles;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkRectLayerKHR
{
	public VkOffset2D offset; // upper-left corner of a rectangle that has not changed, in pixels of a presentation images
	public VkExtent2D extent; // Dimensions of a rectangle that has not changed, in pixels of a presentation images
	public uint32 layer; // Layer of a swapchain's image(s), for stereoscopic-3D images

	public this(VkOffset2D offset, VkExtent2D extent, uint32 layer)
	{
		this.offset = offset;
		this.extent = extent;
		this.layer = layer;
	}

	public this()
	{
		this = default;
	}
}

static { public const uint32 VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME = "VK_KHR_descriptor_update_template"; }

typealias VkDescriptorUpdateTemplateCreateFlagsKHR = VkDescriptorUpdateTemplateCreateFlags;
typealias VkDescriptorUpdateTemplateTypeKHR = VkDescriptorUpdateTemplateType;
typealias VkDescriptorUpdateTemplateEntryKHR = VkDescriptorUpdateTemplateEntry;
typealias VkDescriptorUpdateTemplateCreateInfoKHR = VkDescriptorUpdateTemplateCreateInfo;

static { public const uint32 VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME = "VK_NV_clip_space_w_scaling"; }

[CRepr] struct VkViewportWScalingNV
{
	public float xcoeff;
	public float ycoeff;

	public this(float xcoeff, float ycoeff)
	{
		this.xcoeff = xcoeff;
		this.ycoeff = ycoeff;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkPipelineViewportWScalingStateCreateInfoNV
{
	public const VkStructureType SType = .VkPipelineViewportWScalingStateCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 viewportWScalingEnable;
	public uint32 viewportCount;
	public VkViewportWScalingNV* pViewportWScalings;
	public VulkanSpan<VkViewportWScalingNV> viewportWScalings
	{
		[Inline] get => .(viewportCount, pViewportWScalings);
		[Inline] set mut { viewportCount = value.count; pViewportWScalings = value.ptr; }
	}

	public this(void* pNext, VkBool32 viewportWScalingEnable, VulkanSpan<VkViewportWScalingNV> viewportWScalings = .()) : this()
	{
		this.pNext = pNext;
		this.viewportWScalingEnable = viewportWScalingEnable;
		this.viewportWScalings = viewportWScalings;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32 firstViewport, uint32 viewportCount, VkViewportWScalingNV* pViewportWScalings);

static { public const uint32 VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME = "VK_EXT_direct_mode_display"; }

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display);

static { public const uint32 VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME = "VK_EXT_acquire_xlib_display"; }

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkAcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, out Display dpy, VkDisplayKHR display);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, out Display dpy, RROutput rrOutput, out VkDisplayKHR pDisplay);

static { public const uint32 VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME = "VK_EXT_display_surface_counter"; }

typealias VkSurfaceCounterFlagsEXT = VkSurfaceCounterFlagBitsEXT;

[AllowDuplicates] enum VkSurfaceCounterFlagBitsEXT : int32
{
	VblankEXT = 1 << 0,
}

[CRepr] struct VkSurfaceCapabilities2EXT
{
	public const VkStructureType SType = .VkSurfaceCapabilities2EXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 minImageCount; // Supported minimum number of images for the surface
	public uint32 maxImageCount; // Supported maximum number of images for the surface, 0 for unlimited
	public VkExtent2D currentExtent; // Current image width and height for the surface, (0, 0) if undefined
	public VkExtent2D minImageExtent; // Supported minimum image width and height for the surface
	public VkExtent2D maxImageExtent; // Supported maximum image width and height for the surface
	public uint32 maxImageArrayLayers; // Supported maximum number of image layers for the surface
	public VkSurfaceTransformFlagsKHR supportedTransforms; // 1 or more bits representing the transforms supported
	public VkSurfaceTransformFlagBitsKHR currentTransform; // The surface's current transform relative to the device's natural orientation
	public VkCompositeAlphaFlagsKHR supportedCompositeAlpha; // 1 or more bits representing the alpha compositing modes supported
	public VkImageUsageFlags supportedUsageFlags; // Supported image usage flags for the surface
	public VkSurfaceCounterFlagsEXT supportedSurfaceCounters;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, out VkSurfaceCapabilities2EXT pSurfaceCapabilities);

static { public const uint32 VK_EXT_DISPLAY_CONTROL_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME = "VK_EXT_display_control"; }

[AllowDuplicates] enum VkDisplayPowerStateEXT : int32
{
	OffEXT = 0,
	SuspendEXT = 1,
	OnEXT = 2,
}

[AllowDuplicates] enum VkDeviceEventTypeEXT : int32
{
	DisplayHotplugEXT = 0,
}

[AllowDuplicates] enum VkDisplayEventTypeEXT : int32
{
	FirstPixelOutEXT = 0,
}

[CRepr] struct VkDisplayPowerInfoEXT
{
	public const VkStructureType SType = .VkDisplayPowerInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDisplayPowerStateEXT powerState;

	public this(void* pNext, VkDisplayPowerStateEXT powerState)
	{
		this.pNext = pNext;
		this.powerState = powerState;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceEventInfoEXT
{
	public const VkStructureType SType = .VkDeviceEventInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceEventTypeEXT deviceEvent;

	public this(void* pNext, VkDeviceEventTypeEXT deviceEvent)
	{
		this.pNext = pNext;
		this.deviceEvent = deviceEvent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDisplayEventInfoEXT
{
	public const VkStructureType SType = .VkDisplayEventInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDisplayEventTypeEXT displayEvent;

	public this(void* pNext, VkDisplayEventTypeEXT displayEvent)
	{
		this.pNext = pNext;
		this.displayEvent = displayEvent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSwapchainCounterCreateInfoEXT
{
	public const VkStructureType SType = .VkSwapchainCounterCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSurfaceCounterFlagsEXT surfaceCounters;

	public this(void* pNext = null, VkSurfaceCounterFlagsEXT surfaceCounters = 0)
	{
		this.pNext = pNext;
		this.surfaceCounters = surfaceCounters;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkDisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, VkDisplayPowerInfoEXT* pDisplayPowerInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkRegisterDeviceEventEXT(VkDevice device, VkDeviceEventInfoEXT* pDeviceEventInfo, VkAllocationCallbacks* pAllocator, out VkFence pFence);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkRegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, VkDisplayEventInfoEXT* pDisplayEventInfo, VkAllocationCallbacks* pAllocator, out VkFence pFence);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, out uint64 pCounterValue);

static { public const uint32 VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION = 1; }
static { public const c_char* VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME = "VK_GOOGLE_display_timing"; }

[CRepr] struct VkRefreshCycleDurationGOOGLE
{
	public uint64 refreshDuration; // Number of nanoseconds from the start of one refresh cycle to the next
}

[CRepr] struct VkPastPresentationTimingGOOGLE
{
	public uint32 presentID; // Application-provided identifier, previously given to vkQueuePresentKHR
	public uint64 desiredPresentTime; // Earliest time an image should have been presented, previously given to vkQueuePresentKHR
	public uint64 actualPresentTime; // Time the image was actually displayed
	public uint64 earliestPresentTime; // Earliest time the image could have been displayed
	public uint64 presentMargin; // How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime
}

[CRepr] struct VkPresentTimesInfoGOOGLE
{
	public const VkStructureType SType = .VkPresentTimesInfoGOOGLE;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 swapchainCount; // Copy of VkPresentInfoKHR::swapchainCount
	public VkPresentTimeGOOGLE* pTimes; // The earliest times to present images
	public VulkanSpan<VkPresentTimeGOOGLE> times
	{
		[Inline] get => .(swapchainCount, pTimes);
		[Inline] set mut { swapchainCount = value.count; pTimes = value.ptr; }
	} // The earliest times to present images

	public this(void* pNext, VulkanSpan<VkPresentTimeGOOGLE> times = .()) : this()
	{
		this.pNext = pNext;
		this.times = times;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPresentTimeGOOGLE
{
	public uint32 presentID; // Application-provided identifier
	public uint64 desiredPresentTime; // Earliest time an image should be presented

	public this(uint32 presentID, uint64 desiredPresentTime)
	{
		this.presentID = presentID;
		this.desiredPresentTime = desiredPresentTime;
	}

	public this()
	{
		this = default;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, out VkRefreshCycleDurationGOOGLE pDisplayTimingProperties);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, out uint32 pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings = null);

static { public const uint32 VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME = "VK_NV_sample_mask_override_coverage"; }
static { public const uint32 VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME = "VK_NV_geometry_shader_passthrough"; }
static { public const uint32 VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME = "VK_NV_viewport_array2"; }
static { [Obsolete("aliased")] public const let VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION = VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION; }
static { [Obsolete("aliased")] public const let VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME = VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME; }
static { public const uint32 VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION = 1; }
static { public const c_char* VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME = "VK_NVX_multiview_per_view_attributes"; }

[CRepr] struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX
{
	public const VkStructureType SType = .VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 perViewPositionAllComponents;
}

[CRepr] struct VkMultiviewPerViewAttributesInfoNVX
{
	public const VkStructureType SType = .VkMultiviewPerViewAttributesInfoNVX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 perViewAttributes;
	public VkBool32 perViewAttributesPositionXOnly;

	public this(void* pNext, VkBool32 perViewAttributes, VkBool32 perViewAttributesPositionXOnly)
	{
		this.pNext = pNext;
		this.perViewAttributes = perViewAttributes;
		this.perViewAttributesPositionXOnly = perViewAttributesPositionXOnly;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME = "VK_NV_viewport_swizzle"; }

[CRepr] struct VkViewportSwizzleNV
{
	public VkViewportCoordinateSwizzleNV x;
	public VkViewportCoordinateSwizzleNV y;
	public VkViewportCoordinateSwizzleNV z;
	public VkViewportCoordinateSwizzleNV w;

	public this(VkViewportCoordinateSwizzleNV x, VkViewportCoordinateSwizzleNV y, VkViewportCoordinateSwizzleNV z, VkViewportCoordinateSwizzleNV w)
	{
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkViewportCoordinateSwizzleNV : int32
{
	PositiveXNV = 0,
	NegativeXNV = 1,
	PositiveYNV = 2,
	NegativeYNV = 3,
	PositiveZNV = 4,
	NegativeZNV = 5,
	PositiveWNV = 6,
	NegativeWNV = 7,
}

[CRepr] struct VkPipelineViewportSwizzleStateCreateInfoNV
{
	public const VkStructureType SType = .VkPipelineViewportSwizzleStateCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineViewportSwizzleStateCreateFlagsNV flags;
	public uint32 viewportCount;
	public VkViewportSwizzleNV* pViewportSwizzles;
	public VulkanSpan<VkViewportSwizzleNV> viewportSwizzles
	{
		[Inline] get => .(viewportCount, pViewportSwizzles);
		[Inline] set mut { viewportCount = value.count; pViewportSwizzles = value.ptr; }
	}

	public this(void* pNext, VkPipelineViewportSwizzleStateCreateFlagsNV flags, VulkanSpan<VkViewportSwizzleNV> viewportSwizzles) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.viewportSwizzles = viewportSwizzles;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineViewportSwizzleStateCreateFlagsNV = VkFlags;

static { public const uint32 VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME = "VK_EXT_discard_rectangles"; }

[CRepr] struct VkPhysicalDeviceDiscardRectanglePropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceDiscardRectanglePropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxDiscardRectangles; // max number of active discard rectangles
}

[CRepr] struct VkPipelineDiscardRectangleStateCreateInfoEXT
{
	public const VkStructureType SType = .VkPipelineDiscardRectangleStateCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineDiscardRectangleStateCreateFlagsEXT flags;
	public VkDiscardRectangleModeEXT discardRectangleMode;
	public uint32 discardRectangleCount;
	public VkRect2D* pDiscardRectangles;
	public VulkanSpan<VkRect2D> discardRectangles
	{
		[Inline] get => .(discardRectangleCount, pDiscardRectangles);
		[Inline] set mut { discardRectangleCount = value.count; pDiscardRectangles = value.ptr; }
	}

	public this(void* pNext, VkPipelineDiscardRectangleStateCreateFlagsEXT flags, VkDiscardRectangleModeEXT discardRectangleMode, VulkanSpan<VkRect2D> discardRectangles = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.discardRectangleMode = discardRectangleMode;
		this.discardRectangles = discardRectangles;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineDiscardRectangleStateCreateFlagsEXT = VkFlags;

[AllowDuplicates] enum VkDiscardRectangleModeEXT : int32
{
	InclusiveEXT = 0,
	ExclusiveEXT = 1,
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer, uint32 firstDiscardRectangle, uint32 discardRectangleCount, VkRect2D* pDiscardRectangles);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDiscardRectangleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDiscardRectangleModeEXT(VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode);

static { public const uint32 VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME = "VK_EXT_conservative_rasterization"; }

[CRepr] struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceConservativeRasterizationPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public float primitiveOverestimationSize; // The size in pixels the primitive is enlarged at each edge during conservative rasterization
	public float maxExtraPrimitiveOverestimationSize; // The maximum additional overestimation the client can specify in the pipeline state
	public float extraPrimitiveOverestimationSizeGranularity; // The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize
	public VkBool32 primitiveUnderestimation; // true if the implementation supports conservative rasterization underestimation mode
	public VkBool32 conservativePointAndLineRasterization; // true if conservative rasterization also applies to points and lines
	public VkBool32 degenerateTrianglesRasterized; // true if degenerate triangles (those with zero area after snap) are rasterized
	public VkBool32 degenerateLinesRasterized; // true if degenerate lines (those with zero length after snap) are rasterized
	public VkBool32 fullyCoveredFragmentShaderInputVariable; // true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable
	public VkBool32 conservativeRasterizationPostDepthCoverage; // true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask
}

[CRepr] struct VkPipelineRasterizationConservativeStateCreateInfoEXT
{
	public const VkStructureType SType = .VkPipelineRasterizationConservativeStateCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineRasterizationConservativeStateCreateFlagsEXT flags; // Reserved
	public VkConservativeRasterizationModeEXT conservativeRasterizationMode; // Conservative rasterization mode
	public float extraPrimitiveOverestimationSize; // Extra overestimation to add to the primitive

	public this(void* pNext, VkPipelineRasterizationConservativeStateCreateFlagsEXT flags, VkConservativeRasterizationModeEXT conservativeRasterizationMode, float extraPrimitiveOverestimationSize)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.conservativeRasterizationMode = conservativeRasterizationMode;
		this.extraPrimitiveOverestimationSize = extraPrimitiveOverestimationSize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineRasterizationConservativeStateCreateFlagsEXT = VkFlags;

[AllowDuplicates] enum VkConservativeRasterizationModeEXT : int32
{
	DisabledEXT = 0,
	OverestimateEXT = 1,
	UnderestimateEXT = 2,
}

static { public const uint32 VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME = "VK_EXT_depth_clip_enable"; }

[CRepr] struct VkPhysicalDeviceDepthClipEnableFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceDepthClipEnableFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 depthClipEnable;

	public this(void* pNext, VkBool32 depthClipEnable)
	{
		this.pNext = pNext;
		this.depthClipEnable = depthClipEnable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineRasterizationDepthClipStateCreateInfoEXT
{
	public const VkStructureType SType = .VkPipelineRasterizationDepthClipStateCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineRasterizationDepthClipStateCreateFlagsEXT flags; // Reserved
	public VkBool32 depthClipEnable;

	public this(void* pNext, VkPipelineRasterizationDepthClipStateCreateFlagsEXT flags, VkBool32 depthClipEnable)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.depthClipEnable = depthClipEnable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineRasterizationDepthClipStateCreateFlagsEXT = VkFlags;

static { public const uint32 VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION = 5; }
static { public const c_char* VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME = "VK_EXT_swapchain_colorspace"; }
static { public const uint32 VK_EXT_HDR_METADATA_SPEC_VERSION = 3; }
static { public const c_char* VK_EXT_HDR_METADATA_EXTENSION_NAME = "VK_EXT_hdr_metadata"; }

[CRepr] struct VkHdrMetadataEXT
{
	// Display primary in chromaticity coordinates
	public const VkStructureType SType = .VkHdrMetadataEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	// From SMPTE 2086
	public VkXYColorEXT displayPrimaryRed; // Display primary's Red
	public VkXYColorEXT displayPrimaryGreen; // Display primary's Green
	public VkXYColorEXT displayPrimaryBlue; // Display primary's Blue
	public VkXYColorEXT whitePoint; // Display primary's Blue
	public float maxLuminance; // Display maximum luminance
	public float minLuminance; // Display minimum luminance
	// From CTA 861.3
	public float maxContentLightLevel; // Content maximum luminance
	public float maxFrameAverageLightLevel;

	public this(void* pNext, VkXYColorEXT displayPrimaryRed, VkXYColorEXT displayPrimaryGreen, VkXYColorEXT displayPrimaryBlue, VkXYColorEXT whitePoint, float maxLuminance, float minLuminance, float maxContentLightLevel, float maxFrameAverageLightLevel)
	{
		this.pNext = pNext;
		this.displayPrimaryRed = displayPrimaryRed;
		this.displayPrimaryGreen = displayPrimaryGreen;
		this.displayPrimaryBlue = displayPrimaryBlue;
		this.whitePoint = whitePoint;
		this.maxLuminance = maxLuminance;
		this.minLuminance = minLuminance;
		this.maxContentLightLevel = maxContentLightLevel;
		this.maxFrameAverageLightLevel = maxFrameAverageLightLevel;
	}

	public this()
	{
		this = default;
	}
}

// Chromaticity coordinate
[CRepr] struct VkXYColorEXT
{
	public float x;
	public float y;

	public this(float x, float y)
	{
		this.x = x;
		this.y = y;
	}

	public this()
	{
		this = default;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkSetHdrMetadataEXT(VkDevice device, uint32 swapchainCount, VkSwapchainKHR* pSwapchains, VkHdrMetadataEXT* pMetadata);

static { public const uint32 VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME = "VK_KHR_imageless_framebuffer"; }

typealias VkPhysicalDeviceImagelessFramebufferFeaturesKHR = VkPhysicalDeviceImagelessFramebufferFeatures;
typealias VkFramebufferAttachmentsCreateInfoKHR = VkFramebufferAttachmentsCreateInfo;
typealias VkFramebufferAttachmentImageInfoKHR = VkFramebufferAttachmentImageInfo;
typealias VkRenderPassAttachmentBeginInfoKHR = VkRenderPassAttachmentBeginInfo;

static { public const uint32 VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME = "VK_KHR_create_renderpass2"; }

typealias VkRenderPassCreateInfo2KHR = VkRenderPassCreateInfo2;
typealias VkAttachmentDescription2KHR = VkAttachmentDescription2;
typealias VkAttachmentReference2KHR = VkAttachmentReference2;
typealias VkSubpassDescription2KHR = VkSubpassDescription2;
typealias VkSubpassDependency2KHR = VkSubpassDependency2;
typealias VkSubpassBeginInfoKHR = VkSubpassBeginInfo;
typealias VkSubpassEndInfoKHR = VkSubpassEndInfo;

static { public const uint32 VK_IMG_RELAXED_LINE_RASTERIZATION_SPEC_VERSION = 1; }
static { public const c_char* VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME = "VK_IMG_relaxed_line_rasterization"; }

[CRepr] struct VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG
{
	public const VkStructureType SType = .VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 relaxedLineRasterization;

	public this(void* pNext, VkBool32 relaxedLineRasterization)
	{
		this.pNext = pNext;
		this.relaxedLineRasterization = relaxedLineRasterization;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME = "VK_KHR_shared_presentable_image"; }

[CRepr] struct VkSharedPresentSurfaceCapabilitiesKHR
{
	public const VkStructureType SType = .VkSharedPresentSurfaceCapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageUsageFlags sharedPresentSupportedUsageFlags; // Supported image usage flags if swapchain created using a shared present mode
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain);

static { public const uint32 VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME = "VK_KHR_external_fence_capabilities"; }
typealias VkExternalFenceHandleTypeFlagsKHR = VkExternalFenceHandleTypeFlags;
typealias VkExternalFenceHandleTypeFlagBitsKHR = VkExternalFenceHandleTypeFlagBits;
typealias VkExternalFenceFeatureFlagsKHR = VkExternalFenceFeatureFlags;
typealias VkExternalFenceFeatureFlagBitsKHR = VkExternalFenceFeatureFlagBits;
typealias VkPhysicalDeviceExternalFenceInfoKHR = VkPhysicalDeviceExternalFenceInfo;
typealias VkExternalFencePropertiesKHR = VkExternalFenceProperties;
static { public const uint32 VK_KHR_EXTERNAL_FENCE_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME = "VK_KHR_external_fence"; }

typealias VkFenceImportFlagsKHR = VkFenceImportFlags;
typealias VkFenceImportFlagBitsKHR = VkFenceImportFlagBits;
typealias VkExportFenceCreateInfoKHR = VkExportFenceCreateInfo;

static { public const uint32 VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME = "VK_KHR_external_fence_win32"; }

[CRepr] struct VkImportFenceWin32HandleInfoKHR
{
	public const VkStructureType SType = .VkImportFenceWin32HandleInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFence fence;
	public VkFenceImportFlags flags;
	public VkExternalFenceHandleTypeFlagBits handleType;
	public HANDLE handle;
	public LPCWSTR name;

	public this(void* pNext, VkFence fence, VkFenceImportFlags flags, VkExternalFenceHandleTypeFlagBits handleType, HANDLE handle = null, LPCWSTR name = null)
	{
		this.pNext = pNext;
		this.fence = fence;
		this.flags = flags;
		this.handleType = handleType;
		this.handle = handle;
		this.name = name;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExportFenceWin32HandleInfoKHR
{
	public const VkStructureType SType = .VkExportFenceWin32HandleInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public SECURITY_ATTRIBUTES* pAttributes;
	public DWORD dwAccess;
	public LPCWSTR name;

	public this(void* pNext, SECURITY_ATTRIBUTES* pAttributes, DWORD dwAccess, LPCWSTR name)
	{
		this.pNext = pNext;
		this.pAttributes = pAttributes;
		this.dwAccess = dwAccess;
		this.name = name;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkFenceGetWin32HandleInfoKHR
{
	public const VkStructureType SType = .VkFenceGetWin32HandleInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFence fence;
	public VkExternalFenceHandleTypeFlagBits handleType;

	public this(void* pNext, VkFence fence, VkExternalFenceHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.fence = fence;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkImportFenceWin32HandleKHR(VkDevice device, VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetFenceWin32HandleKHR(VkDevice device, VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, out HANDLE pHandle);

static { public const uint32 VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME = "VK_KHR_external_fence_fd"; }

[CRepr] struct VkImportFenceFdInfoKHR
{
	public const VkStructureType SType = .VkImportFenceFdInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFence fence;
	public VkFenceImportFlags flags;
	public VkExternalFenceHandleTypeFlagBits handleType;
	public c_int fd;

	public this(void* pNext, VkFence fence, VkFenceImportFlags flags, VkExternalFenceHandleTypeFlagBits handleType, c_int fd)
	{
		this.pNext = pNext;
		this.fence = fence;
		this.flags = flags;
		this.handleType = handleType;
		this.fd = fd;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkFenceGetFdInfoKHR
{
	public const VkStructureType SType = .VkFenceGetFdInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFence fence;
	public VkExternalFenceHandleTypeFlagBits handleType;

	public this(void* pNext, VkFence fence, VkExternalFenceHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.fence = fence;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkImportFenceFdKHR(VkDevice device, VkImportFenceFdInfoKHR* pImportFenceFdInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetFenceFdKHR(VkDevice device, VkFenceGetFdInfoKHR* pGetFdInfo, out c_int pFd);

static { public const uint32 VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME = "VK_KHR_performance_query"; }

[CRepr] struct VkPhysicalDevicePerformanceQueryFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDevicePerformanceQueryFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 performanceCounterQueryPools; // performance counters supported in query pools
	public VkBool32 performanceCounterMultipleQueryPools; // performance counters from multiple query pools can be accessed in the same primary command buffer

	public this(void* pNext, VkBool32 performanceCounterQueryPools, VkBool32 performanceCounterMultipleQueryPools)
	{
		this.pNext = pNext;
		this.performanceCounterQueryPools = performanceCounterQueryPools;
		this.performanceCounterMultipleQueryPools = performanceCounterMultipleQueryPools;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDevicePerformanceQueryPropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDevicePerformanceQueryPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 allowCommandBufferQueryCopies; // Flag to specify whether performance queries are allowed to be used in vkCmdCopyQueryPoolResults
}

[CRepr] struct VkPerformanceCounterKHR
{
	public const VkStructureType SType = .VkPerformanceCounterKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPerformanceCounterUnitKHR unit;
	public VkPerformanceCounterScopeKHR @scope;
	public VkPerformanceCounterStorageKHR storage;
	public uint8[VK_UUID_SIZE] uuid;
}

[CRepr] struct VkPerformanceCounterDescriptionKHR
{
	public const VkStructureType SType = .VkPerformanceCounterDescriptionKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPerformanceCounterDescriptionFlagsKHR flags;
	public c_char[VK_MAX_DESCRIPTION_SIZE] name;
	public c_char[VK_MAX_DESCRIPTION_SIZE] category;
	public c_char[VK_MAX_DESCRIPTION_SIZE] description;
}

typealias VkPerformanceCounterDescriptionFlagsKHR = VkPerformanceCounterDescriptionFlagBitsKHR;

[AllowDuplicates] enum VkPerformanceCounterDescriptionFlagBitsKHR : int32
{
	PerformanceImpactingKHR = 1 << 0,
	ConcurrentlyImpactedKHR = 1 << 1,
}

[CRepr] struct VkQueryPoolPerformanceCreateInfoKHR
{
	public const VkStructureType SType = .VkQueryPoolPerformanceCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 queueFamilyIndex;
	public uint32 counterIndexCount;
	public uint32* pCounterIndices;
	public VulkanSpan<uint32> counterIndices
	{
		[Inline] get => .(counterIndexCount, pCounterIndices);
		[Inline] set mut { counterIndexCount = value.count; pCounterIndices = value.ptr; }
	}

	public this(void* pNext, uint32 queueFamilyIndex, VulkanSpan<uint32> counterIndices) : this()
	{
		this.pNext = pNext;
		this.queueFamilyIndex = queueFamilyIndex;
		this.counterIndices = counterIndices;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkPerformanceCounterScopeKHR : int32
{
	CommandBufferKHR = 0,
	RenderPassKHR = 1,
	CommandKHR = 2,
	VkQueryScopeCommandBufferKHR = CommandBufferKHR,
	VkQueryScopeRenderPassKHR = RenderPassKHR,
	VkQueryScopeCommandKHR = CommandKHR,
}

[AllowDuplicates] enum VkPerformanceCounterStorageKHR : int32
{
	Int32KHR = 0,
	Int64KHR = 1,
	Uint32KHR = 2,
	Uint64KHR = 3,
	Float32KHR = 4,
	Float64KHR = 5,
}

[AllowDuplicates] enum VkPerformanceCounterUnitKHR : int32
{
	GenericKHR = 0,
	PercentageKHR = 1,
	NanosecondsKHR = 2,
	BytesKHR = 3,
	BytesPerSecondKHR = 4,
	KelvinKHR = 5,
	WattsKHR = 6,
	VoltsKHR = 7,
	AmpsKHR = 8,
	HertzKHR = 9,
	CyclesKHR = 10,
}

// Union of all the possible return types a counter result could return
[Union, CRepr] struct VkPerformanceCounterResultKHR
{
	public int32 int32;
	public int64 int64;
	public uint32 uint32;
	public uint64 uint64;
	public float float32;
	public double float64;
}

[CRepr] struct VkAcquireProfilingLockInfoKHR
{
	public const VkStructureType SType = .VkAcquireProfilingLockInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAcquireProfilingLockFlagsKHR flags; // Acquire profiling lock flags
	public uint64 timeout;

	public this(void* pNext, VkAcquireProfilingLockFlagsKHR flags, uint64 timeout)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.timeout = timeout;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkAcquireProfilingLockFlagsKHR = VkAcquireProfilingLockFlagBitsKHR;

[AllowDuplicates] enum VkAcquireProfilingLockFlagBitsKHR : int32
{
}

[CRepr] struct VkPerformanceQuerySubmitInfoKHR
{
	public const VkStructureType SType = .VkPerformanceQuerySubmitInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 counterPassIndex; // Index for which counter pass to submit

	public this(void* pNext, uint32 counterPassIndex)
	{
		this.pNext = pNext;
		this.counterPassIndex = counterPassIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32 queueFamilyIndex, out uint32 pCounterCount, VkPerformanceCounterKHR* pCounters = null, VkPerformanceCounterDescriptionKHR* pCounterDescriptions = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo, out uint32 pNumPasses);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkAcquireProfilingLockKHR(VkDevice device, VkAcquireProfilingLockInfoKHR* pInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkReleaseProfilingLockKHR(VkDevice device);

static { public const uint32 VK_KHR_MAINTENANCE_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_MAINTENANCE_2_EXTENSION_NAME = "VK_KHR_maintenance2"; }
static { [Obsolete("aliased")] public const let VK_KHR_MAINTENANCE2_SPEC_VERSION = VK_KHR_MAINTENANCE_2_SPEC_VERSION; }
static { [Obsolete("aliased")] public const let VK_KHR_MAINTENANCE2_EXTENSION_NAME = VK_KHR_MAINTENANCE_2_EXTENSION_NAME; }

typealias VkPhysicalDevicePointClippingPropertiesKHR = VkPhysicalDevicePointClippingProperties;
typealias VkPointClippingBehaviorKHR = VkPointClippingBehavior;
typealias VkRenderPassInputAttachmentAspectCreateInfoKHR = VkRenderPassInputAttachmentAspectCreateInfo;
typealias VkInputAttachmentAspectReferenceKHR = VkInputAttachmentAspectReference;
typealias VkImageViewUsageCreateInfoKHR = VkImageViewUsageCreateInfo;
typealias VkTessellationDomainOriginKHR = VkTessellationDomainOrigin;
typealias VkPipelineTessellationDomainOriginStateCreateInfoKHR = VkPipelineTessellationDomainOriginStateCreateInfo;

static { public const uint32 VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME = "VK_KHR_get_surface_capabilities2"; }

[CRepr] struct VkPhysicalDeviceSurfaceInfo2KHR
{
	public const VkStructureType SType = .VkPhysicalDeviceSurfaceInfo2KHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSurfaceKHR surface;

	public this(void* pNext = null, VkSurfaceKHR surface = null)
	{
		this.pNext = pNext;
		this.surface = surface;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSurfaceCapabilities2KHR
{
	public const VkStructureType SType = .VkSurfaceCapabilities2KHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSurfaceCapabilitiesKHR surfaceCapabilities;
}

[CRepr] struct VkSurfaceFormat2KHR
{
	public const VkStructureType SType = .VkSurfaceFormat2KHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSurfaceFormatKHR surfaceFormat;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, out VkSurfaceCapabilities2KHR pSurfaceCapabilities);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, out uint32 pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats = null);

static { public const uint32 VK_KHR_VARIABLE_POINTERS_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME = "VK_KHR_variable_pointers"; }

typealias VkPhysicalDeviceVariablePointerFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;
typealias VkPhysicalDeviceVariablePointersFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;

static { public const uint32 VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_display_properties2"; }

[CRepr] struct VkDisplayProperties2KHR
{
	public const VkStructureType SType = .VkDisplayProperties2KHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDisplayPropertiesKHR displayProperties;
}

[CRepr] struct VkDisplayPlaneProperties2KHR
{
	public const VkStructureType SType = .VkDisplayPlaneProperties2KHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDisplayPlanePropertiesKHR displayPlaneProperties;
}

[CRepr] struct VkDisplayModeProperties2KHR
{
	public const VkStructureType SType = .VkDisplayModeProperties2KHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDisplayModePropertiesKHR displayModeProperties;
}

[CRepr] struct VkDisplayPlaneInfo2KHR
{
	public const VkStructureType SType = .VkDisplayPlaneInfo2KHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDisplayModeKHR mode;
	public uint32 planeIndex;

	public this(void* pNext, VkDisplayModeKHR mode, uint32 planeIndex)
	{
		this.pNext = pNext;
		this.mode = mode;
		this.planeIndex = planeIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDisplayPlaneCapabilities2KHR
{
	public const VkStructureType SType = .VkDisplayPlaneCapabilities2KHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDisplayPlaneCapabilitiesKHR capabilities;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, out uint32 pPropertyCount, VkDisplayProperties2KHR* pProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, out uint32 pPropertyCount, VkDisplayPlaneProperties2KHR* pProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, out uint32 pPropertyCount, VkDisplayModeProperties2KHR* pProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo, out VkDisplayPlaneCapabilities2KHR pCapabilities);

static { public const uint32 VK_MVK_IOS_SURFACE_SPEC_VERSION = 3; }
static { public const c_char* VK_MVK_IOS_SURFACE_EXTENSION_NAME = "VK_MVK_ios_surface"; }

typealias VkIOSSurfaceCreateFlagsMVK = VkFlags;

[CRepr] struct VkIOSSurfaceCreateInfoMVK
{
	public const VkStructureType SType = .VkIosSurfaceCreateInfoMVK;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkIOSSurfaceCreateFlagsMVK flags;
	public void* pView;

	public this(void* pNext, VkIOSSurfaceCreateFlagsMVK flags, void* pView)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.pView = pView;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateIOSSurfaceMVK(VkInstance instance, VkIOSSurfaceCreateInfoMVK* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);

static { public const uint32 VK_MVK_MACOS_SURFACE_SPEC_VERSION = 3; }
static { public const c_char* VK_MVK_MACOS_SURFACE_EXTENSION_NAME = "VK_MVK_macos_surface"; }

typealias VkMacOSSurfaceCreateFlagsMVK = VkFlags;

[CRepr] struct VkMacOSSurfaceCreateInfoMVK
{
	public const VkStructureType SType = .VkMacosSurfaceCreateInfoMVK;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkMacOSSurfaceCreateFlagsMVK flags;
	public void* pView;

	public this(void* pNext, VkMacOSSurfaceCreateFlagsMVK flags, void* pView)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.pView = pView;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateMacOSSurfaceMVK(VkInstance instance, VkMacOSSurfaceCreateInfoMVK* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);

static { public const uint32 VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME = "VK_EXT_external_memory_dma_buf"; }
static { public const uint32 VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME = "VK_EXT_queue_family_foreign"; }
static { public const uint32 VK_QUEUE_FAMILY_FOREIGN_EXT = (.)(~2U); }
static { public const uint32 VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION = 3; }
static { public const c_char* VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME = "VK_KHR_dedicated_allocation"; }

typealias VkMemoryDedicatedRequirementsKHR = VkMemoryDedicatedRequirements;
typealias VkMemoryDedicatedAllocateInfoKHR = VkMemoryDedicatedAllocateInfo;

static { public const uint32 VK_EXT_DEBUG_UTILS_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_DEBUG_UTILS_EXTENSION_NAME = "VK_EXT_debug_utils"; }

[CallingConvention(VKAPI_PTR)] function VkBool32 PFN_vkDebugUtilsMessengerCallbackEXT(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData);

[CRepr] struct VkDebugUtilsLabelEXT
{
	public const VkStructureType SType = .VkDebugUtilsLabelEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_char* pLabelName;
	public float[4] color;

	public this(void* pNext, c_char* pLabelName, float[4] color)
	{
		this.pNext = pNext;
		this.pLabelName = pLabelName;
		this.color = color;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkDebugUtilsMessageSeverityFlagBitsEXT : int32
{
	VerboseEXT = 1 << 0,
	InfoEXT = 1 << 4,
	WarningEXT = 1 << 8,
	ErrorEXT = 1 << 12,
}

typealias VkDebugUtilsMessageSeverityFlagsEXT = VkDebugUtilsMessageSeverityFlagBitsEXT;

[AllowDuplicates] enum VkDebugUtilsMessageTypeFlagBitsEXT : int32
{
	GeneralEXT = 1 << 0,
	ValidationEXT = 1 << 1,
	PerformanceEXT = 1 << 2,
	DeviceAddressBindingEXT = 1 << 3,
}

typealias VkDebugUtilsMessageTypeFlagsEXT = VkDebugUtilsMessageTypeFlagBitsEXT;

[CRepr] struct VkDebugUtilsMessengerCallbackDataEXT
{
	public const VkStructureType SType = .VkDebugUtilsMessengerCallbackDataEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDebugUtilsMessengerCallbackDataFlagsEXT flags;
	public c_char* pMessageIdName;
	public int32 messageIdNumber;
	public c_char* pMessage;
	public uint32 queueLabelCount;
	public VkDebugUtilsLabelEXT* pQueueLabels;
	public VulkanSpan<VkDebugUtilsLabelEXT> queueLabels
	{
		[Inline] get => .(queueLabelCount, pQueueLabels);
		[Inline] set mut { queueLabelCount = value.count; pQueueLabels = value.ptr; }
	}
	public uint32 cmdBufLabelCount;
	public VkDebugUtilsLabelEXT* pCmdBufLabels;
	public VulkanSpan<VkDebugUtilsLabelEXT> cmdBufLabels
	{
		[Inline] get => .(cmdBufLabelCount, pCmdBufLabels);
		[Inline] set mut { cmdBufLabelCount = value.count; pCmdBufLabels = value.ptr; }
	}
	public uint32 objectCount;
	public VkDebugUtilsObjectNameInfoEXT* pObjects;
	public VulkanSpan<VkDebugUtilsObjectNameInfoEXT> objects
	{
		[Inline] get => .(objectCount, pObjects);
		[Inline] set mut { objectCount = value.count; pObjects = value.ptr; }
	}

	public this(void* pNext, VkDebugUtilsMessengerCallbackDataFlagsEXT flags, c_char* pMessageIdName, int32 messageIdNumber, c_char* pMessage = null, VulkanSpan<VkDebugUtilsLabelEXT> queueLabels = .(), VulkanSpan<VkDebugUtilsLabelEXT> cmdBufLabels = .(), VulkanSpan<VkDebugUtilsObjectNameInfoEXT> objects = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.pMessageIdName = pMessageIdName;
		this.messageIdNumber = messageIdNumber;
		this.pMessage = pMessage;
		this.queueLabels = queueLabels;
		this.cmdBufLabels = cmdBufLabels;
		this.objects = objects;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkDebugUtilsMessengerCallbackDataFlagsEXT = VkFlags;
typealias VkDebugUtilsMessengerCreateFlagsEXT = VkFlags;

[CRepr] struct VkDebugUtilsMessengerCreateInfoEXT
{
	public const VkStructureType SType = .VkDebugUtilsMessengerCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDebugUtilsMessengerCreateFlagsEXT flags;
	public VkDebugUtilsMessageSeverityFlagsEXT messageSeverity;
	public VkDebugUtilsMessageTypeFlagsEXT messageType;
	public PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback;
	public void* pUserData;

	public this(void* pNext, VkDebugUtilsMessengerCreateFlagsEXT flags, VkDebugUtilsMessageSeverityFlagsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback, void* pUserData = null)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.messageSeverity = messageSeverity;
		this.messageType = messageType;
		this.pfnUserCallback = pfnUserCallback;
		this.pUserData = pUserData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

class VkDebugUtilsMessengerEXT { private this() { } }

[CRepr] struct VkDebugUtilsObjectNameInfoEXT
{
	public const VkStructureType SType = .VkDebugUtilsObjectNameInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkObjectType objectType;
	public uint64 objectHandle;
	public c_char* pObjectName;

	public this(void* pNext, VkObjectType objectType, uint64 objectHandle, c_char* pObjectName = null)
	{
		this.pNext = pNext;
		this.objectType = objectType;
		this.objectHandle = objectHandle;
		this.pObjectName = pObjectName;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDebugUtilsObjectTagInfoEXT
{
	public const VkStructureType SType = .VkDebugUtilsObjectTagInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkObjectType objectType;
	public uint64 objectHandle;
	public uint64 tagName;
	public c_size tagSize;
	public void* pTag;

	public this(void* pNext, VkObjectType objectType, uint64 objectHandle, uint64 tagName, c_size tagSize, void* pTag)
	{
		this.pNext = pNext;
		this.objectType = objectType;
		this.objectHandle = objectHandle;
		this.tagName = tagName;
		this.tagSize = tagSize;
		this.pTag = pTag;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkSetDebugUtilsObjectNameEXT(VkDevice device, VkDebugUtilsObjectNameInfoEXT* pNameInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkSetDebugUtilsObjectTagEXT(VkDevice device, VkDebugUtilsObjectTagInfoEXT* pTagInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkQueueBeginDebugUtilsLabelEXT(VkQueue queue, VkDebugUtilsLabelEXT* pLabelInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkQueueEndDebugUtilsLabelEXT(VkQueue queue);
[CallingConvention(VKAPI_PTR)] function void PFN_vkQueueInsertDebugUtilsLabelEXT(VkQueue queue, VkDebugUtilsLabelEXT* pLabelInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, VkDebugUtilsLabelEXT* pLabelInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, VkDebugUtilsLabelEXT* pLabelInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkDebugUtilsMessengerEXT pMessenger);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkSubmitDebugUtilsMessageEXT(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, VkDebugUtilsMessengerCallbackDataEXT* pCallbackData);

static { public const uint32 VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 5; }
static { public const c_char* VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME = "VK_ANDROID_external_memory_android_hardware_buffer"; }

[CRepr] struct VkAndroidHardwareBufferUsageANDROID
{
	public const VkStructureType SType = .VkAndroidHardwareBufferUsageANDROID;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 androidHardwareBufferUsage;
}

[CRepr] struct VkAndroidHardwareBufferPropertiesANDROID
{
	public const VkStructureType SType = .VkAndroidHardwareBufferPropertiesANDROID;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize allocationSize;
	public uint32 memoryTypeBits;
}

[CRepr] struct VkAndroidHardwareBufferFormatPropertiesANDROID
{
	public const VkStructureType SType = .VkAndroidHardwareBufferFormatPropertiesANDROID;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat format;
	public uint64 externalFormat;
	public VkFormatFeatureFlags formatFeatures;
	public VkComponentMapping samplerYcbcrConversionComponents;
	public VkSamplerYcbcrModelConversion suggestedYcbcrModel;
	public VkSamplerYcbcrRange suggestedYcbcrRange;
	public VkChromaLocation suggestedXChromaOffset;
	public VkChromaLocation suggestedYChromaOffset;
}

[CRepr] struct VkImportAndroidHardwareBufferInfoANDROID
{
	public const VkStructureType SType = .VkImportAndroidHardwareBufferInfoANDROID;
	public VkStructureType sType = SType;
	public void* pNext;
	public AHardwareBuffer* buffer;

	public this(void* pNext, AHardwareBuffer* buffer)
	{
		this.pNext = pNext;
		this.buffer = buffer;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryGetAndroidHardwareBufferInfoANDROID
{
	public const VkStructureType SType = .VkMemoryGetAndroidHardwareBufferInfoANDROID;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceMemory memory;

	public this(void* pNext, VkDeviceMemory memory)
	{
		this.pNext = pNext;
		this.memory = memory;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExternalFormatANDROID
{
	public const VkStructureType SType = .VkExternalFormatANDROID;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 externalFormat;

	public this(void* pNext, uint64 externalFormat)
	{
		this.pNext = pNext;
		this.externalFormat = externalFormat;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetAndroidHardwareBufferPropertiesANDROID(VkDevice device, AHardwareBuffer* buffer, out VkAndroidHardwareBufferPropertiesANDROID pProperties);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetMemoryAndroidHardwareBufferANDROID(VkDevice device, VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo, out AHardwareBuffer* pBuffer);

[CRepr] struct VkAndroidHardwareBufferFormatProperties2ANDROID
{
	public const VkStructureType SType = .VkAndroidHardwareBufferFormatProperties2ANDROID;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat format;
	public uint64 externalFormat;
	public VkFormatFeatureFlags2 formatFeatures;
	public VkComponentMapping samplerYcbcrConversionComponents;
	public VkSamplerYcbcrModelConversion suggestedYcbcrModel;
	public VkSamplerYcbcrRange suggestedYcbcrRange;
	public VkChromaLocation suggestedXChromaOffset;
	public VkChromaLocation suggestedYChromaOffset;
}

static { public const uint32 VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME = "VK_EXT_sampler_filter_minmax"; }

typealias VkSamplerReductionModeEXT = VkSamplerReductionMode;
typealias VkSamplerReductionModeCreateInfoEXT = VkSamplerReductionModeCreateInfo;
typealias VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = VkPhysicalDeviceSamplerFilterMinmaxProperties;

static { public const uint32 VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME = "VK_KHR_storage_buffer_storage_class"; }
static { public const uint32 VK_AMD_GPU_SHADER_INT16_SPEC_VERSION = 2; }
static { public const c_char* VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME = "VK_AMD_gpu_shader_int16"; }
static { public const uint32 VK_AMDX_SHADER_ENQUEUE_SPEC_VERSION = 2; }
static { public const c_char* VK_AMDX_SHADER_ENQUEUE_EXTENSION_NAME = "VK_AMDX_shader_enqueue"; }
static { public const uint32 VK_SHADER_INDEX_UNUSED_AMDX = (.)(~0U); }

[CRepr] struct VkPhysicalDeviceShaderEnqueueFeaturesAMDX
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderEnqueueFeaturesAMDX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderEnqueue;
	public VkBool32 shaderMeshEnqueue;

	public this(void* pNext, VkBool32 shaderEnqueue, VkBool32 shaderMeshEnqueue)
	{
		this.pNext = pNext;
		this.shaderEnqueue = shaderEnqueue;
		this.shaderMeshEnqueue = shaderMeshEnqueue;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceShaderEnqueuePropertiesAMDX
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderEnqueuePropertiesAMDX;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxExecutionGraphDepth;
	public uint32 maxExecutionGraphShaderOutputNodes;
	public uint32 maxExecutionGraphShaderPayloadSize;
	public uint32 maxExecutionGraphShaderPayloadCount;
	public uint32 executionGraphDispatchAddressAlignment;
	public uint32[3] maxExecutionGraphWorkgroupCount;
	public uint32 maxExecutionGraphWorkgroups;
}

[CRepr] struct VkExecutionGraphPipelineScratchSizeAMDX
{
	public const VkStructureType SType = .VkExecutionGraphPipelineScratchSizeAMDX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize minSize;
	public VkDeviceSize maxSize;
	public VkDeviceSize sizeGranularity;

	public this(void* pNext, VkDeviceSize minSize, VkDeviceSize maxSize, VkDeviceSize sizeGranularity)
	{
		this.pNext = pNext;
		this.minSize = minSize;
		this.maxSize = maxSize;
		this.sizeGranularity = sizeGranularity;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExecutionGraphPipelineCreateInfoAMDX
{
	public const VkStructureType SType = .VkExecutionGraphPipelineCreateInfoAMDX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineCreateFlags flags;
	public uint32 stageCount;
	public VkPipelineShaderStageCreateInfo* pStages;
	public VulkanSpan<VkPipelineShaderStageCreateInfo> stages
	{
		[Inline] get => .(stageCount, pStages);
		[Inline] set mut { stageCount = value.count; pStages = value.ptr; }
	}
	public VkPipelineLibraryCreateInfoKHR* pLibraryInfo;
	public VkPipelineLayout layout;
	public VkPipeline basePipelineHandle;
	public int32 basePipelineIndex;

	public this(void* pNext, VkPipelineCreateFlags flags, VulkanSpan<VkPipelineShaderStageCreateInfo> stages, VkPipelineLibraryCreateInfoKHR* pLibraryInfo, VkPipelineLayout layout, VkPipeline basePipelineHandle, int32 basePipelineIndex) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.stages = stages;
		this.pLibraryInfo = pLibraryInfo;
		this.layout = layout;
		this.basePipelineHandle = basePipelineHandle;
		this.basePipelineIndex = basePipelineIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDispatchGraphInfoAMDX
{
	public uint32 nodeIndex;
	public uint32 payloadCount;
	public VkDeviceOrHostAddressConstAMDX payloads;
	public uint64 payloadStride;

	public this(uint32 nodeIndex, uint32 payloadCount, VkDeviceOrHostAddressConstAMDX payloads, uint64 payloadStride)
	{
		this.nodeIndex = nodeIndex;
		this.payloadCount = payloadCount;
		this.payloads = payloads;
		this.payloadStride = payloadStride;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkDispatchGraphCountInfoAMDX
{
	public uint32 count;
	public VkDeviceOrHostAddressConstAMDX infos;
	public uint64 stride;

	public this(uint32 count, VkDeviceOrHostAddressConstAMDX infos, uint64 stride)
	{
		this.count = count;
		this.infos = infos;
		this.stride = stride;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkPipelineShaderStageNodeCreateInfoAMDX
{
	public const VkStructureType SType = .VkPipelineShaderStageNodeCreateInfoAMDX;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_char* pName;
	public uint32 index;

	public this(void* pNext, c_char* pName, uint32 index)
	{
		this.pNext = pNext;
		this.pName = pName;
		this.index = index;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[Union, CRepr] struct VkDeviceOrHostAddressConstAMDX
{
	public VkDeviceAddress deviceAddress;
	public void* hostAddress;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateExecutionGraphPipelinesAMDX(VkDevice device, VkPipelineCache pipelineCache, uint32 createInfoCount, VkExecutionGraphPipelineCreateInfoAMDX* pCreateInfos, VkAllocationCallbacks* pAllocator, out VkPipeline pPipelines);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetExecutionGraphPipelineScratchSizeAMDX(VkDevice device, VkPipeline executionGraph, out VkExecutionGraphPipelineScratchSizeAMDX pSizeInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetExecutionGraphPipelineNodeIndexAMDX(VkDevice device, VkPipeline executionGraph, VkPipelineShaderStageNodeCreateInfoAMDX* pNodeInfo, out uint32 pNodeIndex);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdInitializeGraphScratchMemoryAMDX(VkCommandBuffer commandBuffer, VkPipeline executionGraph, VkDeviceAddress scratch, VkDeviceSize scratchSize);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDispatchGraphAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, VkDispatchGraphCountInfoAMDX* pCountInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDispatchGraphIndirectAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, VkDispatchGraphCountInfoAMDX* pCountInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDispatchGraphIndirectCountAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, VkDeviceAddress countInfo);

static { public const uint32 VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME = "VK_AMD_mixed_attachment_samples"; }

[CRepr] struct VkAttachmentSampleCountInfoAMD
{
	public const VkStructureType SType = .VkAttachmentSampleCountInfoAMD;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 colorAttachmentCount;
	public VkSampleCountFlagBits* pColorAttachmentSamples;
	public VulkanSpan<VkSampleCountFlagBits> colorAttachmentSamples
	{
		[Inline] get => .(colorAttachmentCount, pColorAttachmentSamples);
		[Inline] set mut { colorAttachmentCount = value.count; pColorAttachmentSamples = value.ptr; }
	}
	public VkSampleCountFlagBits depthStencilAttachmentSamples;

	public this(void* pNext = null, VulkanSpan<VkSampleCountFlagBits> colorAttachmentSamples = .(), VkSampleCountFlagBits depthStencilAttachmentSamples = 0) : this()
	{
		this.pNext = pNext;
		this.colorAttachmentSamples = colorAttachmentSamples;
		this.depthStencilAttachmentSamples = depthStencilAttachmentSamples;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME = "VK_AMD_shader_fragment_mask"; }
static { public const uint32 VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME = "VK_EXT_inline_uniform_block"; }

typealias VkPhysicalDeviceInlineUniformBlockFeaturesEXT = VkPhysicalDeviceInlineUniformBlockFeatures;
typealias VkPhysicalDeviceInlineUniformBlockPropertiesEXT = VkPhysicalDeviceInlineUniformBlockProperties;
typealias VkWriteDescriptorSetInlineUniformBlockEXT = VkWriteDescriptorSetInlineUniformBlock;
typealias VkDescriptorPoolInlineUniformBlockCreateInfoEXT = VkDescriptorPoolInlineUniformBlockCreateInfo;

static { public const uint32 VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME = "VK_EXT_shader_stencil_export"; }
static { public const uint32 VK_KHR_SHADER_BFLOAT16_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME = "VK_KHR_shader_bfloat16"; }

[CRepr] struct VkPhysicalDeviceShaderBfloat16FeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderBfloat16FeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderBFloat16Type;
	public VkBool32 shaderBFloat16DotProduct;
	public VkBool32 shaderBFloat16CooperativeMatrix;

	public this(void* pNext, VkBool32 shaderBFloat16Type, VkBool32 shaderBFloat16DotProduct, VkBool32 shaderBFloat16CooperativeMatrix)
	{
		this.pNext = pNext;
		this.shaderBFloat16Type = shaderBFloat16Type;
		this.shaderBFloat16DotProduct = shaderBFloat16DotProduct;
		this.shaderBFloat16CooperativeMatrix = shaderBFloat16CooperativeMatrix;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME = "VK_EXT_sample_locations"; }

[CRepr] struct VkSampleLocationEXT
{
	public float x;
	public float y;

	public this(float x, float y)
	{
		this.x = x;
		this.y = y;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkSampleLocationsInfoEXT
{
	public const VkStructureType SType = .VkSampleLocationsInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSampleCountFlagBits sampleLocationsPerPixel;
	public VkExtent2D sampleLocationGridSize;
	public uint32 sampleLocationsCount;
	public VkSampleLocationEXT* pSampleLocations;
	public VulkanSpan<VkSampleLocationEXT> sampleLocations
	{
		[Inline] get => .(sampleLocationsCount, pSampleLocations);
		[Inline] set mut { sampleLocationsCount = value.count; pSampleLocations = value.ptr; }
	}

	public this(void* pNext, VkSampleCountFlagBits sampleLocationsPerPixel, VkExtent2D sampleLocationGridSize, VulkanSpan<VkSampleLocationEXT> sampleLocations = .()) : this()
	{
		this.pNext = pNext;
		this.sampleLocationsPerPixel = sampleLocationsPerPixel;
		this.sampleLocationGridSize = sampleLocationGridSize;
		this.sampleLocations = sampleLocations;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAttachmentSampleLocationsEXT
{
	public uint32 attachmentIndex;
	public VkSampleLocationsInfoEXT sampleLocationsInfo;

	public this(uint32 attachmentIndex, VkSampleLocationsInfoEXT sampleLocationsInfo)
	{
		this.attachmentIndex = attachmentIndex;
		this.sampleLocationsInfo = sampleLocationsInfo;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkSubpassSampleLocationsEXT
{
	public uint32 subpassIndex;
	public VkSampleLocationsInfoEXT sampleLocationsInfo;

	public this(uint32 subpassIndex, VkSampleLocationsInfoEXT sampleLocationsInfo)
	{
		this.subpassIndex = subpassIndex;
		this.sampleLocationsInfo = sampleLocationsInfo;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkRenderPassSampleLocationsBeginInfoEXT
{
	public const VkStructureType SType = .VkRenderPassSampleLocationsBeginInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 attachmentInitialSampleLocationsCount;
	public VkAttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations;
	public VulkanSpan<VkAttachmentSampleLocationsEXT> attachmentInitialSampleLocations
	{
		[Inline] get => .(attachmentInitialSampleLocationsCount, pAttachmentInitialSampleLocations);
		[Inline] set mut { attachmentInitialSampleLocationsCount = value.count; pAttachmentInitialSampleLocations = value.ptr; }
	}
	public uint32 postSubpassSampleLocationsCount;
	public VkSubpassSampleLocationsEXT* pPostSubpassSampleLocations;
	public VulkanSpan<VkSubpassSampleLocationsEXT> postSubpassSampleLocations
	{
		[Inline] get => .(postSubpassSampleLocationsCount, pPostSubpassSampleLocations);
		[Inline] set mut { postSubpassSampleLocationsCount = value.count; pPostSubpassSampleLocations = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkAttachmentSampleLocationsEXT> attachmentInitialSampleLocations = .(), VulkanSpan<VkSubpassSampleLocationsEXT> postSubpassSampleLocations = .()) : this()
	{
		this.pNext = pNext;
		this.attachmentInitialSampleLocations = attachmentInitialSampleLocations;
		this.postSubpassSampleLocations = postSubpassSampleLocations;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineSampleLocationsStateCreateInfoEXT
{
	public const VkStructureType SType = .VkPipelineSampleLocationsStateCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 sampleLocationsEnable;
	public VkSampleLocationsInfoEXT sampleLocationsInfo;

	public this(void* pNext, VkBool32 sampleLocationsEnable, VkSampleLocationsInfoEXT sampleLocationsInfo)
	{
		this.pNext = pNext;
		this.sampleLocationsEnable = sampleLocationsEnable;
		this.sampleLocationsInfo = sampleLocationsInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceSampleLocationsPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceSampleLocationsPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSampleCountFlags sampleLocationSampleCounts;
	public VkExtent2D maxSampleLocationGridSize;
	public float[2] sampleLocationCoordinateRange;
	public uint32 sampleLocationSubPixelBits;
	public VkBool32 variableSampleLocations;
}

[CRepr] struct VkMultisamplePropertiesEXT
{
	public const VkStructureType SType = .VkMultisamplePropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExtent2D maxSampleLocationGridSize;
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer, VkSampleLocationsInfoEXT* pSampleLocationsInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, out VkMultisamplePropertiesEXT pMultisampleProperties);

static { public const uint32 VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME = "VK_KHR_relaxed_block_layout"; }
static { public const uint32 VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME = "VK_KHR_get_memory_requirements2"; }

typealias VkBufferMemoryRequirementsInfo2KHR = VkBufferMemoryRequirementsInfo2;
typealias VkImageMemoryRequirementsInfo2KHR = VkImageMemoryRequirementsInfo2;
typealias VkImageSparseMemoryRequirementsInfo2KHR = VkImageSparseMemoryRequirementsInfo2;
typealias VkMemoryRequirements2KHR = VkMemoryRequirements2;
typealias VkSparseImageMemoryRequirements2KHR = VkSparseImageMemoryRequirements2;

static { public const uint32 VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME = "VK_KHR_image_format_list"; }

typealias VkImageFormatListCreateInfoKHR = VkImageFormatListCreateInfo;

static { public const uint32 VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME = "VK_EXT_blend_operation_advanced"; }

[CRepr] struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 advancedBlendCoherentOperations;

	public this(void* pNext, VkBool32 advancedBlendCoherentOperations)
	{
		this.pNext = pNext;
		this.advancedBlendCoherentOperations = advancedBlendCoherentOperations;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 advancedBlendMaxColorAttachments;
	public VkBool32 advancedBlendIndependentBlend;
	public VkBool32 advancedBlendNonPremultipliedSrcColor;
	public VkBool32 advancedBlendNonPremultipliedDstColor;
	public VkBool32 advancedBlendCorrelatedOverlap;
	public VkBool32 advancedBlendAllOperations;
}

[CRepr] struct VkPipelineColorBlendAdvancedStateCreateInfoEXT
{
	public const VkStructureType SType = .VkPipelineColorBlendAdvancedStateCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 srcPremultiplied;
	public VkBool32 dstPremultiplied;
	public VkBlendOverlapEXT blendOverlap;

	public this(void* pNext, VkBool32 srcPremultiplied, VkBool32 dstPremultiplied, VkBlendOverlapEXT blendOverlap)
	{
		this.pNext = pNext;
		this.srcPremultiplied = srcPremultiplied;
		this.dstPremultiplied = dstPremultiplied;
		this.blendOverlap = blendOverlap;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkBlendOverlapEXT : int32
{
	UncorrelatedEXT = 0,
	DisjointEXT = 1,
	ConjointEXT = 2,
}

static { public const uint32 VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME = "VK_NV_fragment_coverage_to_color"; }

typealias VkPipelineCoverageToColorStateCreateFlagsNV = VkFlags;

[CRepr] struct VkPipelineCoverageToColorStateCreateInfoNV
{
	public const VkStructureType SType = .VkPipelineCoverageToColorStateCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineCoverageToColorStateCreateFlagsNV flags;
	public VkBool32 coverageToColorEnable;
	public uint32 coverageToColorLocation;

	public this(void* pNext, VkPipelineCoverageToColorStateCreateFlagsNV flags, VkBool32 coverageToColorEnable, uint32 coverageToColorLocation = 0)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.coverageToColorEnable = coverageToColorEnable;
		this.coverageToColorLocation = coverageToColorLocation;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION = 13; }
static { public const c_char* VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME = "VK_KHR_acceleration_structure"; }

[AllowDuplicates] enum VkAccelerationStructureTypeKHR : int32
{
	TopLevelKHR = 0,
	BottomLevelKHR = 1,
	GenericKHR = 2,
	VkAccelerationStructureTypeTopLevelNV = TopLevelKHR,
	VkAccelerationStructureTypeBottomLevelNV = BottomLevelKHR,
}

[Union, CRepr] struct VkDeviceOrHostAddressKHR
{
	public VkDeviceAddress deviceAddress;
	public void* hostAddress;
}

[Union, CRepr] struct VkDeviceOrHostAddressConstKHR
{
	public VkDeviceAddress deviceAddress;
	public void* hostAddress;
}

[CRepr] struct VkAccelerationStructureBuildRangeInfoKHR
{
	public uint32 primitiveCount;
	public uint32 primitiveOffset;
	public uint32 firstVertex;
	public uint32 transformOffset;

	public this(uint32 primitiveCount, uint32 primitiveOffset, uint32 firstVertex, uint32 transformOffset)
	{
		this.primitiveCount = primitiveCount;
		this.primitiveOffset = primitiveOffset;
		this.firstVertex = firstVertex;
		this.transformOffset = transformOffset;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkAabbPositionsKHR
{
	public float minX;
	public float minY;
	public float minZ;
	public float maxX;
	public float maxY;
	public float maxZ;

	public this(float minX, float minY, float minZ, float maxX, float maxY, float maxZ)
	{
		this.minX = minX;
		this.minY = minY;
		this.minZ = minZ;
		this.maxX = maxX;
		this.maxY = maxY;
		this.maxZ = maxZ;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkAccelerationStructureGeometryTrianglesDataKHR
{
	public const VkStructureType SType = .VkAccelerationStructureGeometryTrianglesDataKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat vertexFormat;
	public VkDeviceOrHostAddressConstKHR vertexData;
	public VkDeviceSize vertexStride;
	public uint32 maxVertex;
	public VkIndexType indexType;
	public VkDeviceOrHostAddressConstKHR indexData;
	public VkDeviceOrHostAddressConstKHR transformData;

	public this(void* pNext, VkFormat vertexFormat, VkDeviceOrHostAddressConstKHR vertexData, VkDeviceSize vertexStride, uint32 maxVertex, VkIndexType indexType, VkDeviceOrHostAddressConstKHR indexData, VkDeviceOrHostAddressConstKHR transformData)
	{
		this.pNext = pNext;
		this.vertexFormat = vertexFormat;
		this.vertexData = vertexData;
		this.vertexStride = vertexStride;
		this.maxVertex = maxVertex;
		this.indexType = indexType;
		this.indexData = indexData;
		this.transformData = transformData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkTransformMatrixKHR
{
	public float[3][4] matrix;

	public this(float[3][4] matrix)
	{
		this.matrix = matrix;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkAccelerationStructureBuildGeometryInfoKHR
{
	public const VkStructureType SType = .VkAccelerationStructureBuildGeometryInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAccelerationStructureTypeKHR type;
	public VkBuildAccelerationStructureFlagsKHR flags;
	public VkBuildAccelerationStructureModeKHR mode;
	public VkAccelerationStructureKHR srcAccelerationStructure;
	public VkAccelerationStructureKHR dstAccelerationStructure;
	public uint32 geometryCount;
	public VkAccelerationStructureGeometryKHR* pGeometries;
	public VkAccelerationStructureGeometryKHR** ppGeometries;
	public VulkanDuoSpan<VkAccelerationStructureGeometryKHR, VkAccelerationStructureGeometryKHR*> geometries_geometries
	{
		[Inline] get => .(geometryCount, pGeometries, ppGeometries);
		[Inline] set mut { geometryCount = value.count; pGeometries = value.ptr1; ppGeometries = value.ptr2; }
	}
	public VkDeviceOrHostAddressKHR scratchData;

	public this(void* pNext, VkAccelerationStructureTypeKHR type, VkBuildAccelerationStructureFlagsKHR flags, VkBuildAccelerationStructureModeKHR mode, VkAccelerationStructureKHR srcAccelerationStructure, VkAccelerationStructureKHR dstAccelerationStructure, VulkanDuoSpan<VkAccelerationStructureGeometryKHR, VkAccelerationStructureGeometryKHR*> geometries_geometries, VkDeviceOrHostAddressKHR scratchData) : this()
	{
		this.pNext = pNext;
		this.type = type;
		this.flags = flags;
		this.mode = mode;
		this.srcAccelerationStructure = srcAccelerationStructure;
		this.dstAccelerationStructure = dstAccelerationStructure;
		this.geometries_geometries = geometries_geometries;
		this.scratchData = scratchData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkAccelerationStructureBuildTypeKHR : int32
{
	HostKHR = 0,
	DeviceKHR = 1,
	HostOrDeviceKHR = 2,
}

[CRepr] struct VkAccelerationStructureGeometryAabbsDataKHR
{
	public const VkStructureType SType = .VkAccelerationStructureGeometryAabbsDataKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceOrHostAddressConstKHR data;
	public VkDeviceSize stride;

	public this(void* pNext, VkDeviceOrHostAddressConstKHR data, VkDeviceSize stride)
	{
		this.pNext = pNext;
		this.data = data;
		this.stride = stride;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAccelerationStructureInstanceKHR
{
	// The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.
	public VkTransformMatrixKHR transform;
	[Bitfield(.Public, .Bits(24), "instanceCustomIndex")]
	[Bitfield(.Public, .Bits(8), "mask")]
	private uint32 __bitfields_mask;
	[Bitfield(.Public, .Bits(24), "instanceShaderBindingTableRecordOffset")]
	[Bitfield(.Public, .Bits(8), "flags")]
	private uint32 __bitfields_flags;
	public uint64 accelerationStructureReference;

	public this(VkTransformMatrixKHR transform, uint32 instanceCustomIndex, uint32 mask, uint32 instanceShaderBindingTableRecordOffset, VkGeometryInstanceFlagsKHR flags, uint64 accelerationStructureReference) : this()
	{
		this.transform = transform;
		this.instanceCustomIndex = instanceCustomIndex;
		this.mask = mask;
		this.instanceShaderBindingTableRecordOffset = instanceShaderBindingTableRecordOffset;
		this.flags = (.)flags;
		this.accelerationStructureReference = accelerationStructureReference;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkAccelerationStructureGeometryInstancesDataKHR
{
	public const VkStructureType SType = .VkAccelerationStructureGeometryInstancesDataKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 arrayOfPointers;
	public VkDeviceOrHostAddressConstKHR data;

	public this(void* pNext, VkBool32 arrayOfPointers, VkDeviceOrHostAddressConstKHR data)
	{
		this.pNext = pNext;
		this.arrayOfPointers = arrayOfPointers;
		this.data = data;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[Union, CRepr] struct VkAccelerationStructureGeometryDataKHR
{
	public VkAccelerationStructureGeometryTrianglesDataKHR triangles;
	public VkAccelerationStructureGeometryAabbsDataKHR aabbs;
	public VkAccelerationStructureGeometryInstancesDataKHR instances;
}

[CRepr] struct VkAccelerationStructureGeometryKHR
{
	public const VkStructureType SType = .VkAccelerationStructureGeometryKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkGeometryTypeKHR geometryType;
	public VkAccelerationStructureGeometryDataKHR geometry;
	public VkGeometryFlagsKHR flags;

	public this(void* pNext, VkGeometryTypeKHR geometryType, VkAccelerationStructureGeometryDataKHR geometry, VkGeometryFlagsKHR flags = 0)
	{
		this.pNext = pNext;
		this.geometryType = geometryType;
		this.geometry = geometry;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkGeometryFlagsKHR = VkGeometryFlagBitsKHR;
typealias VkGeometryInstanceFlagsKHR = VkGeometryInstanceFlagBitsKHR;

[AllowDuplicates] enum VkGeometryFlagBitsKHR : int32
{
	OpaqueKHR = 1 << 0,
	NoDuplicateAnyHitInvocationKHR = 1 << 1,
	VkGeometryOpaqueNV = OpaqueKHR,
	VkGeometryNoDuplicateAnyHitInvocationNV = NoDuplicateAnyHitInvocationKHR,
}

[AllowDuplicates] enum VkGeometryInstanceFlagBitsKHR : int32
{
	TriangleFacingCullDisableKHR = 1 << 0,
	TriangleFlipFacingKHR = 1 << 1,
	ForceOpaqueKHR = 1 << 2,
	ForceNoOpaqueKHR = 1 << 3,
	TriangleFrontCounterclockwiseKHR = TriangleFlipFacingKHR,
	VkGeometryInstanceTriangleCullDisableNV = TriangleFacingCullDisableKHR,
	VkGeometryInstanceTriangleFrontCounterclockwiseNV = TriangleFrontCounterclockwiseKHR,
	VkGeometryInstanceForceOpaqueNV = ForceOpaqueKHR,
	VkGeometryInstanceForceNoOpaqueNV = ForceNoOpaqueKHR,
	VkGeometryInstanceForceOpacityMicromap2StateEXT = 1 << 4,
	VkGeometryInstanceDisableOpacityMicromapsEXT = 1 << 5,
}

[CRepr] struct VkAccelerationStructureCreateInfoKHR
{
	public const VkStructureType SType = .VkAccelerationStructureCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAccelerationStructureCreateFlagsKHR createFlags;
	public VkBuffer buffer;
	public VkDeviceSize offset; // Specified in bytes
	public VkDeviceSize size;
	public VkAccelerationStructureTypeKHR type;
	public VkDeviceAddress deviceAddress;

	public this(void* pNext, VkAccelerationStructureCreateFlagsKHR createFlags, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkAccelerationStructureTypeKHR type, VkDeviceAddress deviceAddress = 0)
	{
		this.pNext = pNext;
		this.createFlags = createFlags;
		this.buffer = buffer;
		this.offset = offset;
		this.size = size;
		this.type = type;
		this.deviceAddress = deviceAddress;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

class VkAccelerationStructureKHR { private this() { } }

[AllowDuplicates] enum VkBuildAccelerationStructureFlagBitsKHR : int32
{
	AllowUpdateKHR = 1 << 0,
	AllowCompactionKHR = 1 << 1,
	PreferFastTraceKHR = 1 << 2,
	PreferFastBuildKHR = 1 << 3,
	LowMemoryKHR = 1 << 4,
	VkBuildAccelerationStructureAllowUpdateNV = AllowUpdateKHR,
	VkBuildAccelerationStructureAllowCompactionNV = AllowCompactionKHR,
	VkBuildAccelerationStructurePreferFastTraceNV = PreferFastTraceKHR,
	VkBuildAccelerationStructurePreferFastBuildNV = PreferFastBuildKHR,
	VkBuildAccelerationStructureLowMemoryNV = LowMemoryKHR,
	VkBuildAccelerationStructureMotionNV = 1 << 5,
	VkBuildAccelerationStructureAllowOpacityMicromapUpdateEXT = 1 << 6,
	VkBuildAccelerationStructureAllowDisableOpacityMicromapsEXT = 1 << 7,
	VkBuildAccelerationStructureAllowOpacityMicromapDataUpdateEXT = 1 << 8,
	VkBuildAccelerationStructureAllowDisplacementMicromapUpdateNV = 1 << 9,
	AllowDataAccessKHR = 1 << 11,
}

typealias VkBuildAccelerationStructureFlagsKHR = VkBuildAccelerationStructureFlagBitsKHR;

[AllowDuplicates] enum VkCopyAccelerationStructureModeKHR : int32
{
	CloneKHR = 0,
	CompactKHR = 1,
	SerializeKHR = 2,
	DeserializeKHR = 3,
	VkCopyAccelerationStructureModeCloneNV = CloneKHR,
	VkCopyAccelerationStructureModeCompactNV = CompactKHR,
}

[AllowDuplicates] enum VkGeometryTypeKHR : int32
{
	TrianglesKHR = 0,
	AabbsKHR = 1,
	InstancesKHR = 2,
	VkGeometryTypeTrianglesNV = TrianglesKHR,
	VkGeometryTypeAabbsNV = AabbsKHR,
	VkGeometryTypeSpheresNV = 1000429004,
	VkGeometryTypeLinearSweptSpheresNV = 1000429005,
}

[CRepr] struct VkWriteDescriptorSetAccelerationStructureKHR
{
	public const VkStructureType SType = .VkWriteDescriptorSetAccelerationStructureKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 accelerationStructureCount;
	public VkAccelerationStructureKHR* pAccelerationStructures;
	public VulkanSpan<VkAccelerationStructureKHR> accelerationStructures
	{
		[Inline] get => .(accelerationStructureCount, pAccelerationStructures);
		[Inline] set mut { accelerationStructureCount = value.count; pAccelerationStructures = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<VkAccelerationStructureKHR> accelerationStructures) : this()
	{
		this.pNext = pNext;
		this.accelerationStructures = accelerationStructures;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceAccelerationStructureFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceAccelerationStructureFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 accelerationStructure;
	public VkBool32 accelerationStructureCaptureReplay;
	public VkBool32 accelerationStructureIndirectBuild;
	public VkBool32 accelerationStructureHostCommands;
	public VkBool32 descriptorBindingAccelerationStructureUpdateAfterBind;

	public this(void* pNext, VkBool32 accelerationStructure, VkBool32 accelerationStructureCaptureReplay, VkBool32 accelerationStructureIndirectBuild, VkBool32 accelerationStructureHostCommands, VkBool32 descriptorBindingAccelerationStructureUpdateAfterBind)
	{
		this.pNext = pNext;
		this.accelerationStructure = accelerationStructure;
		this.accelerationStructureCaptureReplay = accelerationStructureCaptureReplay;
		this.accelerationStructureIndirectBuild = accelerationStructureIndirectBuild;
		this.accelerationStructureHostCommands = accelerationStructureHostCommands;
		this.descriptorBindingAccelerationStructureUpdateAfterBind = descriptorBindingAccelerationStructureUpdateAfterBind;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceAccelerationStructurePropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceAccelerationStructurePropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 maxGeometryCount;
	public uint64 maxInstanceCount;
	public uint64 maxPrimitiveCount;
	public uint32 maxPerStageDescriptorAccelerationStructures;
	public uint32 maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
	public uint32 maxDescriptorSetAccelerationStructures;
	public uint32 maxDescriptorSetUpdateAfterBindAccelerationStructures;
	public uint32 minAccelerationStructureScratchOffsetAlignment;
}

[CRepr] struct VkAccelerationStructureDeviceAddressInfoKHR
{
	public const VkStructureType SType = .VkAccelerationStructureDeviceAddressInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAccelerationStructureKHR accelerationStructure;

	public this(void* pNext, VkAccelerationStructureKHR accelerationStructure)
	{
		this.pNext = pNext;
		this.accelerationStructure = accelerationStructure;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAccelerationStructureVersionInfoKHR
{
	public const VkStructureType SType = .VkAccelerationStructureVersionInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint8* pVersionData;

	public this(void* pNext, uint8* pVersionData)
	{
		this.pNext = pNext;
		this.pVersionData = pVersionData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCopyAccelerationStructureToMemoryInfoKHR
{
	public const VkStructureType SType = .VkCopyAccelerationStructureToMemoryInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAccelerationStructureKHR src;
	public VkDeviceOrHostAddressKHR dst;
	public VkCopyAccelerationStructureModeKHR mode;

	public this(void* pNext, VkAccelerationStructureKHR src, VkDeviceOrHostAddressKHR dst, VkCopyAccelerationStructureModeKHR mode)
	{
		this.pNext = pNext;
		this.src = src;
		this.dst = dst;
		this.mode = mode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCopyMemoryToAccelerationStructureInfoKHR
{
	public const VkStructureType SType = .VkCopyMemoryToAccelerationStructureInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceOrHostAddressConstKHR src;
	public VkAccelerationStructureKHR dst;
	public VkCopyAccelerationStructureModeKHR mode;

	public this(void* pNext, VkDeviceOrHostAddressConstKHR src, VkAccelerationStructureKHR dst, VkCopyAccelerationStructureModeKHR mode)
	{
		this.pNext = pNext;
		this.src = src;
		this.dst = dst;
		this.mode = mode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCopyAccelerationStructureInfoKHR
{
	public const VkStructureType SType = .VkCopyAccelerationStructureInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAccelerationStructureKHR src;
	public VkAccelerationStructureKHR dst;
	public VkCopyAccelerationStructureModeKHR mode;

	public this(void* pNext, VkAccelerationStructureKHR src, VkAccelerationStructureKHR dst, VkCopyAccelerationStructureModeKHR mode)
	{
		this.pNext = pNext;
		this.src = src;
		this.dst = dst;
		this.mode = mode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkAccelerationStructureCompatibilityKHR : int32
{
	CompatibleKHR = 0,
	IncompatibleKHR = 1,
}

[AllowDuplicates] enum VkAccelerationStructureCreateFlagBitsKHR : int32
{
	DeviceAddressCaptureReplayKHR = 1 << 0,
	VkAccelerationStructureCreateDescriptorBufferCaptureReplayEXT = 1 << 3,
	VkAccelerationStructureCreateMotionNV = 1 << 2,
}

typealias VkAccelerationStructureCreateFlagsKHR = VkAccelerationStructureCreateFlagBitsKHR;

[AllowDuplicates] enum VkBuildAccelerationStructureModeKHR : int32
{
	BuildKHR = 0,
	UpdateKHR = 1,
}

[CRepr] struct VkAccelerationStructureBuildSizesInfoKHR
{
	public const VkStructureType SType = .VkAccelerationStructureBuildSizesInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize accelerationStructureSize;
	public VkDeviceSize updateScratchSize;
	public VkDeviceSize buildScratchSize;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateAccelerationStructureKHR(VkDevice device, VkAccelerationStructureCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkAccelerationStructureKHR pAccelerationStructure);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32 infoCount, VkAccelerationStructureBuildGeometryInfoKHR* pInfos, VkAccelerationStructureBuildRangeInfoKHR* ppBuildRangeInfos);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32 infoCount, VkAccelerationStructureBuildGeometryInfoKHR* pInfos, VkDeviceAddress* pIndirectDeviceAddresses, uint32* pIndirectStrides, uint32* ppMaxPrimitiveCounts);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkBuildAccelerationStructuresKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32 infoCount, VkAccelerationStructureBuildGeometryInfoKHR* pInfos, VkAccelerationStructureBuildRangeInfoKHR* ppBuildRangeInfos);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkCopyAccelerationStructureInfoKHR* pInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkCopyAccelerationStructureToMemoryInfoKHR* pInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkCopyMemoryToAccelerationStructureInfoKHR* pInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkWriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32 accelerationStructureCount, VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, c_size dataSize, out void pData, c_size stride);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, VkCopyAccelerationStructureInfoKHR* pInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, VkCopyAccelerationStructureToMemoryInfoKHR* pInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, VkCopyMemoryToAccelerationStructureInfoKHR* pInfo);
[CallingConvention(VKAPI_PTR)] function VkDeviceAddress PFN_vkGetAccelerationStructureDeviceAddressKHR(VkDevice device, VkAccelerationStructureDeviceAddressInfoKHR* pInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32 accelerationStructureCount, VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32 firstQuery);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, VkAccelerationStructureVersionInfoKHR* pVersionInfo, out VkAccelerationStructureCompatibilityKHR pCompatibility);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo, uint32* pMaxPrimitiveCounts, out VkAccelerationStructureBuildSizesInfoKHR pSizeInfo);

static { public const uint32 VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME = "VK_KHR_ray_tracing_pipeline"; }
static { public const uint32 VK_SHADER_UNUSED_KHR = (.)(~0U); }

[CRepr] struct VkRayTracingShaderGroupCreateInfoKHR
{
	public const VkStructureType SType = .VkRayTracingShaderGroupCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRayTracingShaderGroupTypeKHR type;
	public uint32 generalShader;
	public uint32 closestHitShader;
	public uint32 anyHitShader;
	public uint32 intersectionShader;
	public void* pShaderGroupCaptureReplayHandle;

	public this(void* pNext, VkRayTracingShaderGroupTypeKHR type, uint32 generalShader, uint32 closestHitShader, uint32 anyHitShader, uint32 intersectionShader, void* pShaderGroupCaptureReplayHandle = null)
	{
		this.pNext = pNext;
		this.type = type;
		this.generalShader = generalShader;
		this.closestHitShader = closestHitShader;
		this.anyHitShader = anyHitShader;
		this.intersectionShader = intersectionShader;
		this.pShaderGroupCaptureReplayHandle = pShaderGroupCaptureReplayHandle;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkRayTracingShaderGroupTypeKHR : int32
{
	GeneralKHR = 0,
	TrianglesHitGroupKHR = 1,
	ProceduralHitGroupKHR = 2,
	VkRayTracingShaderGroupTypeGeneralNV = GeneralKHR,
	VkRayTracingShaderGroupTypeTrianglesHitGroupNV = TrianglesHitGroupKHR,
	VkRayTracingShaderGroupTypeProceduralHitGroupNV = ProceduralHitGroupKHR,
}

[CRepr] struct VkRayTracingPipelineCreateInfoKHR
{
	public const VkStructureType SType = .VkRayTracingPipelineCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineCreateFlags flags; // Pipeline creation flags
	public uint32 stageCount;
	public VkPipelineShaderStageCreateInfo* pStages; // One entry for each active shader stage
	public VulkanSpan<VkPipelineShaderStageCreateInfo> stages
	{
		[Inline] get => .(stageCount, pStages);
		[Inline] set mut { stageCount = value.count; pStages = value.ptr; }
	} // One entry for each active shader stage
	public uint32 groupCount;
	public VkRayTracingShaderGroupCreateInfoKHR* pGroups;
	public VulkanSpan<VkRayTracingShaderGroupCreateInfoKHR> groups
	{
		[Inline] get => .(groupCount, pGroups);
		[Inline] set mut { groupCount = value.count; pGroups = value.ptr; }
	}
	public uint32 maxPipelineRayRecursionDepth;
	public VkPipelineLibraryCreateInfoKHR* pLibraryInfo;
	public VkRayTracingPipelineInterfaceCreateInfoKHR* pLibraryInterface;
	public VkPipelineDynamicStateCreateInfo* pDynamicState;
	public VkPipelineLayout layout; // Interface layout of the pipeline
	public VkPipeline basePipelineHandle; // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
	public int32 basePipelineIndex; // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of

	public this(void* pNext, VkPipelineCreateFlags flags, VulkanSpan<VkPipelineShaderStageCreateInfo> stages, VulkanSpan<VkRayTracingShaderGroupCreateInfoKHR> groups, uint32 maxPipelineRayRecursionDepth, VkPipelineLibraryCreateInfoKHR* pLibraryInfo, VkRayTracingPipelineInterfaceCreateInfoKHR* pLibraryInterface, VkPipelineDynamicStateCreateInfo* pDynamicState, VkPipelineLayout layout, VkPipeline basePipelineHandle, int32 basePipelineIndex) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.stages = stages;
		this.groups = groups;
		this.maxPipelineRayRecursionDepth = maxPipelineRayRecursionDepth;
		this.pLibraryInfo = pLibraryInfo;
		this.pLibraryInterface = pLibraryInterface;
		this.pDynamicState = pDynamicState;
		this.layout = layout;
		this.basePipelineHandle = basePipelineHandle;
		this.basePipelineIndex = basePipelineIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceRayTracingPipelineFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceRayTracingPipelineFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 rayTracingPipeline;
	public VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplay;
	public VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
	public VkBool32 rayTracingPipelineTraceRaysIndirect;
	public VkBool32 rayTraversalPrimitiveCulling;

	public this(void* pNext, VkBool32 rayTracingPipeline, VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplay, VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplayMixed, VkBool32 rayTracingPipelineTraceRaysIndirect, VkBool32 rayTraversalPrimitiveCulling)
	{
		this.pNext = pNext;
		this.rayTracingPipeline = rayTracingPipeline;
		this.rayTracingPipelineShaderGroupHandleCaptureReplay = rayTracingPipelineShaderGroupHandleCaptureReplay;
		this.rayTracingPipelineShaderGroupHandleCaptureReplayMixed = rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
		this.rayTracingPipelineTraceRaysIndirect = rayTracingPipelineTraceRaysIndirect;
		this.rayTraversalPrimitiveCulling = rayTraversalPrimitiveCulling;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceRayTracingPipelinePropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceRayTracingPipelinePropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 shaderGroupHandleSize;
	public uint32 maxRayRecursionDepth;
	public uint32 maxShaderGroupStride;
	public uint32 shaderGroupBaseAlignment;
	public uint32 shaderGroupHandleCaptureReplaySize;
	public uint32 maxRayDispatchInvocationCount;
	public uint32 shaderGroupHandleAlignment;
	public uint32 maxRayHitAttributeSize;
}

[CRepr] struct VkStridedDeviceAddressRegionKHR
{
	public VkDeviceAddress deviceAddress;
	public VkDeviceSize stride;
	public VkDeviceSize size;

	public this(VkDeviceAddress deviceAddress, VkDeviceSize stride, VkDeviceSize size)
	{
		this.deviceAddress = deviceAddress;
		this.stride = stride;
		this.size = size;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkTraceRaysIndirectCommandKHR
{
	public uint32 width;
	public uint32 height;
	public uint32 depth;

	public this(uint32 width, uint32 height, uint32 depth)
	{
		this.width = width;
		this.height = height;
		this.depth = depth;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkRayTracingPipelineInterfaceCreateInfoKHR
{
	public const VkStructureType SType = .VkRayTracingPipelineInterfaceCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxPipelineRayPayloadSize;
	public uint32 maxPipelineRayHitAttributeSize;

	public this(void* pNext, uint32 maxPipelineRayPayloadSize, uint32 maxPipelineRayHitAttributeSize)
	{
		this.pNext = pNext;
		this.maxPipelineRayPayloadSize = maxPipelineRayPayloadSize;
		this.maxPipelineRayHitAttributeSize = maxPipelineRayHitAttributeSize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkShaderGroupShaderKHR : int32
{
	GeneralKHR = 0,
	ClosestHitKHR = 1,
	AnyHitKHR = 2,
	IntersectionKHR = 3,
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdTraceRaysKHR(VkCommandBuffer commandBuffer, VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32 width, uint32 height, uint32 depth);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32 createInfoCount, VkRayTracingPipelineCreateInfoKHR* pCreateInfos, VkAllocationCallbacks* pAllocator, out VkPipeline pPipelines);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetRayTracingShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32 firstGroup, uint32 groupCount, c_size dataSize, out void pData);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32 firstGroup, uint32 groupCount, c_size dataSize, out void pData);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress);
[CallingConvention(VKAPI_PTR)] function VkDeviceSize PFN_vkGetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32 group, VkShaderGroupShaderKHR groupShader);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32 pipelineStackSize);

static { public const uint32 VK_KHR_RAY_QUERY_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_RAY_QUERY_EXTENSION_NAME = "VK_KHR_ray_query"; }

[CRepr] struct VkPhysicalDeviceRayQueryFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceRayQueryFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 rayQuery;

	public this(void* pNext, VkBool32 rayQuery)
	{
		this.pNext = pNext;
		this.rayQuery = rayQuery;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME = "VK_NV_framebuffer_mixed_samples"; }

[CRepr] struct VkPipelineCoverageModulationStateCreateInfoNV
{
	public const VkStructureType SType = .VkPipelineCoverageModulationStateCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineCoverageModulationStateCreateFlagsNV flags;
	public VkCoverageModulationModeNV coverageModulationMode;
	public VkBool32 coverageModulationTableEnable;
	public uint32 coverageModulationTableCount;
	public float* pCoverageModulationTable;
	public VulkanSpan<float> coverageModulationTable
	{
		[Inline] get => .(coverageModulationTableCount, pCoverageModulationTable);
		[Inline] set mut { coverageModulationTableCount = value.count; pCoverageModulationTable = value.ptr; }
	}

	public this(void* pNext, VkPipelineCoverageModulationStateCreateFlagsNV flags, VkCoverageModulationModeNV coverageModulationMode, VkBool32 coverageModulationTableEnable, VulkanSpan<float> coverageModulationTable = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.coverageModulationMode = coverageModulationMode;
		this.coverageModulationTableEnable = coverageModulationTableEnable;
		this.coverageModulationTable = coverageModulationTable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineCoverageModulationStateCreateFlagsNV = VkFlags;

[AllowDuplicates] enum VkCoverageModulationModeNV : int32
{
	NoneNV = 0,
	RgbNV = 1,
	AlphaNV = 2,
	RgbaNV = 3,
}

typealias VkAttachmentSampleCountInfoNV = VkAttachmentSampleCountInfoAMD;

static { public const uint32 VK_NV_FILL_RECTANGLE_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_FILL_RECTANGLE_EXTENSION_NAME = "VK_NV_fill_rectangle"; }
static { public const uint32 VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME = "VK_NV_shader_sm_builtins"; }

[CRepr] struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderSmBuiltinsPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 shaderSMCount;
	public uint32 shaderWarpsPerSM;
}

[CRepr] struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderSmBuiltinsFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderSMBuiltins;

	public this(void* pNext, VkBool32 shaderSMBuiltins)
	{
		this.pNext = pNext;
		this.shaderSMBuiltins = shaderSMBuiltins;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME = "VK_EXT_post_depth_coverage"; }
static { public const uint32 VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION = 14; }
static { public const c_char* VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME = "VK_KHR_sampler_ycbcr_conversion"; }

typealias VkSamplerYcbcrConversionCreateInfoKHR = VkSamplerYcbcrConversionCreateInfo;
typealias VkSamplerYcbcrConversionInfoKHR = VkSamplerYcbcrConversionInfo;
typealias VkBindImagePlaneMemoryInfoKHR = VkBindImagePlaneMemoryInfo;
typealias VkImagePlaneMemoryRequirementsInfoKHR = VkImagePlaneMemoryRequirementsInfo;
typealias VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = VkPhysicalDeviceSamplerYcbcrConversionFeatures;
typealias VkSamplerYcbcrConversionImageFormatPropertiesKHR = VkSamplerYcbcrConversionImageFormatProperties;
typealias VkSamplerYcbcrModelConversionKHR = VkSamplerYcbcrModelConversion;
typealias VkSamplerYcbcrRangeKHR = VkSamplerYcbcrRange;
typealias VkChromaLocationKHR = VkChromaLocation;

static { public const uint32 VK_KHR_BIND_MEMORY_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_BIND_MEMORY_2_EXTENSION_NAME = "VK_KHR_bind_memory2"; }

typealias VkBindBufferMemoryInfoKHR = VkBindBufferMemoryInfo;
typealias VkBindImageMemoryInfoKHR = VkBindImageMemoryInfo;

static { public const uint32 VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME = "VK_EXT_image_drm_format_modifier"; }

[CRepr] struct VkDrmFormatModifierPropertiesListEXT
{
	public const VkStructureType SType = .VkDrmFormatModifierPropertiesListEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 drmFormatModifierCount;
	public VkDrmFormatModifierPropertiesEXT* pDrmFormatModifierProperties;
	public VulkanSpan<VkDrmFormatModifierPropertiesEXT> drmFormatModifierProperties
	{
		[Inline] get => .(drmFormatModifierCount, pDrmFormatModifierProperties);
		[Inline] set mut { drmFormatModifierCount = value.count; pDrmFormatModifierProperties = value.ptr; }
	}
}

[CRepr] struct VkDrmFormatModifierPropertiesEXT
{
	public uint64 drmFormatModifier;
	public uint32 drmFormatModifierPlaneCount;
	public VkFormatFeatureFlags drmFormatModifierTilingFeatures;
}

[CRepr] struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceImageDrmFormatModifierInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 drmFormatModifier;
	public VkSharingMode sharingMode;
	public uint32 queueFamilyIndexCount;
	public uint32* pQueueFamilyIndices;
	public VulkanSpan<uint32> queueFamilyIndices
	{
		[Inline] get => .(queueFamilyIndexCount, pQueueFamilyIndices);
		[Inline] set mut { queueFamilyIndexCount = value.count; pQueueFamilyIndices = value.ptr; }
	}

	public this(void* pNext, uint64 drmFormatModifier, VkSharingMode sharingMode, VulkanSpan<uint32> queueFamilyIndices = .()) : this()
	{
		this.pNext = pNext;
		this.drmFormatModifier = drmFormatModifier;
		this.sharingMode = sharingMode;
		this.queueFamilyIndices = queueFamilyIndices;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageDrmFormatModifierListCreateInfoEXT
{
	public const VkStructureType SType = .VkImageDrmFormatModifierListCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 drmFormatModifierCount;
	public uint64* pDrmFormatModifiers;
	public VulkanSpan<uint64> drmFormatModifiers
	{
		[Inline] get => .(drmFormatModifierCount, pDrmFormatModifiers);
		[Inline] set mut { drmFormatModifierCount = value.count; pDrmFormatModifiers = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<uint64> drmFormatModifiers) : this()
	{
		this.pNext = pNext;
		this.drmFormatModifiers = drmFormatModifiers;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageDrmFormatModifierExplicitCreateInfoEXT
{
	public const VkStructureType SType = .VkImageDrmFormatModifierExplicitCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 drmFormatModifier;
	public uint32 drmFormatModifierPlaneCount;
	public VkSubresourceLayout* pPlaneLayouts;
	public VulkanSpan<VkSubresourceLayout> planeLayouts
	{
		[Inline] get => .(drmFormatModifierPlaneCount, pPlaneLayouts);
		[Inline] set mut { drmFormatModifierPlaneCount = value.count; pPlaneLayouts = value.ptr; }
	}

	public this(void* pNext, uint64 drmFormatModifier, VulkanSpan<VkSubresourceLayout> planeLayouts) : this()
	{
		this.pNext = pNext;
		this.drmFormatModifier = drmFormatModifier;
		this.planeLayouts = planeLayouts;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageDrmFormatModifierPropertiesEXT
{
	public const VkStructureType SType = .VkImageDrmFormatModifierPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 drmFormatModifier;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, out VkImageDrmFormatModifierPropertiesEXT pProperties);

[CRepr] struct VkDrmFormatModifierPropertiesList2EXT
{
	public const VkStructureType SType = .VkDrmFormatModifierPropertiesList2EXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 drmFormatModifierCount;
	public VkDrmFormatModifierProperties2EXT* pDrmFormatModifierProperties;
	public VulkanSpan<VkDrmFormatModifierProperties2EXT> drmFormatModifierProperties
	{
		[Inline] get => .(drmFormatModifierCount, pDrmFormatModifierProperties);
		[Inline] set mut { drmFormatModifierCount = value.count; pDrmFormatModifierProperties = value.ptr; }
	}
}

[CRepr] struct VkDrmFormatModifierProperties2EXT
{
	public uint64 drmFormatModifier;
	public uint32 drmFormatModifierPlaneCount;
	public VkFormatFeatureFlags2 drmFormatModifierTilingFeatures;
}

static { public const uint32 VK_EXT_VALIDATION_CACHE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_VALIDATION_CACHE_EXTENSION_NAME = "VK_EXT_validation_cache"; }

class VkValidationCacheEXT { private this() { } }

[CRepr] struct VkValidationCacheCreateInfoEXT
{
	public const VkStructureType SType = .VkValidationCacheCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkValidationCacheCreateFlagsEXT flags;
	public c_size initialDataSize;
	public void* pInitialData;

	public this(void* pNext, VkValidationCacheCreateFlagsEXT flags, c_size initialDataSize, void* pInitialData)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.initialDataSize = initialDataSize;
		this.pInitialData = pInitialData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkShaderModuleValidationCacheCreateInfoEXT
{
	public const VkStructureType SType = .VkShaderModuleValidationCacheCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkValidationCacheEXT validationCache;

	public this(void* pNext, VkValidationCacheEXT validationCache)
	{
		this.pNext = pNext;
		this.validationCache = validationCache;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkValidationCacheHeaderVersionEXT : int32
{
	OneEXT = 1,
}

typealias VkValidationCacheCreateFlagsEXT = VkFlags;

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateValidationCacheEXT(VkDevice device, VkValidationCacheCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkValidationCacheEXT pValidationCache);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyValidationCacheEXT(VkDevice device, VkValidationCacheEXT validationCache = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkMergeValidationCachesEXT(VkDevice device, VkValidationCacheEXT dstCache, uint32 srcCacheCount, VkValidationCacheEXT* pSrcCaches);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, out c_size pDataSize, out void pData);

static { public const uint32 VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME = "VK_EXT_descriptor_indexing"; }

typealias VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = VkDescriptorSetLayoutBindingFlagsCreateInfo;
typealias VkPhysicalDeviceDescriptorIndexingFeaturesEXT = VkPhysicalDeviceDescriptorIndexingFeatures;
typealias VkPhysicalDeviceDescriptorIndexingPropertiesEXT = VkPhysicalDeviceDescriptorIndexingProperties;
typealias VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = VkDescriptorSetVariableDescriptorCountAllocateInfo;
typealias VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = VkDescriptorSetVariableDescriptorCountLayoutSupport;
typealias VkDescriptorBindingFlagBitsEXT = VkDescriptorBindingFlagBits;
typealias VkDescriptorBindingFlagsEXT = VkDescriptorBindingFlags;

static { public const uint32 VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME = "VK_EXT_shader_viewport_index_layer"; }
static { public const uint32 VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME = "VK_KHR_portability_subset"; }

[CRepr] struct VkPhysicalDevicePortabilitySubsetFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDevicePortabilitySubsetFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 constantAlphaColorBlendFactors;
	public VkBool32 events;
	public VkBool32 imageViewFormatReinterpretation;
	public VkBool32 imageViewFormatSwizzle;
	public VkBool32 imageView2DOn3DImage;
	public VkBool32 multisampleArrayImage;
	public VkBool32 mutableComparisonSamplers;
	public VkBool32 pointPolygons;
	public VkBool32 samplerMipLodBias;
	public VkBool32 separateStencilMaskRef;
	public VkBool32 shaderSampleRateInterpolationFunctions;
	public VkBool32 tessellationIsolines;
	public VkBool32 tessellationPointMode;
	public VkBool32 triangleFans;
	public VkBool32 vertexAttributeAccessBeyondStride;

	public this(void* pNext, VkBool32 constantAlphaColorBlendFactors, VkBool32 events, VkBool32 imageViewFormatReinterpretation, VkBool32 imageViewFormatSwizzle, VkBool32 imageView2DOn3DImage, VkBool32 multisampleArrayImage, VkBool32 mutableComparisonSamplers, VkBool32 pointPolygons, VkBool32 samplerMipLodBias, VkBool32 separateStencilMaskRef, VkBool32 shaderSampleRateInterpolationFunctions, VkBool32 tessellationIsolines, VkBool32 tessellationPointMode, VkBool32 triangleFans, VkBool32 vertexAttributeAccessBeyondStride)
	{
		this.pNext = pNext;
		this.constantAlphaColorBlendFactors = constantAlphaColorBlendFactors;
		this.events = events;
		this.imageViewFormatReinterpretation = imageViewFormatReinterpretation;
		this.imageViewFormatSwizzle = imageViewFormatSwizzle;
		this.imageView2DOn3DImage = imageView2DOn3DImage;
		this.multisampleArrayImage = multisampleArrayImage;
		this.mutableComparisonSamplers = mutableComparisonSamplers;
		this.pointPolygons = pointPolygons;
		this.samplerMipLodBias = samplerMipLodBias;
		this.separateStencilMaskRef = separateStencilMaskRef;
		this.shaderSampleRateInterpolationFunctions = shaderSampleRateInterpolationFunctions;
		this.tessellationIsolines = tessellationIsolines;
		this.tessellationPointMode = tessellationPointMode;
		this.triangleFans = triangleFans;
		this.vertexAttributeAccessBeyondStride = vertexAttributeAccessBeyondStride;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDevicePortabilitySubsetPropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDevicePortabilitySubsetPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 minVertexInputBindingStrideAlignment;
}

static { public const uint32 VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION = 3; }
static { public const c_char* VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME = "VK_NV_shading_rate_image"; }

[AllowDuplicates] enum VkShadingRatePaletteEntryNV : int32
{
	NoInvocationsNV = 0,
	VK_16InvocationsPerPixelNV = 1,
	VK_8InvocationsPerPixelNV = 2,
	VK_4InvocationsPerPixelNV = 3,
	VK_2InvocationsPerPixelNV = 4,
	VK_1InvocationPerPixelNV = 5,
	VK_1InvocationPer2x1PixelsNV = 6,
	VK_1InvocationPer1x2PixelsNV = 7,
	VK_1InvocationPer2x2PixelsNV = 8,
	VK_1InvocationPer4x2PixelsNV = 9,
	VK_1InvocationPer2x4PixelsNV = 10,
	VK_1InvocationPer4x4PixelsNV = 11,
}

[CRepr] struct VkShadingRatePaletteNV
{
	public uint32 shadingRatePaletteEntryCount;
	public VkShadingRatePaletteEntryNV* pShadingRatePaletteEntries;
	public VulkanSpan<VkShadingRatePaletteEntryNV> shadingRatePaletteEntries
	{
		[Inline] get => .(shadingRatePaletteEntryCount, pShadingRatePaletteEntries);
		[Inline] set mut { shadingRatePaletteEntryCount = value.count; pShadingRatePaletteEntries = value.ptr; }
	}

	public this(VulkanSpan<VkShadingRatePaletteEntryNV> shadingRatePaletteEntries) : this()
	{
		this.shadingRatePaletteEntries = shadingRatePaletteEntries;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkPipelineViewportShadingRateImageStateCreateInfoNV
{
	public const VkStructureType SType = .VkPipelineViewportShadingRateImageStateCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shadingRateImageEnable;
	public uint32 viewportCount;
	public VkShadingRatePaletteNV* pShadingRatePalettes;
	public VulkanSpan<VkShadingRatePaletteNV> shadingRatePalettes
	{
		[Inline] get => .(viewportCount, pShadingRatePalettes);
		[Inline] set mut { viewportCount = value.count; pShadingRatePalettes = value.ptr; }
	}

	public this(void* pNext, VkBool32 shadingRateImageEnable, VulkanSpan<VkShadingRatePaletteNV> shadingRatePalettes = .()) : this()
	{
		this.pNext = pNext;
		this.shadingRateImageEnable = shadingRateImageEnable;
		this.shadingRatePalettes = shadingRatePalettes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceShadingRateImageFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceShadingRateImageFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shadingRateImage;
	public VkBool32 shadingRateCoarseSampleOrder;

	public this(void* pNext, VkBool32 shadingRateImage, VkBool32 shadingRateCoarseSampleOrder)
	{
		this.pNext = pNext;
		this.shadingRateImage = shadingRateImage;
		this.shadingRateCoarseSampleOrder = shadingRateCoarseSampleOrder;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceShadingRateImagePropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceShadingRateImagePropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExtent2D shadingRateTexelSize;
	public uint32 shadingRatePaletteSize;
	public uint32 shadingRateMaxCoarseSamples;
}

[CRepr] struct VkCoarseSampleLocationNV
{
	public uint32 pixelX;
	public uint32 pixelY;
	public uint32 sample;

	public this(uint32 pixelX, uint32 pixelY, uint32 sample)
	{
		this.pixelX = pixelX;
		this.pixelY = pixelY;
		this.sample = sample;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkCoarseSampleOrderCustomNV
{
	public VkShadingRatePaletteEntryNV shadingRate;
	public uint32 sampleCount;
	public uint32 sampleLocationCount;
	public VkCoarseSampleLocationNV* pSampleLocations;
	public VulkanSpan<VkCoarseSampleLocationNV> sampleLocations
	{
		[Inline] get => .(sampleLocationCount, pSampleLocations);
		[Inline] set mut { sampleLocationCount = value.count; pSampleLocations = value.ptr; }
	}

	public this(VkShadingRatePaletteEntryNV shadingRate, uint32 sampleCount, VulkanSpan<VkCoarseSampleLocationNV> sampleLocations) : this()
	{
		this.shadingRate = shadingRate;
		this.sampleCount = sampleCount;
		this.sampleLocations = sampleLocations;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV
{
	public const VkStructureType SType = .VkPipelineViewportCoarseSampleOrderStateCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkCoarseSampleOrderTypeNV sampleOrderType;
	public uint32 customSampleOrderCount;
	public VkCoarseSampleOrderCustomNV* pCustomSampleOrders;
	public VulkanSpan<VkCoarseSampleOrderCustomNV> customSampleOrders
	{
		[Inline] get => .(customSampleOrderCount, pCustomSampleOrders);
		[Inline] set mut { customSampleOrderCount = value.count; pCustomSampleOrders = value.ptr; }
	}

	public this(void* pNext, VkCoarseSampleOrderTypeNV sampleOrderType, VulkanSpan<VkCoarseSampleOrderCustomNV> customSampleOrders = .()) : this()
	{
		this.pNext = pNext;
		this.sampleOrderType = sampleOrderType;
		this.customSampleOrders = customSampleOrders;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkCoarseSampleOrderTypeNV : int32
{
	DefaultNV = 0,
	CustomNV = 1,
	PixelMajorNV = 2,
	SampleMajorNV = 3,
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32 firstViewport, uint32 viewportCount, VkShadingRatePaletteNV* pShadingRatePalettes);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32 customSampleOrderCount = 0, VkCoarseSampleOrderCustomNV* pCustomSampleOrders = null);

static { public const uint32 VK_NV_RAY_TRACING_SPEC_VERSION = 3; }
static { public const c_char* VK_NV_RAY_TRACING_EXTENSION_NAME = "VK_NV_ray_tracing"; }
static { public const let VK_SHADER_UNUSED_NV = VK_SHADER_UNUSED_KHR; }

[CRepr] struct VkRayTracingShaderGroupCreateInfoNV
{
	public const VkStructureType SType = .VkRayTracingShaderGroupCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRayTracingShaderGroupTypeKHR type;
	public uint32 generalShader;
	public uint32 closestHitShader;
	public uint32 anyHitShader;
	public uint32 intersectionShader;

	public this(void* pNext, VkRayTracingShaderGroupTypeKHR type, uint32 generalShader, uint32 closestHitShader, uint32 anyHitShader, uint32 intersectionShader)
	{
		this.pNext = pNext;
		this.type = type;
		this.generalShader = generalShader;
		this.closestHitShader = closestHitShader;
		this.anyHitShader = anyHitShader;
		this.intersectionShader = intersectionShader;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkRayTracingShaderGroupTypeNV = VkRayTracingShaderGroupTypeKHR;

[CRepr] struct VkRayTracingPipelineCreateInfoNV
{
	public const VkStructureType SType = .VkRayTracingPipelineCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineCreateFlags flags; // Pipeline creation flags
	public uint32 stageCount;
	public VkPipelineShaderStageCreateInfo* pStages; // One entry for each active shader stage
	public VulkanSpan<VkPipelineShaderStageCreateInfo> stages
	{
		[Inline] get => .(stageCount, pStages);
		[Inline] set mut { stageCount = value.count; pStages = value.ptr; }
	} // One entry for each active shader stage
	public uint32 groupCount;
	public VkRayTracingShaderGroupCreateInfoNV* pGroups;
	public VulkanSpan<VkRayTracingShaderGroupCreateInfoNV> groups
	{
		[Inline] get => .(groupCount, pGroups);
		[Inline] set mut { groupCount = value.count; pGroups = value.ptr; }
	}
	public uint32 maxRecursionDepth;
	public VkPipelineLayout layout; // Interface layout of the pipeline
	public VkPipeline basePipelineHandle; // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
	public int32 basePipelineIndex; // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of

	public this(void* pNext, VkPipelineCreateFlags flags, VulkanSpan<VkPipelineShaderStageCreateInfo> stages, VulkanSpan<VkRayTracingShaderGroupCreateInfoNV> groups, uint32 maxRecursionDepth, VkPipelineLayout layout, VkPipeline basePipelineHandle, int32 basePipelineIndex) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.stages = stages;
		this.groups = groups;
		this.maxRecursionDepth = maxRecursionDepth;
		this.layout = layout;
		this.basePipelineHandle = basePipelineHandle;
		this.basePipelineIndex = basePipelineIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkGeometryTypeNV = VkGeometryTypeKHR;
typealias VkAccelerationStructureTypeNV = VkAccelerationStructureTypeKHR;

[CRepr] struct VkGeometryTrianglesNV
{
	public const VkStructureType SType = .VkGeometryTrianglesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBuffer vertexData;
	public VkDeviceSize vertexOffset;
	public uint32 vertexCount;
	public VkDeviceSize vertexStride;
	public VkFormat vertexFormat;
	public VkBuffer indexData;
	public VkDeviceSize indexOffset;
	public uint32 indexCount;
	public VkIndexType indexType;
	public VkBuffer transformData; // Optional reference to array of floats representing a 3x4 row major affine transformation matrix.
	public VkDeviceSize transformOffset;

	public this(void* pNext, VkBuffer vertexData, VkDeviceSize vertexOffset, uint32 vertexCount, VkDeviceSize vertexStride, VkFormat vertexFormat, VkBuffer indexData, VkDeviceSize indexOffset, uint32 indexCount, VkIndexType indexType, VkBuffer transformData, VkDeviceSize transformOffset)
	{
		this.pNext = pNext;
		this.vertexData = vertexData;
		this.vertexOffset = vertexOffset;
		this.vertexCount = vertexCount;
		this.vertexStride = vertexStride;
		this.vertexFormat = vertexFormat;
		this.indexData = indexData;
		this.indexOffset = indexOffset;
		this.indexCount = indexCount;
		this.indexType = indexType;
		this.transformData = transformData;
		this.transformOffset = transformOffset;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkGeometryAABBNV
{
	public const VkStructureType SType = .VkGeometryAabbNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBuffer aabbData;
	public uint32 numAABBs;
	public uint32 stride; // Stride in bytes between AABBs
	public VkDeviceSize offset; // Offset in bytes of the first AABB in aabbData

	public this(void* pNext, VkBuffer aabbData, uint32 numAABBs, uint32 stride, VkDeviceSize offset)
	{
		this.pNext = pNext;
		this.aabbData = aabbData;
		this.numAABBs = numAABBs;
		this.stride = stride;
		this.offset = offset;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkGeometryDataNV
{
	public VkGeometryTrianglesNV triangles;
	public VkGeometryAABBNV aabbs;

	public this(VkGeometryTrianglesNV triangles, VkGeometryAABBNV aabbs)
	{
		this.triangles = triangles;
		this.aabbs = aabbs;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkGeometryNV
{
	public const VkStructureType SType = .VkGeometryNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkGeometryTypeKHR geometryType;
	public VkGeometryDataNV geometry;
	public VkGeometryFlagsKHR flags;

	public this(void* pNext, VkGeometryTypeKHR geometryType, VkGeometryDataNV geometry, VkGeometryFlagsKHR flags = 0)
	{
		this.pNext = pNext;
		this.geometryType = geometryType;
		this.geometry = geometry;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkGeometryFlagsNV = VkGeometryFlagsKHR;
typealias VkGeometryFlagBitsNV = VkGeometryFlagBitsKHR;
typealias VkGeometryInstanceFlagsNV = VkGeometryInstanceFlagsKHR;
typealias VkGeometryInstanceFlagBitsNV = VkGeometryInstanceFlagBitsKHR;

[CRepr] struct VkAccelerationStructureInfoNV
{
	public const VkStructureType SType = .VkAccelerationStructureInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAccelerationStructureTypeNV type;
	public VkBuildAccelerationStructureFlagsNV flags;
	public uint32 instanceCount;
	public uint32 geometryCount;
	public VkGeometryNV* pGeometries;
	public VulkanSpan<VkGeometryNV> geometries
	{
		[Inline] get => .(geometryCount, pGeometries);
		[Inline] set mut { geometryCount = value.count; pGeometries = value.ptr; }
	}

	public this(void* pNext, VkAccelerationStructureTypeNV type, VkBuildAccelerationStructureFlagsNV flags = 0, uint32 instanceCount = 0, VulkanSpan<VkGeometryNV> geometries = .()) : this()
	{
		this.pNext = pNext;
		this.type = type;
		this.flags = flags;
		this.instanceCount = instanceCount;
		this.geometries = geometries;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAccelerationStructureCreateInfoNV
{
	public const VkStructureType SType = .VkAccelerationStructureCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize compactedSize;
	public VkAccelerationStructureInfoNV info;

	public this(void* pNext, VkDeviceSize compactedSize, VkAccelerationStructureInfoNV info)
	{
		this.pNext = pNext;
		this.compactedSize = compactedSize;
		this.info = info;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

class VkAccelerationStructureNV { private this() { } }

typealias VkBuildAccelerationStructureFlagBitsNV = VkBuildAccelerationStructureFlagBitsKHR;
typealias VkBuildAccelerationStructureFlagsNV = VkBuildAccelerationStructureFlagsKHR;
typealias VkCopyAccelerationStructureModeNV = VkCopyAccelerationStructureModeKHR;

[CRepr] struct VkBindAccelerationStructureMemoryInfoNV
{
	public const VkStructureType SType = .VkBindAccelerationStructureMemoryInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAccelerationStructureNV accelerationStructure;
	public VkDeviceMemory memory;
	public VkDeviceSize memoryOffset;
	public uint32 deviceIndexCount;
	public uint32* pDeviceIndices;
	public VulkanSpan<uint32> deviceIndices
	{
		[Inline] get => .(deviceIndexCount, pDeviceIndices);
		[Inline] set mut { deviceIndexCount = value.count; pDeviceIndices = value.ptr; }
	}

	public this(void* pNext, VkAccelerationStructureNV accelerationStructure, VkDeviceMemory memory, VkDeviceSize memoryOffset, VulkanSpan<uint32> deviceIndices = .()) : this()
	{
		this.pNext = pNext;
		this.accelerationStructure = accelerationStructure;
		this.memory = memory;
		this.memoryOffset = memoryOffset;
		this.deviceIndices = deviceIndices;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkWriteDescriptorSetAccelerationStructureNV
{
	public const VkStructureType SType = .VkWriteDescriptorSetAccelerationStructureNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 accelerationStructureCount;
	public VkAccelerationStructureNV* pAccelerationStructures;
	public VulkanSpan<VkAccelerationStructureNV> accelerationStructures
	{
		[Inline] get => .(accelerationStructureCount, pAccelerationStructures);
		[Inline] set mut { accelerationStructureCount = value.count; pAccelerationStructures = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<VkAccelerationStructureNV> accelerationStructures) : this()
	{
		this.pNext = pNext;
		this.accelerationStructures = accelerationStructures;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAccelerationStructureMemoryRequirementsInfoNV
{
	public const VkStructureType SType = .VkAccelerationStructureMemoryRequirementsInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAccelerationStructureMemoryRequirementsTypeNV type;
	public VkAccelerationStructureNV accelerationStructure;

	public this(void* pNext, VkAccelerationStructureMemoryRequirementsTypeNV type, VkAccelerationStructureNV accelerationStructure)
	{
		this.pNext = pNext;
		this.type = type;
		this.accelerationStructure = accelerationStructure;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceRayTracingPropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceRayTracingPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 shaderGroupHandleSize;
	public uint32 maxRecursionDepth;
	public uint32 maxShaderGroupStride;
	public uint32 shaderGroupBaseAlignment;
	public uint64 maxGeometryCount;
	public uint64 maxInstanceCount;
	public uint64 maxTriangleCount;
	public uint32 maxDescriptorSetAccelerationStructures;
}

[AllowDuplicates] enum VkAccelerationStructureMemoryRequirementsTypeNV : int32
{
	ObjectNV = 0,
	BuildScratchNV = 1,
	UpdateScratchNV = 2,
}

typealias VkTransformMatrixNV = VkTransformMatrixKHR;
typealias VkAabbPositionsNV = VkAabbPositionsKHR;
typealias VkAccelerationStructureInstanceNV = VkAccelerationStructureInstanceKHR;

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateAccelerationStructureNV(VkDevice device, VkAccelerationStructureCreateInfoNV* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkAccelerationStructureNV pAccelerationStructure);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetAccelerationStructureMemoryRequirementsNV(VkDevice device, VkAccelerationStructureMemoryRequirementsInfoNV* pInfo, out VkMemoryRequirements2KHR pMemoryRequirements);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkBindAccelerationStructureMemoryNV(VkDevice device, uint32 bindInfoCount, VkBindAccelerationStructureMemoryInfoNV* pBindInfos);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureInfoNV* pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32 width, uint32 height, uint32 depth);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32 createInfoCount, VkRayTracingPipelineCreateInfoNV* pCreateInfos, VkAllocationCallbacks* pAllocator, out VkPipeline pPipelines);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, c_size dataSize, out void pData);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32 accelerationStructureCount, VkAccelerationStructureNV* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32 firstQuery);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32 shader);

static { public const uint32 VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION = 2; }
static { public const c_char* VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME = "VK_NV_representative_fragment_test"; }

[CRepr] struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 representativeFragmentTest;

	public this(void* pNext, VkBool32 representativeFragmentTest)
	{
		this.pNext = pNext;
		this.representativeFragmentTest = representativeFragmentTest;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV
{
	public const VkStructureType SType = .VkPipelineRepresentativeFragmentTestStateCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 representativeFragmentTestEnable;

	public this(void* pNext, VkBool32 representativeFragmentTestEnable)
	{
		this.pNext = pNext;
		this.representativeFragmentTestEnable = representativeFragmentTestEnable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_MAINTENANCE_3_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_MAINTENANCE_3_EXTENSION_NAME = "VK_KHR_maintenance3"; }
static { [Obsolete("aliased")] public const let VK_KHR_MAINTENANCE3_SPEC_VERSION = VK_KHR_MAINTENANCE_3_SPEC_VERSION; }
static { [Obsolete("aliased")] public const let VK_KHR_MAINTENANCE3_EXTENSION_NAME = VK_KHR_MAINTENANCE_3_EXTENSION_NAME; }

typealias VkPhysicalDeviceMaintenance3PropertiesKHR = VkPhysicalDeviceMaintenance3Properties;
typealias VkDescriptorSetLayoutSupportKHR = VkDescriptorSetLayoutSupport;

static { public const uint32 VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME = "VK_KHR_draw_indirect_count"; }
static { public const uint32 VK_EXT_FILTER_CUBIC_SPEC_VERSION = 3; }
static { public const c_char* VK_EXT_FILTER_CUBIC_EXTENSION_NAME = "VK_EXT_filter_cubic"; }

[CRepr] struct VkPhysicalDeviceImageViewImageFormatInfoEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceImageViewImageFormatInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageViewType imageViewType;

	public this(void* pNext, VkImageViewType imageViewType)
	{
		this.pNext = pNext;
		this.imageViewType = imageViewType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkFilterCubicImageViewImageFormatPropertiesEXT
{
	public const VkStructureType SType = .VkFilterCubicImageViewImageFormatPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 filterCubic; // The combinations of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT
	public VkBool32 filterCubicMinmax; // The combination of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT and ReductionMode of Min or Max
}

static { public const uint32 VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION = 4; }
static { public const c_char* VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME = "VK_QCOM_render_pass_shader_resolve"; }
static { public const uint32 VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME = "VK_EXT_global_priority"; }

typealias VkDeviceQueueGlobalPriorityCreateInfoEXT = VkDeviceQueueGlobalPriorityCreateInfo;
typealias VkQueueGlobalPriorityEXT = VkQueueGlobalPriority;

static { public const uint32 VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME = "VK_KHR_shader_subgroup_extended_types"; }

typealias VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;

static { public const uint32 VK_KHR_8BIT_STORAGE_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_8BIT_STORAGE_EXTENSION_NAME = "VK_KHR_8bit_storage"; }

typealias VkPhysicalDevice8BitStorageFeaturesKHR = VkPhysicalDevice8BitStorageFeatures;

static { public const uint32 VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME = "VK_EXT_external_memory_host"; }

[CRepr] struct VkImportMemoryHostPointerInfoEXT
{
	public const VkStructureType SType = .VkImportMemoryHostPointerInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlagBits handleType;
	public void* pHostPointer;

	public this(void* pNext, VkExternalMemoryHandleTypeFlagBits handleType, void* pHostPointer)
	{
		this.pNext = pNext;
		this.handleType = handleType;
		this.pHostPointer = pHostPointer;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryHostPointerPropertiesEXT
{
	public const VkStructureType SType = .VkMemoryHostPointerPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 memoryTypeBits;
}

[CRepr] struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceExternalMemoryHostPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize minImportedHostPointerAlignment;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, void* pHostPointer, out VkMemoryHostPointerPropertiesEXT pMemoryHostPointerProperties);

static { public const uint32 VK_AMD_BUFFER_MARKER_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_BUFFER_MARKER_EXTENSION_NAME = "VK_AMD_buffer_marker"; }

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32 marker);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32 marker);

static { public const uint32 VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME = "VK_KHR_shader_atomic_int64"; }

typealias VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = VkPhysicalDeviceShaderAtomicInt64Features;

static { public const uint32 VK_KHR_SHADER_CLOCK_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_CLOCK_EXTENSION_NAME = "VK_KHR_shader_clock"; }

[CRepr] struct VkPhysicalDeviceShaderClockFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderClockFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderSubgroupClock;
	public VkBool32 shaderDeviceClock;

	public this(void* pNext, VkBool32 shaderSubgroupClock, VkBool32 shaderDeviceClock)
	{
		this.pNext = pNext;
		this.shaderSubgroupClock = shaderSubgroupClock;
		this.shaderDeviceClock = shaderDeviceClock;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME = "VK_AMD_pipeline_compiler_control"; }

[AllowDuplicates] enum VkPipelineCompilerControlFlagBitsAMD : int32
{
}

typealias VkPipelineCompilerControlFlagsAMD = VkPipelineCompilerControlFlagBitsAMD;

[CRepr] struct VkPipelineCompilerControlCreateInfoAMD
{
	public const VkStructureType SType = .VkPipelineCompilerControlCreateInfoAMD;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineCompilerControlFlagsAMD compilerControlFlags;

	public this(void* pNext = null, VkPipelineCompilerControlFlagsAMD compilerControlFlags = 0)
	{
		this.pNext = pNext;
		this.compilerControlFlags = compilerControlFlags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME = "VK_EXT_calibrated_timestamps"; }

typealias VkTimeDomainEXT = VkTimeDomainKHR;
typealias VkCalibratedTimestampInfoEXT = VkCalibratedTimestampInfoKHR;

static { public const uint32 VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION = 2; }
static { public const c_char* VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME = "VK_AMD_shader_core_properties"; }

[CRepr] struct VkPhysicalDeviceShaderCorePropertiesAMD
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderCorePropertiesAMD;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 shaderEngineCount; // number of shader engines
	public uint32 shaderArraysPerEngineCount; // number of shader arrays
	public uint32 computeUnitsPerShaderArray; // number of physical CUs per shader array
	public uint32 simdPerComputeUnit; // number of SIMDs per compute unit
	public uint32 wavefrontsPerSimd; // number of wavefront slots in each SIMD
	public uint32 wavefrontSize; // maximum number of threads per wavefront
	public uint32 sgprsPerSimd; // number of physical SGPRs per SIMD
	public uint32 minSgprAllocation; // minimum number of SGPRs that can be allocated by a wave
	public uint32 maxSgprAllocation; // number of available SGPRs
	public uint32 sgprAllocationGranularity; // SGPRs are allocated in groups of this size
	public uint32 vgprsPerSimd; // number of physical VGPRs per SIMD
	public uint32 minVgprAllocation; // minimum number of VGPRs that can be allocated by a wave
	public uint32 maxVgprAllocation; // number of available VGPRs
	public uint32 vgprAllocationGranularity; // VGPRs are allocated in groups of this size
}

static { public const uint32 VK_KHR_VIDEO_DECODE_H265_SPEC_VERSION = 8; }
static { public const c_char* VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME = "VK_KHR_video_decode_h265"; }

[CRepr] struct VkVideoDecodeH265ProfileInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeH265ProfileInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoH265ProfileIdc stdProfileIdc;

	public this(void* pNext, StdVideoH265ProfileIdc stdProfileIdc)
	{
		this.pNext = pNext;
		this.stdProfileIdc = stdProfileIdc;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeH265CapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoDecodeH265CapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoH265LevelIdc maxLevelIdc;
}

[CRepr] struct VkVideoDecodeH265SessionParametersCreateInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeH265SessionParametersCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxStdVPSCount;
	public uint32 maxStdSPSCount;
	public uint32 maxStdPPSCount;
	public VkVideoDecodeH265SessionParametersAddInfoKHR* pParametersAddInfo;

	public this(void* pNext, uint32 maxStdVPSCount, uint32 maxStdSPSCount, uint32 maxStdPPSCount, VkVideoDecodeH265SessionParametersAddInfoKHR* pParametersAddInfo = null)
	{
		this.pNext = pNext;
		this.maxStdVPSCount = maxStdVPSCount;
		this.maxStdSPSCount = maxStdSPSCount;
		this.maxStdPPSCount = maxStdPPSCount;
		this.pParametersAddInfo = pParametersAddInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeH265SessionParametersAddInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeH265SessionParametersAddInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 stdVPSCount;
	public StdVideoH265VideoParameterSet* pStdVPSs;
	public VulkanSpan<StdVideoH265VideoParameterSet> stdVPSs
	{
		[Inline] get => .(stdVPSCount, pStdVPSs);
		[Inline] set mut { stdVPSCount = value.count; pStdVPSs = value.ptr; }
	}
	public uint32 stdSPSCount;
	public StdVideoH265SequenceParameterSet* pStdSPSs;
	public VulkanSpan<StdVideoH265SequenceParameterSet> stdSPSs
	{
		[Inline] get => .(stdSPSCount, pStdSPSs);
		[Inline] set mut { stdSPSCount = value.count; pStdSPSs = value.ptr; }
	}
	public uint32 stdPPSCount;
	public StdVideoH265PictureParameterSet* pStdPPSs; // List of Picture Parameters associated with the spsStd, above
	public VulkanSpan<StdVideoH265PictureParameterSet> stdPPSs
	{
		[Inline] get => .(stdPPSCount, pStdPPSs);
		[Inline] set mut { stdPPSCount = value.count; pStdPPSs = value.ptr; }
	} // List of Picture Parameters associated with the spsStd, above

	public this(void* pNext = null, VulkanSpan<StdVideoH265VideoParameterSet> stdVPSs = .(), VulkanSpan<StdVideoH265SequenceParameterSet> stdSPSs = .(), VulkanSpan<StdVideoH265PictureParameterSet> stdPPSs = .()) : this()
	{
		this.pNext = pNext;
		this.stdVPSs = stdVPSs;
		this.stdSPSs = stdSPSs;
		this.stdPPSs = stdPPSs;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeH265PictureInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeH265PictureInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoDecodeH265PictureInfo* pStdPictureInfo;
	public uint32 sliceSegmentCount;
	public uint32* pSliceSegmentOffsets;
	public VulkanSpan<uint32> sliceSegmentOffsets
	{
		[Inline] get => .(sliceSegmentCount, pSliceSegmentOffsets);
		[Inline] set mut { sliceSegmentCount = value.count; pSliceSegmentOffsets = value.ptr; }
	}

	public this(void* pNext, StdVideoDecodeH265PictureInfo* pStdPictureInfo, VulkanSpan<uint32> sliceSegmentOffsets) : this()
	{
		this.pNext = pNext;
		this.pStdPictureInfo = pStdPictureInfo;
		this.sliceSegmentOffsets = sliceSegmentOffsets;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeH265DpbSlotInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeH265DpbSlotInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoDecodeH265ReferenceInfo* pStdReferenceInfo;

	public this(void* pNext, StdVideoDecodeH265ReferenceInfo* pStdReferenceInfo)
	{
		this.pNext = pNext;
		this.pStdReferenceInfo = pStdReferenceInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_GLOBAL_PRIORITY_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME = "VK_KHR_global_priority"; }
static { public const let VK_MAX_GLOBAL_PRIORITY_SIZE_KHR = VK_MAX_GLOBAL_PRIORITY_SIZE; }

typealias VkDeviceQueueGlobalPriorityCreateInfoKHR = VkDeviceQueueGlobalPriorityCreateInfo;
typealias VkQueueGlobalPriorityKHR = VkQueueGlobalPriority;
typealias VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR = VkPhysicalDeviceGlobalPriorityQueryFeatures;
typealias VkQueueFamilyGlobalPriorityPropertiesKHR = VkQueueFamilyGlobalPriorityProperties;

static { public const uint32 VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME = "VK_AMD_memory_overallocation_behavior"; }

[AllowDuplicates] enum VkMemoryOverallocationBehaviorAMD : int32
{
	DefaultAMD = 0,
	AllowedAMD = 1,
	DisallowedAMD = 2,
}

[CRepr] struct VkDeviceMemoryOverallocationCreateInfoAMD
{
	public const VkStructureType SType = .VkDeviceMemoryOverallocationCreateInfoAMD;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkMemoryOverallocationBehaviorAMD overallocationBehavior;

	public this(void* pNext, VkMemoryOverallocationBehaviorAMD overallocationBehavior)
	{
		this.pNext = pNext;
		this.overallocationBehavior = overallocationBehavior;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION = 3; }
static { public const c_char* VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME = "VK_EXT_vertex_attribute_divisor"; }

[CRepr] struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxVertexAttribDivisor; // max value of vertex attribute divisor
}

typealias VkVertexInputBindingDivisorDescriptionEXT = VkVertexInputBindingDivisorDescription;
typealias VkPipelineVertexInputDivisorStateCreateInfoEXT = VkPipelineVertexInputDivisorStateCreateInfo;
typealias VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = VkPhysicalDeviceVertexAttributeDivisorFeatures;

static { public const uint32 VK_GGP_FRAME_TOKEN_SPEC_VERSION = 1; }
static { public const c_char* VK_GGP_FRAME_TOKEN_EXTENSION_NAME = "VK_GGP_frame_token"; }

[CRepr] struct VkPresentFrameTokenGGP
{
	public const VkStructureType SType = .VkPresentFrameTokenGGP;
	public VkStructureType sType = SType;
	public void* pNext;
	public GgpFrameToken frameToken;

	public this(void* pNext, GgpFrameToken frameToken)
	{
		this.pNext = pNext;
		this.frameToken = frameToken;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME = "VK_EXT_pipeline_creation_feedback"; }

typealias VkPipelineCreationFeedbackFlagBitsEXT = VkPipelineCreationFeedbackFlagBits;
typealias VkPipelineCreationFeedbackFlagsEXT = VkPipelineCreationFeedbackFlags;
typealias VkPipelineCreationFeedbackCreateInfoEXT = VkPipelineCreationFeedbackCreateInfo;
typealias VkPipelineCreationFeedbackEXT = VkPipelineCreationFeedback;

static { public const uint32 VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME = "VK_KHR_driver_properties"; }
static { public const let VK_MAX_DRIVER_NAME_SIZE_KHR = VK_MAX_DRIVER_NAME_SIZE; }
static { public const let VK_MAX_DRIVER_INFO_SIZE_KHR = VK_MAX_DRIVER_INFO_SIZE; }

typealias VkDriverIdKHR = VkDriverId;
typealias VkConformanceVersionKHR = VkConformanceVersion;
typealias VkPhysicalDeviceDriverPropertiesKHR = VkPhysicalDeviceDriverProperties;

static { public const uint32 VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION = 4; }
static { public const c_char* VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME = "VK_KHR_shader_float_controls"; }

typealias VkPhysicalDeviceFloatControlsPropertiesKHR = VkPhysicalDeviceFloatControlsProperties;
typealias VkShaderFloatControlsIndependenceKHR = VkShaderFloatControlsIndependence;

static { public const uint32 VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME = "VK_NV_shader_subgroup_partitioned"; }
static { public const uint32 VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME = "VK_KHR_depth_stencil_resolve"; }

typealias VkSubpassDescriptionDepthStencilResolveKHR = VkSubpassDescriptionDepthStencilResolve;
typealias VkPhysicalDeviceDepthStencilResolvePropertiesKHR = VkPhysicalDeviceDepthStencilResolveProperties;
typealias VkResolveModeFlagBitsKHR = VkResolveModeFlagBits;
typealias VkResolveModeFlagsKHR = VkResolveModeFlags;

static { public const uint32 VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME = "VK_KHR_swapchain_mutable_format"; }
static { public const uint32 VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME = "VK_NV_compute_shader_derivatives"; }

typealias VkPhysicalDeviceComputeShaderDerivativesFeaturesNV = VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR;

static { public const uint32 VK_NV_MESH_SHADER_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_MESH_SHADER_EXTENSION_NAME = "VK_NV_mesh_shader"; }

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32 taskCount, uint32 firstTask);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32 drawCount, uint32 stride);

[CRepr] struct VkPhysicalDeviceMeshShaderFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceMeshShaderFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 taskShader;
	public VkBool32 meshShader;

	public this(void* pNext, VkBool32 taskShader, VkBool32 meshShader)
	{
		this.pNext = pNext;
		this.taskShader = taskShader;
		this.meshShader = meshShader;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceMeshShaderPropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceMeshShaderPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxDrawMeshTasksCount;
	public uint32 maxTaskWorkGroupInvocations;
	public uint32[3] maxTaskWorkGroupSize;
	public uint32 maxTaskTotalMemorySize;
	public uint32 maxTaskOutputCount;
	public uint32 maxMeshWorkGroupInvocations;
	public uint32[3] maxMeshWorkGroupSize;
	public uint32 maxMeshTotalMemorySize;
	public uint32 maxMeshOutputVertices;
	public uint32 maxMeshOutputPrimitives;
	public uint32 maxMeshMultiviewViewCount;
	public uint32 meshOutputPerVertexGranularity;
	public uint32 meshOutputPerPrimitiveGranularity;
}

[CRepr] struct VkDrawMeshTasksIndirectCommandNV
{
	public uint32 taskCount;
	public uint32 firstTask;

	public this(uint32 taskCount, uint32 firstTask)
	{
		this.taskCount = taskCount;
		this.firstTask = firstTask;
	}

	public this()
	{
		this = default;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32 maxDrawCount, uint32 stride);

static { public const uint32 VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = "VK_NV_fragment_shader_barycentric"; }

typealias VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV = VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR;

static { public const uint32 VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION = 2; }
static { public const c_char* VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME = "VK_NV_shader_image_footprint"; }

[CRepr] struct VkPhysicalDeviceShaderImageFootprintFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderImageFootprintFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 imageFootprint;

	public this(void* pNext, VkBool32 imageFootprint)
	{
		this.pNext = pNext;
		this.imageFootprint = imageFootprint;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION = 2; }
static { public const c_char* VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME = "VK_NV_scissor_exclusive"; }

[CRepr] struct VkPipelineViewportExclusiveScissorStateCreateInfoNV
{
	public const VkStructureType SType = .VkPipelineViewportExclusiveScissorStateCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 exclusiveScissorCount;
	public VkRect2D* pExclusiveScissors;
	public VulkanSpan<VkRect2D> exclusiveScissors
	{
		[Inline] get => .(exclusiveScissorCount, pExclusiveScissors);
		[Inline] set mut { exclusiveScissorCount = value.count; pExclusiveScissors = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkRect2D> exclusiveScissors = .()) : this()
	{
		this.pNext = pNext;
		this.exclusiveScissors = exclusiveScissors;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceExclusiveScissorFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceExclusiveScissorFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 exclusiveScissor;

	public this(void* pNext, VkBool32 exclusiveScissor)
	{
		this.pNext = pNext;
		this.exclusiveScissor = exclusiveScissor;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetExclusiveScissorEnableNV(VkCommandBuffer commandBuffer, uint32 firstExclusiveScissor, uint32 exclusiveScissorCount, VkBool32* pExclusiveScissorEnables);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32 firstExclusiveScissor, uint32 exclusiveScissorCount, VkRect2D* pExclusiveScissors);

static { public const uint32 VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION = 2; }
static { public const c_char* VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME = "VK_NV_device_diagnostic_checkpoints"; }

[CRepr] struct VkQueueFamilyCheckpointPropertiesNV
{
	public const VkStructureType SType = .VkQueueFamilyCheckpointPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineStageFlags checkpointExecutionStageMask;
}

[CRepr] struct VkCheckpointDataNV
{
	public const VkStructureType SType = .VkCheckpointDataNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineStageFlagBits stage;
	public void* pCheckpointMarker;
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetCheckpointNV(VkCommandBuffer commandBuffer, void* pCheckpointMarker);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetQueueCheckpointDataNV(VkQueue queue, out uint32 pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData = null);

[CRepr] struct VkQueueFamilyCheckpointProperties2NV
{
	public const VkStructureType SType = .VkQueueFamilyCheckpointProperties2NV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineStageFlags2 checkpointExecutionStageMask;
}

[CRepr] struct VkCheckpointData2NV
{
	public const VkStructureType SType = .VkCheckpointData2NV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineStageFlags2 stage;
	public void* pCheckpointMarker;
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetQueueCheckpointData2NV(VkQueue queue, out uint32 pCheckpointDataCount, VkCheckpointData2NV* pCheckpointData = null);

static { public const uint32 VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION = 2; }
static { public const c_char* VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME = "VK_KHR_timeline_semaphore"; }

typealias VkSemaphoreTypeKHR = VkSemaphoreType;
typealias VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = VkPhysicalDeviceTimelineSemaphoreFeatures;
typealias VkPhysicalDeviceTimelineSemaphorePropertiesKHR = VkPhysicalDeviceTimelineSemaphoreProperties;
typealias VkSemaphoreTypeCreateInfoKHR = VkSemaphoreTypeCreateInfo;
typealias VkTimelineSemaphoreSubmitInfoKHR = VkTimelineSemaphoreSubmitInfo;
typealias VkSemaphoreWaitFlagBitsKHR = VkSemaphoreWaitFlagBits;
typealias VkSemaphoreWaitFlagsKHR = VkSemaphoreWaitFlags;
typealias VkSemaphoreWaitInfoKHR = VkSemaphoreWaitInfo;
typealias VkSemaphoreSignalInfoKHR = VkSemaphoreSignalInfo;

static { public const uint32 VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION = 1; }
static { public const c_char* VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME = "VK_INTEL_shader_integer_functions2"; }

[CRepr] struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderIntegerFunctions2;

	public this(void* pNext, VkBool32 shaderIntegerFunctions2)
	{
		this.pNext = pNext;
		this.shaderIntegerFunctions2 = shaderIntegerFunctions2;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION = 2; }
static { public const c_char* VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME = "VK_INTEL_performance_query"; }

[AllowDuplicates] enum VkPerformanceConfigurationTypeINTEL : int32
{
	CommandQueueMetricsDiscoveryActivatedINTEL = 0,
}

[AllowDuplicates] enum VkQueryPoolSamplingModeINTEL : int32
{
	ManualINTEL = 0,
}

[AllowDuplicates] enum VkPerformanceOverrideTypeINTEL : int32
{
	NullHardwareINTEL = 0,
	FlushGpuCachesINTEL = 1,
}

[AllowDuplicates] enum VkPerformanceParameterTypeINTEL : int32
{
	HwCountersSupportedINTEL = 0,
	StreamMarkerValidBitsINTEL = 1,
}

[AllowDuplicates] enum VkPerformanceValueTypeINTEL : int32
{
	Uint32INTEL = 0,
	Uint64INTEL = 1,
	FloatINTEL = 2,
	BoolINTEL = 3,
	StringINTEL = 4,
}

[Union, CRepr] struct VkPerformanceValueDataINTEL
{
	public uint32 value32;
	public uint64 value64;
	public float valueFloat;
	public VkBool32 valueBool;
	public c_char* valueString;
}

[CRepr] struct VkPerformanceValueINTEL
{
	public VkPerformanceValueTypeINTEL type;
	public VkPerformanceValueDataINTEL data;
}

[CRepr] struct VkInitializePerformanceApiInfoINTEL
{
	public const VkStructureType SType = .VkInitializePerformanceApiInfoINTEL;
	public VkStructureType sType = SType;
	public void* pNext;
	public void* pUserData;

	public this(void* pNext = null, void* pUserData = null)
	{
		this.pNext = pNext;
		this.pUserData = pUserData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkQueryPoolCreateInfoINTEL = VkQueryPoolPerformanceQueryCreateInfoINTEL;

[CRepr] struct VkQueryPoolPerformanceQueryCreateInfoINTEL
{
	public const VkStructureType SType = .VkQueryPoolPerformanceQueryCreateInfoINTEL;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkQueryPoolSamplingModeINTEL performanceCountersSampling;

	public this(void* pNext, VkQueryPoolSamplingModeINTEL performanceCountersSampling)
	{
		this.pNext = pNext;
		this.performanceCountersSampling = performanceCountersSampling;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPerformanceMarkerInfoINTEL
{
	public const VkStructureType SType = .VkPerformanceMarkerInfoINTEL;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 marker;

	public this(void* pNext, uint64 marker)
	{
		this.pNext = pNext;
		this.marker = marker;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPerformanceStreamMarkerInfoINTEL
{
	public const VkStructureType SType = .VkPerformanceStreamMarkerInfoINTEL;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 marker;

	public this(void* pNext, uint32 marker)
	{
		this.pNext = pNext;
		this.marker = marker;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPerformanceOverrideInfoINTEL
{
	public const VkStructureType SType = .VkPerformanceOverrideInfoINTEL;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPerformanceOverrideTypeINTEL type;
	public VkBool32 enable;
	public uint64 parameter;

	public this(void* pNext, VkPerformanceOverrideTypeINTEL type, VkBool32 enable, uint64 parameter)
	{
		this.pNext = pNext;
		this.type = type;
		this.enable = enable;
		this.parameter = parameter;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPerformanceConfigurationAcquireInfoINTEL
{
	public const VkStructureType SType = .VkPerformanceConfigurationAcquireInfoINTEL;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPerformanceConfigurationTypeINTEL type;

	public this(void* pNext, VkPerformanceConfigurationTypeINTEL type)
	{
		this.pNext = pNext;
		this.type = type;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

class VkPerformanceConfigurationINTEL { private this() { } }

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkInitializePerformanceApiINTEL(VkDevice device, VkInitializePerformanceApiInfoINTEL* pInitializeInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkUninitializePerformanceApiINTEL(VkDevice device);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, VkPerformanceMarkerInfoINTEL* pMarkerInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, VkPerformanceOverrideInfoINTEL* pOverrideInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkAcquirePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo, out VkPerformanceConfigurationINTEL pConfiguration);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkQueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, out VkPerformanceValueINTEL pValue);

static { public const uint32 VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION = 3; }
static { public const c_char* VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME = "VK_KHR_vulkan_memory_model"; }

typealias VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = VkPhysicalDeviceVulkanMemoryModelFeatures;

static { public const uint32 VK_EXT_PCI_BUS_INFO_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_PCI_BUS_INFO_EXTENSION_NAME = "VK_EXT_pci_bus_info"; }

[CRepr] struct VkPhysicalDevicePCIBusInfoPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDevicePciBusInfoPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 pciDomain;
	public uint32 pciBus;
	public uint32 pciDevice;
	public uint32 pciFunction;
}

static { public const uint32 VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME = "VK_AMD_display_native_hdr"; }

[CRepr] struct VkDisplayNativeHdrSurfaceCapabilitiesAMD
{
	public const VkStructureType SType = .VkDisplayNativeHdrSurfaceCapabilitiesAMD;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 localDimmingSupport;
}

[CRepr] struct VkSwapchainDisplayNativeHdrCreateInfoAMD
{
	public const VkStructureType SType = .VkSwapchainDisplayNativeHdrCreateInfoAMD;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 localDimmingEnable;

	public this(void* pNext, VkBool32 localDimmingEnable)
	{
		this.pNext = pNext;
		this.localDimmingEnable = localDimmingEnable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkSetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable);

static { public const uint32 VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION = 1; }
static { public const c_char* VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME = "VK_FUCHSIA_imagepipe_surface"; }

typealias VkImagePipeSurfaceCreateFlagsFUCHSIA = VkFlags;

[CRepr] struct VkImagePipeSurfaceCreateInfoFUCHSIA
{
	public const VkStructureType SType = .VkImagepipeSurfaceCreateInfoFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImagePipeSurfaceCreateFlagsFUCHSIA flags;
	public zx_handle_t imagePipeHandle;

	public this(void* pNext, VkImagePipeSurfaceCreateFlagsFUCHSIA flags, zx_handle_t imagePipeHandle)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.imagePipeHandle = imagePipeHandle;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateImagePipeSurfaceFUCHSIA(VkInstance instance, VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);

static { public const uint32 VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME = "VK_KHR_shader_terminate_invocation"; }

typealias VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR = VkPhysicalDeviceShaderTerminateInvocationFeatures;

static { public const uint32 VK_EXT_METAL_SURFACE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_METAL_SURFACE_EXTENSION_NAME = "VK_EXT_metal_surface"; }

typealias VkMetalSurfaceCreateFlagsEXT = VkFlags;

[CRepr] struct VkMetalSurfaceCreateInfoEXT
{
	public const VkStructureType SType = .VkMetalSurfaceCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkMetalSurfaceCreateFlagsEXT flags;
	public CAMetalLayer* pLayer;

	public this(void* pNext, VkMetalSurfaceCreateFlagsEXT flags, CAMetalLayer* pLayer)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.pLayer = pLayer;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateMetalSurfaceEXT(VkInstance instance, VkMetalSurfaceCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);

static { public const uint32 VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME = "VK_EXT_fragment_density_map"; }

[CRepr] struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentDensityMapFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 fragmentDensityMap;
	public VkBool32 fragmentDensityMapDynamic;
	public VkBool32 fragmentDensityMapNonSubsampledImages;

	public this(void* pNext, VkBool32 fragmentDensityMap, VkBool32 fragmentDensityMapDynamic, VkBool32 fragmentDensityMapNonSubsampledImages)
	{
		this.pNext = pNext;
		this.fragmentDensityMap = fragmentDensityMap;
		this.fragmentDensityMapDynamic = fragmentDensityMapDynamic;
		this.fragmentDensityMapNonSubsampledImages = fragmentDensityMapNonSubsampledImages;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentDensityMapPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExtent2D minFragmentDensityTexelSize;
	public VkExtent2D maxFragmentDensityTexelSize;
	public VkBool32 fragmentDensityInvocations;
}

[CRepr] struct VkRenderPassFragmentDensityMapCreateInfoEXT
{
	public const VkStructureType SType = .VkRenderPassFragmentDensityMapCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAttachmentReference fragmentDensityMapAttachment;

	public this(void* pNext, VkAttachmentReference fragmentDensityMapAttachment)
	{
		this.pNext = pNext;
		this.fragmentDensityMapAttachment = fragmentDensityMapAttachment;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkRenderingFragmentDensityMapAttachmentInfoEXT
{
	public const VkStructureType SType = .VkRenderingFragmentDensityMapAttachmentInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageView imageView;
	public VkImageLayout imageLayout;

	public this(void* pNext, VkImageView imageView, VkImageLayout imageLayout)
	{
		this.pNext = pNext;
		this.imageView = imageView;
		this.imageLayout = imageLayout;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME = "VK_EXT_scalar_block_layout"; }

typealias VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = VkPhysicalDeviceScalarBlockLayoutFeatures;

static { public const uint32 VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION = 1; }
static { public const c_char* VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME = "VK_GOOGLE_hlsl_functionality1"; }
static { [Obsolete("aliased")] public const let VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION = VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION; }
static { [Obsolete("aliased")] public const let VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME = VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME; }
static { public const uint32 VK_GOOGLE_DECORATE_STRING_SPEC_VERSION = 1; }
static { public const c_char* VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME = "VK_GOOGLE_decorate_string"; }
static { public const uint32 VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME = "VK_EXT_subgroup_size_control"; }

typealias VkPhysicalDeviceSubgroupSizeControlFeaturesEXT = VkPhysicalDeviceSubgroupSizeControlFeatures;
typealias VkPhysicalDeviceSubgroupSizeControlPropertiesEXT = VkPhysicalDeviceSubgroupSizeControlProperties;
typealias VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;

static { public const uint32 VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION = 2; }
static { public const c_char* VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME = "VK_KHR_fragment_shading_rate"; }

[AllowDuplicates] enum VkFragmentShadingRateCombinerOpKHR : int32
{
	KeepKHR = 0,
	ReplaceKHR = 1,
	MinKHR = 2,
	MaxKHR = 3,
	MulKHR = 4,
}

[CRepr] struct VkFragmentShadingRateAttachmentInfoKHR
{
	public const VkStructureType SType = .VkFragmentShadingRateAttachmentInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAttachmentReference2* pFragmentShadingRateAttachment;
	public VkExtent2D shadingRateAttachmentTexelSize;

	public this(void* pNext, VkAttachmentReference2* pFragmentShadingRateAttachment, VkExtent2D shadingRateAttachmentTexelSize)
	{
		this.pNext = pNext;
		this.pFragmentShadingRateAttachment = pFragmentShadingRateAttachment;
		this.shadingRateAttachmentTexelSize = shadingRateAttachmentTexelSize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineFragmentShadingRateStateCreateInfoKHR
{
	public const VkStructureType SType = .VkPipelineFragmentShadingRateStateCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExtent2D fragmentSize;
	public VkFragmentShadingRateCombinerOpKHR[2] combinerOps;

	public this(void* pNext, VkExtent2D fragmentSize, VkFragmentShadingRateCombinerOpKHR[2] combinerOps)
	{
		this.pNext = pNext;
		this.fragmentSize = fragmentSize;
		this.combinerOps = combinerOps;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceFragmentShadingRateFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentShadingRateFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 pipelineFragmentShadingRate;
	public VkBool32 primitiveFragmentShadingRate;
	public VkBool32 attachmentFragmentShadingRate;

	public this(void* pNext, VkBool32 pipelineFragmentShadingRate, VkBool32 primitiveFragmentShadingRate, VkBool32 attachmentFragmentShadingRate)
	{
		this.pNext = pNext;
		this.pipelineFragmentShadingRate = pipelineFragmentShadingRate;
		this.primitiveFragmentShadingRate = primitiveFragmentShadingRate;
		this.attachmentFragmentShadingRate = attachmentFragmentShadingRate;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceFragmentShadingRatePropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentShadingRatePropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExtent2D minFragmentShadingRateAttachmentTexelSize;
	public VkExtent2D maxFragmentShadingRateAttachmentTexelSize;
	public uint32 maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
	public VkBool32 primitiveFragmentShadingRateWithMultipleViewports;
	public VkBool32 layeredShadingRateAttachments;
	public VkBool32 fragmentShadingRateNonTrivialCombinerOps;
	public VkExtent2D maxFragmentSize;
	public uint32 maxFragmentSizeAspectRatio;
	public uint32 maxFragmentShadingRateCoverageSamples;
	public VkSampleCountFlagBits maxFragmentShadingRateRasterizationSamples;
	public VkBool32 fragmentShadingRateWithShaderDepthStencilWrites;
	public VkBool32 fragmentShadingRateWithSampleMask;
	public VkBool32 fragmentShadingRateWithShaderSampleMask;
	public VkBool32 fragmentShadingRateWithConservativeRasterization;
	public VkBool32 fragmentShadingRateWithFragmentShaderInterlock;
	public VkBool32 fragmentShadingRateWithCustomSampleLocations;
	public VkBool32 fragmentShadingRateStrictMultiplyCombiner;
}

[CRepr] struct VkPhysicalDeviceFragmentShadingRateKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentShadingRateKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSampleCountFlags sampleCounts;
	public VkExtent2D fragmentSize;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR(VkPhysicalDevice physicalDevice, out uint32 pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetFragmentShadingRateKHR(VkCommandBuffer commandBuffer, VkExtent2D* pFragmentSize, VkFragmentShadingRateCombinerOpKHR[2] combinerOps);

// Remove 'api' attribute once gitlab #4074 is fixed
[CRepr] struct VkRenderingFragmentShadingRateAttachmentInfoKHR
{
	public const VkStructureType SType = .VkRenderingFragmentShadingRateAttachmentInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageView imageView;
	public VkImageLayout imageLayout;
	public VkExtent2D shadingRateAttachmentTexelSize;

	public this(void* pNext, VkImageView imageView, VkImageLayout imageLayout, VkExtent2D shadingRateAttachmentTexelSize)
	{
		this.pNext = pNext;
		this.imageView = imageView;
		this.imageLayout = imageLayout;
		this.shadingRateAttachmentTexelSize = shadingRateAttachmentTexelSize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME = "VK_AMD_shader_core_properties2"; }

[CRepr] struct VkPhysicalDeviceShaderCoreProperties2AMD
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderCoreProperties2AMD;
	public VkStructureType sType = SType;
	public void* pNext; // Pointer to next structure
	public VkShaderCorePropertiesFlagsAMD shaderCoreFeatures; // features supported by the shader core
	public uint32 activeComputeUnitCount; // number of active compute units across all shader engines/arrays
}

[AllowDuplicates] enum VkShaderCorePropertiesFlagBitsAMD : int32
{
}

typealias VkShaderCorePropertiesFlagsAMD = VkShaderCorePropertiesFlagBitsAMD;

static { public const uint32 VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME = "VK_AMD_device_coherent_memory"; }

[CRepr] struct VkPhysicalDeviceCoherentMemoryFeaturesAMD
{
	public const VkStructureType SType = .VkPhysicalDeviceCoherentMemoryFeaturesAMD;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 deviceCoherentMemory;

	public this(void* pNext, VkBool32 deviceCoherentMemory)
	{
		this.pNext = pNext;
		this.deviceCoherentMemory = deviceCoherentMemory;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME = "VK_KHR_dynamic_rendering_local_read"; }

typealias VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = VkPhysicalDeviceDynamicRenderingLocalReadFeatures;
typealias VkRenderingAttachmentLocationInfoKHR = VkRenderingAttachmentLocationInfo;
typealias VkRenderingInputAttachmentIndexInfoKHR = VkRenderingInputAttachmentIndexInfo;

static { public const uint32 VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME = "VK_EXT_shader_image_atomic_int64"; }

[CRepr] struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderImageInt64Atomics;
	public VkBool32 sparseImageInt64Atomics;

	public this(void* pNext, VkBool32 shaderImageInt64Atomics, VkBool32 sparseImageInt64Atomics)
	{
		this.pNext = pNext;
		this.shaderImageInt64Atomics = shaderImageInt64Atomics;
		this.sparseImageInt64Atomics = sparseImageInt64Atomics;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_SHADER_QUAD_CONTROL_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME = "VK_KHR_shader_quad_control"; }

[CRepr] struct VkPhysicalDeviceShaderQuadControlFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderQuadControlFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderQuadControl;

	public this(void* pNext, VkBool32 shaderQuadControl)
	{
		this.pNext = pNext;
		this.shaderQuadControl = shaderQuadControl;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_SPIRV_1_4_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SPIRV_1_4_EXTENSION_NAME = "VK_KHR_spirv_1_4"; }
static { public const uint32 VK_EXT_MEMORY_BUDGET_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_MEMORY_BUDGET_EXTENSION_NAME = "VK_EXT_memory_budget"; }

[CRepr] struct VkPhysicalDeviceMemoryBudgetPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceMemoryBudgetPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize[VK_MAX_MEMORY_HEAPS] heapBudget;
	public VkDeviceSize[VK_MAX_MEMORY_HEAPS] heapUsage;
}

static { public const uint32 VK_EXT_MEMORY_PRIORITY_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME = "VK_EXT_memory_priority"; }

[CRepr] struct VkPhysicalDeviceMemoryPriorityFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceMemoryPriorityFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 memoryPriority;

	public this(void* pNext, VkBool32 memoryPriority)
	{
		this.pNext = pNext;
		this.memoryPriority = memoryPriority;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryPriorityAllocateInfoEXT
{
	public const VkStructureType SType = .VkMemoryPriorityAllocateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public float priority;

	public this(void* pNext, float priority)
	{
		this.pNext = pNext;
		this.priority = priority;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME = "VK_KHR_surface_protected_capabilities"; }

[CRepr] struct VkSurfaceProtectedCapabilitiesKHR
{
	public const VkStructureType SType = .VkSurfaceProtectedCapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 supportsProtected; // Represents if surface can be protected
}

static { public const uint32 VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME = "VK_NV_dedicated_allocation_image_aliasing"; }

[CRepr] struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 dedicatedAllocationImageAliasing;

	public this(void* pNext, VkBool32 dedicatedAllocationImageAliasing)
	{
		this.pNext = pNext;
		this.dedicatedAllocationImageAliasing = dedicatedAllocationImageAliasing;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME = "VK_KHR_separate_depth_stencil_layouts"; }

typealias VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;
typealias VkAttachmentReferenceStencilLayoutKHR = VkAttachmentReferenceStencilLayout;
typealias VkAttachmentDescriptionStencilLayoutKHR = VkAttachmentDescriptionStencilLayout;

static { public const uint32 VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = "VK_EXT_buffer_device_address"; }

typealias VkPhysicalDeviceBufferAddressFeaturesEXT = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;

[CRepr] struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 bufferDeviceAddress;
	public VkBool32 bufferDeviceAddressCaptureReplay;
	public VkBool32 bufferDeviceAddressMultiDevice;

	public this(void* pNext, VkBool32 bufferDeviceAddress, VkBool32 bufferDeviceAddressCaptureReplay, VkBool32 bufferDeviceAddressMultiDevice)
	{
		this.pNext = pNext;
		this.bufferDeviceAddress = bufferDeviceAddress;
		this.bufferDeviceAddressCaptureReplay = bufferDeviceAddressCaptureReplay;
		this.bufferDeviceAddressMultiDevice = bufferDeviceAddressMultiDevice;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkBufferDeviceAddressInfoEXT = VkBufferDeviceAddressInfo;

[CRepr] struct VkBufferDeviceAddressCreateInfoEXT
{
	public const VkStructureType SType = .VkBufferDeviceAddressCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceAddress deviceAddress;

	public this(void* pNext, VkDeviceAddress deviceAddress)
	{
		this.pNext = pNext;
		this.deviceAddress = deviceAddress;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_TOOLING_INFO_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_TOOLING_INFO_EXTENSION_NAME = "VK_EXT_tooling_info"; }

typealias VkToolPurposeFlagBitsEXT = VkToolPurposeFlagBits;
typealias VkToolPurposeFlagsEXT = VkToolPurposeFlags;
typealias VkPhysicalDeviceToolPropertiesEXT = VkPhysicalDeviceToolProperties;

static { public const uint32 VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME = "VK_EXT_separate_stencil_usage"; }

typealias VkImageStencilUsageCreateInfoEXT = VkImageStencilUsageCreateInfo;

static { public const uint32 VK_EXT_VALIDATION_FEATURES_SPEC_VERSION = 6; }
static { public const c_char* VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME = "VK_EXT_validation_features"; }

[CRepr] struct VkValidationFeaturesEXT
{
	public const VkStructureType SType = .VkValidationFeaturesEXT;
	public VkStructureType sType = SType; // Must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT
	public void* pNext;
	public uint32 enabledValidationFeatureCount; // Number of validation features to enable
	public VkValidationFeatureEnableEXT* pEnabledValidationFeatures; // Validation features to enable
	public VulkanSpan<VkValidationFeatureEnableEXT> enabledValidationFeatures
	{
		[Inline] get => .(enabledValidationFeatureCount, pEnabledValidationFeatures);
		[Inline] set mut { enabledValidationFeatureCount = value.count; pEnabledValidationFeatures = value.ptr; }
	} // Validation features to enable
	public uint32 disabledValidationFeatureCount; // Number of validation features to disable
	public VkValidationFeatureDisableEXT* pDisabledValidationFeatures; // Validation features to disable
	public VulkanSpan<VkValidationFeatureDisableEXT> disabledValidationFeatures
	{
		[Inline] get => .(disabledValidationFeatureCount, pDisabledValidationFeatures);
		[Inline] set mut { disabledValidationFeatureCount = value.count; pDisabledValidationFeatures = value.ptr; }
	} // Validation features to disable

	public this(void* pNext = null, VulkanSpan<VkValidationFeatureEnableEXT> enabledValidationFeatures = .(), VulkanSpan<VkValidationFeatureDisableEXT> disabledValidationFeatures = .()) : this()
	{
		this.pNext = pNext;
		this.enabledValidationFeatures = enabledValidationFeatures;
		this.disabledValidationFeatures = disabledValidationFeatures;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkValidationFeatureEnableEXT : int32
{
	GpuAssistedEXT = 0,
	GpuAssistedReserveBindingSlotEXT = 1,
	BestPracticesEXT = 2,
	DebugPrintfEXT = 3,
	SynchronizationValidationEXT = 4,
}

[AllowDuplicates] enum VkValidationFeatureDisableEXT : int32
{
	AllEXT = 0,
	ShadersEXT = 1,
	ThreadSafetyEXT = 2,
	ApiParametersEXT = 3,
	ObjectLifetimesEXT = 4,
	CoreChecksEXT = 5,
	UniqueHandlesEXT = 6,
	ShaderValidationCacheEXT = 7,
}

static { public const uint32 VK_KHR_PRESENT_WAIT_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_PRESENT_WAIT_EXTENSION_NAME = "VK_KHR_present_wait"; }

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkWaitForPresentKHR(VkDevice device, VkSwapchainKHR swapchain, uint64 presentId, uint64 timeout);

[CRepr] struct VkPhysicalDevicePresentWaitFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDevicePresentWaitFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 presentWait; // vkWaitForPresentKHR is supported

	public this(void* pNext, VkBool32 presentWait)
	{
		this.pNext = pNext;
		this.presentWait = presentWait;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME = "VK_NV_cooperative_matrix"; }

[CRepr] struct VkCooperativeMatrixPropertiesNV
{
	public const VkStructureType SType = .VkCooperativeMatrixPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 MSize;
	public uint32 NSize;
	public uint32 KSize;
	public VkComponentTypeNV AType;
	public VkComponentTypeNV BType;
	public VkComponentTypeNV CType;
	public VkComponentTypeNV DType;
	public VkScopeNV @scope;
}

typealias VkScopeNV = VkScopeKHR;
typealias VkComponentTypeNV = VkComponentTypeKHR;

[CRepr] struct VkPhysicalDeviceCooperativeMatrixFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceCooperativeMatrixFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 cooperativeMatrix;
	public VkBool32 cooperativeMatrixRobustBufferAccess;

	public this(void* pNext, VkBool32 cooperativeMatrix, VkBool32 cooperativeMatrixRobustBufferAccess)
	{
		this.pNext = pNext;
		this.cooperativeMatrix = cooperativeMatrix;
		this.cooperativeMatrixRobustBufferAccess = cooperativeMatrixRobustBufferAccess;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceCooperativeMatrixPropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceCooperativeMatrixPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkShaderStageFlags cooperativeMatrixSupportedStages;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, out uint32 pPropertyCount, VkCooperativeMatrixPropertiesNV* pProperties = null);

static { public const uint32 VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME = "VK_NV_coverage_reduction_mode"; }

[CRepr] struct VkPhysicalDeviceCoverageReductionModeFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceCoverageReductionModeFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 coverageReductionMode;

	public this(void* pNext, VkBool32 coverageReductionMode)
	{
		this.pNext = pNext;
		this.coverageReductionMode = coverageReductionMode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineCoverageReductionStateCreateInfoNV
{
	public const VkStructureType SType = .VkPipelineCoverageReductionStateCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineCoverageReductionStateCreateFlagsNV flags;
	public VkCoverageReductionModeNV coverageReductionMode;

	public this(void* pNext, VkPipelineCoverageReductionStateCreateFlagsNV flags, VkCoverageReductionModeNV coverageReductionMode)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.coverageReductionMode = coverageReductionMode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPipelineCoverageReductionStateCreateFlagsNV = VkFlags;

[AllowDuplicates] enum VkCoverageReductionModeNV : int32
{
	MergeNV = 0,
	TruncateNV = 1,
}

[CRepr] struct VkFramebufferMixedSamplesCombinationNV
{
	public const VkStructureType SType = .VkFramebufferMixedSamplesCombinationNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkCoverageReductionModeNV coverageReductionMode;
	public VkSampleCountFlagBits rasterizationSamples;
	public VkSampleCountFlags depthStencilSamples;
	public VkSampleCountFlags colorSamples;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, out uint32 pCombinationCount, VkFramebufferMixedSamplesCombinationNV* pCombinations = null);

static { public const uint32 VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME = "VK_EXT_fragment_shader_interlock"; }

[CRepr] struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext; // Pointer to next structure
	public VkBool32 fragmentShaderSampleInterlock;
	public VkBool32 fragmentShaderPixelInterlock;
	public VkBool32 fragmentShaderShadingRateInterlock;

	public this(void* pNext, VkBool32 fragmentShaderSampleInterlock, VkBool32 fragmentShaderPixelInterlock, VkBool32 fragmentShaderShadingRateInterlock)
	{
		this.pNext = pNext;
		this.fragmentShaderSampleInterlock = fragmentShaderSampleInterlock;
		this.fragmentShaderPixelInterlock = fragmentShaderPixelInterlock;
		this.fragmentShaderShadingRateInterlock = fragmentShaderShadingRateInterlock;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME = "VK_EXT_ycbcr_image_arrays"; }

[CRepr] struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceYcbcrImageArraysFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 ycbcrImageArrays;

	public this(void* pNext, VkBool32 ycbcrImageArrays)
	{
		this.pNext = pNext;
		this.ycbcrImageArrays = ycbcrImageArrays;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME = "VK_KHR_uniform_buffer_standard_layout"; }

typealias VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = VkPhysicalDeviceUniformBufferStandardLayoutFeatures;

static { public const uint32 VK_EXT_PROVOKING_VERTEX_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME = "VK_EXT_provoking_vertex"; }

[CRepr] struct VkPhysicalDeviceProvokingVertexFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceProvokingVertexFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 provokingVertexLast;
	public VkBool32 transformFeedbackPreservesProvokingVertex;

	public this(void* pNext, VkBool32 provokingVertexLast, VkBool32 transformFeedbackPreservesProvokingVertex)
	{
		this.pNext = pNext;
		this.provokingVertexLast = provokingVertexLast;
		this.transformFeedbackPreservesProvokingVertex = transformFeedbackPreservesProvokingVertex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceProvokingVertexPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceProvokingVertexPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 provokingVertexModePerPipeline;
	public VkBool32 transformFeedbackPreservesTriangleFanProvokingVertex;
}

[CRepr] struct VkPipelineRasterizationProvokingVertexStateCreateInfoEXT
{
	public const VkStructureType SType = .VkPipelineRasterizationProvokingVertexStateCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkProvokingVertexModeEXT provokingVertexMode;

	public this(void* pNext, VkProvokingVertexModeEXT provokingVertexMode)
	{
		this.pNext = pNext;
		this.provokingVertexMode = provokingVertexMode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkProvokingVertexModeEXT : int32
{
	FirstVertexEXT = 0,
	LastVertexEXT = 1,
}

static { public const uint32 VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION = 4; }
static { public const c_char* VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME = "VK_EXT_full_screen_exclusive"; }

[AllowDuplicates] enum VkFullScreenExclusiveEXT : int32
{
	DefaultEXT = 0,
	AllowedEXT = 1,
	DisallowedEXT = 2,
	ApplicationControlledEXT = 3,
}

[CRepr] struct VkSurfaceFullScreenExclusiveInfoEXT
{
	public const VkStructureType SType = .VkSurfaceFullScreenExclusiveInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFullScreenExclusiveEXT fullScreenExclusive;

	public this(void* pNext, VkFullScreenExclusiveEXT fullScreenExclusive)
	{
		this.pNext = pNext;
		this.fullScreenExclusive = fullScreenExclusive;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSurfaceCapabilitiesFullScreenExclusiveEXT
{
	public const VkStructureType SType = .VkSurfaceCapabilitiesFullScreenExclusiveEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 fullScreenExclusiveSupported;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice, VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, out uint32 pPresentModeCount, VkPresentModeKHR* pPresentModes = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkAcquireFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkReleaseFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain);

[CRepr] struct VkSurfaceFullScreenExclusiveWin32InfoEXT
{
	public const VkStructureType SType = .VkSurfaceFullScreenExclusiveWin32InfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public HMONITOR hmonitor;

	public this(void* pNext, HMONITOR hmonitor)
	{
		this.pNext = pNext;
		this.hmonitor = hmonitor;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDeviceGroupSurfacePresentModes2EXT(VkDevice device, VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, out VkDeviceGroupPresentModeFlagsKHR pModes);

static { public const uint32 VK_EXT_HEADLESS_SURFACE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME = "VK_EXT_headless_surface"; }

typealias VkHeadlessSurfaceCreateFlagsEXT = VkFlags;

[CRepr] struct VkHeadlessSurfaceCreateInfoEXT
{
	public const VkStructureType SType = .VkHeadlessSurfaceCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkHeadlessSurfaceCreateFlagsEXT flags;

	public this(void* pNext = null, VkHeadlessSurfaceCreateFlagsEXT flags = 0)
	{
		this.pNext = pNext;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateHeadlessSurfaceEXT(VkInstance instance, VkHeadlessSurfaceCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);

static { public const uint32 VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = "VK_KHR_buffer_device_address"; }

typealias VkPhysicalDeviceBufferDeviceAddressFeaturesKHR = VkPhysicalDeviceBufferDeviceAddressFeatures;
typealias VkBufferDeviceAddressInfoKHR = VkBufferDeviceAddressInfo;
typealias VkBufferOpaqueCaptureAddressCreateInfoKHR = VkBufferOpaqueCaptureAddressCreateInfo;
typealias VkMemoryOpaqueCaptureAddressAllocateInfoKHR = VkMemoryOpaqueCaptureAddressAllocateInfo;
typealias VkDeviceMemoryOpaqueCaptureAddressInfoKHR = VkDeviceMemoryOpaqueCaptureAddressInfo;

static { public const uint32 VK_EXT_LINE_RASTERIZATION_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME = "VK_EXT_line_rasterization"; }

typealias VkPhysicalDeviceLineRasterizationFeaturesEXT = VkPhysicalDeviceLineRasterizationFeatures;
typealias VkPhysicalDeviceLineRasterizationPropertiesEXT = VkPhysicalDeviceLineRasterizationProperties;
typealias VkPipelineRasterizationLineStateCreateInfoEXT = VkPipelineRasterizationLineStateCreateInfo;
typealias VkLineRasterizationModeEXT = VkLineRasterizationMode;

static { public const uint32 VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME = "VK_EXT_shader_atomic_float"; }

[CRepr] struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderAtomicFloatFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderBufferFloat32Atomics;
	public VkBool32 shaderBufferFloat32AtomicAdd;
	public VkBool32 shaderBufferFloat64Atomics;
	public VkBool32 shaderBufferFloat64AtomicAdd;
	public VkBool32 shaderSharedFloat32Atomics;
	public VkBool32 shaderSharedFloat32AtomicAdd;
	public VkBool32 shaderSharedFloat64Atomics;
	public VkBool32 shaderSharedFloat64AtomicAdd;
	public VkBool32 shaderImageFloat32Atomics;
	public VkBool32 shaderImageFloat32AtomicAdd;
	public VkBool32 sparseImageFloat32Atomics;
	public VkBool32 sparseImageFloat32AtomicAdd;

	public this(void* pNext, VkBool32 shaderBufferFloat32Atomics, VkBool32 shaderBufferFloat32AtomicAdd, VkBool32 shaderBufferFloat64Atomics, VkBool32 shaderBufferFloat64AtomicAdd, VkBool32 shaderSharedFloat32Atomics, VkBool32 shaderSharedFloat32AtomicAdd, VkBool32 shaderSharedFloat64Atomics, VkBool32 shaderSharedFloat64AtomicAdd, VkBool32 shaderImageFloat32Atomics, VkBool32 shaderImageFloat32AtomicAdd, VkBool32 sparseImageFloat32Atomics, VkBool32 sparseImageFloat32AtomicAdd)
	{
		this.pNext = pNext;
		this.shaderBufferFloat32Atomics = shaderBufferFloat32Atomics;
		this.shaderBufferFloat32AtomicAdd = shaderBufferFloat32AtomicAdd;
		this.shaderBufferFloat64Atomics = shaderBufferFloat64Atomics;
		this.shaderBufferFloat64AtomicAdd = shaderBufferFloat64AtomicAdd;
		this.shaderSharedFloat32Atomics = shaderSharedFloat32Atomics;
		this.shaderSharedFloat32AtomicAdd = shaderSharedFloat32AtomicAdd;
		this.shaderSharedFloat64Atomics = shaderSharedFloat64Atomics;
		this.shaderSharedFloat64AtomicAdd = shaderSharedFloat64AtomicAdd;
		this.shaderImageFloat32Atomics = shaderImageFloat32Atomics;
		this.shaderImageFloat32AtomicAdd = shaderImageFloat32AtomicAdd;
		this.sparseImageFloat32Atomics = sparseImageFloat32Atomics;
		this.sparseImageFloat32AtomicAdd = sparseImageFloat32AtomicAdd;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_HOST_QUERY_RESET_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME = "VK_EXT_host_query_reset"; }

typealias VkPhysicalDeviceHostQueryResetFeaturesEXT = VkPhysicalDeviceHostQueryResetFeatures;

static { public const uint32 VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME = "VK_EXT_index_type_uint8"; }

typealias VkPhysicalDeviceIndexTypeUint8FeaturesEXT = VkPhysicalDeviceIndexTypeUint8Features;

static { public const uint32 VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME = "VK_EXT_extended_dynamic_state"; }

[CRepr] struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceExtendedDynamicStateFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 extendedDynamicState;

	public this(void* pNext, VkBool32 extendedDynamicState)
	{
		this.pNext = pNext;
		this.extendedDynamicState = extendedDynamicState;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION = 4; }
static { public const c_char* VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME = "VK_KHR_deferred_host_operations"; }

class VkDeferredOperationKHR { private this() { } }

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateDeferredOperationKHR(VkDevice device, VkAllocationCallbacks* pAllocator, out VkDeferredOperationKHR pDeferredOperation);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function uint32 PFN_vkGetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDeferredOperationResultKHR(VkDevice device, VkDeferredOperationKHR operation);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkDeferredOperationJoinKHR(VkDevice device, VkDeferredOperationKHR operation);

static { public const uint32 VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME = "VK_KHR_pipeline_executable_properties"; }

[CRepr] struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 pipelineExecutableInfo;

	public this(void* pNext, VkBool32 pipelineExecutableInfo)
	{
		this.pNext = pNext;
		this.pipelineExecutableInfo = pipelineExecutableInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineInfoKHR
{
	public const VkStructureType SType = .VkPipelineInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkPipeline pipeline;

	public this(void* pNext, VkPipeline pipeline)
	{
		this.pNext = pNext;
		this.pipeline = pipeline;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineExecutablePropertiesKHR
{
	public const VkStructureType SType = .VkPipelineExecutablePropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkShaderStageFlags stages;
	public c_char[VK_MAX_DESCRIPTION_SIZE] name;
	public c_char[VK_MAX_DESCRIPTION_SIZE] description;
	public uint32 subgroupSize;
}

[CRepr] struct VkPipelineExecutableInfoKHR
{
	public const VkStructureType SType = .VkPipelineExecutableInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipeline pipeline;
	public uint32 executableIndex;

	public this(void* pNext, VkPipeline pipeline, uint32 executableIndex)
	{
		this.pNext = pNext;
		this.pipeline = pipeline;
		this.executableIndex = executableIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkPipelineExecutableStatisticFormatKHR : int32
{
	Bool32KHR = 0,
	Int64KHR = 1,
	Uint64KHR = 2,
	Float64KHR = 3,
}

[Union, CRepr] struct VkPipelineExecutableStatisticValueKHR
{
	public VkBool32 b32;
	public int64 i64;
	public uint64 u64;
	public double f64;
}

[CRepr] struct VkPipelineExecutableStatisticKHR
{
	public const VkStructureType SType = .VkPipelineExecutableStatisticKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_char[VK_MAX_DESCRIPTION_SIZE] name;
	public c_char[VK_MAX_DESCRIPTION_SIZE] description;
	public VkPipelineExecutableStatisticFormatKHR format;
	public VkPipelineExecutableStatisticValueKHR value;
}

[CRepr] struct VkPipelineExecutableInternalRepresentationKHR
{
	public const VkStructureType SType = .VkPipelineExecutableInternalRepresentationKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_char[VK_MAX_DESCRIPTION_SIZE] name;
	public c_char[VK_MAX_DESCRIPTION_SIZE] description;
	public VkBool32 isText;
	public c_size dataSize;
	public void* pData;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPipelineExecutablePropertiesKHR(VkDevice device, VkPipelineInfoKHR* pPipelineInfo, out uint32 pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPipelineExecutableStatisticsKHR(VkDevice device, VkPipelineExecutableInfoKHR* pExecutableInfo, out uint32 pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPipelineExecutableInternalRepresentationsKHR(VkDevice device, VkPipelineExecutableInfoKHR* pExecutableInfo, out uint32 pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations = null);

static { public const uint32 VK_EXT_HOST_IMAGE_COPY_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME = "VK_EXT_host_image_copy"; }

typealias VkPhysicalDeviceHostImageCopyFeaturesEXT = VkPhysicalDeviceHostImageCopyFeatures;
typealias VkPhysicalDeviceHostImageCopyPropertiesEXT = VkPhysicalDeviceHostImageCopyProperties;
typealias VkHostImageCopyFlagBitsEXT = VkHostImageCopyFlagBits;
typealias VkHostImageCopyFlagsEXT = VkHostImageCopyFlags;
typealias VkMemoryToImageCopyEXT = VkMemoryToImageCopy;
typealias VkImageToMemoryCopyEXT = VkImageToMemoryCopy;
typealias VkCopyMemoryToImageInfoEXT = VkCopyMemoryToImageInfo;
typealias VkCopyImageToMemoryInfoEXT = VkCopyImageToMemoryInfo;
typealias VkCopyImageToImageInfoEXT = VkCopyImageToImageInfo;
typealias VkHostImageLayoutTransitionInfoEXT = VkHostImageLayoutTransitionInfo;
typealias VkSubresourceHostMemcpySizeEXT = VkSubresourceHostMemcpySize;
typealias VkHostImageCopyDevicePerformanceQueryEXT = VkHostImageCopyDevicePerformanceQuery;
typealias VkSubresourceLayout2EXT = VkSubresourceLayout2;
typealias VkImageSubresource2EXT = VkImageSubresource2;

static { public const uint32 VK_KHR_MAP_MEMORY_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_MAP_MEMORY_2_EXTENSION_NAME = "VK_KHR_map_memory2"; }

typealias VkMemoryMapInfoKHR = VkMemoryMapInfo;
typealias VkMemoryUnmapInfoKHR = VkMemoryUnmapInfo;
typealias VkMemoryUnmapFlagBitsKHR = VkMemoryUnmapFlagBits;
typealias VkMemoryUnmapFlagsKHR = VkMemoryUnmapFlags;

static { public const uint32 VK_EXT_MAP_MEMORY_PLACED_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME = "VK_EXT_map_memory_placed"; }

[CRepr] struct VkPhysicalDeviceMapMemoryPlacedFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceMapMemoryPlacedFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 memoryMapPlaced;
	public VkBool32 memoryMapRangePlaced;
	public VkBool32 memoryUnmapReserve;

	public this(void* pNext, VkBool32 memoryMapPlaced, VkBool32 memoryMapRangePlaced, VkBool32 memoryUnmapReserve)
	{
		this.pNext = pNext;
		this.memoryMapPlaced = memoryMapPlaced;
		this.memoryMapRangePlaced = memoryMapRangePlaced;
		this.memoryUnmapReserve = memoryUnmapReserve;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceMapMemoryPlacedPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceMapMemoryPlacedPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize minPlacedMemoryMapAlignment;
}

[CRepr] struct VkMemoryMapPlacedInfoEXT
{
	public const VkStructureType SType = .VkMemoryMapPlacedInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public void* pPlacedAddress;

	public this(void* pNext, void* pPlacedAddress)
	{
		this.pNext = pNext;
		this.pPlacedAddress = pPlacedAddress;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME = "VK_EXT_shader_atomic_float2"; }

[CRepr] struct VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderBufferFloat16Atomics;
	public VkBool32 shaderBufferFloat16AtomicAdd;
	public VkBool32 shaderBufferFloat16AtomicMinMax;
	public VkBool32 shaderBufferFloat32AtomicMinMax;
	public VkBool32 shaderBufferFloat64AtomicMinMax;
	public VkBool32 shaderSharedFloat16Atomics;
	public VkBool32 shaderSharedFloat16AtomicAdd;
	public VkBool32 shaderSharedFloat16AtomicMinMax;
	public VkBool32 shaderSharedFloat32AtomicMinMax;
	public VkBool32 shaderSharedFloat64AtomicMinMax;
	public VkBool32 shaderImageFloat32AtomicMinMax;
	public VkBool32 sparseImageFloat32AtomicMinMax;

	public this(void* pNext, VkBool32 shaderBufferFloat16Atomics, VkBool32 shaderBufferFloat16AtomicAdd, VkBool32 shaderBufferFloat16AtomicMinMax, VkBool32 shaderBufferFloat32AtomicMinMax, VkBool32 shaderBufferFloat64AtomicMinMax, VkBool32 shaderSharedFloat16Atomics, VkBool32 shaderSharedFloat16AtomicAdd, VkBool32 shaderSharedFloat16AtomicMinMax, VkBool32 shaderSharedFloat32AtomicMinMax, VkBool32 shaderSharedFloat64AtomicMinMax, VkBool32 shaderImageFloat32AtomicMinMax, VkBool32 sparseImageFloat32AtomicMinMax)
	{
		this.pNext = pNext;
		this.shaderBufferFloat16Atomics = shaderBufferFloat16Atomics;
		this.shaderBufferFloat16AtomicAdd = shaderBufferFloat16AtomicAdd;
		this.shaderBufferFloat16AtomicMinMax = shaderBufferFloat16AtomicMinMax;
		this.shaderBufferFloat32AtomicMinMax = shaderBufferFloat32AtomicMinMax;
		this.shaderBufferFloat64AtomicMinMax = shaderBufferFloat64AtomicMinMax;
		this.shaderSharedFloat16Atomics = shaderSharedFloat16Atomics;
		this.shaderSharedFloat16AtomicAdd = shaderSharedFloat16AtomicAdd;
		this.shaderSharedFloat16AtomicMinMax = shaderSharedFloat16AtomicMinMax;
		this.shaderSharedFloat32AtomicMinMax = shaderSharedFloat32AtomicMinMax;
		this.shaderSharedFloat64AtomicMinMax = shaderSharedFloat64AtomicMinMax;
		this.shaderImageFloat32AtomicMinMax = shaderImageFloat32AtomicMinMax;
		this.sparseImageFloat32AtomicMinMax = sparseImageFloat32AtomicMinMax;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_SURFACE_MAINTENANCE_1_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME = "VK_EXT_surface_maintenance1"; }

typealias VkSurfacePresentModeEXT = VkSurfacePresentModeKHR;
typealias VkPresentScalingFlagBitsEXT = VkPresentScalingFlagBitsKHR;
typealias VkPresentScalingFlagsEXT = VkPresentScalingFlagsKHR;
typealias VkPresentGravityFlagBitsEXT = VkPresentGravityFlagBitsKHR;
typealias VkPresentGravityFlagsEXT = VkPresentGravityFlagsKHR;
typealias VkSurfacePresentScalingCapabilitiesEXT = VkSurfacePresentScalingCapabilitiesKHR;
typealias VkSurfacePresentModeCompatibilityEXT = VkSurfacePresentModeCompatibilityKHR;

static { public const uint32 VK_EXT_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME = "VK_EXT_swapchain_maintenance1"; }

typealias VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT = VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR;
typealias VkSwapchainPresentFenceInfoEXT = VkSwapchainPresentFenceInfoKHR;
typealias VkSwapchainPresentModesCreateInfoEXT = VkSwapchainPresentModesCreateInfoKHR;
typealias VkSwapchainPresentModeInfoEXT = VkSwapchainPresentModeInfoKHR;
typealias VkSwapchainPresentScalingCreateInfoEXT = VkSwapchainPresentScalingCreateInfoKHR;
typealias VkReleaseSwapchainImagesInfoEXT = VkReleaseSwapchainImagesInfoKHR;

static { public const uint32 VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME = "VK_EXT_shader_demote_to_helper_invocation"; }

typealias VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;

static { public const uint32 VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION = 3; }
static { public const c_char* VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = "VK_NV_device_generated_commands"; }

[CRepr] struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxGraphicsShaderGroupCount;
	public uint32 maxIndirectSequenceCount;
	public uint32 maxIndirectCommandsTokenCount;
	public uint32 maxIndirectCommandsStreamCount;
	public uint32 maxIndirectCommandsTokenOffset;
	public uint32 maxIndirectCommandsStreamStride;
	public uint32 minSequencesCountBufferOffsetAlignment;
	public uint32 minSequencesIndexBufferOffsetAlignment;
	public uint32 minIndirectCommandsBufferOffsetAlignment;
}

[CRepr] struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 deviceGeneratedCommands;

	public this(void* pNext, VkBool32 deviceGeneratedCommands)
	{
		this.pNext = pNext;
		this.deviceGeneratedCommands = deviceGeneratedCommands;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkGraphicsShaderGroupCreateInfoNV
{
	public const VkStructureType SType = .VkGraphicsShaderGroupCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 stageCount;
	public VkPipelineShaderStageCreateInfo* pStages;
	public VulkanSpan<VkPipelineShaderStageCreateInfo> stages
	{
		[Inline] get => .(stageCount, pStages);
		[Inline] set mut { stageCount = value.count; pStages = value.ptr; }
	}
	public VkPipelineVertexInputStateCreateInfo* pVertexInputState;
	public VkPipelineTessellationStateCreateInfo* pTessellationState;

	public this(void* pNext, VulkanSpan<VkPipelineShaderStageCreateInfo> stages, VkPipelineVertexInputStateCreateInfo* pVertexInputState = null, VkPipelineTessellationStateCreateInfo* pTessellationState = null) : this()
	{
		this.pNext = pNext;
		this.stages = stages;
		this.pVertexInputState = pVertexInputState;
		this.pTessellationState = pTessellationState;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkGraphicsPipelineShaderGroupsCreateInfoNV
{
	public const VkStructureType SType = .VkGraphicsPipelineShaderGroupsCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 groupCount;
	public VkGraphicsShaderGroupCreateInfoNV* pGroups;
	public VulkanSpan<VkGraphicsShaderGroupCreateInfoNV> groups
	{
		[Inline] get => .(groupCount, pGroups);
		[Inline] set mut { groupCount = value.count; pGroups = value.ptr; }
	}
	public uint32 pipelineCount;
	public VkPipeline* pPipelines;
	public VulkanSpan<VkPipeline> pipelines
	{
		[Inline] get => .(pipelineCount, pPipelines);
		[Inline] set mut { pipelineCount = value.count; pPipelines = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkGraphicsShaderGroupCreateInfoNV> groups = .(), VulkanSpan<VkPipeline> pipelines = .()) : this()
	{
		this.pNext = pNext;
		this.groups = groups;
		this.pipelines = pipelines;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBindShaderGroupIndirectCommandNV
{
	public uint32 groupIndex;

	public this(uint32 groupIndex)
	{
		this.groupIndex = groupIndex;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkBindIndexBufferIndirectCommandNV
{
	public VkDeviceAddress bufferAddress;
	public uint32 size;
	public VkIndexType indexType;

	public this(VkDeviceAddress bufferAddress, uint32 size, VkIndexType indexType)
	{
		this.bufferAddress = bufferAddress;
		this.size = size;
		this.indexType = indexType;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkBindVertexBufferIndirectCommandNV
{
	public VkDeviceAddress bufferAddress;
	public uint32 size;
	public uint32 stride;

	public this(VkDeviceAddress bufferAddress, uint32 size, uint32 stride)
	{
		this.bufferAddress = bufferAddress;
		this.size = size;
		this.stride = stride;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkSetStateFlagsIndirectCommandNV
{
	public uint32 data;

	public this(uint32 data)
	{
		this.data = data;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkIndirectStateFlagBitsNV : int32
{
	FlagFrontfaceNV = 1 << 0,
}

typealias VkIndirectStateFlagsNV = VkIndirectStateFlagBitsNV;

class VkIndirectCommandsLayoutNV { private this() { } }

[AllowDuplicates] enum VkIndirectCommandsTokenTypeNV : int32
{
	ShaderGroupNV = 0,
	StateFlagsNV = 1,
	IndexBufferNV = 2,
	VertexBufferNV = 3,
	PushConstantNV = 4,
	DrawIndexedNV = 5,
	DrawNV = 6,
	DrawTasksNV = 7,
	DrawMeshTasksNV = 1000328000,
	PipelineNV = 1000428003,
	DispatchNV = 1000428004,
}

[AllowDuplicates] enum VkIndirectCommandsLayoutUsageFlagBitsNV : int32
{
	ExplicitPreprocessNV = 1 << 0,
	IndexedSequencesNV = 1 << 1,
	UnorderedSequencesNV = 1 << 2,
}

typealias VkIndirectCommandsLayoutUsageFlagsNV = VkIndirectCommandsLayoutUsageFlagBitsNV;

[CRepr] struct VkIndirectCommandsStreamNV
{
	public VkBuffer buffer;
	public VkDeviceSize offset;

	public this(VkBuffer buffer, VkDeviceSize offset)
	{
		this.buffer = buffer;
		this.offset = offset;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkIndirectCommandsLayoutTokenNV
{
	public const VkStructureType SType = .VkIndirectCommandsLayoutTokenNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkIndirectCommandsTokenTypeNV tokenType;
	public uint32 stream;
	public uint32 offset;
	public uint32 vertexBindingUnit;
	public VkBool32 vertexDynamicStride;
	public VkPipelineLayout pushconstantPipelineLayout;
	public VkShaderStageFlags pushconstantShaderStageFlags;
	public uint32 pushconstantOffset;
	public uint32 pushconstantSize;
	public VkIndirectStateFlagsNV indirectStateFlags;
	public uint32 indexTypeCount;
	public VkIndexType* pIndexTypes;
	public uint32* pIndexTypeValues;
	public VulkanDuoSpan<VkIndexType, uint32> indexTypes_indexTypeValues
	{
		[Inline] get => .(indexTypeCount, pIndexTypes, pIndexTypeValues);
		[Inline] set mut { indexTypeCount = value.count; pIndexTypes = value.ptr1; pIndexTypeValues = value.ptr2; }
	}

	public this(void* pNext, VkIndirectCommandsTokenTypeNV tokenType, uint32 stream, uint32 offset, uint32 vertexBindingUnit, VkBool32 vertexDynamicStride, VkPipelineLayout pushconstantPipelineLayout, VkShaderStageFlags pushconstantShaderStageFlags, uint32 pushconstantOffset, uint32 pushconstantSize, VkIndirectStateFlagsNV indirectStateFlags = 0, VulkanDuoSpan<VkIndexType, uint32> indexTypes_indexTypeValues = .()) : this()
	{
		this.pNext = pNext;
		this.tokenType = tokenType;
		this.stream = stream;
		this.offset = offset;
		this.vertexBindingUnit = vertexBindingUnit;
		this.vertexDynamicStride = vertexDynamicStride;
		this.pushconstantPipelineLayout = pushconstantPipelineLayout;
		this.pushconstantShaderStageFlags = pushconstantShaderStageFlags;
		this.pushconstantOffset = pushconstantOffset;
		this.pushconstantSize = pushconstantSize;
		this.indirectStateFlags = indirectStateFlags;
		this.indexTypes_indexTypeValues = indexTypes_indexTypeValues;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkIndirectCommandsLayoutCreateInfoNV
{
	public const VkStructureType SType = .VkIndirectCommandsLayoutCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkIndirectCommandsLayoutUsageFlagsNV flags;
	public VkPipelineBindPoint pipelineBindPoint;
	public uint32 tokenCount;
	public VkIndirectCommandsLayoutTokenNV* pTokens;
	public VulkanSpan<VkIndirectCommandsLayoutTokenNV> tokens
	{
		[Inline] get => .(tokenCount, pTokens);
		[Inline] set mut { tokenCount = value.count; pTokens = value.ptr; }
	}
	public uint32 streamCount;
	public uint32* pStreamStrides;
	public VulkanSpan<uint32> streamStrides
	{
		[Inline] get => .(streamCount, pStreamStrides);
		[Inline] set mut { streamCount = value.count; pStreamStrides = value.ptr; }
	}

	public this(void* pNext, VkIndirectCommandsLayoutUsageFlagsNV flags, VkPipelineBindPoint pipelineBindPoint, VulkanSpan<VkIndirectCommandsLayoutTokenNV> tokens, VulkanSpan<uint32> streamStrides) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.pipelineBindPoint = pipelineBindPoint;
		this.tokens = tokens;
		this.streamStrides = streamStrides;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkGeneratedCommandsInfoNV
{
	public const VkStructureType SType = .VkGeneratedCommandsInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineBindPoint pipelineBindPoint;
	public VkPipeline pipeline;
	public VkIndirectCommandsLayoutNV indirectCommandsLayout;
	public uint32 streamCount;
	public VkIndirectCommandsStreamNV* pStreams;
	public VulkanSpan<VkIndirectCommandsStreamNV> streams
	{
		[Inline] get => .(streamCount, pStreams);
		[Inline] set mut { streamCount = value.count; pStreams = value.ptr; }
	}
	public uint32 sequencesCount;
	public VkBuffer preprocessBuffer;
	public VkDeviceSize preprocessOffset;
	public VkDeviceSize preprocessSize;
	public VkBuffer sequencesCountBuffer;
	public VkDeviceSize sequencesCountOffset;
	public VkBuffer sequencesIndexBuffer;
	public VkDeviceSize sequencesIndexOffset;

	public this(void* pNext, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, VkIndirectCommandsLayoutNV indirectCommandsLayout, VulkanSpan<VkIndirectCommandsStreamNV> streams, uint32 sequencesCount, VkBuffer preprocessBuffer, VkDeviceSize preprocessOffset, VkDeviceSize preprocessSize, VkBuffer sequencesCountBuffer, VkDeviceSize sequencesCountOffset, VkBuffer sequencesIndexBuffer, VkDeviceSize sequencesIndexOffset) : this()
	{
		this.pNext = pNext;
		this.pipelineBindPoint = pipelineBindPoint;
		this.pipeline = pipeline;
		this.indirectCommandsLayout = indirectCommandsLayout;
		this.streams = streams;
		this.sequencesCount = sequencesCount;
		this.preprocessBuffer = preprocessBuffer;
		this.preprocessOffset = preprocessOffset;
		this.preprocessSize = preprocessSize;
		this.sequencesCountBuffer = sequencesCountBuffer;
		this.sequencesCountOffset = sequencesCountOffset;
		this.sequencesIndexBuffer = sequencesIndexBuffer;
		this.sequencesIndexOffset = sequencesIndexOffset;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkGeneratedCommandsMemoryRequirementsInfoNV
{
	public const VkStructureType SType = .VkGeneratedCommandsMemoryRequirementsInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineBindPoint pipelineBindPoint;
	public VkPipeline pipeline;
	public VkIndirectCommandsLayoutNV indirectCommandsLayout;
	public uint32 maxSequencesCount;

	public this(void* pNext, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, VkIndirectCommandsLayoutNV indirectCommandsLayout, uint32 maxSequencesCount)
	{
		this.pNext = pNext;
		this.pipelineBindPoint = pipelineBindPoint;
		this.pipeline = pipeline;
		this.indirectCommandsLayout = indirectCommandsLayout;
		this.maxSequencesCount = maxSequencesCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetGeneratedCommandsMemoryRequirementsNV(VkDevice device, VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo, out VkMemoryRequirements2 pMemoryRequirements);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32 groupIndex);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkIndirectCommandsLayoutNV pIndirectCommandsLayout);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout = null, VkAllocationCallbacks* pAllocator = null);

static { public const uint32 VK_NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME = "VK_NV_inherited_viewport_scissor"; }

[CRepr] struct VkPhysicalDeviceInheritedViewportScissorFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceInheritedViewportScissorFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 inheritedViewportScissor2D;

	public this(void* pNext, VkBool32 inheritedViewportScissor2D)
	{
		this.pNext = pNext;
		this.inheritedViewportScissor2D = inheritedViewportScissor2D;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCommandBufferInheritanceViewportScissorInfoNV
{
	public const VkStructureType SType = .VkCommandBufferInheritanceViewportScissorInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 viewportScissor2D;
	public uint32 viewportDepthCount;
	public VkViewport* pViewportDepths;

	public this(void* pNext, VkBool32 viewportScissor2D, uint32 viewportDepthCount, VkViewport* pViewportDepths)
	{
		this.pNext = pNext;
		this.viewportScissor2D = viewportScissor2D;
		this.viewportDepthCount = viewportDepthCount;
		this.pViewportDepths = pViewportDepths;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME = "VK_KHR_shader_integer_dot_product"; }

typealias VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = VkPhysicalDeviceShaderIntegerDotProductFeatures;
typealias VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR = VkPhysicalDeviceShaderIntegerDotProductProperties;

static { public const uint32 VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME = "VK_EXT_texel_buffer_alignment"; }

[CRepr] struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 texelBufferAlignment;

	public this(void* pNext, VkBool32 texelBufferAlignment)
	{
		this.pNext = pNext;
		this.texelBufferAlignment = texelBufferAlignment;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = VkPhysicalDeviceTexelBufferAlignmentProperties;

static { public const uint32 VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION = 5; }
static { public const c_char* VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME = "VK_QCOM_render_pass_transform"; }

[CRepr] struct VkRenderPassTransformBeginInfoQCOM
{
	public const VkStructureType SType = .VkRenderPassTransformBeginInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext; // Pointer to next structure
	public VkSurfaceTransformFlagBitsKHR transform;

	public this(void* pNext, VkSurfaceTransformFlagBitsKHR transform)
	{
		this.pNext = pNext;
		this.transform = transform;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCommandBufferInheritanceRenderPassTransformInfoQCOM
{
	public const VkStructureType SType = .VkCommandBufferInheritanceRenderPassTransformInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext; // Pointer to next structure
	public VkSurfaceTransformFlagBitsKHR transform;
	public VkRect2D renderArea;

	public this(void* pNext, VkSurfaceTransformFlagBitsKHR transform, VkRect2D renderArea)
	{
		this.pNext = pNext;
		this.transform = transform;
		this.renderArea = renderArea;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_DEPTH_BIAS_CONTROL_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME = "VK_EXT_depth_bias_control"; }

[CRepr] struct VkPhysicalDeviceDepthBiasControlFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceDepthBiasControlFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 depthBiasControl;
	public VkBool32 leastRepresentableValueForceUnormRepresentation;
	public VkBool32 floatRepresentation;
	public VkBool32 depthBiasExact;

	public this(void* pNext, VkBool32 depthBiasControl, VkBool32 leastRepresentableValueForceUnormRepresentation, VkBool32 floatRepresentation, VkBool32 depthBiasExact)
	{
		this.pNext = pNext;
		this.depthBiasControl = depthBiasControl;
		this.leastRepresentableValueForceUnormRepresentation = leastRepresentableValueForceUnormRepresentation;
		this.floatRepresentation = floatRepresentation;
		this.depthBiasExact = depthBiasExact;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDepthBiasInfoEXT
{
	public const VkStructureType SType = .VkDepthBiasInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public float depthBiasConstantFactor;
	public float depthBiasClamp;
	public float depthBiasSlopeFactor;

	public this(void* pNext, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor)
	{
		this.pNext = pNext;
		this.depthBiasConstantFactor = depthBiasConstantFactor;
		this.depthBiasClamp = depthBiasClamp;
		this.depthBiasSlopeFactor = depthBiasSlopeFactor;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkDepthBiasRepresentationEXT : int32
{
	LeastRepresentableValueFormatEXT = 0,
	LeastRepresentableValueForceUnormEXT = 1,
	FloatEXT = 2,
}

[CRepr] struct VkDepthBiasRepresentationInfoEXT
{
	public const VkStructureType SType = .VkDepthBiasRepresentationInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDepthBiasRepresentationEXT depthBiasRepresentation;
	public VkBool32 depthBiasExact;

	public this(void* pNext, VkDepthBiasRepresentationEXT depthBiasRepresentation, VkBool32 depthBiasExact)
	{
		this.pNext = pNext;
		this.depthBiasRepresentation = depthBiasRepresentation;
		this.depthBiasExact = depthBiasExact;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, VkDepthBiasInfoEXT* pDepthBiasInfo);

static { public const uint32 VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME = "VK_EXT_device_memory_report"; }

[CRepr] struct VkPhysicalDeviceDeviceMemoryReportFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceDeviceMemoryReportFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 deviceMemoryReport;

	public this(void* pNext, VkBool32 deviceMemoryReport)
	{
		this.pNext = pNext;
		this.deviceMemoryReport = deviceMemoryReport;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceDeviceMemoryReportCreateInfoEXT
{
	public const VkStructureType SType = .VkDeviceDeviceMemoryReportCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceMemoryReportFlagsEXT flags;
	public PFN_vkDeviceMemoryReportCallbackEXT pfnUserCallback;
	public void* pUserData;

	public this(void* pNext, VkDeviceMemoryReportFlagsEXT flags, PFN_vkDeviceMemoryReportCallbackEXT pfnUserCallback, void* pUserData)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.pfnUserCallback = pfnUserCallback;
		this.pUserData = pUserData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceMemoryReportCallbackDataEXT
{
	public const VkStructureType SType = .VkDeviceMemoryReportCallbackDataEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceMemoryReportFlagsEXT flags;
	public VkDeviceMemoryReportEventTypeEXT type;
	public uint64 memoryObjectId;
	public VkDeviceSize size;
	public VkObjectType objectType;
	public uint64 objectHandle;
	public uint32 heapIndex;
}

typealias VkDeviceMemoryReportFlagsEXT = VkFlags;

[AllowDuplicates] enum VkDeviceMemoryReportEventTypeEXT : int32
{
	AllocateEXT = 0,
	FreeEXT = 1,
	ImportEXT = 2,
	UnimportEXT = 3,
	AllocationFailedEXT = 4,
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkDeviceMemoryReportCallbackEXT( VkDeviceMemoryReportCallbackDataEXT* pCallbackData, void* pUserData);

static { public const uint32 VK_EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME = "VK_EXT_acquire_drm_display"; }

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkAcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32 drmFd, VkDisplayKHR display);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32 drmFd, uint32 connectorId, out VkDisplayKHR display);

static { public const uint32 VK_EXT_ROBUSTNESS_2_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_ROBUSTNESS_2_EXTENSION_NAME = "VK_EXT_robustness2"; }

typealias VkPhysicalDeviceRobustness2FeaturesEXT = VkPhysicalDeviceRobustness2FeaturesKHR;
typealias VkPhysicalDeviceRobustness2PropertiesEXT = VkPhysicalDeviceRobustness2PropertiesKHR;

static { public const uint32 VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION = 12; }
static { public const c_char* VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME = "VK_EXT_custom_border_color"; }

[CRepr] struct VkSamplerCustomBorderColorCreateInfoEXT
{
	public const VkStructureType SType = .VkSamplerCustomBorderColorCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkClearColorValue customBorderColor;
	public VkFormat format;

	public this(void* pNext, VkClearColorValue customBorderColor, VkFormat format)
	{
		this.pNext = pNext;
		this.customBorderColor = customBorderColor;
		this.format = format;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceCustomBorderColorPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceCustomBorderColorPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxCustomBorderColorSamplers;
}

[CRepr] struct VkPhysicalDeviceCustomBorderColorFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceCustomBorderColorFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 customBorderColors;
	public VkBool32 customBorderColorWithoutFormat;

	public this(void* pNext, VkBool32 customBorderColors, VkBool32 customBorderColorWithoutFormat)
	{
		this.pNext = pNext;
		this.customBorderColors = customBorderColors;
		this.customBorderColorWithoutFormat = customBorderColorWithoutFormat;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_GOOGLE_USER_TYPE_SPEC_VERSION = 1; }
static { public const c_char* VK_GOOGLE_USER_TYPE_EXTENSION_NAME = "VK_GOOGLE_user_type"; }
static { public const uint32 VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME = "VK_KHR_pipeline_library"; }

[CRepr] struct VkPipelineLibraryCreateInfoKHR
{
	public const VkStructureType SType = .VkPipelineLibraryCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 libraryCount;
	public VkPipeline* pLibraries;
	public VulkanSpan<VkPipeline> libraries
	{
		[Inline] get => .(libraryCount, pLibraries);
		[Inline] set mut { libraryCount = value.count; pLibraries = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkPipeline> libraries = .()) : this()
	{
		this.pNext = pNext;
		this.libraries = libraries;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_PRESENT_BARRIER_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_PRESENT_BARRIER_EXTENSION_NAME = "VK_NV_present_barrier"; }

[CRepr] struct VkPhysicalDevicePresentBarrierFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDevicePresentBarrierFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 presentBarrier;

	public this(void* pNext, VkBool32 presentBarrier)
	{
		this.pNext = pNext;
		this.presentBarrier = presentBarrier;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSurfaceCapabilitiesPresentBarrierNV
{
	public const VkStructureType SType = .VkSurfaceCapabilitiesPresentBarrierNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 presentBarrierSupported;
}

[CRepr] struct VkSwapchainPresentBarrierCreateInfoNV
{
	public const VkStructureType SType = .VkSwapchainPresentBarrierCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 presentBarrierEnable;

	public this(void* pNext, VkBool32 presentBarrierEnable)
	{
		this.pNext = pNext;
		this.presentBarrierEnable = presentBarrierEnable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME = "VK_KHR_shader_non_semantic_info"; }
static { public const uint32 VK_KHR_PRESENT_ID_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_PRESENT_ID_EXTENSION_NAME = "VK_KHR_present_id"; }

[CRepr] struct VkPresentIdKHR
{
	public const VkStructureType SType = .VkPresentIdKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 swapchainCount; // Copy of VkPresentInfoKHR::swapchainCount
	public uint64* pPresentIds; // Present ID values for each swapchain
	public VulkanSpan<uint64> presentIds
	{
		[Inline] get => .(swapchainCount, pPresentIds);
		[Inline] set mut { swapchainCount = value.count; pPresentIds = value.ptr; }
	} // Present ID values for each swapchain

	public this(void* pNext, VulkanSpan<uint64> presentIds = .()) : this()
	{
		this.pNext = pNext;
		this.presentIds = presentIds;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDevicePresentIdFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDevicePresentIdFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 presentId; // Present ID in VkPresentInfoKHR

	public this(void* pNext, VkBool32 presentId)
	{
		this.pNext = pNext;
		this.presentId = presentId;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_PRIVATE_DATA_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_PRIVATE_DATA_EXTENSION_NAME = "VK_EXT_private_data"; }

typealias VkPhysicalDevicePrivateDataFeaturesEXT = VkPhysicalDevicePrivateDataFeatures;
typealias VkDevicePrivateDataCreateInfoEXT = VkDevicePrivateDataCreateInfo;
typealias VkPrivateDataSlotCreateInfoEXT = VkPrivateDataSlotCreateInfo;
typealias VkPrivateDataSlotCreateFlagsEXT = VkPrivateDataSlotCreateFlags;

static { public const uint32 VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION = 3; }
static { public const c_char* VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME = "VK_EXT_pipeline_creation_cache_control"; }

typealias VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT = VkPhysicalDevicePipelineCreationCacheControlFeatures;

[AllowDuplicates] enum VkPipelineCacheCreateFlagBits : int32
{
	ExternallySynchronized = 1 << 0,
	ExternallySynchronizedEXT = ExternallySynchronized,
	InternallySynchronizedMergeKHR = 1 << 3,
}

static { public const uint32 VK_KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION = 12; }
static { public const c_char* VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME = "VK_KHR_video_encode_queue"; }

typealias VkVideoEncodeFlagsKHR = VkVideoEncodeFlagBitsKHR;

[CRepr] struct VkVideoEncodeInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeFlagsKHR flags;
	public VkBuffer dstBuffer;
	public VkDeviceSize dstBufferOffset;
	public VkDeviceSize dstBufferRange;
	public VkVideoPictureResourceInfoKHR srcPictureResource;
	public VkVideoReferenceSlotInfoKHR* pSetupReferenceSlot;
	public uint32 referenceSlotCount;
	public VkVideoReferenceSlotInfoKHR* pReferenceSlots;
	public VulkanSpan<VkVideoReferenceSlotInfoKHR> referenceSlots
	{
		[Inline] get => .(referenceSlotCount, pReferenceSlots);
		[Inline] set mut { referenceSlotCount = value.count; pReferenceSlots = value.ptr; }
	}
	public uint32 precedingExternallyEncodedBytes;

	public this(void* pNext, VkVideoEncodeFlagsKHR flags, VkBuffer dstBuffer, VkDeviceSize dstBufferOffset, VkDeviceSize dstBufferRange, VkVideoPictureResourceInfoKHR srcPictureResource, VkVideoReferenceSlotInfoKHR* pSetupReferenceSlot, VulkanSpan<VkVideoReferenceSlotInfoKHR> referenceSlots, uint32 precedingExternallyEncodedBytes) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.dstBuffer = dstBuffer;
		this.dstBufferOffset = dstBufferOffset;
		this.dstBufferRange = dstBufferRange;
		this.srcPictureResource = srcPictureResource;
		this.pSetupReferenceSlot = pSetupReferenceSlot;
		this.referenceSlots = referenceSlots;
		this.precedingExternallyEncodedBytes = precedingExternallyEncodedBytes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkVideoEncodeCapabilityFlagBitsKHR : int32
{
	PrecedingExternallyEncodedBytesKHR = 1 << 0,
	InsufficientBitstreamBufferRangeDetectionKHR = 1 << 1,
	QuantizationDeltaMapKHR = 1 << 2,
	EmphasisMapKHR = 1 << 3,
}

typealias VkVideoEncodeCapabilityFlagsKHR = VkVideoEncodeCapabilityFlagBitsKHR;

[CRepr] struct VkVideoEncodeCapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoEncodeCapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeCapabilityFlagsKHR flags;
	public VkVideoEncodeRateControlModeFlagsKHR rateControlModes;
	public uint32 maxRateControlLayers;
	public uint64 maxBitrate;
	public uint32 maxQualityLevels;
	public VkExtent2D encodeInputPictureGranularity;
	public VkVideoEncodeFeedbackFlagsKHR supportedEncodeFeedbackFlags;
}

[CRepr] struct VkQueryPoolVideoEncodeFeedbackCreateInfoKHR
{
	public const VkStructureType SType = .VkQueryPoolVideoEncodeFeedbackCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeFeedbackFlagsKHR encodeFeedbackFlags;

	public this(void* pNext, VkVideoEncodeFeedbackFlagsKHR encodeFeedbackFlags)
	{
		this.pNext = pNext;
		this.encodeFeedbackFlags = encodeFeedbackFlags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkVideoEncodeFeedbackFlagBitsKHR : int32
{
	BitstreamBufferOffsetKHR = 1 << 0,
	BitstreamBytesWrittenKHR = 1 << 1,
	BitstreamHasOverridesKHR = 1 << 2,
}

typealias VkVideoEncodeFeedbackFlagsKHR = VkVideoEncodeFeedbackFlagBitsKHR;

[AllowDuplicates] enum VkVideoEncodeUsageFlagBitsKHR : int32
{
	DefaultKHR = 0,
	TranscodingKHR = 1 << 0,
	StreamingKHR = 1 << 1,
	RecordingKHR = 1 << 2,
	ConferencingKHR = 1 << 3,
}

typealias VkVideoEncodeUsageFlagsKHR = VkVideoEncodeUsageFlagBitsKHR;

[AllowDuplicates] enum VkVideoEncodeContentFlagBitsKHR : int32
{
	DefaultKHR = 0,
	CameraKHR = 1 << 0,
	DesktopKHR = 1 << 1,
	RenderedKHR = 1 << 2,
}

typealias VkVideoEncodeContentFlagsKHR = VkVideoEncodeContentFlagBitsKHR;

[AllowDuplicates] enum VkVideoEncodeTuningModeKHR : int32
{
	DefaultKHR = 0,
	HighQualityKHR = 1,
	LowLatencyKHR = 2,
	UltraLowLatencyKHR = 3,
	LosslessKHR = 4,
}

[CRepr] struct VkVideoEncodeUsageInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeUsageInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeUsageFlagsKHR videoUsageHints;
	public VkVideoEncodeContentFlagsKHR videoContentHints;
	public VkVideoEncodeTuningModeKHR tuningMode;

	public this(void* pNext = null, VkVideoEncodeUsageFlagsKHR videoUsageHints = 0, VkVideoEncodeContentFlagsKHR videoContentHints = 0, VkVideoEncodeTuningModeKHR tuningMode = 0)
	{
		this.pNext = pNext;
		this.videoUsageHints = videoUsageHints;
		this.videoContentHints = videoContentHints;
		this.tuningMode = tuningMode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkVideoEncodeRateControlFlagsKHR = VkFlags;

[AllowDuplicates] enum VkVideoEncodeRateControlModeFlagBitsKHR : int32
{
	DefaultKHR = 0,
	DisabledKHR = 1 << 0,
	CbrKHR = 1 << 1,
	VbrKHR = 1 << 2,
}

typealias VkVideoEncodeRateControlModeFlagsKHR = VkVideoEncodeRateControlModeFlagBitsKHR;

[CRepr] struct VkVideoEncodeRateControlInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeRateControlInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeRateControlFlagsKHR flags;
	public VkVideoEncodeRateControlModeFlagBitsKHR rateControlMode;
	public uint32 layerCount;
	public VkVideoEncodeRateControlLayerInfoKHR* pLayers;
	public VulkanSpan<VkVideoEncodeRateControlLayerInfoKHR> layers
	{
		[Inline] get => .(layerCount, pLayers);
		[Inline] set mut { layerCount = value.count; pLayers = value.ptr; }
	}
	public uint32 virtualBufferSizeInMs;
	public uint32 initialVirtualBufferSizeInMs;

	public this(void* pNext, VkVideoEncodeRateControlFlagsKHR flags, VkVideoEncodeRateControlModeFlagBitsKHR rateControlMode, VulkanSpan<VkVideoEncodeRateControlLayerInfoKHR> layers, uint32 virtualBufferSizeInMs, uint32 initialVirtualBufferSizeInMs) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.rateControlMode = rateControlMode;
		this.layers = layers;
		this.virtualBufferSizeInMs = virtualBufferSizeInMs;
		this.initialVirtualBufferSizeInMs = initialVirtualBufferSizeInMs;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeRateControlLayerInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeRateControlLayerInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 averageBitrate;
	public uint64 maxBitrate;
	public uint32 frameRateNumerator;
	public uint32 frameRateDenominator;

	public this(void* pNext, uint64 averageBitrate, uint64 maxBitrate, uint32 frameRateNumerator, uint32 frameRateDenominator)
	{
		this.pNext = pNext;
		this.averageBitrate = averageBitrate;
		this.maxBitrate = maxBitrate;
		this.frameRateNumerator = frameRateNumerator;
		this.frameRateDenominator = frameRateDenominator;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoProfileInfoKHR* pVideoProfile;
	public uint32 qualityLevel;

	public this(void* pNext, VkVideoProfileInfoKHR* pVideoProfile, uint32 qualityLevel)
	{
		this.pNext = pNext;
		this.pVideoProfile = pVideoProfile;
		this.qualityLevel = qualityLevel;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeQualityLevelPropertiesKHR
{
	public const VkStructureType SType = .VkVideoEncodeQualityLevelPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeRateControlModeFlagBitsKHR preferredRateControlMode;
	public uint32 preferredRateControlLayerCount;
}

[CRepr] struct VkVideoEncodeQualityLevelInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeQualityLevelInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 qualityLevel;

	public this(void* pNext, uint32 qualityLevel)
	{
		this.pNext = pNext;
		this.qualityLevel = qualityLevel;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeSessionParametersGetInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeSessionParametersGetInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoSessionParametersKHR videoSessionParameters;

	public this(void* pNext, VkVideoSessionParametersKHR videoSessionParameters)
	{
		this.pNext = pNext;
		this.videoSessionParameters = videoSessionParameters;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeSessionParametersFeedbackInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeSessionParametersFeedbackInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 hasOverrides;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* pQualityLevelInfo, out VkVideoEncodeQualityLevelPropertiesKHR pQualityLevelProperties);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetEncodedVideoSessionParametersKHR(VkDevice device, VkVideoEncodeSessionParametersGetInfoKHR* pVideoSessionParametersInfo, out VkVideoEncodeSessionParametersFeedbackInfoKHR pFeedbackInfo, out c_size pDataSize, out void pData);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdEncodeVideoKHR(VkCommandBuffer commandBuffer, VkVideoEncodeInfoKHR* pEncodeInfo);

static { public const uint32 VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION = 2; }
static { public const c_char* VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME = "VK_NV_device_diagnostics_config"; }

[CRepr] struct VkPhysicalDeviceDiagnosticsConfigFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceDiagnosticsConfigFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 diagnosticsConfig;

	public this(void* pNext, VkBool32 diagnosticsConfig)
	{
		this.pNext = pNext;
		this.diagnosticsConfig = diagnosticsConfig;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceDiagnosticsConfigCreateInfoNV
{
	public const VkStructureType SType = .VkDeviceDiagnosticsConfigCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceDiagnosticsConfigFlagsNV flags;

	public this(void* pNext = null, VkDeviceDiagnosticsConfigFlagsNV flags = 0)
	{
		this.pNext = pNext;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkDeviceDiagnosticsConfigFlagsNV = VkDeviceDiagnosticsConfigFlagBitsNV;

[AllowDuplicates] enum VkDeviceDiagnosticsConfigFlagBitsNV : int32
{
	EnableShaderDebugInfoNV = 1 << 0,
	EnableResourceTrackingNV = 1 << 1,
	EnableAutomaticCheckpointsNV = 1 << 2,
	EnableShaderErrorReportingNV = 1 << 3,
}

static { public const uint32 VK_QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION = 2; }
static { public const c_char* VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME = "VK_QCOM_render_pass_store_ops"; }
static { public const uint32 VK_NV_CUDA_KERNEL_LAUNCH_SPEC_VERSION = 2; }
static { public const c_char* VK_NV_CUDA_KERNEL_LAUNCH_EXTENSION_NAME = "VK_NV_cuda_kernel_launch"; }

class VkCudaModuleNV { private this() { } }
class VkCudaFunctionNV { private this() { } }

[CRepr] struct VkCudaModuleCreateInfoNV
{
	public const VkStructureType SType = .VkCudaModuleCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_size dataSize;
	public void* pData;

	public this(void* pNext, c_size dataSize, void* pData)
	{
		this.pNext = pNext;
		this.dataSize = dataSize;
		this.pData = pData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCudaFunctionCreateInfoNV
{
	public const VkStructureType SType = .VkCudaFunctionCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkCudaModuleNV module;
	public c_char* pName;

	public this(void* pNext, VkCudaModuleNV module, c_char* pName)
	{
		this.pNext = pNext;
		this.module = module;
		this.pName = pName;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCudaLaunchInfoNV
{
	public const VkStructureType SType = .VkCudaLaunchInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkCudaFunctionNV @function;
	public uint32 gridDimX;
	public uint32 gridDimY;
	public uint32 gridDimZ;
	public uint32 blockDimX;
	public uint32 blockDimY;
	public uint32 blockDimZ;
	public uint32 sharedMemBytes;
	public c_size paramCount;
	public void** pParams;
	public c_size extraCount;
	public void** pExtras;

	public this(void* pNext, VkCudaFunctionNV @function, uint32 gridDimX, uint32 gridDimY, uint32 gridDimZ, uint32 blockDimX, uint32 blockDimY, uint32 blockDimZ, uint32 sharedMemBytes, c_size paramCount, void** pParams, c_size extraCount, void** pExtras)
	{
		this.pNext = pNext;
		this.@function = @function;
		this.gridDimX = gridDimX;
		this.gridDimY = gridDimY;
		this.gridDimZ = gridDimZ;
		this.blockDimX = blockDimX;
		this.blockDimY = blockDimY;
		this.blockDimZ = blockDimZ;
		this.sharedMemBytes = sharedMemBytes;
		this.paramCount = paramCount;
		this.pParams = pParams;
		this.extraCount = extraCount;
		this.pExtras = pExtras;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceCudaKernelLaunchFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceCudaKernelLaunchFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 cudaKernelLaunchFeatures;

	public this(void* pNext, VkBool32 cudaKernelLaunchFeatures)
	{
		this.pNext = pNext;
		this.cudaKernelLaunchFeatures = cudaKernelLaunchFeatures;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceCudaKernelLaunchPropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceCudaKernelLaunchPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 computeCapabilityMinor;
	public uint32 computeCapabilityMajor;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateCudaModuleNV(VkDevice device, VkCudaModuleCreateInfoNV* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkCudaModuleNV pModule);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, out c_size pCacheSize, out void pCacheData);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateCudaFunctionNV(VkDevice device, VkCudaFunctionCreateInfoNV* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkCudaFunctionNV pFunction);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV @function, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, VkCudaLaunchInfoNV* pLaunchInfo);

static { public const uint32 VK_QCOM_TILE_SHADING_SPEC_VERSION = 1; }
static { public const c_char* VK_QCOM_TILE_SHADING_EXTENSION_NAME = "VK_QCOM_tile_shading"; }

[CRepr] struct VkPhysicalDeviceTileShadingFeaturesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceTileShadingFeaturesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 tileShading;
	public VkBool32 tileShadingFragmentStage;
	public VkBool32 tileShadingColorAttachments;
	public VkBool32 tileShadingDepthAttachments;
	public VkBool32 tileShadingStencilAttachments;
	public VkBool32 tileShadingInputAttachments;
	public VkBool32 tileShadingSampledAttachments;
	public VkBool32 tileShadingPerTileDraw;
	public VkBool32 tileShadingPerTileDispatch;
	public VkBool32 tileShadingDispatchTile;
	public VkBool32 tileShadingApron;
	public VkBool32 tileShadingAnisotropicApron;
	public VkBool32 tileShadingAtomicOps;
	public VkBool32 tileShadingImageProcessing;

	public this(void* pNext, VkBool32 tileShading, VkBool32 tileShadingFragmentStage, VkBool32 tileShadingColorAttachments, VkBool32 tileShadingDepthAttachments, VkBool32 tileShadingStencilAttachments, VkBool32 tileShadingInputAttachments, VkBool32 tileShadingSampledAttachments, VkBool32 tileShadingPerTileDraw, VkBool32 tileShadingPerTileDispatch, VkBool32 tileShadingDispatchTile, VkBool32 tileShadingApron, VkBool32 tileShadingAnisotropicApron, VkBool32 tileShadingAtomicOps, VkBool32 tileShadingImageProcessing)
	{
		this.pNext = pNext;
		this.tileShading = tileShading;
		this.tileShadingFragmentStage = tileShadingFragmentStage;
		this.tileShadingColorAttachments = tileShadingColorAttachments;
		this.tileShadingDepthAttachments = tileShadingDepthAttachments;
		this.tileShadingStencilAttachments = tileShadingStencilAttachments;
		this.tileShadingInputAttachments = tileShadingInputAttachments;
		this.tileShadingSampledAttachments = tileShadingSampledAttachments;
		this.tileShadingPerTileDraw = tileShadingPerTileDraw;
		this.tileShadingPerTileDispatch = tileShadingPerTileDispatch;
		this.tileShadingDispatchTile = tileShadingDispatchTile;
		this.tileShadingApron = tileShadingApron;
		this.tileShadingAnisotropicApron = tileShadingAnisotropicApron;
		this.tileShadingAtomicOps = tileShadingAtomicOps;
		this.tileShadingImageProcessing = tileShadingImageProcessing;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceTileShadingPropertiesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceTileShadingPropertiesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxApronSize;
	public VkBool32 preferNonCoherent;
	public VkExtent2D tileGranularity;
	public VkExtent2D maxTileShadingRate;
}

[CRepr] struct VkRenderPassTileShadingCreateInfoQCOM
{
	public const VkStructureType SType = .VkRenderPassTileShadingCreateInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTileShadingRenderPassFlagsQCOM flags;
	public VkExtent2D tileApronSize;

	public this(void* pNext = null, VkTileShadingRenderPassFlagsQCOM flags = 0, VkExtent2D tileApronSize = .())
	{
		this.pNext = pNext;
		this.flags = flags;
		this.tileApronSize = tileApronSize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPerTileBeginInfoQCOM
{
	public const VkStructureType SType = .VkPerTileBeginInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext;

	public this(void* pNext = null)
	{
		this.pNext = pNext;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPerTileEndInfoQCOM
{
	public const VkStructureType SType = .VkPerTileEndInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext;

	public this(void* pNext = null)
	{
		this.pNext = pNext;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDispatchTileInfoQCOM
{
	public const VkStructureType SType = .VkDispatchTileInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext;

	public this(void* pNext = null)
	{
		this.pNext = pNext;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkTileShadingRenderPassFlagsQCOM = VkTileShadingRenderPassFlagBitsQCOM;

[AllowDuplicates] enum VkTileShadingRenderPassFlagBitsQCOM : int32
{
	EnableQCOM = 1 << 0,
	PerTileExecutionQCOM = 1 << 1,
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDispatchTileQCOM(VkCommandBuffer commandBuffer, VkDispatchTileInfoQCOM* pDispatchTileInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBeginPerTileExecutionQCOM(VkCommandBuffer commandBuffer, VkPerTileBeginInfoQCOM* pPerTileBeginInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdEndPerTileExecutionQCOM(VkCommandBuffer commandBuffer, VkPerTileEndInfoQCOM* pPerTileEndInfo);

static { public const uint32 VK_NV_LOW_LATENCY_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_LOW_LATENCY_EXTENSION_NAME = "VK_NV_low_latency"; }

[CRepr] struct VkQueryLowLatencySupportNV
{
	public const VkStructureType SType = .VkQueryLowLatencySupportNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public void* pQueriedLowLatencyData;

	public this(void* pNext, void* pQueriedLowLatencyData)
	{
		this.pNext = pNext;
		this.pQueriedLowLatencyData = pQueriedLowLatencyData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_METAL_OBJECTS_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_METAL_OBJECTS_EXTENSION_NAME = "VK_EXT_metal_objects"; }

[AllowDuplicates] enum VkExportMetalObjectTypeFlagBitsEXT : int32
{
	MetalDeviceEXT = 1 << 0,
	MetalCommandQueueEXT = 1 << 1,
	MetalBufferEXT = 1 << 2,
	MetalTextureEXT = 1 << 3,
	MetalIosurfaceEXT = 1 << 4,
	MetalSharedEventEXT = 1 << 5,
}

typealias VkExportMetalObjectTypeFlagsEXT = VkExportMetalObjectTypeFlagBitsEXT;

[CRepr] struct VkExportMetalObjectCreateInfoEXT
{
	public const VkStructureType SType = .VkExportMetalObjectCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExportMetalObjectTypeFlagBitsEXT exportObjectType;

	public this(void* pNext = null, VkExportMetalObjectTypeFlagBitsEXT exportObjectType = 0)
	{
		this.pNext = pNext;
		this.exportObjectType = exportObjectType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExportMetalObjectsInfoEXT
{
	public const VkStructureType SType = .VkExportMetalObjectsInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;

	public this(void* pNext = null)
	{
		this.pNext = pNext;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExportMetalDeviceInfoEXT
{
	public const VkStructureType SType = .VkExportMetalDeviceInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public MTLDevice_id mtlDevice;

	public this(void* pNext, MTLDevice_id mtlDevice)
	{
		this.pNext = pNext;
		this.mtlDevice = mtlDevice;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExportMetalCommandQueueInfoEXT
{
	public const VkStructureType SType = .VkExportMetalCommandQueueInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkQueue queue;
	public MTLCommandQueue_id mtlCommandQueue;

	public this(void* pNext, VkQueue queue, MTLCommandQueue_id mtlCommandQueue)
	{
		this.pNext = pNext;
		this.queue = queue;
		this.mtlCommandQueue = mtlCommandQueue;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExportMetalBufferInfoEXT
{
	public const VkStructureType SType = .VkExportMetalBufferInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceMemory memory;
	public MTLBuffer_id mtlBuffer;

	public this(void* pNext, VkDeviceMemory memory, MTLBuffer_id mtlBuffer)
	{
		this.pNext = pNext;
		this.memory = memory;
		this.mtlBuffer = mtlBuffer;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImportMetalBufferInfoEXT
{
	public const VkStructureType SType = .VkImportMetalBufferInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public MTLBuffer_id mtlBuffer;

	public this(void* pNext, MTLBuffer_id mtlBuffer)
	{
		this.pNext = pNext;
		this.mtlBuffer = mtlBuffer;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExportMetalTextureInfoEXT
{
	public const VkStructureType SType = .VkExportMetalTextureInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImage image;
	public VkImageView imageView;
	public VkBufferView bufferView;
	public VkImageAspectFlagBits plane;
	public MTLTexture_id mtlTexture;

	public this(void* pNext, VkImage image, VkImageView imageView, VkBufferView bufferView, VkImageAspectFlagBits plane, MTLTexture_id mtlTexture)
	{
		this.pNext = pNext;
		this.image = image;
		this.imageView = imageView;
		this.bufferView = bufferView;
		this.plane = plane;
		this.mtlTexture = mtlTexture;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImportMetalTextureInfoEXT
{
	public const VkStructureType SType = .VkImportMetalTextureInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageAspectFlagBits plane;
	public MTLTexture_id mtlTexture;

	public this(void* pNext, VkImageAspectFlagBits plane, MTLTexture_id mtlTexture)
	{
		this.pNext = pNext;
		this.plane = plane;
		this.mtlTexture = mtlTexture;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExportMetalIOSurfaceInfoEXT
{
	public const VkStructureType SType = .VkExportMetalIoSurfaceInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImage image;
	public IOSurfaceRef ioSurface;

	public this(void* pNext, VkImage image, IOSurfaceRef ioSurface)
	{
		this.pNext = pNext;
		this.image = image;
		this.ioSurface = ioSurface;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImportMetalIOSurfaceInfoEXT
{
	public const VkStructureType SType = .VkImportMetalIoSurfaceInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public IOSurfaceRef ioSurface;

	public this(void* pNext = null, IOSurfaceRef ioSurface = null)
	{
		this.pNext = pNext;
		this.ioSurface = ioSurface;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExportMetalSharedEventInfoEXT
{
	public const VkStructureType SType = .VkExportMetalSharedEventInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSemaphore semaphore;
	public VkEvent event;
	public MTLSharedEvent_id mtlSharedEvent;

	public this(void* pNext, VkSemaphore semaphore, VkEvent event, MTLSharedEvent_id mtlSharedEvent)
	{
		this.pNext = pNext;
		this.semaphore = semaphore;
		this.event = event;
		this.mtlSharedEvent = mtlSharedEvent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImportMetalSharedEventInfoEXT
{
	public const VkStructureType SType = .VkImportMetalSharedEventInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public MTLSharedEvent_id mtlSharedEvent;

	public this(void* pNext, MTLSharedEvent_id mtlSharedEvent)
	{
		this.pNext = pNext;
		this.mtlSharedEvent = mtlSharedEvent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkExportMetalObjectsEXT(VkDevice device, out VkExportMetalObjectsInfoEXT pMetalObjectsInfo);

static { public const uint32 VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME = "VK_KHR_synchronization2"; }

typealias VkPipelineStageFlags2KHR = VkPipelineStageFlags2;
typealias VkPipelineStageFlagBits2KHR = VkPipelineStageFlagBits2;
typealias VkAccessFlags2KHR = VkAccessFlags2;
typealias VkAccessFlagBits2KHR = VkAccessFlagBits2;
typealias VkMemoryBarrier2KHR = VkMemoryBarrier2;
typealias VkBufferMemoryBarrier2KHR = VkBufferMemoryBarrier2;
typealias VkImageMemoryBarrier2KHR = VkImageMemoryBarrier2;
typealias VkDependencyInfoKHR = VkDependencyInfo;
typealias VkSubmitInfo2KHR = VkSubmitInfo2;
typealias VkSemaphoreSubmitInfoKHR = VkSemaphoreSubmitInfo;
typealias VkCommandBufferSubmitInfoKHR = VkCommandBufferSubmitInfo;
typealias VkSubmitFlagBitsKHR = VkSubmitFlagBits;
typealias VkSubmitFlagsKHR = VkSubmitFlags;
typealias VkPhysicalDeviceSynchronization2FeaturesKHR = VkPhysicalDeviceSynchronization2Features;

static { public const uint32 VK_EXT_DESCRIPTOR_BUFFER_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME = "VK_EXT_descriptor_buffer"; }

[CRepr] struct VkPhysicalDeviceDescriptorBufferPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceDescriptorBufferPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 combinedImageSamplerDescriptorSingleArray;
	public VkBool32 bufferlessPushDescriptors;
	public VkBool32 allowSamplerImageViewPostSubmitCreation;
	public VkDeviceSize descriptorBufferOffsetAlignment;
	public uint32 maxDescriptorBufferBindings;
	public uint32 maxResourceDescriptorBufferBindings;
	public uint32 maxSamplerDescriptorBufferBindings;
	public uint32 maxEmbeddedImmutableSamplerBindings;
	public uint32 maxEmbeddedImmutableSamplers;
	public c_size bufferCaptureReplayDescriptorDataSize;
	public c_size imageCaptureReplayDescriptorDataSize;
	public c_size imageViewCaptureReplayDescriptorDataSize;
	public c_size samplerCaptureReplayDescriptorDataSize;
	public c_size accelerationStructureCaptureReplayDescriptorDataSize;
	public c_size samplerDescriptorSize;
	public c_size combinedImageSamplerDescriptorSize;
	public c_size sampledImageDescriptorSize;
	public c_size storageImageDescriptorSize;
	public c_size uniformTexelBufferDescriptorSize;
	public c_size robustUniformTexelBufferDescriptorSize;
	public c_size storageTexelBufferDescriptorSize;
	public c_size robustStorageTexelBufferDescriptorSize;
	public c_size uniformBufferDescriptorSize;
	public c_size robustUniformBufferDescriptorSize;
	public c_size storageBufferDescriptorSize;
	public c_size robustStorageBufferDescriptorSize;
	public c_size inputAttachmentDescriptorSize;
	public c_size accelerationStructureDescriptorSize;
	public VkDeviceSize maxSamplerDescriptorBufferRange;
	public VkDeviceSize maxResourceDescriptorBufferRange;
	public VkDeviceSize samplerDescriptorBufferAddressSpaceSize;
	public VkDeviceSize resourceDescriptorBufferAddressSpaceSize;
	public VkDeviceSize descriptorBufferAddressSpaceSize;
}

[CRepr] struct VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_size combinedImageSamplerDensityMapDescriptorSize;
}

[CRepr] struct VkPhysicalDeviceDescriptorBufferFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceDescriptorBufferFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 descriptorBuffer;
	public VkBool32 descriptorBufferCaptureReplay;
	public VkBool32 descriptorBufferImageLayoutIgnored;
	public VkBool32 descriptorBufferPushDescriptors;

	public this(void* pNext, VkBool32 descriptorBuffer, VkBool32 descriptorBufferCaptureReplay, VkBool32 descriptorBufferImageLayoutIgnored, VkBool32 descriptorBufferPushDescriptors)
	{
		this.pNext = pNext;
		this.descriptorBuffer = descriptorBuffer;
		this.descriptorBufferCaptureReplay = descriptorBufferCaptureReplay;
		this.descriptorBufferImageLayoutIgnored = descriptorBufferImageLayoutIgnored;
		this.descriptorBufferPushDescriptors = descriptorBufferPushDescriptors;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDescriptorAddressInfoEXT
{
	public const VkStructureType SType = .VkDescriptorAddressInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceAddress address;
	public VkDeviceSize range;
	public VkFormat format;

	public this(void* pNext, VkDeviceAddress address, VkDeviceSize range, VkFormat format)
	{
		this.pNext = pNext;
		this.address = address;
		this.range = range;
		this.format = format;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDescriptorBufferBindingInfoEXT
{
	public const VkStructureType SType = .VkDescriptorBufferBindingInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceAddress address;
	public VkBufferUsageFlags usage;

	public this(void* pNext, VkDeviceAddress address, VkBufferUsageFlags usage = 0)
	{
		this.pNext = pNext;
		this.address = address;
		this.usage = usage;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDescriptorBufferBindingPushDescriptorBufferHandleEXT
{
	public const VkStructureType SType = .VkDescriptorBufferBindingPushDescriptorBufferHandleEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBuffer buffer;

	public this(void* pNext, VkBuffer buffer)
	{
		this.pNext = pNext;
		this.buffer = buffer;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[Union, CRepr] struct VkDescriptorDataEXT
{
	public VkSampler* pSampler;
	public VkDescriptorImageInfo* pCombinedImageSampler;
	public VkDescriptorImageInfo* pInputAttachmentImage;
	public VkDescriptorImageInfo* pSampledImage;
	public VkDescriptorImageInfo* pStorageImage;
	public VkDescriptorAddressInfoEXT* pUniformTexelBuffer;
	public VkDescriptorAddressInfoEXT* pStorageTexelBuffer;
	public VkDescriptorAddressInfoEXT* pUniformBuffer;
	public VkDescriptorAddressInfoEXT* pStorageBuffer;
	public VkDeviceAddress accelerationStructure;
}

[CRepr] struct VkDescriptorGetInfoEXT
{
	public const VkStructureType SType = .VkDescriptorGetInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDescriptorType type;
	public VkDescriptorDataEXT data;

	public this(void* pNext, VkDescriptorType type, VkDescriptorDataEXT data)
	{
		this.pNext = pNext;
		this.type = type;
		this.data = data;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBufferCaptureDescriptorDataInfoEXT
{
	public const VkStructureType SType = .VkBufferCaptureDescriptorDataInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkBuffer buffer;

	public this(void* pNext, VkBuffer buffer)
	{
		this.pNext = pNext;
		this.buffer = buffer;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageCaptureDescriptorDataInfoEXT
{
	public const VkStructureType SType = .VkImageCaptureDescriptorDataInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkImage image;

	public this(void* pNext, VkImage image)
	{
		this.pNext = pNext;
		this.image = image;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageViewCaptureDescriptorDataInfoEXT
{
	public const VkStructureType SType = .VkImageViewCaptureDescriptorDataInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkImageView imageView;

	public this(void* pNext, VkImageView imageView)
	{
		this.pNext = pNext;
		this.imageView = imageView;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSamplerCaptureDescriptorDataInfoEXT
{
	public const VkStructureType SType = .VkSamplerCaptureDescriptorDataInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
#unwarn
	public using public VkSampler sampler;

	public this(void* pNext, VkSampler sampler)
	{
		this.pNext = pNext;
		this.sampler = sampler;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkOpaqueCaptureDescriptorDataCreateInfoEXT
{
	public const VkStructureType SType = .VkOpaqueCaptureDescriptorDataCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public void* opaqueCaptureDescriptorData;

	public this(void* pNext, void* opaqueCaptureDescriptorData)
	{
		this.pNext = pNext;
		this.opaqueCaptureDescriptorData = opaqueCaptureDescriptorData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout, out VkDeviceSize pLayoutSizeInBytes);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32 binding, out VkDeviceSize pOffset);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDescriptorEXT(VkDevice device, VkDescriptorGetInfoEXT* pDescriptorInfo, c_size dataSize, out void pDescriptor);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32 bufferCount, VkDescriptorBufferBindingInfoEXT* pBindingInfos);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32 firstSet, uint32 setCount, uint32* pBufferIndices, VkDeviceSize* pOffsets);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32 set);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device, VkBufferCaptureDescriptorDataInfoEXT* pInfo, out void pData);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, VkImageCaptureDescriptorDataInfoEXT* pInfo, out void pData);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, VkImageViewCaptureDescriptorDataInfoEXT* pInfo, out void pData);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, VkSamplerCaptureDescriptorDataInfoEXT* pInfo, out void pData);

[CRepr] struct VkAccelerationStructureCaptureDescriptorDataInfoEXT
{
	public const VkStructureType SType = .VkAccelerationStructureCaptureDescriptorDataInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAccelerationStructureKHR accelerationStructure;
	public VkAccelerationStructureNV accelerationStructureNV;

	public this(void* pNext = null, VkAccelerationStructureKHR accelerationStructure = null, VkAccelerationStructureNV accelerationStructureNV = null)
	{
		this.pNext = pNext;
		this.accelerationStructure = accelerationStructure;
		this.accelerationStructureNV = accelerationStructureNV;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(VkDevice device, VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo, out void pData);

static { public const uint32 VK_EXT_GRAPHICS_PIPELINE_LIBRARY_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME = "VK_EXT_graphics_pipeline_library"; }

[CRepr] struct VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 graphicsPipelineLibrary;

	public this(void* pNext, VkBool32 graphicsPipelineLibrary)
	{
		this.pNext = pNext;
		this.graphicsPipelineLibrary = graphicsPipelineLibrary;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 graphicsPipelineLibraryFastLinking;
	public VkBool32 graphicsPipelineLibraryIndependentInterpolationDecoration;
}

[CRepr] struct VkGraphicsPipelineLibraryCreateInfoEXT
{
	public const VkStructureType SType = .VkGraphicsPipelineLibraryCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkGraphicsPipelineLibraryFlagsEXT flags;

	public this(void* pNext, VkGraphicsPipelineLibraryFlagsEXT flags)
	{
		this.pNext = pNext;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkGraphicsPipelineLibraryFlagBitsEXT : int32
{
	VertexInputInterfaceEXT = 1 << 0,
	PreRasterizationShadersEXT = 1 << 1,
	FragmentShaderEXT = 1 << 2,
	FragmentOutputInterfaceEXT = 1 << 3,
}

typealias VkGraphicsPipelineLibraryFlagsEXT = VkGraphicsPipelineLibraryFlagBitsEXT;

[AllowDuplicates] enum VkPipelineLayoutCreateFlagBits : int32
{
	IndependentSetsEXT = 1 << 1,
}

static { public const uint32 VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME = "VK_AMD_shader_early_and_late_fragment_tests"; }

[CRepr] struct VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderEarlyAndLateFragmentTests;

	public this(void* pNext, VkBool32 shaderEarlyAndLateFragmentTests)
	{
		this.pNext = pNext;
		this.shaderEarlyAndLateFragmentTests = shaderEarlyAndLateFragmentTests;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = "VK_KHR_fragment_shader_barycentric"; }

[CRepr] struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 fragmentShaderBarycentric;

	public this(void* pNext, VkBool32 fragmentShaderBarycentric)
	{
		this.pNext = pNext;
		this.fragmentShaderBarycentric = fragmentShaderBarycentric;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 triStripVertexOrderIndependentOfProvokingVertex;
}

static { public const uint32 VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME = "VK_KHR_shader_subgroup_uniform_control_flow"; }

[CRepr] struct VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderSubgroupUniformControlFlow;

	public this(void* pNext, VkBool32 shaderSubgroupUniformControlFlow)
	{
		this.pNext = pNext;
		this.shaderSubgroupUniformControlFlow = shaderSubgroupUniformControlFlow;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME = "VK_KHR_zero_initialize_workgroup_memory"; }

typealias VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;

static { public const uint32 VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME = "VK_NV_fragment_shading_rate_enums"; }

[CRepr] struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 fragmentShadingRateEnums;
	public VkBool32 supersampleFragmentShadingRates;
	public VkBool32 noInvocationFragmentShadingRates;

	public this(void* pNext, VkBool32 fragmentShadingRateEnums, VkBool32 supersampleFragmentShadingRates, VkBool32 noInvocationFragmentShadingRates)
	{
		this.pNext = pNext;
		this.fragmentShadingRateEnums = fragmentShadingRateEnums;
		this.supersampleFragmentShadingRates = supersampleFragmentShadingRates;
		this.noInvocationFragmentShadingRates = noInvocationFragmentShadingRates;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSampleCountFlagBits maxFragmentShadingRateInvocationCount;
}

[CRepr] struct VkPipelineFragmentShadingRateEnumStateCreateInfoNV
{
	public const VkStructureType SType = .VkPipelineFragmentShadingRateEnumStateCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFragmentShadingRateTypeNV shadingRateType;
	public VkFragmentShadingRateNV shadingRate;
	public VkFragmentShadingRateCombinerOpKHR[2] combinerOps;

	public this(void* pNext, VkFragmentShadingRateTypeNV shadingRateType, VkFragmentShadingRateNV shadingRate, VkFragmentShadingRateCombinerOpKHR[2] combinerOps)
	{
		this.pNext = pNext;
		this.shadingRateType = shadingRateType;
		this.shadingRate = shadingRate;
		this.combinerOps = combinerOps;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkFragmentShadingRateNV : int32
{
	VK_1InvocationPerPixelNV = 0,
	VK_1InvocationPer1x2PixelsNV = 1,
	VK_1InvocationPer2x1PixelsNV = 4,
	VK_1InvocationPer2x2PixelsNV = 5,
	VK_1InvocationPer2x4PixelsNV = 6,
	VK_1InvocationPer4x2PixelsNV = 9,
	VK_1InvocationPer4x4PixelsNV = 10,
	VK_2InvocationsPerPixelNV = 11,
	VK_4InvocationsPerPixelNV = 12,
	VK_8InvocationsPerPixelNV = 13,
	VK_16InvocationsPerPixelNV = 14,
	NoInvocationsNV = 15,
}

[AllowDuplicates] enum VkFragmentShadingRateTypeNV : int32
{
	FragmentSizeNV = 0,
	EnumsNV = 1,
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, VkFragmentShadingRateCombinerOpKHR[2] combinerOps);

static { public const uint32 VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME = "VK_NV_ray_tracing_motion_blur"; }

[CRepr] struct VkAccelerationStructureGeometryMotionTrianglesDataNV
{
	public const VkStructureType SType = .VkAccelerationStructureGeometryMotionTrianglesDataNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceOrHostAddressConstKHR vertexData;

	public this(void* pNext, VkDeviceOrHostAddressConstKHR vertexData)
	{
		this.pNext = pNext;
		this.vertexData = vertexData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAccelerationStructureMotionInfoNV
{
	public const VkStructureType SType = .VkAccelerationStructureMotionInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxInstances;
	public VkAccelerationStructureMotionInfoFlagsNV flags;

	public this(void* pNext, uint32 maxInstances, VkAccelerationStructureMotionInfoFlagsNV flags = 0)
	{
		this.pNext = pNext;
		this.maxInstances = maxInstances;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAccelerationStructureMotionInstanceNV
{
	public VkAccelerationStructureMotionInstanceTypeNV type;
	public VkAccelerationStructureMotionInstanceFlagsNV flags;
	public VkAccelerationStructureMotionInstanceDataNV data;

	public this(VkAccelerationStructureMotionInstanceTypeNV type, VkAccelerationStructureMotionInstanceFlagsNV flags, VkAccelerationStructureMotionInstanceDataNV data)
	{
		this.type = type;
		this.flags = flags;
		this.data = data;
	}

	public this()
	{
		this = default;
	}
}

[Union, CRepr] struct VkAccelerationStructureMotionInstanceDataNV
{
	public VkAccelerationStructureInstanceKHR staticInstance;
	public VkAccelerationStructureMatrixMotionInstanceNV matrixMotionInstance;
	public VkAccelerationStructureSRTMotionInstanceNV srtMotionInstance;
}

[CRepr] struct VkAccelerationStructureMatrixMotionInstanceNV
{
	// The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.
	public VkTransformMatrixKHR transformT0;
	public VkTransformMatrixKHR transformT1;
	[Bitfield(.Public, .Bits(24), "instanceCustomIndex")]
	[Bitfield(.Public, .Bits(8), "mask")]
	private uint32 __bitfields_mask;
	[Bitfield(.Public, .Bits(24), "instanceShaderBindingTableRecordOffset")]
	[Bitfield(.Public, .Bits(8), "flags")]
	private uint32 __bitfields_flags;
	public uint64 accelerationStructureReference;

	public this(VkTransformMatrixKHR transformT0, VkTransformMatrixKHR transformT1, uint32 instanceCustomIndex, uint32 mask, uint32 instanceShaderBindingTableRecordOffset, VkGeometryInstanceFlagsKHR flags, uint64 accelerationStructureReference) : this()
	{
		this.transformT0 = transformT0;
		this.transformT1 = transformT1;
		this.instanceCustomIndex = instanceCustomIndex;
		this.mask = mask;
		this.instanceShaderBindingTableRecordOffset = instanceShaderBindingTableRecordOffset;
		this.flags = (.)flags;
		this.accelerationStructureReference = accelerationStructureReference;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkAccelerationStructureSRTMotionInstanceNV
{
	// The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.
	public VkSRTDataNV transformT0;
	public VkSRTDataNV transformT1;
	[Bitfield(.Public, .Bits(24), "instanceCustomIndex")]
	[Bitfield(.Public, .Bits(8), "mask")]
	private uint32 __bitfields_mask;
	[Bitfield(.Public, .Bits(24), "instanceShaderBindingTableRecordOffset")]
	[Bitfield(.Public, .Bits(8), "flags")]
	private uint32 __bitfields_flags;
	public uint64 accelerationStructureReference;

	public this(VkSRTDataNV transformT0, VkSRTDataNV transformT1, uint32 instanceCustomIndex, uint32 mask, uint32 instanceShaderBindingTableRecordOffset, VkGeometryInstanceFlagsKHR flags, uint64 accelerationStructureReference) : this()
	{
		this.transformT0 = transformT0;
		this.transformT1 = transformT1;
		this.instanceCustomIndex = instanceCustomIndex;
		this.mask = mask;
		this.instanceShaderBindingTableRecordOffset = instanceShaderBindingTableRecordOffset;
		this.flags = (.)flags;
		this.accelerationStructureReference = accelerationStructureReference;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkSRTDataNV
{
	public float sx;
	public float a;
	public float b;
	public float pvx;
	public float sy;
	public float c;
	public float pvy;
	public float sz;
	public float pvz;
	public float qx;
	public float qy;
	public float qz;
	public float qw;
	public float tx;
	public float ty;
	public float tz;

	public this(float sx, float a, float b, float pvx, float sy, float c, float pvy, float sz, float pvz, float qx, float qy, float qz, float qw, float tx, float ty, float tz)
	{
		this.sx = sx;
		this.a = a;
		this.b = b;
		this.pvx = pvx;
		this.sy = sy;
		this.c = c;
		this.pvy = pvy;
		this.sz = sz;
		this.pvz = pvz;
		this.qx = qx;
		this.qy = qy;
		this.qz = qz;
		this.qw = qw;
		this.tx = tx;
		this.ty = ty;
		this.tz = tz;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkAccelerationStructureMotionInstanceTypeNV : int32
{
	StaticNV = 0,
	MatrixMotionNV = 1,
	SrtMotionNV = 2,
}

[CRepr] struct VkPhysicalDeviceRayTracingMotionBlurFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceRayTracingMotionBlurFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 rayTracingMotionBlur;
	public VkBool32 rayTracingMotionBlurPipelineTraceRaysIndirect;

	public this(void* pNext, VkBool32 rayTracingMotionBlur, VkBool32 rayTracingMotionBlurPipelineTraceRaysIndirect)
	{
		this.pNext = pNext;
		this.rayTracingMotionBlur = rayTracingMotionBlur;
		this.rayTracingMotionBlurPipelineTraceRaysIndirect = rayTracingMotionBlurPipelineTraceRaysIndirect;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkAccelerationStructureMotionInfoFlagsNV = VkFlags;
typealias VkAccelerationStructureMotionInstanceFlagsNV = VkFlags;

static { public const uint32 VK_EXT_MESH_SHADER_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_MESH_SHADER_EXTENSION_NAME = "VK_EXT_mesh_shader"; }

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32 groupCountX, uint32 groupCountY, uint32 groupCountZ);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32 drawCount, uint32 stride);

[CRepr] struct VkPhysicalDeviceMeshShaderFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceMeshShaderFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 taskShader;
	public VkBool32 meshShader;
	public VkBool32 multiviewMeshShader;
	public VkBool32 primitiveFragmentShadingRateMeshShader;
	public VkBool32 meshShaderQueries;

	public this(void* pNext, VkBool32 taskShader, VkBool32 meshShader, VkBool32 multiviewMeshShader, VkBool32 primitiveFragmentShadingRateMeshShader, VkBool32 meshShaderQueries)
	{
		this.pNext = pNext;
		this.taskShader = taskShader;
		this.meshShader = meshShader;
		this.multiviewMeshShader = multiviewMeshShader;
		this.primitiveFragmentShadingRateMeshShader = primitiveFragmentShadingRateMeshShader;
		this.meshShaderQueries = meshShaderQueries;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceMeshShaderPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceMeshShaderPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxTaskWorkGroupTotalCount;
	public uint32[3] maxTaskWorkGroupCount;
	public uint32 maxTaskWorkGroupInvocations;
	public uint32[3] maxTaskWorkGroupSize;
	public uint32 maxTaskPayloadSize;
	public uint32 maxTaskSharedMemorySize;
	public uint32 maxTaskPayloadAndSharedMemorySize;
	public uint32 maxMeshWorkGroupTotalCount;
	public uint32[3] maxMeshWorkGroupCount;
	public uint32 maxMeshWorkGroupInvocations;
	public uint32[3] maxMeshWorkGroupSize;
	public uint32 maxMeshSharedMemorySize;
	public uint32 maxMeshPayloadAndSharedMemorySize;
	public uint32 maxMeshOutputMemorySize;
	public uint32 maxMeshPayloadAndOutputMemorySize;
	public uint32 maxMeshOutputComponents;
	public uint32 maxMeshOutputVertices;
	public uint32 maxMeshOutputPrimitives;
	public uint32 maxMeshOutputLayers;
	public uint32 maxMeshMultiviewViewCount;
	public uint32 meshOutputPerVertexGranularity;
	public uint32 meshOutputPerPrimitiveGranularity;
	public uint32 maxPreferredTaskWorkGroupInvocations;
	public uint32 maxPreferredMeshWorkGroupInvocations;
	public VkBool32 prefersLocalInvocationVertexOutput;
	public VkBool32 prefersLocalInvocationPrimitiveOutput;
	public VkBool32 prefersCompactVertexOutput;
	public VkBool32 prefersCompactPrimitiveOutput;
}

[CRepr] struct VkDrawMeshTasksIndirectCommandEXT
{
	public uint32 groupCountX;
	public uint32 groupCountY;
	public uint32 groupCountZ;

	public this(uint32 groupCountX, uint32 groupCountY, uint32 groupCountZ)
	{
		this.groupCountX = groupCountX;
		this.groupCountY = groupCountY;
		this.groupCountZ = groupCountZ;
	}

	public this()
	{
		this = default;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32 maxDrawCount, uint32 stride);

static { public const uint32 VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME = "VK_EXT_ycbcr_2plane_444_formats"; }

[CRepr] struct VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 ycbcr2plane444Formats;

	public this(void* pNext, VkBool32 ycbcr2plane444Formats)
	{
		this.pNext = pNext;
		this.ycbcr2plane444Formats = ycbcr2plane444Formats;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME = "VK_EXT_fragment_density_map2"; }

[CRepr] struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentDensityMap2FeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 fragmentDensityMapDeferred;

	public this(void* pNext, VkBool32 fragmentDensityMapDeferred)
	{
		this.pNext = pNext;
		this.fragmentDensityMapDeferred = fragmentDensityMapDeferred;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentDensityMap2PropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 subsampledLoads;
	public VkBool32 subsampledCoarseReconstructionEarlyAccess;
	public uint32 maxSubsampledArrayLayers;
	public uint32 maxDescriptorSetSubsampledSamplers;
}

static { public const uint32 VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION = 2; }
static { public const c_char* VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME = "VK_QCOM_rotated_copy_commands"; }

[CRepr] struct VkCopyCommandTransformInfoQCOM
{
	public const VkStructureType SType = .VkCopyCommandTransformInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSurfaceTransformFlagBitsKHR transform;

	public this(void* pNext, VkSurfaceTransformFlagBitsKHR transform)
	{
		this.pNext = pNext;
		this.transform = transform;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME = "VK_EXT_image_robustness"; }

typealias VkPhysicalDeviceImageRobustnessFeaturesEXT = VkPhysicalDeviceImageRobustnessFeatures;

static { public const uint32 VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME = "VK_KHR_workgroup_memory_explicit_layout"; }

[CRepr] struct VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 workgroupMemoryExplicitLayout;
	public VkBool32 workgroupMemoryExplicitLayoutScalarBlockLayout;
	public VkBool32 workgroupMemoryExplicitLayout8BitAccess;
	public VkBool32 workgroupMemoryExplicitLayout16BitAccess;

	public this(void* pNext, VkBool32 workgroupMemoryExplicitLayout, VkBool32 workgroupMemoryExplicitLayoutScalarBlockLayout, VkBool32 workgroupMemoryExplicitLayout8BitAccess, VkBool32 workgroupMemoryExplicitLayout16BitAccess)
	{
		this.pNext = pNext;
		this.workgroupMemoryExplicitLayout = workgroupMemoryExplicitLayout;
		this.workgroupMemoryExplicitLayoutScalarBlockLayout = workgroupMemoryExplicitLayoutScalarBlockLayout;
		this.workgroupMemoryExplicitLayout8BitAccess = workgroupMemoryExplicitLayout8BitAccess;
		this.workgroupMemoryExplicitLayout16BitAccess = workgroupMemoryExplicitLayout16BitAccess;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_COPY_COMMANDS_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME = "VK_KHR_copy_commands2"; }

typealias VkCopyBufferInfo2KHR = VkCopyBufferInfo2;
typealias VkCopyImageInfo2KHR = VkCopyImageInfo2;
typealias VkCopyBufferToImageInfo2KHR = VkCopyBufferToImageInfo2;
typealias VkCopyImageToBufferInfo2KHR = VkCopyImageToBufferInfo2;
typealias VkBlitImageInfo2KHR = VkBlitImageInfo2;
typealias VkResolveImageInfo2KHR = VkResolveImageInfo2;
typealias VkBufferCopy2KHR = VkBufferCopy2;
typealias VkImageCopy2KHR = VkImageCopy2;
typealias VkImageBlit2KHR = VkImageBlit2;
typealias VkBufferImageCopy2KHR = VkBufferImageCopy2;
typealias VkImageResolve2KHR = VkImageResolve2;

static { public const uint32 VK_EXT_IMAGE_COMPRESSION_CONTROL_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME = "VK_EXT_image_compression_control"; }

[CRepr] struct VkPhysicalDeviceImageCompressionControlFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceImageCompressionControlFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 imageCompressionControl;

	public this(void* pNext, VkBool32 imageCompressionControl)
	{
		this.pNext = pNext;
		this.imageCompressionControl = imageCompressionControl;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageCompressionControlEXT
{
	public const VkStructureType SType = .VkImageCompressionControlEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageCompressionFlagsEXT flags;
	public uint32 compressionControlPlaneCount;
	public VkImageCompressionFixedRateFlagsEXT* pFixedRateFlags;
	public VulkanSpan<VkImageCompressionFixedRateFlagsEXT> fixedRateFlags
	{
		[Inline] get => .(compressionControlPlaneCount, pFixedRateFlags);
		[Inline] set mut { compressionControlPlaneCount = value.count; pFixedRateFlags = value.ptr; }
	}

	public this(void* pNext, VkImageCompressionFlagsEXT flags, VulkanSpan<VkImageCompressionFixedRateFlagsEXT> fixedRateFlags = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.fixedRateFlags = fixedRateFlags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageCompressionPropertiesEXT
{
	public const VkStructureType SType = .VkImageCompressionPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageCompressionFlagsEXT imageCompressionFlags;
	public VkImageCompressionFixedRateFlagsEXT imageCompressionFixedRateFlags;
}

[AllowDuplicates] enum VkImageCompressionFlagBitsEXT : int32
{
	DefaultEXT = 0,
	FixedRateDefaultEXT = 1 << 0,
	FixedRateExplicitEXT = 1 << 1,
	DisabledEXT = 1 << 2,
}

typealias VkImageCompressionFlagsEXT = VkImageCompressionFlagBitsEXT;

[AllowDuplicates] enum VkImageCompressionFixedRateFlagBitsEXT : int32
{
	NoneEXT = 0,
	VK_1bpcEXT = 1 << 0,
	VK_2bpcEXT = 1 << 1,
	VK_3bpcEXT = 1 << 2,
	VK_4bpcEXT = 1 << 3,
	VK_5bpcEXT = 1 << 4,
	VK_6bpcEXT = 1 << 5,
	VK_7bpcEXT = 1 << 6,
	VK_8bpcEXT = 1 << 7,
	VK_9bpcEXT = 1 << 8,
	VK_10bpcEXT = 1 << 9,
	VK_11bpcEXT = 1 << 10,
	VK_12bpcEXT = 1 << 11,
	VK_13bpcEXT = 1 << 12,
	VK_14bpcEXT = 1 << 13,
	VK_15bpcEXT = 1 << 14,
	VK_16bpcEXT = 1 << 15,
	VK_17bpcEXT = 1 << 16,
	VK_18bpcEXT = 1 << 17,
	VK_19bpcEXT = 1 << 18,
	VK_20bpcEXT = 1 << 19,
	VK_21bpcEXT = 1 << 20,
	VK_22bpcEXT = 1 << 21,
	VK_23bpcEXT = 1 << 22,
	VK_24bpcEXT = 1 << 23,
}

typealias VkImageCompressionFixedRateFlagsEXT = VkImageCompressionFixedRateFlagBitsEXT;

static { public const uint32 VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME = "VK_EXT_attachment_feedback_loop_layout"; }

[CRepr] struct VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 attachmentFeedbackLoopLayout;

	public this(void* pNext, VkBool32 attachmentFeedbackLoopLayout)
	{
		this.pNext = pNext;
		this.attachmentFeedbackLoopLayout = attachmentFeedbackLoopLayout;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_4444_FORMATS_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_4444_FORMATS_EXTENSION_NAME = "VK_EXT_4444_formats"; }

[CRepr] struct VkPhysicalDevice4444FormatsFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDevice4444FormatsFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 formatA4R4G4B4;
	public VkBool32 formatA4B4G4R4;

	public this(void* pNext, VkBool32 formatA4R4G4B4, VkBool32 formatA4B4G4R4)
	{
		this.pNext = pNext;
		this.formatA4R4G4B4 = formatA4R4G4B4;
		this.formatA4B4G4R4 = formatA4B4G4R4;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_DEVICE_FAULT_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_DEVICE_FAULT_EXTENSION_NAME = "VK_EXT_device_fault"; }

[CRepr] struct VkPhysicalDeviceFaultFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceFaultFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 deviceFault;
	public VkBool32 deviceFaultVendorBinary;

	public this(void* pNext, VkBool32 deviceFault, VkBool32 deviceFaultVendorBinary)
	{
		this.pNext = pNext;
		this.deviceFault = deviceFault;
		this.deviceFaultVendorBinary = deviceFaultVendorBinary;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceFaultCountsEXT
{
	public const VkStructureType SType = .VkDeviceFaultCountsEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 addressInfoCount;
	public uint32 vendorInfoCount;
	public VkDeviceSize vendorBinarySize; // Specified in bytes

	public this(void* pNext = null, uint32 addressInfoCount = 0, uint32 vendorInfoCount = 0, VkDeviceSize vendorBinarySize = 0)
	{
		this.pNext = pNext;
		this.addressInfoCount = addressInfoCount;
		this.vendorInfoCount = vendorInfoCount;
		this.vendorBinarySize = vendorBinarySize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceFaultInfoEXT
{
	public const VkStructureType SType = .VkDeviceFaultInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_char[VK_MAX_DESCRIPTION_SIZE] description; // Free-form description of the fault
	public VkDeviceFaultAddressInfoEXT* pAddressInfos;
	public VkDeviceFaultVendorInfoEXT* pVendorInfos;
	public void* pVendorBinaryData;
}

[CRepr] struct VkDeviceFaultAddressInfoEXT
{
	public VkDeviceFaultAddressTypeEXT addressType;
	public VkDeviceAddress reportedAddress;
	public VkDeviceSize addressPrecision;

	public this(VkDeviceFaultAddressTypeEXT addressType, VkDeviceAddress reportedAddress, VkDeviceSize addressPrecision)
	{
		this.addressType = addressType;
		this.reportedAddress = reportedAddress;
		this.addressPrecision = addressPrecision;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkDeviceFaultAddressTypeEXT : int32
{
	NoneEXT = 0, // Currently unused
	ReadInvalidEXT = 1,
	WriteInvalidEXT = 2,
	ExecuteInvalidEXT = 3,
	InstructionPointerUnknownEXT = 4,
	InstructionPointerInvalidEXT = 5,
	InstructionPointerFaultEXT = 6,
}

[CRepr] struct VkDeviceFaultVendorInfoEXT
{
	public c_char[VK_MAX_DESCRIPTION_SIZE] description; // Free-form description of the fault
	public uint64 vendorFaultCode;
	public uint64 vendorFaultData;

	public this(c_char[VK_MAX_DESCRIPTION_SIZE] description, uint64 vendorFaultCode, uint64 vendorFaultData)
	{
		this.description = description;
		this.vendorFaultCode = vendorFaultCode;
		this.vendorFaultData = vendorFaultData;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkDeviceFaultVendorBinaryHeaderVersionEXT : int32
{
	OneEXT = 1,
}

[CRepr] struct VkDeviceFaultVendorBinaryHeaderVersionOneEXT
{
	// The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.
	public uint32 headerSize;
	public VkDeviceFaultVendorBinaryHeaderVersionEXT headerVersion;
	public uint32 vendorID;
	public uint32 deviceID;
	public uint32 driverVersion;
	public uint8[VK_UUID_SIZE] pipelineCacheUUID;
	public uint32 applicationNameOffset;
	public uint32 applicationVersion;
	public uint32 engineNameOffset;
	public uint32 engineVersion;
	public uint32 apiVersion;

	public this(uint32 headerSize, VkDeviceFaultVendorBinaryHeaderVersionEXT headerVersion, uint32 vendorID, uint32 deviceID, uint32 driverVersion, uint8[VK_UUID_SIZE] pipelineCacheUUID, uint32 applicationNameOffset, uint32 applicationVersion, uint32 engineNameOffset, uint32 engineVersion, uint32 apiVersion)
	{
		this.headerSize = headerSize;
		this.headerVersion = headerVersion;
		this.vendorID = vendorID;
		this.deviceID = deviceID;
		this.driverVersion = driverVersion;
		this.pipelineCacheUUID = pipelineCacheUUID;
		this.applicationNameOffset = applicationNameOffset;
		this.applicationVersion = applicationVersion;
		this.engineNameOffset = engineNameOffset;
		this.engineVersion = engineVersion;
		this.apiVersion = apiVersion;
	}

	public this()
	{
		this = default;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDeviceFaultInfoEXT(VkDevice device, out VkDeviceFaultCountsEXT pFaultCounts, out VkDeviceFaultInfoEXT pFaultInfo);

static { public const uint32 VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION = 1; }
static { public const c_char* VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME = "VK_ARM_rasterization_order_attachment_access"; }

typealias VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;

static { public const uint32 VK_EXT_RGBA10X6_FORMATS_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME = "VK_EXT_rgba10x6_formats"; }

[CRepr] struct VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceRgba10x6FormatsFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 formatRgba10x6WithoutYCbCrSampler;

	public this(void* pNext, VkBool32 formatRgba10x6WithoutYCbCrSampler)
	{
		this.pNext = pNext;
		this.formatRgba10x6WithoutYCbCrSampler = formatRgba10x6WithoutYCbCrSampler;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_ACQUIRE_WINRT_DISPLAY_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME = "VK_NV_acquire_winrt_display"; }

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkAcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32 deviceRelativeId, out VkDisplayKHR pDisplay);

static { public const uint32 VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME = "VK_EXT_directfb_surface"; }

typealias VkDirectFBSurfaceCreateFlagsEXT = VkFlags;

[CRepr] struct VkDirectFBSurfaceCreateInfoEXT
{
	public const VkStructureType SType = .VkDirectfbSurfaceCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDirectFBSurfaceCreateFlagsEXT flags;
	public IDirectFB* dfb;
	public IDirectFBSurface* surface;

	public this(void* pNext, VkDirectFBSurfaceCreateFlagsEXT flags, IDirectFB* dfb, IDirectFBSurface* surface)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.dfb = dfb;
		this.surface = surface;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateDirectFBSurfaceEXT(VkInstance instance, VkDirectFBSurfaceCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);
[CallingConvention(VKAPI_PTR)] function VkBool32 PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice, uint32 queueFamilyIndex, out IDirectFB dfb);

static { public const uint32 VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION = 1; }
static { public const c_char* VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME = "VK_VALVE_mutable_descriptor_type"; }

typealias VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE = VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT;
typealias VkMutableDescriptorTypeListVALVE = VkMutableDescriptorTypeListEXT;
typealias VkMutableDescriptorTypeCreateInfoVALVE = VkMutableDescriptorTypeCreateInfoEXT;

static { public const uint32 VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME = "VK_EXT_vertex_input_dynamic_state"; }

[CRepr] struct VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 vertexInputDynamicState;

	public this(void* pNext, VkBool32 vertexInputDynamicState)
	{
		this.pNext = pNext;
		this.vertexInputDynamicState = vertexInputDynamicState;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVertexInputBindingDescription2EXT
{
	public const VkStructureType SType = .VkVertexInputBindingDescription2EXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 binding;
	public uint32 stride;
	public VkVertexInputRate inputRate;
	public uint32 divisor;

	public this(void* pNext, uint32 binding, uint32 stride, VkVertexInputRate inputRate, uint32 divisor)
	{
		this.pNext = pNext;
		this.binding = binding;
		this.stride = stride;
		this.inputRate = inputRate;
		this.divisor = divisor;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVertexInputAttributeDescription2EXT
{
	public const VkStructureType SType = .VkVertexInputAttributeDescription2EXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 location; // location of the shader vertex attrib
	public uint32 binding; // Vertex buffer binding id
	public VkFormat format; // format of source data
	public uint32 offset; // Offset of first element in bytes from base of vertex

	public this(void* pNext, uint32 location, uint32 binding, VkFormat format, uint32 offset)
	{
		this.pNext = pNext;
		this.location = location;
		this.binding = binding;
		this.format = format;
		this.offset = offset;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32 vertexBindingDescriptionCount = 0, VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions = null, uint32 vertexAttributeDescriptionCount = 0, VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions = null);

static { public const uint32 VK_EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME = "VK_EXT_physical_device_drm"; }

[CRepr] struct VkPhysicalDeviceDrmPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceDrmPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 hasPrimary;
	public VkBool32 hasRender;
	public int64 primaryMajor;
	public int64 primaryMinor;
	public int64 renderMajor;
	public int64 renderMinor;
}

static { public const uint32 VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME = "VK_EXT_device_address_binding_report"; }

[CRepr] struct VkPhysicalDeviceAddressBindingReportFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceAddressBindingReportFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 reportAddressBinding;

	public this(void* pNext, VkBool32 reportAddressBinding)
	{
		this.pNext = pNext;
		this.reportAddressBinding = reportAddressBinding;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceAddressBindingCallbackDataEXT
{
	public const VkStructureType SType = .VkDeviceAddressBindingCallbackDataEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceAddressBindingFlagsEXT flags;
	public VkDeviceAddress baseAddress;
	public VkDeviceSize size;
	public VkDeviceAddressBindingTypeEXT bindingType;

	public this(void* pNext, VkDeviceAddressBindingFlagsEXT flags, VkDeviceAddress baseAddress, VkDeviceSize size, VkDeviceAddressBindingTypeEXT bindingType)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.baseAddress = baseAddress;
		this.size = size;
		this.bindingType = bindingType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkDeviceAddressBindingFlagsEXT = VkDeviceAddressBindingFlagBitsEXT;

[AllowDuplicates] enum VkDeviceAddressBindingFlagBitsEXT : int32
{
	InternalObjectEXT = 1 << 0,
}

[AllowDuplicates] enum VkDeviceAddressBindingTypeEXT : int32
{
	BindEXT = 0,
	UnbindEXT = 1,
}

static { public const uint32 VK_EXT_DEPTH_CLIP_CONTROL_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME = "VK_EXT_depth_clip_control"; }

[CRepr] struct VkPhysicalDeviceDepthClipControlFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceDepthClipControlFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 depthClipControl;

	public this(void* pNext, VkBool32 depthClipControl)
	{
		this.pNext = pNext;
		this.depthClipControl = depthClipControl;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineViewportDepthClipControlCreateInfoEXT
{
	public const VkStructureType SType = .VkPipelineViewportDepthClipControlCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 negativeOneToOne;

	public this(void* pNext, VkBool32 negativeOneToOne)
	{
		this.pNext = pNext;
		this.negativeOneToOne = negativeOneToOne;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME = "VK_EXT_primitive_topology_list_restart"; }

[CRepr] struct VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 primitiveTopologyListRestart;
	public VkBool32 primitiveTopologyPatchListRestart;

	public this(void* pNext, VkBool32 primitiveTopologyListRestart, VkBool32 primitiveTopologyPatchListRestart)
	{
		this.pNext = pNext;
		this.primitiveTopologyListRestart = primitiveTopologyListRestart;
		this.primitiveTopologyPatchListRestart = primitiveTopologyPatchListRestart;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION = 2; }
static { public const c_char* VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME = "VK_KHR_format_feature_flags2"; }

typealias VkFormatFeatureFlags2KHR = VkFormatFeatureFlags2;
typealias VkFormatFeatureFlagBits2KHR = VkFormatFeatureFlagBits2;
typealias VkFormatProperties3KHR = VkFormatProperties3;

static { public const uint32 VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME = "VK_EXT_present_mode_fifo_latest_ready"; }

typealias VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT = VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR;

static { public const uint32 VK_FUCHSIA_EXTERNAL_MEMORY_SPEC_VERSION = 1; }
static { public const c_char* VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME = "VK_FUCHSIA_external_memory"; }

[CRepr] struct VkImportMemoryZirconHandleInfoFUCHSIA
{
	public const VkStructureType SType = .VkImportMemoryZirconHandleInfoFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlagBits handleType;
	public zx_handle_t handle;

	public this(void* pNext = null, VkExternalMemoryHandleTypeFlagBits handleType = 0, zx_handle_t handle = null)
	{
		this.pNext = pNext;
		this.handleType = handleType;
		this.handle = handle;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryZirconHandlePropertiesFUCHSIA
{
	public const VkStructureType SType = .VkMemoryZirconHandlePropertiesFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 memoryTypeBits;
}

[CRepr] struct VkMemoryGetZirconHandleInfoFUCHSIA
{
	public const VkStructureType SType = .VkMemoryGetZirconHandleInfoFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceMemory memory;
	public VkExternalMemoryHandleTypeFlagBits handleType;

	public this(void* pNext, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.memory = memory;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetMemoryZirconHandleFUCHSIA(VkDevice device, VkMemoryGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, out zx_handle_t pZirconHandle);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, out VkMemoryZirconHandlePropertiesFUCHSIA pMemoryZirconHandleProperties);

static { public const uint32 VK_FUCHSIA_EXTERNAL_SEMAPHORE_SPEC_VERSION = 1; }
static { public const c_char* VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME = "VK_FUCHSIA_external_semaphore"; }

[CRepr] struct VkImportSemaphoreZirconHandleInfoFUCHSIA
{
	public const VkStructureType SType = .VkImportSemaphoreZirconHandleInfoFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSemaphore semaphore;
	public VkSemaphoreImportFlags flags;
	public VkExternalSemaphoreHandleTypeFlagBits handleType;
	public zx_handle_t zirconHandle;

	public this(void* pNext, VkSemaphore semaphore, VkSemaphoreImportFlags flags, VkExternalSemaphoreHandleTypeFlagBits handleType, zx_handle_t zirconHandle)
	{
		this.pNext = pNext;
		this.semaphore = semaphore;
		this.flags = flags;
		this.handleType = handleType;
		this.zirconHandle = zirconHandle;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSemaphoreGetZirconHandleInfoFUCHSIA
{
	public const VkStructureType SType = .VkSemaphoreGetZirconHandleInfoFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSemaphore semaphore;
	public VkExternalSemaphoreHandleTypeFlagBits handleType;

	public this(void* pNext, VkSemaphore semaphore, VkExternalSemaphoreHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.semaphore = semaphore;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkImportSemaphoreZirconHandleFUCHSIA(VkDevice device, VkImportSemaphoreZirconHandleInfoFUCHSIA* pImportSemaphoreZirconHandleInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetSemaphoreZirconHandleFUCHSIA(VkDevice device, VkSemaphoreGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, out zx_handle_t pZirconHandle);

static { public const uint32 VK_FUCHSIA_BUFFER_COLLECTION_SPEC_VERSION = 2; }
static { public const c_char* VK_FUCHSIA_BUFFER_COLLECTION_EXTENSION_NAME = "VK_FUCHSIA_buffer_collection"; }

class VkBufferCollectionFUCHSIA { private this() { } }

[CRepr] struct VkBufferCollectionCreateInfoFUCHSIA
{
	public const VkStructureType SType = .VkBufferCollectionCreateInfoFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public zx_handle_t collectionToken;

	public this(void* pNext, zx_handle_t collectionToken)
	{
		this.pNext = pNext;
		this.collectionToken = collectionToken;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImportMemoryBufferCollectionFUCHSIA
{
	public const VkStructureType SType = .VkImportMemoryBufferCollectionFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBufferCollectionFUCHSIA collection;
	public uint32 index;

	public this(void* pNext, VkBufferCollectionFUCHSIA collection, uint32 index)
	{
		this.pNext = pNext;
		this.collection = collection;
		this.index = index;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBufferCollectionImageCreateInfoFUCHSIA
{
	public const VkStructureType SType = .VkBufferCollectionImageCreateInfoFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBufferCollectionFUCHSIA collection;
	public uint32 index;

	public this(void* pNext, VkBufferCollectionFUCHSIA collection, uint32 index)
	{
		this.pNext = pNext;
		this.collection = collection;
		this.index = index;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBufferConstraintsInfoFUCHSIA
{
	public const VkStructureType SType = .VkBufferConstraintsInfoFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBufferCreateInfo createInfo;
	public VkFormatFeatureFlags requiredFormatFeatures;
	public VkBufferCollectionConstraintsInfoFUCHSIA bufferCollectionConstraints;

	public this(void* pNext, VkBufferCreateInfo createInfo, VkFormatFeatureFlags requiredFormatFeatures, VkBufferCollectionConstraintsInfoFUCHSIA bufferCollectionConstraints)
	{
		this.pNext = pNext;
		this.createInfo = createInfo;
		this.requiredFormatFeatures = requiredFormatFeatures;
		this.bufferCollectionConstraints = bufferCollectionConstraints;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBufferCollectionBufferCreateInfoFUCHSIA
{
	public const VkStructureType SType = .VkBufferCollectionBufferCreateInfoFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBufferCollectionFUCHSIA collection;
	public uint32 index;

	public this(void* pNext, VkBufferCollectionFUCHSIA collection, uint32 index)
	{
		this.pNext = pNext;
		this.collection = collection;
		this.index = index;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBufferCollectionPropertiesFUCHSIA
{
	public const VkStructureType SType = .VkBufferCollectionPropertiesFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 memoryTypeBits;
	public uint32 bufferCount;
	public uint32 createInfoIndex;
	public uint64 sysmemPixelFormat;
	public VkFormatFeatureFlags formatFeatures;
	public VkSysmemColorSpaceFUCHSIA sysmemColorSpaceIndex;
	public VkComponentMapping samplerYcbcrConversionComponents;
	public VkSamplerYcbcrModelConversion suggestedYcbcrModel;
	public VkSamplerYcbcrRange suggestedYcbcrRange;
	public VkChromaLocation suggestedXChromaOffset;
	public VkChromaLocation suggestedYChromaOffset;
}

typealias VkImageFormatConstraintsFlagsFUCHSIA = VkFlags;

[CRepr] struct VkSysmemColorSpaceFUCHSIA
{
	public const VkStructureType SType = .VkSysmemColorSpaceFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 colorSpace;

	public this(void* pNext, uint32 colorSpace)
	{
		this.pNext = pNext;
		this.colorSpace = colorSpace;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkImageConstraintsInfoFlagBitsFUCHSIA : int32
{
	CpuReadRarelyFUCHSIA = 1 << 0,
	CpuReadOftenFUCHSIA = 1 << 1,
	CpuWriteRarelyFUCHSIA = 1 << 2,
	CpuWriteOftenFUCHSIA = 1 << 3,
	ProtectedOptionalFUCHSIA = 1 << 4,
}

typealias VkImageConstraintsInfoFlagsFUCHSIA = VkImageConstraintsInfoFlagBitsFUCHSIA;

[CRepr] struct VkImageConstraintsInfoFUCHSIA
{
	public const VkStructureType SType = .VkImageConstraintsInfoFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 formatConstraintsCount;
	public VkImageFormatConstraintsInfoFUCHSIA* pFormatConstraints;
	public VulkanSpan<VkImageFormatConstraintsInfoFUCHSIA> formatConstraints
	{
		[Inline] get => .(formatConstraintsCount, pFormatConstraints);
		[Inline] set mut { formatConstraintsCount = value.count; pFormatConstraints = value.ptr; }
	}
	public VkBufferCollectionConstraintsInfoFUCHSIA bufferCollectionConstraints;
	public VkImageConstraintsInfoFlagsFUCHSIA flags;

	public this(void* pNext, VulkanSpan<VkImageFormatConstraintsInfoFUCHSIA> formatConstraints, VkBufferCollectionConstraintsInfoFUCHSIA bufferCollectionConstraints, VkImageConstraintsInfoFlagsFUCHSIA flags = 0) : this()
	{
		this.pNext = pNext;
		this.formatConstraints = formatConstraints;
		this.bufferCollectionConstraints = bufferCollectionConstraints;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageFormatConstraintsInfoFUCHSIA
{
	public const VkStructureType SType = .VkImageFormatConstraintsInfoFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageCreateInfo imageCreateInfo;
	public VkFormatFeatureFlags requiredFormatFeatures;
	public VkImageFormatConstraintsFlagsFUCHSIA flags;
	public uint64 sysmemPixelFormat;
	public uint32 colorSpaceCount;
	public VkSysmemColorSpaceFUCHSIA* pColorSpaces;
	public VulkanSpan<VkSysmemColorSpaceFUCHSIA> colorSpaces
	{
		[Inline] get => .(colorSpaceCount, pColorSpaces);
		[Inline] set mut { colorSpaceCount = value.count; pColorSpaces = value.ptr; }
	}

	public this(void* pNext, VkImageCreateInfo imageCreateInfo, VkFormatFeatureFlags requiredFormatFeatures, VkImageFormatConstraintsFlagsFUCHSIA flags, uint64 sysmemPixelFormat, VulkanSpan<VkSysmemColorSpaceFUCHSIA> colorSpaces) : this()
	{
		this.pNext = pNext;
		this.imageCreateInfo = imageCreateInfo;
		this.requiredFormatFeatures = requiredFormatFeatures;
		this.flags = flags;
		this.sysmemPixelFormat = sysmemPixelFormat;
		this.colorSpaces = colorSpaces;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBufferCollectionConstraintsInfoFUCHSIA
{
	public const VkStructureType SType = .VkBufferCollectionConstraintsInfoFUCHSIA;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 minBufferCount;
	public uint32 maxBufferCount;
	public uint32 minBufferCountForCamping;
	public uint32 minBufferCountForDedicatedSlack;
	public uint32 minBufferCountForSharedSlack;

	public this(void* pNext, uint32 minBufferCount, uint32 maxBufferCount, uint32 minBufferCountForCamping, uint32 minBufferCountForDedicatedSlack, uint32 minBufferCountForSharedSlack)
	{
		this.pNext = pNext;
		this.minBufferCount = minBufferCount;
		this.maxBufferCount = maxBufferCount;
		this.minBufferCountForCamping = minBufferCountForCamping;
		this.minBufferCountForDedicatedSlack = minBufferCountForDedicatedSlack;
		this.minBufferCountForSharedSlack = minBufferCountForSharedSlack;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionCreateInfoFUCHSIA* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkBufferCollectionFUCHSIA pCollection);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkSetBufferCollectionImageConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkImageConstraintsInfoFUCHSIA* pImageConstraintsInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkBufferConstraintsInfoFUCHSIA* pBufferConstraintsInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetBufferCollectionPropertiesFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, out VkBufferCollectionPropertiesFUCHSIA pProperties);

static { public const uint32 VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION = 3; }
static { public const c_char* VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME = "VK_HUAWEI_subpass_shading"; }

[CRepr] struct VkSubpassShadingPipelineCreateInfoHUAWEI
{
	public const VkStructureType SType = .VkSubpassShadingPipelineCreateInfoHUAWEI;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRenderPass renderPass;
	public uint32 subpass;

	public this(void* pNext, VkRenderPass renderPass, uint32 subpass)
	{
		this.pNext = pNext;
		this.renderPass = renderPass;
		this.subpass = subpass;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceSubpassShadingFeaturesHUAWEI
{
	public const VkStructureType SType = .VkPhysicalDeviceSubpassShadingFeaturesHUAWEI;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 subpassShading;

	public this(void* pNext, VkBool32 subpassShading)
	{
		this.pNext = pNext;
		this.subpassShading = subpassShading;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceSubpassShadingPropertiesHUAWEI
{
	public const VkStructureType SType = .VkPhysicalDeviceSubpassShadingPropertiesHUAWEI;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxSubpassShadingWorkgroupSizeAspectRatio;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, out VkExtent2D pMaxWorkgroupSize);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer);

static { public const uint32 VK_HUAWEI_INVOCATION_MASK_SPEC_VERSION = 1; }
static { public const c_char* VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME = "VK_HUAWEI_invocation_mask"; }

[CRepr] struct VkPhysicalDeviceInvocationMaskFeaturesHUAWEI
{
	public const VkStructureType SType = .VkPhysicalDeviceInvocationMaskFeaturesHUAWEI;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 invocationMask;

	public this(void* pNext, VkBool32 invocationMask)
	{
		this.pNext = pNext;
		this.invocationMask = invocationMask;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout);

static { public const uint32 VK_NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME = "VK_NV_external_memory_rdma"; }

[CRepr] struct VkMemoryGetRemoteAddressInfoNV
{
	public const VkStructureType SType = .VkMemoryGetRemoteAddressInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceMemory memory;
	public VkExternalMemoryHandleTypeFlagBits handleType;

	public this(void* pNext, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.memory = memory;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceExternalMemoryRDMAFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceExternalMemoryRdmaFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 externalMemoryRDMA;

	public this(void* pNext, VkBool32 externalMemoryRDMA)
	{
		this.pNext = pNext;
		this.externalMemoryRDMA = externalMemoryRDMA;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetMemoryRemoteAddressNV(VkDevice device, VkMemoryGetRemoteAddressInfoNV* pMemoryGetRemoteAddressInfo, out VkRemoteAddressNV pAddress);

static { public const uint32 VK_EXT_PIPELINE_PROPERTIES_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME = "VK_EXT_pipeline_properties"; }

typealias VkPipelineInfoEXT = VkPipelineInfoKHR;

[CRepr] struct VkPipelinePropertiesIdentifierEXT
{
	public const VkStructureType SType = .VkPipelinePropertiesIdentifierEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint8[VK_UUID_SIZE] pipelineIdentifier;
}

[CRepr] struct VkPhysicalDevicePipelinePropertiesFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDevicePipelinePropertiesFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 pipelinePropertiesIdentifier;

	public this(void* pNext, VkBool32 pipelinePropertiesIdentifier)
	{
		this.pNext = pNext;
		this.pipelinePropertiesIdentifier = pipelinePropertiesIdentifier;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPipelinePropertiesEXT(VkDevice device, VkPipelineInfoEXT* pPipelineInfo, out VkBaseOutStructure pPipelineProperties);

static { public const uint32 VK_EXT_FRAME_BOUNDARY_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME = "VK_EXT_frame_boundary"; }

[CRepr] struct VkPhysicalDeviceFrameBoundaryFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceFrameBoundaryFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 frameBoundary;

	public this(void* pNext, VkBool32 frameBoundary)
	{
		this.pNext = pNext;
		this.frameBoundary = frameBoundary;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkFrameBoundaryEXT
{
	public const VkStructureType SType = .VkFrameBoundaryEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFrameBoundaryFlagsEXT flags;
	public uint64 frameID;
	public uint32 imageCount;
	public VkImage* pImages;
	public VulkanSpan<VkImage> images
	{
		[Inline] get => .(imageCount, pImages);
		[Inline] set mut { imageCount = value.count; pImages = value.ptr; }
	}
	public uint32 bufferCount;
	public VkBuffer* pBuffers;
	public VulkanSpan<VkBuffer> buffers
	{
		[Inline] get => .(bufferCount, pBuffers);
		[Inline] set mut { bufferCount = value.count; pBuffers = value.ptr; }
	}
	public uint64 tagName;
	public c_size tagSize;
	public void* pTag;

	public this(void* pNext, VkFrameBoundaryFlagsEXT flags, uint64 frameID, VulkanSpan<VkImage> images = .(), VulkanSpan<VkBuffer> buffers = .(), uint64 tagName = 0, c_size tagSize = 0, void* pTag = null) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.frameID = frameID;
		this.images = images;
		this.buffers = buffers;
		this.tagName = tagName;
		this.tagSize = tagSize;
		this.pTag = pTag;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkFrameBoundaryFlagBitsEXT : int32
{
	FrameEndEXT = 1 << 0,
}

typealias VkFrameBoundaryFlagsEXT = VkFrameBoundaryFlagBitsEXT;

static { public const uint32 VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME = "VK_EXT_multisampled_render_to_single_sampled"; }

[CRepr] struct VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 multisampledRenderToSingleSampled;

	public this(void* pNext, VkBool32 multisampledRenderToSingleSampled)
	{
		this.pNext = pNext;
		this.multisampledRenderToSingleSampled = multisampledRenderToSingleSampled;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSubpassResolvePerformanceQueryEXT
{
	public const VkStructureType SType = .VkSubpassResolvePerformanceQueryEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 optimal;
}

[CRepr] struct VkMultisampledRenderToSingleSampledInfoEXT
{
	public const VkStructureType SType = .VkMultisampledRenderToSingleSampledInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 multisampledRenderToSingleSampledEnable;
	public VkSampleCountFlagBits rasterizationSamples;

	public this(void* pNext, VkBool32 multisampledRenderToSingleSampledEnable, VkSampleCountFlagBits rasterizationSamples)
	{
		this.pNext = pNext;
		this.multisampledRenderToSingleSampledEnable = multisampledRenderToSingleSampledEnable;
		this.rasterizationSamples = rasterizationSamples;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME = "VK_EXT_extended_dynamic_state2"; }

[CRepr] struct VkPhysicalDeviceExtendedDynamicState2FeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceExtendedDynamicState2FeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 extendedDynamicState2;
	public VkBool32 extendedDynamicState2LogicOp;
	public VkBool32 extendedDynamicState2PatchControlPoints;

	public this(void* pNext, VkBool32 extendedDynamicState2, VkBool32 extendedDynamicState2LogicOp, VkBool32 extendedDynamicState2PatchControlPoints)
	{
		this.pNext = pNext;
		this.extendedDynamicState2 = extendedDynamicState2;
		this.extendedDynamicState2LogicOp = extendedDynamicState2LogicOp;
		this.extendedDynamicState2PatchControlPoints = extendedDynamicState2PatchControlPoints;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32 patchControlPoints);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp);

static { public const uint32 VK_QNX_SCREEN_SURFACE_SPEC_VERSION = 1; }
static { public const c_char* VK_QNX_SCREEN_SURFACE_EXTENSION_NAME = "VK_QNX_screen_surface"; }

typealias VkScreenSurfaceCreateFlagsQNX = VkFlags;

[CRepr] struct VkScreenSurfaceCreateInfoQNX
{
	public const VkStructureType SType = .VkScreenSurfaceCreateInfoQNX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkScreenSurfaceCreateFlagsQNX flags;
	public _screen_context* context;
	public _screen_window* window;

	public this(void* pNext, VkScreenSurfaceCreateFlagsQNX flags, _screen_context* context, _screen_window* window)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.context = context;
		this.window = window;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateScreenSurfaceQNX(VkInstance instance, VkScreenSurfaceCreateInfoQNX* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);
[CallingConvention(VKAPI_PTR)] function VkBool32 PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice, uint32 queueFamilyIndex, out _screen_window window);

static { public const uint32 VK_EXT_COLOR_WRITE_ENABLE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME = "VK_EXT_color_write_enable"; }

[CRepr] struct VkPhysicalDeviceColorWriteEnableFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceColorWriteEnableFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 colorWriteEnable;

	public this(void* pNext, VkBool32 colorWriteEnable)
	{
		this.pNext = pNext;
		this.colorWriteEnable = colorWriteEnable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineColorWriteCreateInfoEXT
{
	public const VkStructureType SType = .VkPipelineColorWriteCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 attachmentCount; // # of pAttachments
	public VkBool32* pColorWriteEnables;
	public VulkanSpan<VkBool32> colorWriteEnables
	{
		[Inline] get => .(attachmentCount, pColorWriteEnables);
		[Inline] set mut { attachmentCount = value.count; pColorWriteEnables = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkBool32> colorWriteEnables = .()) : this()
	{
		this.pNext = pNext;
		this.colorWriteEnables = colorWriteEnables;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32 attachmentCount, VkBool32* pColorWriteEnables);

static { public const uint32 VK_EXT_PRIMITIVES_GENERATED_QUERY_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME = "VK_EXT_primitives_generated_query"; }

[CRepr] struct VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 primitivesGeneratedQuery;
	public VkBool32 primitivesGeneratedQueryWithRasterizerDiscard;
	public VkBool32 primitivesGeneratedQueryWithNonZeroStreams;

	public this(void* pNext, VkBool32 primitivesGeneratedQuery, VkBool32 primitivesGeneratedQueryWithRasterizerDiscard, VkBool32 primitivesGeneratedQueryWithNonZeroStreams)
	{
		this.pNext = pNext;
		this.primitivesGeneratedQuery = primitivesGeneratedQuery;
		this.primitivesGeneratedQueryWithRasterizerDiscard = primitivesGeneratedQueryWithRasterizerDiscard;
		this.primitivesGeneratedQueryWithNonZeroStreams = primitivesGeneratedQueryWithNonZeroStreams;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_RAY_TRACING_MAINTENANCE_1_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_ray_tracing_maintenance1"; }

[CRepr] struct VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 rayTracingMaintenance1;
	public VkBool32 rayTracingPipelineTraceRaysIndirect2;

	public this(void* pNext, VkBool32 rayTracingMaintenance1, VkBool32 rayTracingPipelineTraceRaysIndirect2)
	{
		this.pNext = pNext;
		this.rayTracingMaintenance1 = rayTracingMaintenance1;
		this.rayTracingPipelineTraceRaysIndirect2 = rayTracingPipelineTraceRaysIndirect2;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkTraceRaysIndirectCommand2KHR
{
	public VkDeviceAddress raygenShaderRecordAddress;
	public VkDeviceSize raygenShaderRecordSize;
	public VkDeviceAddress missShaderBindingTableAddress;
	public VkDeviceSize missShaderBindingTableSize;
	public VkDeviceSize missShaderBindingTableStride;
	public VkDeviceAddress hitShaderBindingTableAddress;
	public VkDeviceSize hitShaderBindingTableSize;
	public VkDeviceSize hitShaderBindingTableStride;
	public VkDeviceAddress callableShaderBindingTableAddress;
	public VkDeviceSize callableShaderBindingTableSize;
	public VkDeviceSize callableShaderBindingTableStride;
	public uint32 width;
	public uint32 height;
	public uint32 depth;

	public this(VkDeviceAddress raygenShaderRecordAddress, VkDeviceSize raygenShaderRecordSize, VkDeviceAddress missShaderBindingTableAddress, VkDeviceSize missShaderBindingTableSize, VkDeviceSize missShaderBindingTableStride, VkDeviceAddress hitShaderBindingTableAddress, VkDeviceSize hitShaderBindingTableSize, VkDeviceSize hitShaderBindingTableStride, VkDeviceAddress callableShaderBindingTableAddress, VkDeviceSize callableShaderBindingTableSize, VkDeviceSize callableShaderBindingTableStride, uint32 width, uint32 height, uint32 depth)
	{
		this.raygenShaderRecordAddress = raygenShaderRecordAddress;
		this.raygenShaderRecordSize = raygenShaderRecordSize;
		this.missShaderBindingTableAddress = missShaderBindingTableAddress;
		this.missShaderBindingTableSize = missShaderBindingTableSize;
		this.missShaderBindingTableStride = missShaderBindingTableStride;
		this.hitShaderBindingTableAddress = hitShaderBindingTableAddress;
		this.hitShaderBindingTableSize = hitShaderBindingTableSize;
		this.hitShaderBindingTableStride = hitShaderBindingTableStride;
		this.callableShaderBindingTableAddress = callableShaderBindingTableAddress;
		this.callableShaderBindingTableSize = callableShaderBindingTableSize;
		this.callableShaderBindingTableStride = callableShaderBindingTableStride;
		this.width = width;
		this.height = height;
		this.depth = depth;
	}

	public this()
	{
		this = default;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress);

static { public const uint32 VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME = "VK_EXT_global_priority_query"; }
static { public const let VK_MAX_GLOBAL_PRIORITY_SIZE_EXT = VK_MAX_GLOBAL_PRIORITY_SIZE; }

typealias VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT = VkPhysicalDeviceGlobalPriorityQueryFeatures;
typealias VkQueueFamilyGlobalPriorityPropertiesEXT = VkQueueFamilyGlobalPriorityProperties;

static { public const uint32 VK_EXT_IMAGE_VIEW_MIN_LOD_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME = "VK_EXT_image_view_min_lod"; }

[CRepr] struct VkPhysicalDeviceImageViewMinLodFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceImageViewMinLodFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 minLod;

	public this(void* pNext, VkBool32 minLod)
	{
		this.pNext = pNext;
		this.minLod = minLod;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageViewMinLodCreateInfoEXT
{
	public const VkStructureType SType = .VkImageViewMinLodCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public float minLod;

	public this(void* pNext, float minLod)
	{
		this.pNext = pNext;
		this.minLod = minLod;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_MULTI_DRAW_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_MULTI_DRAW_EXTENSION_NAME = "VK_EXT_multi_draw"; }

[CRepr] struct VkPhysicalDeviceMultiDrawFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceMultiDrawFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 multiDraw;

	public this(void* pNext, VkBool32 multiDraw)
	{
		this.pNext = pNext;
		this.multiDraw = multiDraw;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceMultiDrawPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceMultiDrawPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxMultiDrawCount;
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32 drawCount, VkMultiDrawInfoEXT* pVertexInfo, uint32 instanceCount, uint32 firstInstance, uint32 stride);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32 drawCount, VkMultiDrawIndexedInfoEXT* pIndexInfo, uint32 instanceCount, uint32 firstInstance, uint32 stride, int32* pVertexOffset = null);

[CRepr] struct VkMultiDrawInfoEXT
{
	public uint32 firstVertex;
	public uint32 vertexCount;

	public this(uint32 firstVertex, uint32 vertexCount)
	{
		this.firstVertex = firstVertex;
		this.vertexCount = vertexCount;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkMultiDrawIndexedInfoEXT
{
	public uint32 firstIndex;
	public uint32 indexCount;
	public int32 vertexOffset;

	public this(uint32 firstIndex, uint32 indexCount, int32 vertexOffset)
	{
		this.firstIndex = firstIndex;
		this.indexCount = indexCount;
		this.vertexOffset = vertexOffset;
	}

	public this()
	{
		this = default;
	}
}

static { public const uint32 VK_EXT_IMAGE_2D_VIEW_OF_3D_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME = "VK_EXT_image_2d_view_of_3d"; }

[CRepr] struct VkPhysicalDeviceImage2DViewOf3DFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceImage2dViewOf3dFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 image2DViewOf3D;
	public VkBool32 sampler2DViewOf3D;

	public this(void* pNext, VkBool32 image2DViewOf3D, VkBool32 sampler2DViewOf3D)
	{
		this.pNext = pNext;
		this.image2DViewOf3D = image2DViewOf3D;
		this.sampler2DViewOf3D = sampler2DViewOf3D;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_PORTABILITY_ENUMERATION_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME = "VK_KHR_portability_enumeration"; }
static { public const uint32 VK_EXT_SHADER_TILE_IMAGE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME = "VK_EXT_shader_tile_image"; }

[CRepr] struct VkPhysicalDeviceShaderTileImageFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderTileImageFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderTileImageColorReadAccess;
	public VkBool32 shaderTileImageDepthReadAccess;
	public VkBool32 shaderTileImageStencilReadAccess;

	public this(void* pNext, VkBool32 shaderTileImageColorReadAccess, VkBool32 shaderTileImageDepthReadAccess, VkBool32 shaderTileImageStencilReadAccess)
	{
		this.pNext = pNext;
		this.shaderTileImageColorReadAccess = shaderTileImageColorReadAccess;
		this.shaderTileImageDepthReadAccess = shaderTileImageDepthReadAccess;
		this.shaderTileImageStencilReadAccess = shaderTileImageStencilReadAccess;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceShaderTileImagePropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderTileImagePropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderTileImageCoherentReadAccelerated;
	public VkBool32 shaderTileImageReadSampleFromPixelRateInvocation;
	public VkBool32 shaderTileImageReadFromHelperInvocation;
}

static { public const uint32 VK_EXT_OPACITY_MICROMAP_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME = "VK_EXT_opacity_micromap"; }

[AllowDuplicates] enum VkMicromapTypeEXT : int32
{
	OpacityMicromapEXT = 0,
	VkMicromapTypeDisplacementMicromapNV = 1000397000,
}

[CRepr] struct VkMicromapBuildInfoEXT
{
	public const VkStructureType SType = .VkMicromapBuildInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkMicromapTypeEXT type;
	public VkBuildMicromapFlagsEXT flags;
	public VkBuildMicromapModeEXT mode;
	public VkMicromapEXT dstMicromap;
	public uint32 usageCountsCount;
	public VkMicromapUsageEXT* pUsageCounts;
	public VkMicromapUsageEXT** ppUsageCounts;
	public VulkanDuoSpan<VkMicromapUsageEXT, VkMicromapUsageEXT*> usageCounts_usageCounts
	{
		[Inline] get => .(usageCountsCount, pUsageCounts, ppUsageCounts);
		[Inline] set mut { usageCountsCount = value.count; pUsageCounts = value.ptr1; ppUsageCounts = value.ptr2; }
	}
	public VkDeviceOrHostAddressConstKHR data;
	public VkDeviceOrHostAddressKHR scratchData;
	public VkDeviceOrHostAddressConstKHR triangleArray;
	public VkDeviceSize triangleArrayStride;

	public this(void* pNext, VkMicromapTypeEXT type, VkBuildMicromapFlagsEXT flags, VkBuildMicromapModeEXT mode, VkMicromapEXT dstMicromap, VulkanDuoSpan<VkMicromapUsageEXT, VkMicromapUsageEXT*> usageCounts_usageCounts, VkDeviceOrHostAddressConstKHR data, VkDeviceOrHostAddressKHR scratchData, VkDeviceOrHostAddressConstKHR triangleArray, VkDeviceSize triangleArrayStride) : this()
	{
		this.pNext = pNext;
		this.type = type;
		this.flags = flags;
		this.mode = mode;
		this.dstMicromap = dstMicromap;
		this.usageCounts_usageCounts = usageCounts_usageCounts;
		this.data = data;
		this.scratchData = scratchData;
		this.triangleArray = triangleArray;
		this.triangleArrayStride = triangleArrayStride;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMicromapUsageEXT
{
	public uint32 count;
	public uint32 subdivisionLevel;
	public uint32 format; // Interpretation depends on parent type

	public this(uint32 count, uint32 subdivisionLevel, uint32 format)
	{
		this.count = count;
		this.subdivisionLevel = subdivisionLevel;
		this.format = format;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkMicromapCreateInfoEXT
{
	public const VkStructureType SType = .VkMicromapCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkMicromapCreateFlagsEXT createFlags;
	public VkBuffer buffer;
	public VkDeviceSize offset; // Specified in bytes
	public VkDeviceSize size;
	public VkMicromapTypeEXT type;
	public VkDeviceAddress deviceAddress;

	public this(void* pNext, VkMicromapCreateFlagsEXT createFlags, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkMicromapTypeEXT type, VkDeviceAddress deviceAddress = 0)
	{
		this.pNext = pNext;
		this.createFlags = createFlags;
		this.buffer = buffer;
		this.offset = offset;
		this.size = size;
		this.type = type;
		this.deviceAddress = deviceAddress;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

class VkMicromapEXT { private this() { } }

[AllowDuplicates] enum VkBuildMicromapFlagBitsEXT : int32
{
	PreferFastTraceEXT = 1 << 0,
	PreferFastBuildEXT = 1 << 1,
	AllowCompactionEXT = 1 << 2,
}

typealias VkBuildMicromapFlagsEXT = VkBuildMicromapFlagBitsEXT;

[AllowDuplicates] enum VkCopyMicromapModeEXT : int32
{
	CloneEXT = 0,
	SerializeEXT = 1,
	DeserializeEXT = 2,
	CompactEXT = 3,
}

[CRepr] struct VkPhysicalDeviceOpacityMicromapFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceOpacityMicromapFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 micromap;
	public VkBool32 micromapCaptureReplay;
	public VkBool32 micromapHostCommands;

	public this(void* pNext, VkBool32 micromap, VkBool32 micromapCaptureReplay, VkBool32 micromapHostCommands)
	{
		this.pNext = pNext;
		this.micromap = micromap;
		this.micromapCaptureReplay = micromapCaptureReplay;
		this.micromapHostCommands = micromapHostCommands;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceOpacityMicromapPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceOpacityMicromapPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxOpacity2StateSubdivisionLevel;
	public uint32 maxOpacity4StateSubdivisionLevel;
}

[CRepr] struct VkMicromapVersionInfoEXT
{
	public const VkStructureType SType = .VkMicromapVersionInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint8* pVersionData;

	public this(void* pNext, uint8* pVersionData)
	{
		this.pNext = pNext;
		this.pVersionData = pVersionData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCopyMicromapToMemoryInfoEXT
{
	public const VkStructureType SType = .VkCopyMicromapToMemoryInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkMicromapEXT src;
	public VkDeviceOrHostAddressKHR dst;
	public VkCopyMicromapModeEXT mode;

	public this(void* pNext, VkMicromapEXT src, VkDeviceOrHostAddressKHR dst, VkCopyMicromapModeEXT mode)
	{
		this.pNext = pNext;
		this.src = src;
		this.dst = dst;
		this.mode = mode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCopyMemoryToMicromapInfoEXT
{
	public const VkStructureType SType = .VkCopyMemoryToMicromapInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceOrHostAddressConstKHR src;
	public VkMicromapEXT dst;
	public VkCopyMicromapModeEXT mode;

	public this(void* pNext, VkDeviceOrHostAddressConstKHR src, VkMicromapEXT dst, VkCopyMicromapModeEXT mode)
	{
		this.pNext = pNext;
		this.src = src;
		this.dst = dst;
		this.mode = mode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCopyMicromapInfoEXT
{
	public const VkStructureType SType = .VkCopyMicromapInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkMicromapEXT src;
	public VkMicromapEXT dst;
	public VkCopyMicromapModeEXT mode;

	public this(void* pNext, VkMicromapEXT src, VkMicromapEXT dst, VkCopyMicromapModeEXT mode)
	{
		this.pNext = pNext;
		this.src = src;
		this.dst = dst;
		this.mode = mode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkMicromapCreateFlagBitsEXT : int32
{
	DeviceAddressCaptureReplayEXT = 1 << 0,
}

typealias VkMicromapCreateFlagsEXT = VkMicromapCreateFlagBitsEXT;

[AllowDuplicates] enum VkBuildMicromapModeEXT : int32
{
	BuildEXT = 0,
}

[CRepr] struct VkMicromapBuildSizesInfoEXT
{
	public const VkStructureType SType = .VkMicromapBuildSizesInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize micromapSize;
	public VkDeviceSize buildScratchSize;
	public VkBool32 discardable;

	public this(void* pNext, VkDeviceSize micromapSize, VkDeviceSize buildScratchSize, VkBool32 discardable)
	{
		this.pNext = pNext;
		this.micromapSize = micromapSize;
		this.buildScratchSize = buildScratchSize;
		this.discardable = discardable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkOpacityMicromapFormatEXT : int32
{
	VK_2StateEXT = 1,
	VK_4StateEXT = 2,
}

[CRepr] struct VkAccelerationStructureTrianglesOpacityMicromapEXT
{
	public const VkStructureType SType = .VkAccelerationStructureTrianglesOpacityMicromapEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkIndexType indexType;
	public VkDeviceOrHostAddressConstKHR indexBuffer;
	public VkDeviceSize indexStride;
	public uint32 baseTriangle;
	public uint32 usageCountsCount;
	public VkMicromapUsageEXT* pUsageCounts;
	public VkMicromapUsageEXT** ppUsageCounts;
	public VulkanDuoSpan<VkMicromapUsageEXT, VkMicromapUsageEXT*> usageCounts_usageCounts
	{
		[Inline] get => .(usageCountsCount, pUsageCounts, ppUsageCounts);
		[Inline] set mut { usageCountsCount = value.count; pUsageCounts = value.ptr1; ppUsageCounts = value.ptr2; }
	}
	public VkMicromapEXT micromap;

	public this(void* pNext, VkIndexType indexType, VkDeviceOrHostAddressConstKHR indexBuffer, VkDeviceSize indexStride, uint32 baseTriangle, VulkanDuoSpan<VkMicromapUsageEXT, VkMicromapUsageEXT*> usageCounts_usageCounts = .(), VkMicromapEXT micromap = null) : this()
	{
		this.pNext = pNext;
		this.indexType = indexType;
		this.indexBuffer = indexBuffer;
		this.indexStride = indexStride;
		this.baseTriangle = baseTriangle;
		this.usageCounts_usageCounts = usageCounts_usageCounts;
		this.micromap = micromap;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMicromapTriangleEXT
{
	public uint32 dataOffset; // Specified in bytes
	public uint16 subdivisionLevel;
	public uint16 format;

	public this(uint32 dataOffset, uint16 subdivisionLevel, uint16 format)
	{
		this.dataOffset = dataOffset;
		this.subdivisionLevel = subdivisionLevel;
		this.format = format;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkOpacityMicromapSpecialIndexEXT : int32
{
	FullyTransparentEXT = -1,
	FullyOpaqueEXT = -2,
	FullyUnknownTransparentEXT = -3,
	FullyUnknownOpaqueEXT = -4,
	VkOpacityMicromapSpecialIndexClusterGeometryDisableOpacityMicromapNV = -5,
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateMicromapEXT(VkDevice device, VkMicromapCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkMicromapEXT pMicromap);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32 infoCount, VkMicromapBuildInfoEXT* pInfos);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkBuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32 infoCount, VkMicromapBuildInfoEXT* pInfos);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, VkCopyMicromapInfoEXT* pInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, VkCopyMicromapToMemoryInfoEXT* pInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, VkCopyMemoryToMicromapInfoEXT* pInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkWriteMicromapsPropertiesEXT(VkDevice device, uint32 micromapCount, VkMicromapEXT* pMicromaps, VkQueryType queryType, c_size dataSize, out void pData, c_size stride);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyMicromapEXT(VkCommandBuffer commandBuffer, VkCopyMicromapInfoEXT* pInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, VkCopyMicromapToMemoryInfoEXT* pInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, VkCopyMemoryToMicromapInfoEXT* pInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32 micromapCount, VkMicromapEXT* pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32 firstQuery);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDeviceMicromapCompatibilityEXT(VkDevice device, VkMicromapVersionInfoEXT* pVersionInfo, out VkAccelerationStructureCompatibilityKHR pCompatibility);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, VkMicromapBuildInfoEXT* pBuildInfo, out VkMicromapBuildSizesInfoEXT pSizeInfo);

static { public const uint32 VK_NV_DISPLACEMENT_MICROMAP_SPEC_VERSION = 2; }
static { public const c_char* VK_NV_DISPLACEMENT_MICROMAP_EXTENSION_NAME = "VK_NV_displacement_micromap"; }

[CRepr] struct VkPhysicalDeviceDisplacementMicromapFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceDisplacementMicromapFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 displacementMicromap;

	public this(void* pNext, VkBool32 displacementMicromap)
	{
		this.pNext = pNext;
		this.displacementMicromap = displacementMicromap;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceDisplacementMicromapPropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceDisplacementMicromapPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxDisplacementMicromapSubdivisionLevel;
}

[CRepr] struct VkAccelerationStructureTrianglesDisplacementMicromapNV
{
	public const VkStructureType SType = .VkAccelerationStructureTrianglesDisplacementMicromapNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat displacementBiasAndScaleFormat;
	public VkFormat displacementVectorFormat;
	public VkDeviceOrHostAddressConstKHR displacementBiasAndScaleBuffer;
	public VkDeviceSize displacementBiasAndScaleStride;
	public VkDeviceOrHostAddressConstKHR displacementVectorBuffer;
	public VkDeviceSize displacementVectorStride;
	public VkDeviceOrHostAddressConstKHR displacedMicromapPrimitiveFlags;
	public VkDeviceSize displacedMicromapPrimitiveFlagsStride;
	public VkIndexType indexType;
	public VkDeviceOrHostAddressConstKHR indexBuffer;
	public VkDeviceSize indexStride;
	public uint32 baseTriangle;
	public uint32 usageCountsCount;
	public VkMicromapUsageEXT* pUsageCounts;
	public VkMicromapUsageEXT** ppUsageCounts;
	public VulkanDuoSpan<VkMicromapUsageEXT, VkMicromapUsageEXT*> usageCounts_usageCounts
	{
		[Inline] get => .(usageCountsCount, pUsageCounts, ppUsageCounts);
		[Inline] set mut { usageCountsCount = value.count; pUsageCounts = value.ptr1; ppUsageCounts = value.ptr2; }
	}
	public VkMicromapEXT micromap;

	public this(void* pNext, VkFormat displacementBiasAndScaleFormat, VkFormat displacementVectorFormat, VkDeviceOrHostAddressConstKHR displacementBiasAndScaleBuffer, VkDeviceSize displacementBiasAndScaleStride, VkDeviceOrHostAddressConstKHR displacementVectorBuffer, VkDeviceSize displacementVectorStride, VkDeviceOrHostAddressConstKHR displacedMicromapPrimitiveFlags, VkDeviceSize displacedMicromapPrimitiveFlagsStride, VkIndexType indexType, VkDeviceOrHostAddressConstKHR indexBuffer, VkDeviceSize indexStride, uint32 baseTriangle, VulkanDuoSpan<VkMicromapUsageEXT, VkMicromapUsageEXT*> usageCounts_usageCounts = .(), VkMicromapEXT micromap = null) : this()
	{
		this.pNext = pNext;
		this.displacementBiasAndScaleFormat = displacementBiasAndScaleFormat;
		this.displacementVectorFormat = displacementVectorFormat;
		this.displacementBiasAndScaleBuffer = displacementBiasAndScaleBuffer;
		this.displacementBiasAndScaleStride = displacementBiasAndScaleStride;
		this.displacementVectorBuffer = displacementVectorBuffer;
		this.displacementVectorStride = displacementVectorStride;
		this.displacedMicromapPrimitiveFlags = displacedMicromapPrimitiveFlags;
		this.displacedMicromapPrimitiveFlagsStride = displacedMicromapPrimitiveFlagsStride;
		this.indexType = indexType;
		this.indexBuffer = indexBuffer;
		this.indexStride = indexStride;
		this.baseTriangle = baseTriangle;
		this.usageCounts_usageCounts = usageCounts_usageCounts;
		this.micromap = micromap;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkDisplacementMicromapFormatNV : int32
{
	VK_64Triangles64BytesNV = 1,
	VK_256Triangles128BytesNV = 2,
	VK_1024Triangles128BytesNV = 3,
}

static { public const uint32 VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME = "VK_EXT_load_store_op_none"; }
static { public const uint32 VK_HUAWEI_CLUSTER_CULLING_SHADER_SPEC_VERSION = 3; }
static { public const c_char* VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME = "VK_HUAWEI_cluster_culling_shader"; }

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32 groupCountX, uint32 groupCountY, uint32 groupCountZ);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);

[CRepr] struct VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI
{
	public const VkStructureType SType = .VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 clustercullingShader;
	public VkBool32 multiviewClusterCullingShader;

	public this(void* pNext, VkBool32 clustercullingShader, VkBool32 multiviewClusterCullingShader)
	{
		this.pNext = pNext;
		this.clustercullingShader = clustercullingShader;
		this.multiviewClusterCullingShader = multiviewClusterCullingShader;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI
{
	public const VkStructureType SType = .VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32[3] maxWorkGroupCount;
	public uint32[3] maxWorkGroupSize;
	public uint32 maxOutputClusterCount;
	public VkDeviceSize indirectBufferOffsetAlignment;
}

[CRepr] struct VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI
{
	public const VkStructureType SType = .VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 clusterShadingRate;

	public this(void* pNext, VkBool32 clusterShadingRate)
	{
		this.pNext = pNext;
		this.clusterShadingRate = clusterShadingRate;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME = "VK_EXT_border_color_swizzle"; }

[CRepr] struct VkPhysicalDeviceBorderColorSwizzleFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceBorderColorSwizzleFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 borderColorSwizzle;
	public VkBool32 borderColorSwizzleFromImage;

	public this(void* pNext, VkBool32 borderColorSwizzle, VkBool32 borderColorSwizzleFromImage)
	{
		this.pNext = pNext;
		this.borderColorSwizzle = borderColorSwizzle;
		this.borderColorSwizzleFromImage = borderColorSwizzleFromImage;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSamplerBorderColorComponentMappingCreateInfoEXT
{
	public const VkStructureType SType = .VkSamplerBorderColorComponentMappingCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkComponentMapping components;
	public VkBool32 srgb;

	public this(void* pNext, VkComponentMapping components, VkBool32 srgb)
	{
		this.pNext = pNext;
		this.components = components;
		this.srgb = srgb;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME = "VK_EXT_pageable_device_local_memory"; }

[CRepr] struct VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 pageableDeviceLocalMemory;

	public this(void* pNext, VkBool32 pageableDeviceLocalMemory)
	{
		this.pNext = pNext;
		this.pageableDeviceLocalMemory = pageableDeviceLocalMemory;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkSetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority);

static { public const uint32 VK_KHR_MAINTENANCE_4_SPEC_VERSION = 2; }
static { public const c_char* VK_KHR_MAINTENANCE_4_EXTENSION_NAME = "VK_KHR_maintenance4"; }

typealias VkPhysicalDeviceMaintenance4FeaturesKHR = VkPhysicalDeviceMaintenance4Features;
typealias VkPhysicalDeviceMaintenance4PropertiesKHR = VkPhysicalDeviceMaintenance4Properties;
typealias VkDeviceBufferMemoryRequirementsKHR = VkDeviceBufferMemoryRequirements;
typealias VkDeviceImageMemoryRequirementsKHR = VkDeviceImageMemoryRequirements;

static { public const uint32 VK_ARM_SHADER_CORE_PROPERTIES_SPEC_VERSION = 1; }
static { public const c_char* VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME = "VK_ARM_shader_core_properties"; }

[CRepr] struct VkPhysicalDeviceShaderCorePropertiesARM
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderCorePropertiesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 pixelRate;
	public uint32 texelRate;
	public uint32 fmaRate;
}

static { public const uint32 VK_KHR_SHADER_SUBGROUP_ROTATE_SPEC_VERSION = 2; }
static { public const c_char* VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME = "VK_KHR_shader_subgroup_rotate"; }

typealias VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR = VkPhysicalDeviceShaderSubgroupRotateFeatures;

static { public const uint32 VK_ARM_SCHEDULING_CONTROLS_SPEC_VERSION = 1; }
static { public const c_char* VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME = "VK_ARM_scheduling_controls"; }

[CRepr] struct VkDeviceQueueShaderCoreControlCreateInfoARM
{
	public const VkStructureType SType = .VkDeviceQueueShaderCoreControlCreateInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 shaderCoreCount;

	public this(void* pNext, uint32 shaderCoreCount)
	{
		this.pNext = pNext;
		this.shaderCoreCount = shaderCoreCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceSchedulingControlsFeaturesARM
{
	public const VkStructureType SType = .VkPhysicalDeviceSchedulingControlsFeaturesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 schedulingControls;

	public this(void* pNext, VkBool32 schedulingControls)
	{
		this.pNext = pNext;
		this.schedulingControls = schedulingControls;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceSchedulingControlsPropertiesARM
{
	public const VkStructureType SType = .VkPhysicalDeviceSchedulingControlsPropertiesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPhysicalDeviceSchedulingControlsFlagsARM schedulingControlsFlags;
}

typealias VkPhysicalDeviceSchedulingControlsFlagsARM = VkPhysicalDeviceSchedulingControlsFlagBitsARM;

[AllowDuplicates] enum VkPhysicalDeviceSchedulingControlsFlagBitsARM : int64
{
	ShaderCoreCountARM = 1 << 0,
}

static { public const uint32 VK_EXT_IMAGE_SLICED_VIEW_OF_3D_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME = "VK_EXT_image_sliced_view_of_3d"; }
static { public const uint32 VK_REMAINING_3D_SLICES_EXT = (.)(~0U); }

[CRepr] struct VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceImageSlicedViewOf3dFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 imageSlicedViewOf3D;

	public this(void* pNext, VkBool32 imageSlicedViewOf3D)
	{
		this.pNext = pNext;
		this.imageSlicedViewOf3D = imageSlicedViewOf3D;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkImageViewSlicedCreateInfoEXT
{
	public const VkStructureType SType = .VkImageViewSlicedCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 sliceOffset;
	public uint32 sliceCount;

	public this(void* pNext, uint32 sliceOffset, uint32 sliceCount)
	{
		this.pNext = pNext;
		this.sliceOffset = sliceOffset;
		this.sliceCount = sliceCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_SPEC_VERSION = 1; }
static { public const c_char* VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME = "VK_VALVE_descriptor_set_host_mapping"; }

[CRepr] struct VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE
{
	public const VkStructureType SType = .VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 descriptorSetHostMapping;

	public this(void* pNext, VkBool32 descriptorSetHostMapping)
	{
		this.pNext = pNext;
		this.descriptorSetHostMapping = descriptorSetHostMapping;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDescriptorSetBindingReferenceVALVE
{
	public const VkStructureType SType = .VkDescriptorSetBindingReferenceVALVE;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDescriptorSetLayout descriptorSetLayout;
	public uint32 binding;

	public this(void* pNext, VkDescriptorSetLayout descriptorSetLayout, uint32 binding)
	{
		this.pNext = pNext;
		this.descriptorSetLayout = descriptorSetLayout;
		this.binding = binding;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDescriptorSetLayoutHostMappingInfoVALVE
{
	public const VkStructureType SType = .VkDescriptorSetLayoutHostMappingInfoVALVE;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_size descriptorOffset;
	public uint32 descriptorSize;

	public this(void* pNext, c_size descriptorOffset, uint32 descriptorSize)
	{
		this.pNext = pNext;
		this.descriptorOffset = descriptorOffset;
		this.descriptorSize = descriptorSize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE(VkDevice device, VkDescriptorSetBindingReferenceVALVE* pBindingReference, out VkDescriptorSetLayoutHostMappingInfoVALVE pHostMapping);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, out void* ppData);

static { public const uint32 VK_EXT_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME = "VK_EXT_depth_clamp_zero_one"; }

typealias VkPhysicalDeviceDepthClampZeroOneFeaturesEXT = VkPhysicalDeviceDepthClampZeroOneFeaturesKHR;

static { public const uint32 VK_EXT_NON_SEAMLESS_CUBE_MAP_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME = "VK_EXT_non_seamless_cube_map"; }

[CRepr] struct VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 nonSeamlessCubeMap;

	public this(void* pNext, VkBool32 nonSeamlessCubeMap)
	{
		this.pNext = pNext;
		this.nonSeamlessCubeMap = nonSeamlessCubeMap;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_ARM_RENDER_PASS_STRIPED_SPEC_VERSION = 1; }
static { public const c_char* VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME = "VK_ARM_render_pass_striped"; }

[CRepr] struct VkPhysicalDeviceRenderPassStripedFeaturesARM
{
	public const VkStructureType SType = .VkPhysicalDeviceRenderPassStripedFeaturesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 renderPassStriped;

	public this(void* pNext, VkBool32 renderPassStriped)
	{
		this.pNext = pNext;
		this.renderPassStriped = renderPassStriped;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceRenderPassStripedPropertiesARM
{
	public const VkStructureType SType = .VkPhysicalDeviceRenderPassStripedPropertiesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExtent2D renderPassStripeGranularity;
	public uint32 maxRenderPassStripes;
}

[CRepr] struct VkRenderPassStripeBeginInfoARM
{
	public const VkStructureType SType = .VkRenderPassStripeBeginInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 stripeInfoCount;
	public VkRenderPassStripeInfoARM* pStripeInfos;
	public VulkanSpan<VkRenderPassStripeInfoARM> stripeInfos
	{
		[Inline] get => .(stripeInfoCount, pStripeInfos);
		[Inline] set mut { stripeInfoCount = value.count; pStripeInfos = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<VkRenderPassStripeInfoARM> stripeInfos) : this()
	{
		this.pNext = pNext;
		this.stripeInfos = stripeInfos;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkRenderPassStripeInfoARM
{
	public const VkStructureType SType = .VkRenderPassStripeInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRect2D stripeArea;

	public this(void* pNext, VkRect2D stripeArea)
	{
		this.pNext = pNext;
		this.stripeArea = stripeArea;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkRenderPassStripeSubmitInfoARM
{
	public const VkStructureType SType = .VkRenderPassStripeSubmitInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 stripeSemaphoreInfoCount;
	public VkSemaphoreSubmitInfo* pStripeSemaphoreInfos;
	public VulkanSpan<VkSemaphoreSubmitInfo> stripeSemaphoreInfos
	{
		[Inline] get => .(stripeSemaphoreInfoCount, pStripeSemaphoreInfos);
		[Inline] set mut { stripeSemaphoreInfoCount = value.count; pStripeSemaphoreInfos = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<VkSemaphoreSubmitInfo> stripeSemaphoreInfos) : this()
	{
		this.pNext = pNext;
		this.stripeSemaphoreInfos = stripeSemaphoreInfos;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION = 3; }
static { public const c_char* VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME = "VK_QCOM_fragment_density_map_offset"; }

typealias VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT;
typealias VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT;
typealias VkSubpassFragmentDensityMapOffsetEndInfoQCOM = VkRenderPassFragmentDensityMapOffsetEndInfoEXT;

static { public const uint32 VK_NV_COPY_MEMORY_INDIRECT_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME = "VK_NV_copy_memory_indirect"; }

[CRepr] struct VkCopyMemoryIndirectCommandNV
{
	public VkDeviceAddress srcAddress;
	public VkDeviceAddress dstAddress;
	public VkDeviceSize size; // Specified in bytes

	public this(VkDeviceAddress srcAddress, VkDeviceAddress dstAddress, VkDeviceSize size)
	{
		this.srcAddress = srcAddress;
		this.dstAddress = dstAddress;
		this.size = size;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkCopyMemoryToImageIndirectCommandNV
{
	public VkDeviceAddress srcAddress;
	public uint32 bufferRowLength; // Specified in texels
	public uint32 bufferImageHeight;
	public VkImageSubresourceLayers imageSubresource;
	public VkOffset3D imageOffset; // Specified in pixels for both compressed and uncompressed images
	public VkExtent3D imageExtent; // Specified in pixels for both compressed and uncompressed images

	public this(VkDeviceAddress srcAddress, uint32 bufferRowLength, uint32 bufferImageHeight, VkImageSubresourceLayers imageSubresource, VkOffset3D imageOffset, VkExtent3D imageExtent)
	{
		this.srcAddress = srcAddress;
		this.bufferRowLength = bufferRowLength;
		this.bufferImageHeight = bufferImageHeight;
		this.imageSubresource = imageSubresource;
		this.imageOffset = imageOffset;
		this.imageExtent = imageExtent;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkPhysicalDeviceCopyMemoryIndirectFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceCopyMemoryIndirectFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 indirectCopy;

	public this(void* pNext, VkBool32 indirectCopy)
	{
		this.pNext = pNext;
		this.indirectCopy = indirectCopy;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceCopyMemoryIndirectPropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceCopyMemoryIndirectPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkQueueFlags supportedQueues; // Bitfield of which queues are supported for indirect copy
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32 copyCount, uint32 stride);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32 copyCount, uint32 stride, VkImage dstImage, VkImageLayout dstImageLayout, VkImageSubresourceLayers* pImageSubresources);

static { public const uint32 VK_NV_MEMORY_DECOMPRESSION_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME = "VK_NV_memory_decompression"; }

[AllowDuplicates] enum VkMemoryDecompressionMethodFlagBitsNV : int64
{
	Gdeflate10NV = 1 << 0,
}

typealias VkMemoryDecompressionMethodFlagsNV = VkMemoryDecompressionMethodFlagBitsNV;

[CRepr] struct VkDecompressMemoryRegionNV
{
	public VkDeviceAddress srcAddress;
	public VkDeviceAddress dstAddress;
	public VkDeviceSize compressedSize; // Specified in bytes
	public VkDeviceSize decompressedSize; // Specified in bytes
	public VkMemoryDecompressionMethodFlagsNV decompressionMethod;

	public this(VkDeviceAddress srcAddress, VkDeviceAddress dstAddress, VkDeviceSize compressedSize, VkDeviceSize decompressedSize, VkMemoryDecompressionMethodFlagsNV decompressionMethod)
	{
		this.srcAddress = srcAddress;
		this.dstAddress = dstAddress;
		this.compressedSize = compressedSize;
		this.decompressedSize = decompressedSize;
		this.decompressionMethod = decompressionMethod;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkPhysicalDeviceMemoryDecompressionFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceMemoryDecompressionFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 memoryDecompression;

	public this(void* pNext, VkBool32 memoryDecompression)
	{
		this.pNext = pNext;
		this.memoryDecompression = memoryDecompression;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceMemoryDecompressionPropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceMemoryDecompressionPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkMemoryDecompressionMethodFlagsNV decompressionMethods;
	public uint64 maxDecompressionIndirectCount;
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32 decompressRegionCount, VkDecompressMemoryRegionNV* pDecompressMemoryRegions);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32 stride);

static { public const uint32 VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_SPEC_VERSION = 2; }
static { public const c_char* VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME = "VK_NV_device_generated_commands_compute"; }

[CRepr] struct VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 deviceGeneratedCompute;
	public VkBool32 deviceGeneratedComputePipelines;
	public VkBool32 deviceGeneratedComputeCaptureReplay;

	public this(void* pNext, VkBool32 deviceGeneratedCompute, VkBool32 deviceGeneratedComputePipelines, VkBool32 deviceGeneratedComputeCaptureReplay)
	{
		this.pNext = pNext;
		this.deviceGeneratedCompute = deviceGeneratedCompute;
		this.deviceGeneratedComputePipelines = deviceGeneratedComputePipelines;
		this.deviceGeneratedComputeCaptureReplay = deviceGeneratedComputeCaptureReplay;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkComputePipelineIndirectBufferInfoNV
{
	public const VkStructureType SType = .VkComputePipelineIndirectBufferInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceAddress deviceAddress;
	public VkDeviceSize size;
	public VkDeviceAddress pipelineDeviceAddressCaptureReplay;

	public this(void* pNext, VkDeviceAddress deviceAddress, VkDeviceSize size, VkDeviceAddress pipelineDeviceAddressCaptureReplay)
	{
		this.pNext = pNext;
		this.deviceAddress = deviceAddress;
		this.size = size;
		this.pipelineDeviceAddressCaptureReplay = pipelineDeviceAddressCaptureReplay;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineIndirectDeviceAddressInfoNV
{
	public const VkStructureType SType = .VkPipelineIndirectDeviceAddressInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineBindPoint pipelineBindPoint;
	public VkPipeline pipeline;

	public this(void* pNext, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline)
	{
		this.pNext = pNext;
		this.pipelineBindPoint = pipelineBindPoint;
		this.pipeline = pipeline;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBindPipelineIndirectCommandNV
{
	public VkDeviceAddress pipelineAddress;

	public this(VkDeviceAddress pipelineAddress)
	{
		this.pipelineAddress = pipelineAddress;
	}

	public this()
	{
		this = default;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPipelineIndirectMemoryRequirementsNV(VkDevice device, VkComputePipelineCreateInfo* pCreateInfo, out VkMemoryRequirements2 pMemoryRequirements);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
[CallingConvention(VKAPI_PTR)] function VkDeviceAddress PFN_vkGetPipelineIndirectDeviceAddressNV(VkDevice device, VkPipelineIndirectDeviceAddressInfoNV* pInfo);

static { public const uint32 VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME = "VK_NV_ray_tracing_linear_swept_spheres"; }

[CRepr] struct VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 spheres;
	public VkBool32 linearSweptSpheres;

	public this(void* pNext, VkBool32 spheres, VkBool32 linearSweptSpheres)
	{
		this.pNext = pNext;
		this.spheres = spheres;
		this.linearSweptSpheres = linearSweptSpheres;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAccelerationStructureGeometryLinearSweptSpheresDataNV
{
	public const VkStructureType SType = .VkAccelerationStructureGeometryLinearSweptSpheresDataNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat vertexFormat;
	public VkDeviceOrHostAddressConstKHR vertexData;
	public VkDeviceSize vertexStride;
	public VkFormat radiusFormat;
	public VkDeviceOrHostAddressConstKHR radiusData;
	public VkDeviceSize radiusStride;
	public VkIndexType indexType;
	public VkDeviceOrHostAddressConstKHR indexData;
	public VkDeviceSize indexStride;
	public VkRayTracingLssIndexingModeNV indexingMode;
	public VkRayTracingLssPrimitiveEndCapsModeNV endCapsMode;

	public this(void* pNext, VkFormat vertexFormat, VkDeviceOrHostAddressConstKHR vertexData, VkDeviceSize vertexStride, VkFormat radiusFormat, VkDeviceOrHostAddressConstKHR radiusData, VkDeviceSize radiusStride, VkIndexType indexType, VkDeviceOrHostAddressConstKHR indexData, VkDeviceSize indexStride, VkRayTracingLssIndexingModeNV indexingMode, VkRayTracingLssPrimitiveEndCapsModeNV endCapsMode)
	{
		this.pNext = pNext;
		this.vertexFormat = vertexFormat;
		this.vertexData = vertexData;
		this.vertexStride = vertexStride;
		this.radiusFormat = radiusFormat;
		this.radiusData = radiusData;
		this.radiusStride = radiusStride;
		this.indexType = indexType;
		this.indexData = indexData;
		this.indexStride = indexStride;
		this.indexingMode = indexingMode;
		this.endCapsMode = endCapsMode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAccelerationStructureGeometrySpheresDataNV
{
	public const VkStructureType SType = .VkAccelerationStructureGeometrySpheresDataNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat vertexFormat;
	public VkDeviceOrHostAddressConstKHR vertexData;
	public VkDeviceSize vertexStride;
	public VkFormat radiusFormat;
	public VkDeviceOrHostAddressConstKHR radiusData;
	public VkDeviceSize radiusStride;
	public VkIndexType indexType;
	public VkDeviceOrHostAddressConstKHR indexData;
	public VkDeviceSize indexStride;

	public this(void* pNext, VkFormat vertexFormat, VkDeviceOrHostAddressConstKHR vertexData, VkDeviceSize vertexStride, VkFormat radiusFormat, VkDeviceOrHostAddressConstKHR radiusData, VkDeviceSize radiusStride, VkIndexType indexType, VkDeviceOrHostAddressConstKHR indexData, VkDeviceSize indexStride)
	{
		this.pNext = pNext;
		this.vertexFormat = vertexFormat;
		this.vertexData = vertexData;
		this.vertexStride = vertexStride;
		this.radiusFormat = radiusFormat;
		this.radiusData = radiusData;
		this.radiusStride = radiusStride;
		this.indexType = indexType;
		this.indexData = indexData;
		this.indexStride = indexStride;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkRayTracingLssIndexingModeNV : int32
{
	ListNV = 0,
	SuccessiveNV = 1,
}

[AllowDuplicates] enum VkRayTracingLssPrimitiveEndCapsModeNV : int32
{
	NoneNV = 0,
	ChainedNV = 1,
}

static { public const uint32 VK_NV_LINEAR_COLOR_ATTACHMENT_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME = "VK_NV_linear_color_attachment"; }

[CRepr] struct VkPhysicalDeviceLinearColorAttachmentFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceLinearColorAttachmentFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 linearColorAttachment;

	public this(void* pNext, VkBool32 linearColorAttachment)
	{
		this.pNext = pNext;
		this.linearColorAttachment = linearColorAttachment;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_GOOGLE_SURFACELESS_QUERY_SPEC_VERSION = 2; }
static { public const c_char* VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME = "VK_GOOGLE_surfaceless_query"; }
static { public const uint32 VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME = "VK_KHR_shader_maximal_reconvergence"; }

[CRepr] struct VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderMaximalReconvergence;

	public this(void* pNext, VkBool32 shaderMaximalReconvergence)
	{
		this.pNext = pNext;
		this.shaderMaximalReconvergence = shaderMaximalReconvergence;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME = "VK_EXT_image_compression_control_swapchain"; }

[CRepr] struct VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 imageCompressionControlSwapchain;

	public this(void* pNext, VkBool32 imageCompressionControlSwapchain)
	{
		this.pNext = pNext;
		this.imageCompressionControlSwapchain = imageCompressionControlSwapchain;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_QCOM_IMAGE_PROCESSING_SPEC_VERSION = 1; }
static { public const c_char* VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME = "VK_QCOM_image_processing"; }

[CRepr] struct VkImageViewSampleWeightCreateInfoQCOM
{
	public const VkStructureType SType = .VkImageViewSampleWeightCreateInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkOffset2D filterCenter;
	public VkExtent2D filterSize;
	public uint32 numPhases;

	public this(void* pNext, VkOffset2D filterCenter, VkExtent2D filterSize, uint32 numPhases)
	{
		this.pNext = pNext;
		this.filterCenter = filterCenter;
		this.filterSize = filterSize;
		this.numPhases = numPhases;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceImageProcessingFeaturesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceImageProcessingFeaturesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 textureSampleWeighted;
	public VkBool32 textureBoxFilter;
	public VkBool32 textureBlockMatch;

	public this(void* pNext, VkBool32 textureSampleWeighted, VkBool32 textureBoxFilter, VkBool32 textureBlockMatch)
	{
		this.pNext = pNext;
		this.textureSampleWeighted = textureSampleWeighted;
		this.textureBoxFilter = textureBoxFilter;
		this.textureBlockMatch = textureBlockMatch;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceImageProcessingPropertiesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceImageProcessingPropertiesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxWeightFilterPhases;
	public VkExtent2D maxWeightFilterDimension;
	public VkExtent2D maxBlockMatchRegion;
	public VkExtent2D maxBoxFilterBlockSize;
}

static { public const uint32 VK_EXT_NESTED_COMMAND_BUFFER_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME = "VK_EXT_nested_command_buffer"; }

[CRepr] struct VkPhysicalDeviceNestedCommandBufferFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceNestedCommandBufferFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 nestedCommandBuffer;
	public VkBool32 nestedCommandBufferRendering;
	public VkBool32 nestedCommandBufferSimultaneousUse;

	public this(void* pNext, VkBool32 nestedCommandBuffer, VkBool32 nestedCommandBufferRendering, VkBool32 nestedCommandBufferSimultaneousUse)
	{
		this.pNext = pNext;
		this.nestedCommandBuffer = nestedCommandBuffer;
		this.nestedCommandBufferRendering = nestedCommandBufferRendering;
		this.nestedCommandBufferSimultaneousUse = nestedCommandBufferSimultaneousUse;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceNestedCommandBufferPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceNestedCommandBufferPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxCommandBufferNestingLevel;
}

static { public const uint32 VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME = "VK_EXT_external_memory_acquire_unmodified"; }

[CRepr] struct VkExternalMemoryAcquireUnmodifiedEXT
{
	public const VkStructureType SType = .VkExternalMemoryAcquireUnmodifiedEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 acquireUnmodifiedMemory;

	public this(void* pNext, VkBool32 acquireUnmodifiedMemory)
	{
		this.pNext = pNext;
		this.acquireUnmodifiedMemory = acquireUnmodifiedMemory;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_EXTENDED_DYNAMIC_STATE_3_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME = "VK_EXT_extended_dynamic_state3"; }

[CRepr] struct VkPhysicalDeviceExtendedDynamicState3FeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceExtendedDynamicState3FeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 extendedDynamicState3TessellationDomainOrigin;
	public VkBool32 extendedDynamicState3DepthClampEnable;
	public VkBool32 extendedDynamicState3PolygonMode;
	public VkBool32 extendedDynamicState3RasterizationSamples;
	public VkBool32 extendedDynamicState3SampleMask;
	public VkBool32 extendedDynamicState3AlphaToCoverageEnable;
	public VkBool32 extendedDynamicState3AlphaToOneEnable;
	public VkBool32 extendedDynamicState3LogicOpEnable;
	public VkBool32 extendedDynamicState3ColorBlendEnable;
	public VkBool32 extendedDynamicState3ColorBlendEquation;
	public VkBool32 extendedDynamicState3ColorWriteMask;
	public VkBool32 extendedDynamicState3RasterizationStream;
	public VkBool32 extendedDynamicState3ConservativeRasterizationMode;
	public VkBool32 extendedDynamicState3ExtraPrimitiveOverestimationSize;
	public VkBool32 extendedDynamicState3DepthClipEnable;
	public VkBool32 extendedDynamicState3SampleLocationsEnable;
	public VkBool32 extendedDynamicState3ColorBlendAdvanced;
	public VkBool32 extendedDynamicState3ProvokingVertexMode;
	public VkBool32 extendedDynamicState3LineRasterizationMode;
	public VkBool32 extendedDynamicState3LineStippleEnable;
	public VkBool32 extendedDynamicState3DepthClipNegativeOneToOne;
	public VkBool32 extendedDynamicState3ViewportWScalingEnable;
	public VkBool32 extendedDynamicState3ViewportSwizzle;
	public VkBool32 extendedDynamicState3CoverageToColorEnable;
	public VkBool32 extendedDynamicState3CoverageToColorLocation;
	public VkBool32 extendedDynamicState3CoverageModulationMode;
	public VkBool32 extendedDynamicState3CoverageModulationTableEnable;
	public VkBool32 extendedDynamicState3CoverageModulationTable;
	public VkBool32 extendedDynamicState3CoverageReductionMode;
	public VkBool32 extendedDynamicState3RepresentativeFragmentTestEnable;
	public VkBool32 extendedDynamicState3ShadingRateImageEnable;

	public this(void* pNext, VkBool32 extendedDynamicState3TessellationDomainOrigin, VkBool32 extendedDynamicState3DepthClampEnable, VkBool32 extendedDynamicState3PolygonMode, VkBool32 extendedDynamicState3RasterizationSamples, VkBool32 extendedDynamicState3SampleMask, VkBool32 extendedDynamicState3AlphaToCoverageEnable, VkBool32 extendedDynamicState3AlphaToOneEnable, VkBool32 extendedDynamicState3LogicOpEnable, VkBool32 extendedDynamicState3ColorBlendEnable, VkBool32 extendedDynamicState3ColorBlendEquation, VkBool32 extendedDynamicState3ColorWriteMask, VkBool32 extendedDynamicState3RasterizationStream, VkBool32 extendedDynamicState3ConservativeRasterizationMode, VkBool32 extendedDynamicState3ExtraPrimitiveOverestimationSize, VkBool32 extendedDynamicState3DepthClipEnable, VkBool32 extendedDynamicState3SampleLocationsEnable, VkBool32 extendedDynamicState3ColorBlendAdvanced, VkBool32 extendedDynamicState3ProvokingVertexMode, VkBool32 extendedDynamicState3LineRasterizationMode, VkBool32 extendedDynamicState3LineStippleEnable, VkBool32 extendedDynamicState3DepthClipNegativeOneToOne, VkBool32 extendedDynamicState3ViewportWScalingEnable, VkBool32 extendedDynamicState3ViewportSwizzle, VkBool32 extendedDynamicState3CoverageToColorEnable, VkBool32 extendedDynamicState3CoverageToColorLocation, VkBool32 extendedDynamicState3CoverageModulationMode, VkBool32 extendedDynamicState3CoverageModulationTableEnable, VkBool32 extendedDynamicState3CoverageModulationTable, VkBool32 extendedDynamicState3CoverageReductionMode, VkBool32 extendedDynamicState3RepresentativeFragmentTestEnable, VkBool32 extendedDynamicState3ShadingRateImageEnable)
	{
		this.pNext = pNext;
		this.extendedDynamicState3TessellationDomainOrigin = extendedDynamicState3TessellationDomainOrigin;
		this.extendedDynamicState3DepthClampEnable = extendedDynamicState3DepthClampEnable;
		this.extendedDynamicState3PolygonMode = extendedDynamicState3PolygonMode;
		this.extendedDynamicState3RasterizationSamples = extendedDynamicState3RasterizationSamples;
		this.extendedDynamicState3SampleMask = extendedDynamicState3SampleMask;
		this.extendedDynamicState3AlphaToCoverageEnable = extendedDynamicState3AlphaToCoverageEnable;
		this.extendedDynamicState3AlphaToOneEnable = extendedDynamicState3AlphaToOneEnable;
		this.extendedDynamicState3LogicOpEnable = extendedDynamicState3LogicOpEnable;
		this.extendedDynamicState3ColorBlendEnable = extendedDynamicState3ColorBlendEnable;
		this.extendedDynamicState3ColorBlendEquation = extendedDynamicState3ColorBlendEquation;
		this.extendedDynamicState3ColorWriteMask = extendedDynamicState3ColorWriteMask;
		this.extendedDynamicState3RasterizationStream = extendedDynamicState3RasterizationStream;
		this.extendedDynamicState3ConservativeRasterizationMode = extendedDynamicState3ConservativeRasterizationMode;
		this.extendedDynamicState3ExtraPrimitiveOverestimationSize = extendedDynamicState3ExtraPrimitiveOverestimationSize;
		this.extendedDynamicState3DepthClipEnable = extendedDynamicState3DepthClipEnable;
		this.extendedDynamicState3SampleLocationsEnable = extendedDynamicState3SampleLocationsEnable;
		this.extendedDynamicState3ColorBlendAdvanced = extendedDynamicState3ColorBlendAdvanced;
		this.extendedDynamicState3ProvokingVertexMode = extendedDynamicState3ProvokingVertexMode;
		this.extendedDynamicState3LineRasterizationMode = extendedDynamicState3LineRasterizationMode;
		this.extendedDynamicState3LineStippleEnable = extendedDynamicState3LineStippleEnable;
		this.extendedDynamicState3DepthClipNegativeOneToOne = extendedDynamicState3DepthClipNegativeOneToOne;
		this.extendedDynamicState3ViewportWScalingEnable = extendedDynamicState3ViewportWScalingEnable;
		this.extendedDynamicState3ViewportSwizzle = extendedDynamicState3ViewportSwizzle;
		this.extendedDynamicState3CoverageToColorEnable = extendedDynamicState3CoverageToColorEnable;
		this.extendedDynamicState3CoverageToColorLocation = extendedDynamicState3CoverageToColorLocation;
		this.extendedDynamicState3CoverageModulationMode = extendedDynamicState3CoverageModulationMode;
		this.extendedDynamicState3CoverageModulationTableEnable = extendedDynamicState3CoverageModulationTableEnable;
		this.extendedDynamicState3CoverageModulationTable = extendedDynamicState3CoverageModulationTable;
		this.extendedDynamicState3CoverageReductionMode = extendedDynamicState3CoverageReductionMode;
		this.extendedDynamicState3RepresentativeFragmentTestEnable = extendedDynamicState3RepresentativeFragmentTestEnable;
		this.extendedDynamicState3ShadingRateImageEnable = extendedDynamicState3ShadingRateImageEnable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceExtendedDynamicState3PropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceExtendedDynamicState3PropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 dynamicPrimitiveTopologyUnrestricted;
}

[CRepr] struct VkColorBlendEquationEXT
{
	public VkBlendFactor srcColorBlendFactor;
	public VkBlendFactor dstColorBlendFactor;
	public VkBlendOp colorBlendOp;
	public VkBlendFactor srcAlphaBlendFactor;
	public VkBlendFactor dstAlphaBlendFactor;
	public VkBlendOp alphaBlendOp;

	public this(VkBlendFactor srcColorBlendFactor, VkBlendFactor dstColorBlendFactor, VkBlendOp colorBlendOp, VkBlendFactor srcAlphaBlendFactor, VkBlendFactor dstAlphaBlendFactor, VkBlendOp alphaBlendOp)
	{
		this.srcColorBlendFactor = srcColorBlendFactor;
		this.dstColorBlendFactor = dstColorBlendFactor;
		this.colorBlendOp = colorBlendOp;
		this.srcAlphaBlendFactor = srcAlphaBlendFactor;
		this.dstAlphaBlendFactor = dstAlphaBlendFactor;
		this.alphaBlendOp = alphaBlendOp;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkColorBlendAdvancedEXT
{
	public VkBlendOp advancedBlendOp;
	public VkBool32 srcPremultiplied;
	public VkBool32 dstPremultiplied;
	public VkBlendOverlapEXT blendOverlap;
	public VkBool32 clampResults;

	public this(VkBlendOp advancedBlendOp, VkBool32 srcPremultiplied, VkBool32 dstPremultiplied, VkBlendOverlapEXT blendOverlap, VkBool32 clampResults)
	{
		this.advancedBlendOp = advancedBlendOp;
		this.srcPremultiplied = srcPremultiplied;
		this.dstPremultiplied = dstPremultiplied;
		this.blendOverlap = blendOverlap;
		this.clampResults = clampResults;
	}

	public this()
	{
		this = default;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, VkSampleMask* pSampleMask);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32 firstAttachment, uint32 attachmentCount, VkBool32* pColorBlendEnables);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32 firstAttachment, uint32 attachmentCount, VkColorBlendEquationEXT* pColorBlendEquations);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32 firstAttachment, uint32 attachmentCount, VkColorComponentFlags* pColorWriteMasks);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32 rasterizationStream);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32 firstAttachment, uint32 attachmentCount, VkColorBlendAdvancedEXT* pColorBlendAdvanced);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32 firstViewport, uint32 viewportCount, VkViewportSwizzleNV* pViewportSwizzles);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32 coverageToColorLocation);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32 coverageModulationTableCount, float* pCoverageModulationTable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode);

static { public const uint32 VK_EXT_SUBPASS_MERGE_FEEDBACK_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME = "VK_EXT_subpass_merge_feedback"; }

[CRepr] struct VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 subpassMergeFeedback;

	public this(void* pNext, VkBool32 subpassMergeFeedback)
	{
		this.pNext = pNext;
		this.subpassMergeFeedback = subpassMergeFeedback;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkRenderPassCreationControlEXT
{
	public const VkStructureType SType = .VkRenderPassCreationControlEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 disallowMerging;

	public this(void* pNext, VkBool32 disallowMerging)
	{
		this.pNext = pNext;
		this.disallowMerging = disallowMerging;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkRenderPassCreationFeedbackInfoEXT
{
	public uint32 postMergeSubpassCount;
}

[CRepr] struct VkRenderPassCreationFeedbackCreateInfoEXT
{
	public const VkStructureType SType = .VkRenderPassCreationFeedbackCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRenderPassCreationFeedbackInfoEXT* pRenderPassFeedback;

	public this(void* pNext, VkRenderPassCreationFeedbackInfoEXT* pRenderPassFeedback)
	{
		this.pNext = pNext;
		this.pRenderPassFeedback = pRenderPassFeedback;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkRenderPassSubpassFeedbackInfoEXT
{
	public VkSubpassMergeStatusEXT subpassMergeStatus;
	public c_char[VK_MAX_DESCRIPTION_SIZE] description;
	public uint32 postMergeIndex;
}

[CRepr] struct VkRenderPassSubpassFeedbackCreateInfoEXT
{
	public const VkStructureType SType = .VkRenderPassSubpassFeedbackCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRenderPassSubpassFeedbackInfoEXT* pSubpassFeedback;

	public this(void* pNext, VkRenderPassSubpassFeedbackInfoEXT* pSubpassFeedback)
	{
		this.pNext = pNext;
		this.pSubpassFeedback = pSubpassFeedback;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkSubpassMergeStatusEXT : int32
{
	MergedEXT = 0,
	DisallowedEXT = 1,
	NotMergedSideEffectsEXT = 2,
	NotMergedSamplesMismatchEXT = 3,
	NotMergedViewsMismatchEXT = 4,
	NotMergedAliasingEXT = 5,
	NotMergedDependenciesEXT = 6,
	NotMergedIncompatibleInputAttachmentEXT = 7,
	NotMergedTooManyAttachmentsEXT = 8,
	NotMergedInsufficientStorageEXT = 9,
	NotMergedDepthStencilCountEXT = 10,
	NotMergedResolveAttachmentReuseEXT = 11,
	NotMergedSingleSubpassEXT = 12,
	NotMergedUnspecifiedEXT = 13,
}

static { public const uint32 VK_LUNARG_DIRECT_DRIVER_LOADING_SPEC_VERSION = 1; }
static { public const c_char* VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME = "VK_LUNARG_direct_driver_loading"; }

typealias VkDirectDriverLoadingFlagsLUNARG = VkFlags;

[AllowDuplicates] enum VkDirectDriverLoadingModeLUNARG : int32
{
	ExclusiveLUNARG = 0,
	InclusiveLUNARG = 1,
}

[CRepr] struct VkDirectDriverLoadingInfoLUNARG
{
	public const VkStructureType SType = .VkDirectDriverLoadingInfoLUNARG;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDirectDriverLoadingFlagsLUNARG flags;
	public PFN_vkGetInstanceProcAddrLUNARG pfnGetInstanceProcAddr;

	public this(void* pNext, VkDirectDriverLoadingFlagsLUNARG flags, PFN_vkGetInstanceProcAddrLUNARG pfnGetInstanceProcAddr)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.pfnGetInstanceProcAddr = pfnGetInstanceProcAddr;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDirectDriverLoadingListLUNARG
{
	public const VkStructureType SType = .VkDirectDriverLoadingListLUNARG;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDirectDriverLoadingModeLUNARG mode;
	public uint32 driverCount;
	public VkDirectDriverLoadingInfoLUNARG* pDrivers;
	public VulkanSpan<VkDirectDriverLoadingInfoLUNARG> drivers
	{
		[Inline] get => .(driverCount, pDrivers);
		[Inline] set mut { driverCount = value.count; pDrivers = value.ptr; }
	}

	public this(void* pNext, VkDirectDriverLoadingModeLUNARG mode, VulkanSpan<VkDirectDriverLoadingInfoLUNARG> drivers) : this()
	{
		this.pNext = pNext;
		this.mode = mode;
		this.drivers = drivers;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function PFN_vkVoidFunction PFN_vkGetInstanceProcAddrLUNARG(VkInstance instance, c_char* pName);

static { public const uint32 VK_ARM_TENSORS_SPEC_VERSION = 1; }
static { public const c_char* VK_ARM_TENSORS_EXTENSION_NAME = "VK_ARM_tensors"; }

class VkTensorARM { private this() { } }
class VkTensorViewARM { private this() { } }

typealias VkTensorCreateFlagsARM = VkTensorCreateFlagBitsARM;

[AllowDuplicates] enum VkTensorCreateFlagBitsARM : int64
{
	MutableFormatARM = 1 << 0,
	ProtectedARM = 1 << 1,
	DescriptorBufferCaptureReplayARM = 1 << 2,
}

typealias VkTensorViewCreateFlagsARM = VkTensorViewCreateFlagBitsARM;

[AllowDuplicates] enum VkTensorViewCreateFlagBitsARM : int64
{
	DescriptorBufferCaptureReplayARM = 1 << 0,
}

typealias VkTensorUsageFlagsARM = VkTensorUsageFlagBitsARM;

[AllowDuplicates] enum VkTensorUsageFlagBitsARM : int64
{
	ShaderARM = 1 << 1, // Tensor written/read through shader descriptor
	TransferSrcARM = 1 << 2, // Tensor can be src of a transfer operation
	TransferDstARM = 1 << 3, // Tensor can be dst of a transfer operation
	ImageAliasingARM = 1 << 4, // Tensor can be aliased with an image
	DataGraphARM = 1 << 5,
}

[CRepr] struct VkTensorDescriptionARM
{
	public const VkStructureType SType = .VkTensorDescriptionARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTensorTilingARM tiling;
	public VkFormat format;
	public uint32 dimensionCount;
	public int64* pDimensions;
	public int64* pStrides;
	public VulkanDuoSpan<int64, int64> dimensions_strides
	{
		[Inline] get => .(dimensionCount, pDimensions, pStrides);
		[Inline] set mut { dimensionCount = value.count; pDimensions = value.ptr1; pStrides = value.ptr2; }
	}
	public VkTensorUsageFlagsARM usage;

	public this(void* pNext, VkTensorTilingARM tiling, VkFormat format, VulkanDuoSpan<int64, int64> dimensions_strides, VkTensorUsageFlagsARM usage) : this()
	{
		this.pNext = pNext;
		this.tiling = tiling;
		this.format = format;
		this.dimensions_strides = dimensions_strides;
		this.usage = usage;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkTensorTilingARM : int32
{
	OptimalARM = 0,
	LinearARM = 1,
}

[CRepr] struct VkTensorCreateInfoARM
{
	public const VkStructureType SType = .VkTensorCreateInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTensorCreateFlagsARM flags;
	public VkTensorDescriptionARM* pDescription;
	public VkSharingMode sharingMode;
	public uint32 queueFamilyIndexCount;
	public uint32* pQueueFamilyIndices;
	public VulkanSpan<uint32> queueFamilyIndices
	{
		[Inline] get => .(queueFamilyIndexCount, pQueueFamilyIndices);
		[Inline] set mut { queueFamilyIndexCount = value.count; pQueueFamilyIndices = value.ptr; }
	}

	public this(void* pNext, VkTensorCreateFlagsARM flags, VkTensorDescriptionARM* pDescription, VkSharingMode sharingMode, VulkanSpan<uint32> queueFamilyIndices = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.pDescription = pDescription;
		this.sharingMode = sharingMode;
		this.queueFamilyIndices = queueFamilyIndices;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkTensorViewCreateInfoARM
{
	public const VkStructureType SType = .VkTensorViewCreateInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTensorViewCreateFlagsARM flags;
	public VkTensorARM tensor;
	public VkFormat format;

	public this(void* pNext, VkTensorViewCreateFlagsARM flags, VkTensorARM tensor, VkFormat format)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.tensor = tensor;
		this.format = format;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkTensorMemoryRequirementsInfoARM
{
	public const VkStructureType SType = .VkTensorMemoryRequirementsInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTensorARM tensor;

	public this(void* pNext, VkTensorARM tensor)
	{
		this.pNext = pNext;
		this.tensor = tensor;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBindTensorMemoryInfoARM
{
	public const VkStructureType SType = .VkBindTensorMemoryInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTensorARM tensor;
	public VkDeviceMemory memory;
	public VkDeviceSize memoryOffset;

	public this(void* pNext, VkTensorARM tensor, VkDeviceMemory memory, VkDeviceSize memoryOffset)
	{
		this.pNext = pNext;
		this.tensor = tensor;
		this.memory = memory;
		this.memoryOffset = memoryOffset;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkWriteDescriptorSetTensorARM
{
	public const VkStructureType SType = .VkWriteDescriptorSetTensorARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 tensorViewCount;
	public VkTensorViewARM* pTensorViews;
	public VulkanSpan<VkTensorViewARM> tensorViews
	{
		[Inline] get => .(tensorViewCount, pTensorViews);
		[Inline] set mut { tensorViewCount = value.count; pTensorViews = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<VkTensorViewARM> tensorViews) : this()
	{
		this.pNext = pNext;
		this.tensorViews = tensorViews;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkTensorFormatPropertiesARM
{
	public const VkStructureType SType = .VkTensorFormatPropertiesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormatFeatureFlags2 optimalTilingTensorFeatures;
	public VkFormatFeatureFlags2 linearTilingTensorFeatures;
}

[CRepr] struct VkPhysicalDeviceTensorPropertiesARM
{
	public const VkStructureType SType = .VkPhysicalDeviceTensorPropertiesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxTensorDimensionCount;
	public uint64 maxTensorElements;
	public uint64 maxPerDimensionTensorElements;
	public int64 maxTensorStride;
	public uint64 maxTensorSize;
	public uint32 maxTensorShaderAccessArrayLength;
	public uint32 maxTensorShaderAccessSize;
	public uint32 maxDescriptorSetStorageTensors;
	public uint32 maxPerStageDescriptorSetStorageTensors;
	public uint32 maxDescriptorSetUpdateAfterBindStorageTensors;
	public uint32 maxPerStageDescriptorUpdateAfterBindStorageTensors;
	public VkBool32 shaderStorageTensorArrayNonUniformIndexingNative;
	public VkShaderStageFlags shaderTensorSupportedStages;
}

[CRepr] struct VkTensorMemoryBarrierARM
{
	public const VkStructureType SType = .VkTensorMemoryBarrierARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineStageFlags2 srcStageMask;
	public VkAccessFlags2 srcAccessMask;
	public VkPipelineStageFlags2 dstStageMask;
	public VkAccessFlags2 dstAccessMask;
	public uint32 srcQueueFamilyIndex;
	public uint32 dstQueueFamilyIndex;
	public VkTensorARM tensor;

	public this(void* pNext, VkPipelineStageFlags2 srcStageMask, VkAccessFlags2 srcAccessMask, VkPipelineStageFlags2 dstStageMask, VkAccessFlags2 dstAccessMask, uint32 srcQueueFamilyIndex, uint32 dstQueueFamilyIndex, VkTensorARM tensor)
	{
		this.pNext = pNext;
		this.srcStageMask = srcStageMask;
		this.srcAccessMask = srcAccessMask;
		this.dstStageMask = dstStageMask;
		this.dstAccessMask = dstAccessMask;
		this.srcQueueFamilyIndex = srcQueueFamilyIndex;
		this.dstQueueFamilyIndex = dstQueueFamilyIndex;
		this.tensor = tensor;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkTensorDependencyInfoARM
{
	public const VkStructureType SType = .VkTensorDependencyInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 tensorMemoryBarrierCount;
	public VkTensorMemoryBarrierARM* pTensorMemoryBarriers;

	public this(void* pNext, uint32 tensorMemoryBarrierCount, VkTensorMemoryBarrierARM* pTensorMemoryBarriers)
	{
		this.pNext = pNext;
		this.tensorMemoryBarrierCount = tensorMemoryBarrierCount;
		this.pTensorMemoryBarriers = pTensorMemoryBarriers;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceTensorFeaturesARM
{
	public const VkStructureType SType = .VkPhysicalDeviceTensorFeaturesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 tensorNonPacked;
	public VkBool32 shaderTensorAccess;
	public VkBool32 shaderStorageTensorArrayDynamicIndexing;
	public VkBool32 shaderStorageTensorArrayNonUniformIndexing;
	public VkBool32 descriptorBindingStorageTensorUpdateAfterBind;
	public VkBool32 tensors;

	public this(void* pNext, VkBool32 tensorNonPacked, VkBool32 shaderTensorAccess, VkBool32 shaderStorageTensorArrayDynamicIndexing, VkBool32 shaderStorageTensorArrayNonUniformIndexing, VkBool32 descriptorBindingStorageTensorUpdateAfterBind, VkBool32 tensors)
	{
		this.pNext = pNext;
		this.tensorNonPacked = tensorNonPacked;
		this.shaderTensorAccess = shaderTensorAccess;
		this.shaderStorageTensorArrayDynamicIndexing = shaderStorageTensorArrayDynamicIndexing;
		this.shaderStorageTensorArrayNonUniformIndexing = shaderStorageTensorArrayNonUniformIndexing;
		this.descriptorBindingStorageTensorUpdateAfterBind = descriptorBindingStorageTensorUpdateAfterBind;
		this.tensors = tensors;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDeviceTensorMemoryRequirementsARM
{
	public const VkStructureType SType = .VkDeviceTensorMemoryRequirementsARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTensorCreateInfoARM* pCreateInfo;

	public this(void* pNext, VkTensorCreateInfoARM* pCreateInfo)
	{
		this.pNext = pNext;
		this.pCreateInfo = pCreateInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCopyTensorInfoARM
{
	public const VkStructureType SType = .VkCopyTensorInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTensorARM srcTensor;
	public VkTensorARM dstTensor;
	public uint32 regionCount;
	public VkTensorCopyARM* pRegions;
	public VulkanSpan<VkTensorCopyARM> regions
	{
		[Inline] get => .(regionCount, pRegions);
		[Inline] set mut { regionCount = value.count; pRegions = value.ptr; }
	}

	public this(void* pNext, VkTensorARM srcTensor, VkTensorARM dstTensor, VulkanSpan<VkTensorCopyARM> regions) : this()
	{
		this.pNext = pNext;
		this.srcTensor = srcTensor;
		this.dstTensor = dstTensor;
		this.regions = regions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkTensorCopyARM
{
	public const VkStructureType SType = .VkTensorCopyARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 dimensionCount;
	public uint64* pSrcOffset;
	public uint64* pDstOffset;
	public uint64* pExtent;
	public VulkanTrioSpan<uint64, uint64, uint64> srcOffset_dstOffset_extent
	{
		[Inline] get => .(dimensionCount, pSrcOffset, pDstOffset, pExtent);
		[Inline] set mut { dimensionCount = value.count; pSrcOffset = value.ptr1; pDstOffset = value.ptr2; pExtent = value.ptr3; }
	}

	public this(void* pNext, VulkanTrioSpan<uint64, uint64, uint64> srcOffset_dstOffset_extent = .()) : this()
	{
		this.pNext = pNext;
		this.srcOffset_dstOffset_extent = srcOffset_dstOffset_extent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryDedicatedAllocateInfoTensorARM
{
	public const VkStructureType SType = .VkMemoryDedicatedAllocateInfoTensorARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTensorARM tensor; // Tensor that this allocation will be bound to

	public this(void* pNext, VkTensorARM tensor)
	{
		this.pNext = pNext;
		this.tensor = tensor;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceExternalTensorInfoARM
{
	public const VkStructureType SType = .VkPhysicalDeviceExternalTensorInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTensorCreateFlagsARM flags;
	public VkTensorDescriptionARM* pDescription;
	public VkExternalMemoryHandleTypeFlagBits handleType;

	public this(void* pNext, VkTensorCreateFlagsARM flags, VkTensorDescriptionARM* pDescription, VkExternalMemoryHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.pDescription = pDescription;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExternalTensorPropertiesARM
{
	public const VkStructureType SType = .VkExternalTensorPropertiesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryProperties externalMemoryProperties;

	public this(void* pNext, VkExternalMemoryProperties externalMemoryProperties)
	{
		this.pNext = pNext;
		this.externalMemoryProperties = externalMemoryProperties;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExternalMemoryTensorCreateInfoARM
{
	public const VkStructureType SType = .VkExternalMemoryTensorCreateInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlags handleTypes;

	public this(void* pNext = null, VkExternalMemoryHandleTypeFlags handleTypes = 0)
	{
		this.pNext = pNext;
		this.handleTypes = handleTypes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateTensorARM(VkDevice device, VkTensorCreateInfoARM* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkTensorARM pTensor);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyTensorARM(VkDevice device, VkTensorARM tensor = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateTensorViewARM(VkDevice device, VkTensorViewCreateInfoARM* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkTensorViewARM pView);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyTensorViewARM(VkDevice device, VkTensorViewARM tensorView = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetTensorMemoryRequirementsARM(VkDevice device, VkTensorMemoryRequirementsInfoARM* pInfo, out VkMemoryRequirements2 pMemoryRequirements);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkBindTensorMemoryARM(VkDevice device, uint32 bindInfoCount, VkBindTensorMemoryInfoARM* pBindInfos);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDeviceTensorMemoryRequirementsARM(VkDevice device, VkDeviceTensorMemoryRequirementsARM* pInfo, out VkMemoryRequirements2 pMemoryRequirements);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdCopyTensorARM(VkCommandBuffer commandBuffer, VkCopyTensorInfoARM* pCopyTensorInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceExternalTensorPropertiesARM(VkPhysicalDevice physicalDevice, VkPhysicalDeviceExternalTensorInfoARM* pExternalTensorInfo, out VkExternalTensorPropertiesARM pExternalTensorProperties);

[CRepr] struct VkPhysicalDeviceDescriptorBufferTensorFeaturesARM
{
	public const VkStructureType SType = .VkPhysicalDeviceDescriptorBufferTensorFeaturesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 descriptorBufferTensorDescriptors;

	public this(void* pNext, VkBool32 descriptorBufferTensorDescriptors)
	{
		this.pNext = pNext;
		this.descriptorBufferTensorDescriptors = descriptorBufferTensorDescriptors;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceDescriptorBufferTensorPropertiesARM
{
	public const VkStructureType SType = .VkPhysicalDeviceDescriptorBufferTensorPropertiesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_size tensorCaptureReplayDescriptorDataSize;
	public c_size tensorViewCaptureReplayDescriptorDataSize;
	public c_size tensorDescriptorSize;

	public this(void* pNext, c_size tensorCaptureReplayDescriptorDataSize, c_size tensorViewCaptureReplayDescriptorDataSize, c_size tensorDescriptorSize)
	{
		this.pNext = pNext;
		this.tensorCaptureReplayDescriptorDataSize = tensorCaptureReplayDescriptorDataSize;
		this.tensorViewCaptureReplayDescriptorDataSize = tensorViewCaptureReplayDescriptorDataSize;
		this.tensorDescriptorSize = tensorDescriptorSize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDescriptorGetTensorInfoARM
{
	public const VkStructureType SType = .VkDescriptorGetTensorInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTensorViewARM tensorView;

	public this(void* pNext, VkTensorViewARM tensorView)
	{
		this.pNext = pNext;
		this.tensorView = tensorView;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkTensorCaptureDescriptorDataInfoARM
{
	public const VkStructureType SType = .VkTensorCaptureDescriptorDataInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTensorARM tensor;

	public this(void* pNext, VkTensorARM tensor)
	{
		this.pNext = pNext;
		this.tensor = tensor;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkTensorViewCaptureDescriptorDataInfoARM
{
	public const VkStructureType SType = .VkTensorViewCaptureDescriptorDataInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTensorViewARM tensorView;

	public this(void* pNext, VkTensorViewARM tensorView)
	{
		this.pNext = pNext;
		this.tensorView = tensorView;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetTensorOpaqueCaptureDescriptorDataARM(VkDevice device, VkTensorCaptureDescriptorDataInfoARM* pInfo, out void pData);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM(VkDevice device, VkTensorViewCaptureDescriptorDataInfoARM* pInfo, out void pData);

[CRepr] struct VkFrameBoundaryTensorsARM
{
	public const VkStructureType SType = .VkFrameBoundaryTensorsARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 tensorCount;
	public VkTensorARM* pTensors;
	public VulkanSpan<VkTensorARM> tensors
	{
		[Inline] get => .(tensorCount, pTensors);
		[Inline] set mut { tensorCount = value.count; pTensors = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<VkTensorARM> tensors) : this()
	{
		this.pNext = pNext;
		this.tensors = tensors;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_SHADER_MODULE_IDENTIFIER_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME = "VK_EXT_shader_module_identifier"; }
static { public const uint32 VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT = 32; }

[CRepr] struct VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderModuleIdentifier;

	public this(void* pNext, VkBool32 shaderModuleIdentifier)
	{
		this.pNext = pNext;
		this.shaderModuleIdentifier = shaderModuleIdentifier;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint8[VK_UUID_SIZE] shaderModuleIdentifierAlgorithmUUID;
}

[CRepr] struct VkPipelineShaderStageModuleIdentifierCreateInfoEXT
{
	public const VkStructureType SType = .VkPipelineShaderStageModuleIdentifierCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 identifierSize;
	public uint8* pIdentifier;
	public VulkanSpan<uint8> identifier
	{
		[Inline] get => .(identifierSize, pIdentifier);
		[Inline] set mut { identifierSize = value.count; pIdentifier = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<uint8> identifier = .()) : this()
	{
		this.pNext = pNext;
		this.identifier = identifier;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkShaderModuleIdentifierEXT
{
	public const VkStructureType SType = .VkShaderModuleIdentifierEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 identifierSize;
	public uint8[VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT] identifier;
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, out VkShaderModuleIdentifierEXT pIdentifier);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetShaderModuleCreateInfoIdentifierEXT(VkDevice device, VkShaderModuleCreateInfo* pCreateInfo, out VkShaderModuleIdentifierEXT pIdentifier);

static { public const uint32 VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME = "VK_EXT_rasterization_order_attachment_access"; }

[CRepr] struct VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 rasterizationOrderColorAttachmentAccess;
	public VkBool32 rasterizationOrderDepthAttachmentAccess;
	public VkBool32 rasterizationOrderStencilAttachmentAccess;

	public this(void* pNext, VkBool32 rasterizationOrderColorAttachmentAccess, VkBool32 rasterizationOrderDepthAttachmentAccess, VkBool32 rasterizationOrderStencilAttachmentAccess)
	{
		this.pNext = pNext;
		this.rasterizationOrderColorAttachmentAccess = rasterizationOrderColorAttachmentAccess;
		this.rasterizationOrderDepthAttachmentAccess = rasterizationOrderDepthAttachmentAccess;
		this.rasterizationOrderStencilAttachmentAccess = rasterizationOrderStencilAttachmentAccess;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkPipelineColorBlendStateCreateFlagBits : int32
{
	RasterizationOrderAttachmentAccessARM = RasterizationOrderAttachmentAccessEXT,
	RasterizationOrderAttachmentAccessEXT = 1 << 0,
}

[AllowDuplicates] enum VkPipelineDepthStencilStateCreateFlagBits : int32
{
	RasterizationOrderAttachmentDepthAccessARM = RasterizationOrderAttachmentDepthAccessEXT,
	RasterizationOrderAttachmentStencilAccessARM = RasterizationOrderAttachmentStencilAccessEXT,
	RasterizationOrderAttachmentDepthAccessEXT = 1 << 0,
	RasterizationOrderAttachmentStencilAccessEXT = 1 << 1,
}

static { public const uint32 VK_NV_OPTICAL_FLOW_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_OPTICAL_FLOW_EXTENSION_NAME = "VK_NV_optical_flow"; }

[CRepr] struct VkPhysicalDeviceOpticalFlowFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceOpticalFlowFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 opticalFlow;

	public this(void* pNext, VkBool32 opticalFlow)
	{
		this.pNext = pNext;
		this.opticalFlow = opticalFlow;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceOpticalFlowPropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceOpticalFlowPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkOpticalFlowGridSizeFlagsNV supportedOutputGridSizes;
	public VkOpticalFlowGridSizeFlagsNV supportedHintGridSizes;
	public VkBool32 hintSupported;
	public VkBool32 costSupported;
	public VkBool32 bidirectionalFlowSupported;
	public VkBool32 globalFlowSupported;
	public uint32 minWidth;
	public uint32 minHeight;
	public uint32 maxWidth;
	public uint32 maxHeight;
	public uint32 maxNumRegionsOfInterest;
}

[AllowDuplicates] enum VkOpticalFlowUsageFlagBitsNV : int32
{
	UnknownNV = 0,
	InputNV = 1 << 0,
	OutputNV = 1 << 1,
	HintNV = 1 << 2,
	CostNV = 1 << 3,
	GlobalFlowNV = 1 << 4,
}

typealias VkOpticalFlowUsageFlagsNV = VkOpticalFlowUsageFlagBitsNV;

[CRepr] struct VkOpticalFlowImageFormatInfoNV
{
	public const VkStructureType SType = .VkOpticalFlowImageFormatInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkOpticalFlowUsageFlagsNV usage;

	public this(void* pNext, VkOpticalFlowUsageFlagsNV usage)
	{
		this.pNext = pNext;
		this.usage = usage;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkOpticalFlowImageFormatPropertiesNV
{
	public const VkStructureType SType = .VkOpticalFlowImageFormatPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat format;
}

[AllowDuplicates] enum VkOpticalFlowGridSizeFlagBitsNV : int32
{
	UnknownNV = 0,
	VK_1x1NV = 1 << 0,
	VK_2x2NV = 1 << 1,
	VK_4x4NV = 1 << 2,
	VK_8x8NV = 1 << 3,
}

typealias VkOpticalFlowGridSizeFlagsNV = VkOpticalFlowGridSizeFlagBitsNV;

[AllowDuplicates] enum VkOpticalFlowPerformanceLevelNV : int32
{
	UnknownNV = 0,
	SlowNV = 1,
	MediumNV = 2,
	FastNV = 3,
}

[AllowDuplicates] enum VkOpticalFlowSessionBindingPointNV : int32
{
	UnknownNV = 0,
	InputNV = 1,
	ReferenceNV = 2,
	HintNV = 3,
	FlowVectorNV = 4,
	BackwardFlowVectorNV = 5,
	CostNV = 6,
	BackwardCostNV = 7,
	GlobalFlowNV = 8,
}

[AllowDuplicates] enum VkOpticalFlowSessionCreateFlagBitsNV : int32
{
	EnableHintNV = 1 << 0,
	EnableCostNV = 1 << 1,
	EnableGlobalFlowNV = 1 << 2,
	AllowRegionsNV = 1 << 3,
	BothDirectionsNV = 1 << 4,
}

typealias VkOpticalFlowSessionCreateFlagsNV = VkOpticalFlowSessionCreateFlagBitsNV;

[AllowDuplicates] enum VkOpticalFlowExecuteFlagBitsNV : int32
{
	DisableTemporalHintsNV = 1 << 0,
}

typealias VkOpticalFlowExecuteFlagsNV = VkOpticalFlowExecuteFlagBitsNV;

class VkOpticalFlowSessionNV { private this() { } }

[CRepr] struct VkOpticalFlowSessionCreateInfoNV
{
	public const VkStructureType SType = .VkOpticalFlowSessionCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 width;
	public uint32 height;
	public VkFormat imageFormat;
	public VkFormat flowVectorFormat;
	public VkFormat costFormat;
	public VkOpticalFlowGridSizeFlagsNV outputGridSize;
	public VkOpticalFlowGridSizeFlagsNV hintGridSize;
	public VkOpticalFlowPerformanceLevelNV performanceLevel;
	public VkOpticalFlowSessionCreateFlagsNV flags;

	public this(void* pNext, uint32 width, uint32 height, VkFormat imageFormat, VkFormat flowVectorFormat, VkFormat costFormat, VkOpticalFlowGridSizeFlagsNV outputGridSize, VkOpticalFlowGridSizeFlagsNV hintGridSize = 0, VkOpticalFlowPerformanceLevelNV performanceLevel = 0, VkOpticalFlowSessionCreateFlagsNV flags = 0)
	{
		this.pNext = pNext;
		this.width = width;
		this.height = height;
		this.imageFormat = imageFormat;
		this.flowVectorFormat = flowVectorFormat;
		this.costFormat = costFormat;
		this.outputGridSize = outputGridSize;
		this.hintGridSize = hintGridSize;
		this.performanceLevel = performanceLevel;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkOpticalFlowSessionCreatePrivateDataInfoNV
{
	// NV internal use only
	public const VkStructureType SType = .VkOpticalFlowSessionCreatePrivateDataInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 id;
	public uint32 size;
	public void* pPrivateData;

	public this(void* pNext, uint32 id, uint32 size, void* pPrivateData)
	{
		this.pNext = pNext;
		this.id = id;
		this.size = size;
		this.pPrivateData = pPrivateData;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkOpticalFlowExecuteInfoNV
{
	public const VkStructureType SType = .VkOpticalFlowExecuteInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkOpticalFlowExecuteFlagsNV flags;
	public uint32 regionCount;
	public VkRect2D* pRegions;
	public VulkanSpan<VkRect2D> regions
	{
		[Inline] get => .(regionCount, pRegions);
		[Inline] set mut { regionCount = value.count; pRegions = value.ptr; }
	}

	public this(void* pNext = null, VkOpticalFlowExecuteFlagsNV flags = 0, VulkanSpan<VkRect2D> regions = .()) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.regions = regions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, out uint32 pFormatCount, VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionCreateInfoNV* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkOpticalFlowSessionNV pSession);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkBindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, VkOpticalFlowExecuteInfoNV* pExecuteInfo);

static { public const uint32 VK_EXT_LEGACY_DITHERING_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_LEGACY_DITHERING_EXTENSION_NAME = "VK_EXT_legacy_dithering"; }

[CRepr] struct VkPhysicalDeviceLegacyDitheringFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceLegacyDitheringFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 legacyDithering;

	public this(void* pNext, VkBool32 legacyDithering)
	{
		this.pNext = pNext;
		this.legacyDithering = legacyDithering;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_PIPELINE_PROTECTED_ACCESS_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME = "VK_EXT_pipeline_protected_access"; }

typealias VkPhysicalDevicePipelineProtectedAccessFeaturesEXT = VkPhysicalDevicePipelineProtectedAccessFeatures;

static { public const uint32 VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_SPEC_VERSION = 1; }
static { public const c_char* VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_EXTENSION_NAME = "VK_ANDROID_external_format_resolve"; }

[CRepr] struct VkPhysicalDeviceExternalFormatResolveFeaturesANDROID
{
	public const VkStructureType SType = .VkPhysicalDeviceExternalFormatResolveFeaturesANDROID;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 externalFormatResolve;

	public this(void* pNext, VkBool32 externalFormatResolve)
	{
		this.pNext = pNext;
		this.externalFormatResolve = externalFormatResolve;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceExternalFormatResolvePropertiesANDROID
{
	public const VkStructureType SType = .VkPhysicalDeviceExternalFormatResolvePropertiesANDROID;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 nullColorAttachmentWithExternalFormatResolve;
	public VkChromaLocation externalFormatResolveChromaOffsetX;
	public VkChromaLocation externalFormatResolveChromaOffsetY;
}

[CRepr] struct VkAndroidHardwareBufferFormatResolvePropertiesANDROID
{
	public const VkStructureType SType = .VkAndroidHardwareBufferFormatResolvePropertiesANDROID;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat colorAttachmentFormat;
}

static { public const uint32 VK_KHR_MAINTENANCE_5_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_MAINTENANCE_5_EXTENSION_NAME = "VK_KHR_maintenance5"; }

typealias VkPhysicalDeviceMaintenance5FeaturesKHR = VkPhysicalDeviceMaintenance5Features;
typealias VkPhysicalDeviceMaintenance5PropertiesKHR = VkPhysicalDeviceMaintenance5Properties;
typealias VkRenderingAreaInfoKHR = VkRenderingAreaInfo;
typealias VkDeviceImageSubresourceInfoKHR = VkDeviceImageSubresourceInfo;
typealias VkImageSubresource2KHR = VkImageSubresource2;
typealias VkSubresourceLayout2KHR = VkSubresourceLayout2;

// Split off new 64-bit flags separately, for the moment
typealias VkPipelineCreateFlags2KHR = VkPipelineCreateFlags2;
typealias VkPipelineCreateFlagBits2KHR = VkPipelineCreateFlagBits2;
typealias VkPipelineCreateFlags2CreateInfoKHR = VkPipelineCreateFlags2CreateInfo;
typealias VkBufferUsageFlags2KHR = VkBufferUsageFlags2;
typealias VkBufferUsageFlagBits2KHR = VkBufferUsageFlagBits2;
typealias VkBufferUsageFlags2CreateInfoKHR = VkBufferUsageFlags2CreateInfo;

static { public const uint32 VK_AMD_ANTI_LAG_SPEC_VERSION = 1; }
static { public const c_char* VK_AMD_ANTI_LAG_EXTENSION_NAME = "VK_AMD_anti_lag"; }

[CRepr] struct VkPhysicalDeviceAntiLagFeaturesAMD
{
	public const VkStructureType SType = .VkPhysicalDeviceAntiLagFeaturesAMD;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 antiLag;

	public this(void* pNext, VkBool32 antiLag)
	{
		this.pNext = pNext;
		this.antiLag = antiLag;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAntiLagDataAMD
{
	public const VkStructureType SType = .VkAntiLagDataAMD;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAntiLagModeAMD mode;
	public uint32 maxFPS;
	public VkAntiLagPresentationInfoAMD* pPresentationInfo;

	public this(void* pNext, VkAntiLagModeAMD mode, uint32 maxFPS, VkAntiLagPresentationInfoAMD* pPresentationInfo = null)
	{
		this.pNext = pNext;
		this.mode = mode;
		this.maxFPS = maxFPS;
		this.pPresentationInfo = pPresentationInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAntiLagPresentationInfoAMD
{
	public const VkStructureType SType = .VkAntiLagPresentationInfoAMD;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAntiLagStageAMD stage;
	public uint64 frameIndex;

	public this(void* pNext, VkAntiLagStageAMD stage, uint64 frameIndex)
	{
		this.pNext = pNext;
		this.stage = stage;
		this.frameIndex = frameIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkAntiLagModeAMD : int32
{
	DriverControlAMD = 0,
	OnAMD = 1,
	OffAMD = 2,
}

[AllowDuplicates] enum VkAntiLagStageAMD : int32
{
	InputAMD = 0,
	PresentAMD = 1,
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkAntiLagUpdateAMD(VkDevice device, VkAntiLagDataAMD* pData);

static { public const uint32 VK_KHR_PRESENT_ID_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_PRESENT_ID_2_EXTENSION_NAME = "VK_KHR_present_id2"; }

[CRepr] struct VkSurfaceCapabilitiesPresentId2KHR
{
	public const VkStructureType SType = .VkSurfaceCapabilitiesPresentId2KHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 presentId2Supported;

	public this(void* pNext, VkBool32 presentId2Supported)
	{
		this.pNext = pNext;
		this.presentId2Supported = presentId2Supported;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPresentId2KHR
{
	public const VkStructureType SType = .VkPresentId2KHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 swapchainCount; // Copy of VkPresentInfoKHR::swapchainCount
	public uint64* pPresentIds; // Present ID values for each swapchain
	public VulkanSpan<uint64> presentIds
	{
		[Inline] get => .(swapchainCount, pPresentIds);
		[Inline] set mut { swapchainCount = value.count; pPresentIds = value.ptr; }
	} // Present ID values for each swapchain

	public this(void* pNext, VulkanSpan<uint64> presentIds = .()) : this()
	{
		this.pNext = pNext;
		this.presentIds = presentIds;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDevicePresentId2FeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDevicePresentId2FeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 presentId2; // Present ID2 in VkPresentInfoKHR

	public this(void* pNext, VkBool32 presentId2)
	{
		this.pNext = pNext;
		this.presentId2 = presentId2;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_PRESENT_WAIT_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_PRESENT_WAIT_2_EXTENSION_NAME = "VK_KHR_present_wait2"; }

[CRepr] struct VkSurfaceCapabilitiesPresentWait2KHR
{
	public const VkStructureType SType = .VkSurfaceCapabilitiesPresentWait2KHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 presentWait2Supported;

	public this(void* pNext, VkBool32 presentWait2Supported)
	{
		this.pNext = pNext;
		this.presentWait2Supported = presentWait2Supported;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDevicePresentWait2FeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDevicePresentWait2FeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 presentWait2; // vkWaitForPresent2KHR is supported

	public this(void* pNext, VkBool32 presentWait2)
	{
		this.pNext = pNext;
		this.presentWait2 = presentWait2;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPresentWait2InfoKHR
{
	public const VkStructureType SType = .VkPresentWait2InfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 presentId;
	public uint64 timeout;

	public this(void* pNext, uint64 presentId, uint64 timeout)
	{
		this.pNext = pNext;
		this.presentId = presentId;
		this.timeout = timeout;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkWaitForPresent2KHR(VkDevice device, VkSwapchainKHR swapchain, VkPresentWait2InfoKHR* pPresentWait2Info);

static { public const uint32 VK_KHR_RAY_TRACING_POSITION_FETCH_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME = "VK_KHR_ray_tracing_position_fetch"; }

[CRepr] struct VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 rayTracingPositionFetch;

	public this(void* pNext, VkBool32 rayTracingPositionFetch)
	{
		this.pNext = pNext;
		this.rayTracingPositionFetch = rayTracingPositionFetch;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_SHADER_OBJECT_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SHADER_OBJECT_EXTENSION_NAME = "VK_EXT_shader_object"; }

class VkShaderEXT { private this() { } }

[AllowDuplicates] enum VkShaderCreateFlagBitsEXT : int32
{
	LinkStageEXT = 1 << 0,
	AllowVaryingSubgroupSizeEXT = 1 << 1,
	RequireFullSubgroupsEXT = 1 << 2,
	NoTaskShaderEXT = 1 << 3,
	DispatchBaseEXT = 1 << 4,
	FragmentShadingRateAttachmentEXT = 1 << 5,
	FragmentDensityMapAttachmentEXT = 1 << 6,
	IndirectBindableEXT = 1 << 7,
}

typealias VkShaderCreateFlagsEXT = VkShaderCreateFlagBitsEXT;

[AllowDuplicates] enum VkShaderCodeTypeEXT : int32
{
	BinaryEXT = 0,
	SpirvEXT = 1,
}

[CRepr] struct VkPhysicalDeviceShaderObjectFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderObjectFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderObject;

	public this(void* pNext, VkBool32 shaderObject)
	{
		this.pNext = pNext;
		this.shaderObject = shaderObject;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceShaderObjectPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderObjectPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint8[VK_UUID_SIZE] shaderBinaryUUID;
	public uint32 shaderBinaryVersion;
}

[CRepr] struct VkShaderCreateInfoEXT
{
	public const VkStructureType SType = .VkShaderCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkShaderCreateFlagsEXT flags;
	public VkShaderStageFlagBits stage;
	public VkShaderStageFlags nextStage;
	public VkShaderCodeTypeEXT codeType;
	public c_size codeSize;
	public void* pCode;
	public c_char* pName;
	public uint32 setLayoutCount;
	public VkDescriptorSetLayout* pSetLayouts;
	public VulkanSpan<VkDescriptorSetLayout> setLayouts
	{
		[Inline] get => .(setLayoutCount, pSetLayouts);
		[Inline] set mut { setLayoutCount = value.count; pSetLayouts = value.ptr; }
	}
	public uint32 pushConstantRangeCount;
	public VkPushConstantRange* pPushConstantRanges;
	public VulkanSpan<VkPushConstantRange> pushConstantRanges
	{
		[Inline] get => .(pushConstantRangeCount, pPushConstantRanges);
		[Inline] set mut { pushConstantRangeCount = value.count; pPushConstantRanges = value.ptr; }
	}
	public VkSpecializationInfo* pSpecializationInfo;

	public this(void* pNext, VkShaderCreateFlagsEXT flags, VkShaderStageFlagBits stage, VkShaderStageFlags nextStage, VkShaderCodeTypeEXT codeType, c_size codeSize, void* pCode, c_char* pName = null, VulkanSpan<VkDescriptorSetLayout> setLayouts = .(), VulkanSpan<VkPushConstantRange> pushConstantRanges = .(), VkSpecializationInfo* pSpecializationInfo = null) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.stage = stage;
		this.nextStage = nextStage;
		this.codeType = codeType;
		this.codeSize = codeSize;
		this.pCode = pCode;
		this.pName = pName;
		this.setLayouts = setLayouts;
		this.pushConstantRanges = pushConstantRanges;
		this.pSpecializationInfo = pSpecializationInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkShaderRequiredSubgroupSizeCreateInfoEXT = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateShadersEXT(VkDevice device, uint32 createInfoCount, VkShaderCreateInfoEXT* pCreateInfos, VkAllocationCallbacks* pAllocator, out VkShaderEXT pShaders);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyShaderEXT(VkDevice device, VkShaderEXT shader = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, out c_size pDataSize, out void pData);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32 stageCount, VkShaderStageFlagBits* pStages, VkShaderEXT* pShaders);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDepthClampRangeEXT(VkCommandBuffer commandBuffer, VkDepthClampModeEXT depthClampMode, VkDepthClampRangeEXT* pDepthClampRange = null);

static { public const uint32 VK_KHR_PIPELINE_BINARY_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_PIPELINE_BINARY_EXTENSION_NAME = "VK_KHR_pipeline_binary"; }
static { public const uint32 VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR = 32; }

[CRepr] struct VkPhysicalDevicePipelineBinaryFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDevicePipelineBinaryFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 pipelineBinaries;

	public this(void* pNext, VkBool32 pipelineBinaries)
	{
		this.pNext = pNext;
		this.pipelineBinaries = pipelineBinaries;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDevicePipelineBinaryPropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDevicePipelineBinaryPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 pipelineBinaryInternalCache;
	public VkBool32 pipelineBinaryInternalCacheControl;
	public VkBool32 pipelineBinaryPrefersInternalCache;
	public VkBool32 pipelineBinaryPrecompiledInternalCache;
	public VkBool32 pipelineBinaryCompressedData;
}

[CRepr] struct VkDevicePipelineBinaryInternalCacheControlKHR
{
	public const VkStructureType SType = .VkDevicePipelineBinaryInternalCacheControlKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 disableInternalCache;

	public this(void* pNext, VkBool32 disableInternalCache)
	{
		this.pNext = pNext;
		this.disableInternalCache = disableInternalCache;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

class VkPipelineBinaryKHR { private this() { } }

[CRepr] struct VkPipelineBinaryKeyKHR
{
	public const VkStructureType SType = .VkPipelineBinaryKeyKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 keySize;
	public uint8[VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR] key;

	public this(void* pNext, uint32 keySize, uint8[VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR] key)
	{
		this.pNext = pNext;
		this.keySize = keySize;
		this.key = key;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineBinaryDataKHR
{
	public c_size dataSize;
	public void* pData;

	public this(c_size dataSize, void* pData)
	{
		this.dataSize = dataSize;
		this.pData = pData;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkPipelineBinaryKeysAndDataKHR
{
	public uint32 binaryCount;
	public VkPipelineBinaryKeyKHR* pPipelineBinaryKeys;
	public VkPipelineBinaryDataKHR* pPipelineBinaryData;
	public VulkanDuoSpan<VkPipelineBinaryKeyKHR, VkPipelineBinaryDataKHR> pipelineBinaryKeys_pipelineBinaryData
	{
		[Inline] get => .(binaryCount, pPipelineBinaryKeys, pPipelineBinaryData);
		[Inline] set mut { binaryCount = value.count; pPipelineBinaryKeys = value.ptr1; pPipelineBinaryData = value.ptr2; }
	}

	public this(VulkanDuoSpan<VkPipelineBinaryKeyKHR, VkPipelineBinaryDataKHR> pipelineBinaryKeys_pipelineBinaryData) : this()
	{
		this.pipelineBinaryKeys_pipelineBinaryData = pipelineBinaryKeys_pipelineBinaryData;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkPipelineBinaryCreateInfoKHR
{
	public const VkStructureType SType = .VkPipelineBinaryCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineBinaryKeysAndDataKHR* pKeysAndDataInfo;
	public VkPipeline pipeline;
	public VkPipelineCreateInfoKHR* pPipelineCreateInfo;

	public this(void* pNext = null, VkPipelineBinaryKeysAndDataKHR* pKeysAndDataInfo = null, VkPipeline pipeline = null, VkPipelineCreateInfoKHR* pPipelineCreateInfo = null)
	{
		this.pNext = pNext;
		this.pKeysAndDataInfo = pKeysAndDataInfo;
		this.pipeline = pipeline;
		this.pPipelineCreateInfo = pPipelineCreateInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineBinaryInfoKHR
{
	public const VkStructureType SType = .VkPipelineBinaryInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 binaryCount;
	public VkPipelineBinaryKHR* pPipelineBinaries;
	public VulkanSpan<VkPipelineBinaryKHR> pipelineBinaries
	{
		[Inline] get => .(binaryCount, pPipelineBinaries);
		[Inline] set mut { binaryCount = value.count; pPipelineBinaries = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkPipelineBinaryKHR> pipelineBinaries = .()) : this()
	{
		this.pNext = pNext;
		this.pipelineBinaries = pipelineBinaries;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkReleaseCapturedPipelineDataInfoKHR
{
	public const VkStructureType SType = .VkReleaseCapturedPipelineDataInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipeline pipeline;

	public this(void* pNext, VkPipeline pipeline)
	{
		this.pNext = pNext;
		this.pipeline = pipeline;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineBinaryDataInfoKHR
{
	public const VkStructureType SType = .VkPipelineBinaryDataInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineBinaryKHR pipelineBinary;

	public this(void* pNext, VkPipelineBinaryKHR pipelineBinary)
	{
		this.pNext = pNext;
		this.pipelineBinary = pipelineBinary;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineCreateInfoKHR
{
	public const VkStructureType SType = .VkPipelineCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;

	public this(void* pNext = null)
	{
		this.pNext = pNext;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineBinaryHandlesInfoKHR
{
	public const VkStructureType SType = .VkPipelineBinaryHandlesInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 pipelineBinaryCount;
	public VkPipelineBinaryKHR* pPipelineBinaries;
	public VulkanSpan<VkPipelineBinaryKHR> pipelineBinaries
	{
		[Inline] get => .(pipelineBinaryCount, pPipelineBinaries);
		[Inline] set mut { pipelineBinaryCount = value.count; pPipelineBinaries = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<VkPipelineBinaryKHR> pipelineBinaries = .()) : this()
	{
		this.pNext = pNext;
		this.pipelineBinaries = pipelineBinaries;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreatePipelineBinariesKHR(VkDevice device, VkPipelineBinaryCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkPipelineBinaryHandlesInfoKHR pBinaries);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyPipelineBinaryKHR(VkDevice device, VkPipelineBinaryKHR pipelineBinary = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPipelineKeyKHR(VkDevice device, VkPipelineCreateInfoKHR* pPipelineCreateInfo, out VkPipelineBinaryKeyKHR pPipelineKey);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPipelineBinaryDataKHR(VkDevice device, VkPipelineBinaryDataInfoKHR* pInfo, out VkPipelineBinaryKeyKHR pPipelineBinaryKey, out c_size pPipelineBinaryDataSize, out void pPipelineBinaryData);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkReleaseCapturedPipelineDataKHR(VkDevice device, VkReleaseCapturedPipelineDataInfoKHR* pInfo, VkAllocationCallbacks* pAllocator = null);

static { public const uint32 VK_QCOM_TILE_PROPERTIES_SPEC_VERSION = 1; }
static { public const c_char* VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME = "VK_QCOM_tile_properties"; }

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, out uint32 pPropertiesCount, VkTilePropertiesQCOM* pProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDynamicRenderingTilePropertiesQCOM(VkDevice device, VkRenderingInfo* pRenderingInfo, out VkTilePropertiesQCOM pProperties);

[CRepr] struct VkPhysicalDeviceTilePropertiesFeaturesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceTilePropertiesFeaturesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 tileProperties;

	public this(void* pNext, VkBool32 tileProperties)
	{
		this.pNext = pNext;
		this.tileProperties = tileProperties;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkTilePropertiesQCOM
{
	public const VkStructureType SType = .VkTilePropertiesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExtent3D tileSize;
	public VkExtent2D apronSize;
	public VkOffset2D origin;

	public this(void* pNext, VkExtent3D tileSize, VkExtent2D apronSize, VkOffset2D origin)
	{
		this.pNext = pNext;
		this.tileSize = tileSize;
		this.apronSize = apronSize;
		this.origin = origin;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_SEC_AMIGO_PROFILING_SPEC_VERSION = 1; }
static { public const c_char* VK_SEC_AMIGO_PROFILING_EXTENSION_NAME = "VK_SEC_amigo_profiling"; }

[CRepr] struct VkPhysicalDeviceAmigoProfilingFeaturesSEC
{
	public const VkStructureType SType = .VkPhysicalDeviceAmigoProfilingFeaturesSEC;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 amigoProfiling;

	public this(void* pNext, VkBool32 amigoProfiling)
	{
		this.pNext = pNext;
		this.amigoProfiling = amigoProfiling;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAmigoProfilingSubmitInfoSEC
{
	public const VkStructureType SType = .VkAmigoProfilingSubmitInfoSEC;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 firstDrawTimestamp;
	public uint64 swapBufferTimestamp;

	public this(void* pNext, uint64 firstDrawTimestamp, uint64 swapBufferTimestamp)
	{
		this.pNext = pNext;
		this.firstDrawTimestamp = firstDrawTimestamp;
		this.swapBufferTimestamp = swapBufferTimestamp;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_SURFACE_MAINTENANCE_1_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SURFACE_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_surface_maintenance1"; }

[CRepr] struct VkSurfacePresentModeKHR
{
	public const VkStructureType SType = .VkSurfacePresentModeKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPresentModeKHR presentMode;

	public this(void* pNext, VkPresentModeKHR presentMode)
	{
		this.pNext = pNext;
		this.presentMode = presentMode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkPresentScalingFlagBitsKHR : int32
{
	OneToOneKHR = 1 << 0,
	VkPresentScalingOneToOneEXT = OneToOneKHR,
	AspectRatioStretchKHR = 1 << 1,
	VkPresentScalingAspectRatioStretchEXT = AspectRatioStretchKHR,
	StretchKHR = 1 << 2,
	VkPresentScalingStretchEXT = StretchKHR,
}

typealias VkPresentScalingFlagsKHR = VkPresentScalingFlagBitsKHR;

[AllowDuplicates] enum VkPresentGravityFlagBitsKHR : int32
{
	MinKHR = 1 << 0,
	VkPresentGravityMinEXT = MinKHR,
	MaxKHR = 1 << 1,
	VkPresentGravityMaxEXT = MaxKHR,
	CenteredKHR = 1 << 2,
	VkPresentGravityCenteredEXT = CenteredKHR,
}

typealias VkPresentGravityFlagsKHR = VkPresentGravityFlagBitsKHR;

[CRepr] struct VkSurfacePresentScalingCapabilitiesKHR
{
	public const VkStructureType SType = .VkSurfacePresentScalingCapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPresentScalingFlagsKHR supportedPresentScaling;
	public VkPresentGravityFlagsKHR supportedPresentGravityX;
	public VkPresentGravityFlagsKHR supportedPresentGravityY;
	public VkExtent2D minScaledImageExtent; // Supported minimum image width and height for the surface when scaling is used
	public VkExtent2D maxScaledImageExtent; // Supported maximum image width and height for the surface when scaling is used

	public this(void* pNext = null, VkPresentScalingFlagsKHR supportedPresentScaling = 0, VkPresentGravityFlagsKHR supportedPresentGravityX = 0, VkPresentGravityFlagsKHR supportedPresentGravityY = 0, VkExtent2D minScaledImageExtent = .(), VkExtent2D maxScaledImageExtent = .())
	{
		this.pNext = pNext;
		this.supportedPresentScaling = supportedPresentScaling;
		this.supportedPresentGravityX = supportedPresentGravityX;
		this.supportedPresentGravityY = supportedPresentGravityY;
		this.minScaledImageExtent = minScaledImageExtent;
		this.maxScaledImageExtent = maxScaledImageExtent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSurfacePresentModeCompatibilityKHR
{
	public const VkStructureType SType = .VkSurfacePresentModeCompatibilityKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 presentModeCount;
	public VkPresentModeKHR* pPresentModes; // Output list of present modes compatible with the one specified in VkSurfacePresentModeKHR
	public VulkanSpan<VkPresentModeKHR> presentModes
	{
		[Inline] get => .(presentModeCount, pPresentModes);
		[Inline] set mut { presentModeCount = value.count; pPresentModes = value.ptr; }
	} // Output list of present modes compatible with the one specified in VkSurfacePresentModeKHR

	public this(void* pNext = null, VulkanSpan<VkPresentModeKHR> presentModes = .()) : this()
	{
		this.pNext = pNext;
		this.presentModes = presentModes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_swapchain_maintenance1"; }

[CRepr] struct VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 swapchainMaintenance1;

	public this(void* pNext, VkBool32 swapchainMaintenance1)
	{
		this.pNext = pNext;
		this.swapchainMaintenance1 = swapchainMaintenance1;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSwapchainPresentFenceInfoKHR
{
	public const VkStructureType SType = .VkSwapchainPresentFenceInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 swapchainCount; // Copy of VkPresentInfoKHR::swapchainCount
	public VkFence* pFences; // Fence to signal for each swapchain
	public VulkanSpan<VkFence> fences
	{
		[Inline] get => .(swapchainCount, pFences);
		[Inline] set mut { swapchainCount = value.count; pFences = value.ptr; }
	} // Fence to signal for each swapchain

	public this(void* pNext, VulkanSpan<VkFence> fences) : this()
	{
		this.pNext = pNext;
		this.fences = fences;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSwapchainPresentModesCreateInfoKHR
{
	public const VkStructureType SType = .VkSwapchainPresentModesCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 presentModeCount;
	// Length of the pPresentModes array
	public VkPresentModeKHR* pPresentModes;
	public VulkanSpan<VkPresentModeKHR> presentModes
	{
		[Inline] get => .(presentModeCount, pPresentModes);
		[Inline] set mut { presentModeCount = value.count; pPresentModes = value.ptr; }
	}
	// Presentation modes which will be usable with this swapchain

	public this(void* pNext, VulkanSpan<VkPresentModeKHR> presentModes) : this()
	{
		this.pNext = pNext;
		this.presentModes = presentModes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSwapchainPresentModeInfoKHR
{
	public const VkStructureType SType = .VkSwapchainPresentModeInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 swapchainCount; // Copy of VkPresentInfoKHR::swapchainCount
	public VkPresentModeKHR* pPresentModes; // Presentation mode for each swapchain
	public VulkanSpan<VkPresentModeKHR> presentModes
	{
		[Inline] get => .(swapchainCount, pPresentModes);
		[Inline] set mut { swapchainCount = value.count; pPresentModes = value.ptr; }
	} // Presentation mode for each swapchain

	public this(void* pNext, VulkanSpan<VkPresentModeKHR> presentModes) : this()
	{
		this.pNext = pNext;
		this.presentModes = presentModes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSwapchainPresentScalingCreateInfoKHR
{
	public const VkStructureType SType = .VkSwapchainPresentScalingCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPresentScalingFlagsKHR scalingBehavior;
	public VkPresentGravityFlagsKHR presentGravityX;
	public VkPresentGravityFlagsKHR presentGravityY;

	public this(void* pNext = null, VkPresentScalingFlagsKHR scalingBehavior = 0, VkPresentGravityFlagsKHR presentGravityX = 0, VkPresentGravityFlagsKHR presentGravityY = 0)
	{
		this.pNext = pNext;
		this.scalingBehavior = scalingBehavior;
		this.presentGravityX = presentGravityX;
		this.presentGravityY = presentGravityY;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkReleaseSwapchainImagesInfoKHR
{
	public const VkStructureType SType = .VkReleaseSwapchainImagesInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSwapchainKHR swapchain; // Swapchain for which images are being released
	public uint32 imageIndexCount; // Number of indices to release
	public uint32* pImageIndices; // Indices of which presentable images to release
	public VulkanSpan<uint32> imageIndices
	{
		[Inline] get => .(imageIndexCount, pImageIndices);
		[Inline] set mut { imageIndexCount = value.count; pImageIndices = value.ptr; }
	} // Indices of which presentable images to release

	public this(void* pNext, VkSwapchainKHR swapchain, VulkanSpan<uint32> imageIndices) : this()
	{
		this.pNext = pNext;
		this.swapchain = swapchain;
		this.imageIndices = imageIndices;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkReleaseSwapchainImagesKHR(VkDevice device, VkReleaseSwapchainImagesInfoKHR* pReleaseInfo);

static { public const uint32 VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_SPEC_VERSION = 1; }
static { public const c_char* VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME = "VK_QCOM_multiview_per_view_viewports"; }

[CRepr] struct VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 multiviewPerViewViewports;

	public this(void* pNext, VkBool32 multiviewPerViewViewports)
	{
		this.pNext = pNext;
		this.multiviewPerViewViewports = multiviewPerViewViewports;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME = "VK_NV_ray_tracing_invocation_reorder"; }

[AllowDuplicates] enum VkRayTracingInvocationReorderModeNV : int32
{
	NoneNV = 0,
	ReorderNV = 1,
}

[CRepr] struct VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkRayTracingInvocationReorderModeNV rayTracingInvocationReorderReorderingHint;
}

[CRepr] struct VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 rayTracingInvocationReorder;

	public this(void* pNext, VkBool32 rayTracingInvocationReorder)
	{
		this.pNext = pNext;
		this.rayTracingInvocationReorder = rayTracingInvocationReorder;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_COOPERATIVE_VECTOR_SPEC_VERSION = 4; }
static { public const c_char* VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME = "VK_NV_cooperative_vector"; }

[CRepr] struct VkPhysicalDeviceCooperativeVectorPropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceCooperativeVectorPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkShaderStageFlags cooperativeVectorSupportedStages;
	public VkBool32 cooperativeVectorTrainingFloat16Accumulation;
	public VkBool32 cooperativeVectorTrainingFloat32Accumulation;
	public uint32 maxCooperativeVectorComponents;
}

[CRepr] struct VkPhysicalDeviceCooperativeVectorFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceCooperativeVectorFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 cooperativeVector;
	public VkBool32 cooperativeVectorTraining;

	public this(void* pNext, VkBool32 cooperativeVector, VkBool32 cooperativeVectorTraining)
	{
		this.pNext = pNext;
		this.cooperativeVector = cooperativeVector;
		this.cooperativeVectorTraining = cooperativeVectorTraining;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkCooperativeVectorPropertiesNV
{
	public const VkStructureType SType = .VkCooperativeVectorPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkComponentTypeKHR inputType;
	public VkComponentTypeKHR inputInterpretation;
	public VkComponentTypeKHR matrixInterpretation;
	public VkComponentTypeKHR biasInterpretation;
	public VkComponentTypeKHR resultType;
	public VkBool32 transpose;

	public this(void* pNext, VkComponentTypeKHR inputType, VkComponentTypeKHR inputInterpretation, VkComponentTypeKHR matrixInterpretation, VkComponentTypeKHR biasInterpretation, VkComponentTypeKHR resultType, VkBool32 transpose)
	{
		this.pNext = pNext;
		this.inputType = inputType;
		this.inputInterpretation = inputInterpretation;
		this.matrixInterpretation = matrixInterpretation;
		this.biasInterpretation = biasInterpretation;
		this.resultType = resultType;
		this.transpose = transpose;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkConvertCooperativeVectorMatrixInfoNV
{
	public const VkStructureType SType = .VkConvertCooperativeVectorMatrixInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_size srcSize;
	public VkDeviceOrHostAddressConstKHR srcData;
	public c_size* pDstSize;
	public VkDeviceOrHostAddressKHR dstData;
	public VkComponentTypeKHR srcComponentType;
	public VkComponentTypeKHR dstComponentType;
	public uint32 numRows;
	public uint32 numColumns;
	public VkCooperativeVectorMatrixLayoutNV srcLayout;
	public c_size srcStride;
	public VkCooperativeVectorMatrixLayoutNV dstLayout;
	public c_size dstStride;

	public this(void* pNext, c_size srcSize, VkDeviceOrHostAddressConstKHR srcData, c_size* pDstSize, VkDeviceOrHostAddressKHR dstData, VkComponentTypeKHR srcComponentType, VkComponentTypeKHR dstComponentType, uint32 numRows, uint32 numColumns, VkCooperativeVectorMatrixLayoutNV srcLayout, c_size srcStride, VkCooperativeVectorMatrixLayoutNV dstLayout, c_size dstStride)
	{
		this.pNext = pNext;
		this.srcSize = srcSize;
		this.srcData = srcData;
		this.pDstSize = pDstSize;
		this.dstData = dstData;
		this.srcComponentType = srcComponentType;
		this.dstComponentType = dstComponentType;
		this.numRows = numRows;
		this.numColumns = numColumns;
		this.srcLayout = srcLayout;
		this.srcStride = srcStride;
		this.dstLayout = dstLayout;
		this.dstStride = dstStride;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkCooperativeVectorMatrixLayoutNV : int32
{
	RowMajorNV = 0,
	ColumnMajorNV = 1,
	InferencingOptimalNV = 2,
	TrainingOptimalNV = 3,
}

[AllowDuplicates] enum VkComponentTypeKHR : int32
{
	Float16KHR = 0,
	Float32KHR = 1,
	Float64KHR = 2,
	Sint8KHR = 3,
	Sint16KHR = 4,
	Sint32KHR = 5,
	Sint64KHR = 6,
	Uint8KHR = 7,
	Uint16KHR = 8,
	Uint32KHR = 9,
	Uint64KHR = 10,
	Bfloat16KHR = 1000141000,
	VkComponentTypeFloat16NV = Float16KHR,
	VkComponentTypeFloat32NV = Float32KHR,
	VkComponentTypeFloat64NV = Float64KHR,
	VkComponentTypeSint8NV = Sint8KHR,
	VkComponentTypeSint16NV = Sint16KHR,
	VkComponentTypeSint32NV = Sint32KHR,
	VkComponentTypeSint64NV = Sint64KHR,
	VkComponentTypeUint8NV = Uint8KHR,
	VkComponentTypeUint16NV = Uint16KHR,
	VkComponentTypeUint32NV = Uint32KHR,
	VkComponentTypeUint64NV = Uint64KHR,
	VkComponentTypeSint8PackedNV = 1000491000,
	VkComponentTypeUint8PackedNV = 1000491001,
	VkComponentTypeFloatE4m3NV = VkComponentTypeFloat8E4m3EXT,
	VkComponentTypeFloatE5m2NV = VkComponentTypeFloat8E5m2EXT,
	VkComponentTypeFloat8E4m3EXT = 1000491002,
	VkComponentTypeFloat8E5m2EXT = 1000491003,
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDevice physicalDevice, out uint32 pPropertyCount, VkCooperativeVectorPropertiesNV* pProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkConvertCooperativeVectorMatrixNV(VkDevice device, VkConvertCooperativeVectorMatrixInfoNV* pInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdConvertCooperativeVectorMatrixNV(VkCommandBuffer commandBuffer, uint32 infoCount, VkConvertCooperativeVectorMatrixInfoNV* pInfos);

static { public const uint32 VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME = "VK_NV_extended_sparse_address_space"; }

[CRepr] struct VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 extendedSparseAddressSpace;

	public this(void* pNext, VkBool32 extendedSparseAddressSpace)
	{
		this.pNext = pNext;
		this.extendedSparseAddressSpace = extendedSparseAddressSpace;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize extendedSparseAddressSpaceSize; // Total address space available for extended sparse allocations (bytes)
	public VkImageUsageFlags extendedSparseImageUsageFlags; // Bitfield of which image usages are supported for extended sparse allocations
	public VkBufferUsageFlags extendedSparseBufferUsageFlags; // Bitfield of which buffer usages are supported for extended sparse allocations
}

static { public const uint32 VK_EXT_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME = "VK_EXT_mutable_descriptor_type"; }

[CRepr] struct VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 mutableDescriptorType;

	public this(void* pNext, VkBool32 mutableDescriptorType)
	{
		this.pNext = pNext;
		this.mutableDescriptorType = mutableDescriptorType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMutableDescriptorTypeListEXT
{
	public uint32 descriptorTypeCount;
	public VkDescriptorType* pDescriptorTypes;
	public VulkanSpan<VkDescriptorType> descriptorTypes
	{
		[Inline] get => .(descriptorTypeCount, pDescriptorTypes);
		[Inline] set mut { descriptorTypeCount = value.count; pDescriptorTypes = value.ptr; }
	}

	public this(VulkanSpan<VkDescriptorType> descriptorTypes = .()) : this()
	{
		this.descriptorTypes = descriptorTypes;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkMutableDescriptorTypeCreateInfoEXT
{
	public const VkStructureType SType = .VkMutableDescriptorTypeCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 mutableDescriptorTypeListCount;
	public VkMutableDescriptorTypeListEXT* pMutableDescriptorTypeLists;
	public VulkanSpan<VkMutableDescriptorTypeListEXT> mutableDescriptorTypeLists
	{
		[Inline] get => .(mutableDescriptorTypeListCount, pMutableDescriptorTypeLists);
		[Inline] set mut { mutableDescriptorTypeListCount = value.count; pMutableDescriptorTypeLists = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkMutableDescriptorTypeListEXT> mutableDescriptorTypeLists = .()) : this()
	{
		this.pNext = pNext;
		this.mutableDescriptorTypeLists = mutableDescriptorTypeLists;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_LEGACY_VERTEX_ATTRIBUTES_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_LEGACY_VERTEX_ATTRIBUTES_EXTENSION_NAME = "VK_EXT_legacy_vertex_attributes"; }

[CRepr] struct VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 legacyVertexAttributes;

	public this(void* pNext, VkBool32 legacyVertexAttributes)
	{
		this.pNext = pNext;
		this.legacyVertexAttributes = legacyVertexAttributes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 nativeUnalignedPerformance;
}

static { public const uint32 VK_EXT_LAYER_SETTINGS_SPEC_VERSION = 2; }
static { public const c_char* VK_EXT_LAYER_SETTINGS_EXTENSION_NAME = "VK_EXT_layer_settings"; }

[CRepr] struct VkLayerSettingsCreateInfoEXT
{
	public const VkStructureType SType = .VkLayerSettingsCreateInfoEXT;
	public VkStructureType sType = SType; // Must be VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT
	public void* pNext;
	public uint32 settingCount; // Number of settings to configure
	public VkLayerSettingEXT* pSettings; // Validation features to enable
	public VulkanSpan<VkLayerSettingEXT> settings
	{
		[Inline] get => .(settingCount, pSettings);
		[Inline] set mut { settingCount = value.count; pSettings = value.ptr; }
	} // Validation features to enable

	public this(void* pNext = null, VulkanSpan<VkLayerSettingEXT> settings = .()) : this()
	{
		this.pNext = pNext;
		this.settings = settings;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkLayerSettingEXT
{
	public c_char* pLayerName;
	public c_char* pSettingName;
	public VkLayerSettingTypeEXT type; // The type of the object
	public uint32 valueCount; // Number of values of the setting
	public void* pValues; // Values to pass for a setting

	public this(c_char* pLayerName, c_char* pSettingName, VkLayerSettingTypeEXT type, uint32 valueCount = 0, void* pValues = null)
	{
		this.pLayerName = pLayerName;
		this.pSettingName = pSettingName;
		this.type = type;
		this.valueCount = valueCount;
		this.pValues = pValues;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkLayerSettingTypeEXT : int32
{
	Bool32EXT = 0,
	Int32EXT = 1,
	Int64EXT = 2,
	Uint32EXT = 3,
	Uint64EXT = 4,
	Float32EXT = 5,
	Float64EXT = 6,
	StringEXT = 7,
}

static { public const uint32 VK_ARM_SHADER_CORE_BUILTINS_SPEC_VERSION = 2; }
static { public const c_char* VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME = "VK_ARM_shader_core_builtins"; }

[CRepr] struct VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderCoreBuiltins;

	public this(void* pNext, VkBool32 shaderCoreBuiltins)
	{
		this.pNext = pNext;
		this.shaderCoreBuiltins = shaderCoreBuiltins;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 shaderCoreMask;
	public uint32 shaderCoreCount;
	public uint32 shaderWarpsPerCore;
}

static { public const uint32 VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME = "VK_EXT_pipeline_library_group_handles"; }

[CRepr] struct VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 pipelineLibraryGroupHandles;

	public this(void* pNext, VkBool32 pipelineLibraryGroupHandles)
	{
		this.pNext = pNext;
		this.pipelineLibraryGroupHandles = pipelineLibraryGroupHandles;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME = "VK_EXT_dynamic_rendering_unused_attachments"; }

[CRepr] struct VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 dynamicRenderingUnusedAttachments;

	public this(void* pNext, VkBool32 dynamicRenderingUnusedAttachments)
	{
		this.pNext = pNext;
		this.dynamicRenderingUnusedAttachments = dynamicRenderingUnusedAttachments;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_LOW_LATENCY_2_SPEC_VERSION = 2; }
static { public const c_char* VK_NV_LOW_LATENCY_2_EXTENSION_NAME = "VK_NV_low_latency2"; }

[CRepr] struct VkLatencySleepModeInfoNV
{
	public const VkStructureType SType = .VkLatencySleepModeInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 lowLatencyMode;
	public VkBool32 lowLatencyBoost;
	public uint32 minimumIntervalUs;

	public this(void* pNext, VkBool32 lowLatencyMode, VkBool32 lowLatencyBoost, uint32 minimumIntervalUs)
	{
		this.pNext = pNext;
		this.lowLatencyMode = lowLatencyMode;
		this.lowLatencyBoost = lowLatencyBoost;
		this.minimumIntervalUs = minimumIntervalUs;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkLatencySleepInfoNV
{
	public const VkStructureType SType = .VkLatencySleepInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSemaphore signalSemaphore;
	public uint64 value;

	public this(void* pNext, VkSemaphore signalSemaphore, uint64 value)
	{
		this.pNext = pNext;
		this.signalSemaphore = signalSemaphore;
		this.value = value;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSetLatencyMarkerInfoNV
{
	public const VkStructureType SType = .VkSetLatencyMarkerInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 presentID;
	public VkLatencyMarkerNV marker;

	public this(void* pNext, uint64 presentID, VkLatencyMarkerNV marker)
	{
		this.pNext = pNext;
		this.presentID = presentID;
		this.marker = marker;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkGetLatencyMarkerInfoNV
{
	public const VkStructureType SType = .VkGetLatencyMarkerInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 timingCount;
	public VkLatencyTimingsFrameReportNV* pTimings;
	public VulkanSpan<VkLatencyTimingsFrameReportNV> timings
	{
		[Inline] get => .(timingCount, pTimings);
		[Inline] set mut { timingCount = value.count; pTimings = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkLatencyTimingsFrameReportNV> timings = .()) : this()
	{
		this.pNext = pNext;
		this.timings = timings;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkLatencyTimingsFrameReportNV
{
	public const VkStructureType SType = .VkLatencyTimingsFrameReportNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 presentID;
	public uint64 inputSampleTimeUs;
	public uint64 simStartTimeUs;
	public uint64 simEndTimeUs;
	public uint64 renderSubmitStartTimeUs;
	public uint64 renderSubmitEndTimeUs;
	public uint64 presentStartTimeUs;
	public uint64 presentEndTimeUs;
	public uint64 driverStartTimeUs;
	public uint64 driverEndTimeUs;
	public uint64 osRenderQueueStartTimeUs;
	public uint64 osRenderQueueEndTimeUs;
	public uint64 gpuRenderStartTimeUs;
	public uint64 gpuRenderEndTimeUs;
}

[AllowDuplicates] enum VkLatencyMarkerNV : int32
{
	SimulationStartNV = 0,
	SimulationEndNV = 1,
	RendersubmitStartNV = 2,
	RendersubmitEndNV = 3,
	PresentStartNV = 4,
	PresentEndNV = 5,
	InputSampleNV = 6,
	TriggerFlashNV = 7,
	OutOfBandRendersubmitStartNV = 8,
	OutOfBandRendersubmitEndNV = 9,
	OutOfBandPresentStartNV = 10,
	OutOfBandPresentEndNV = 11,
}

[CRepr] struct VkLatencySubmissionPresentIdNV
{
	public const VkStructureType SType = .VkLatencySubmissionPresentIdNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 presentID;

	public this(void* pNext, uint64 presentID)
	{
		this.pNext = pNext;
		this.presentID = presentID;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSwapchainLatencyCreateInfoNV
{
	public const VkStructureType SType = .VkSwapchainLatencyCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 latencyModeEnable;

	public this(void* pNext = null, VkBool32 latencyModeEnable = 0)
	{
		this.pNext = pNext;
		this.latencyModeEnable = latencyModeEnable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkOutOfBandQueueTypeInfoNV
{
	public const VkStructureType SType = .VkOutOfBandQueueTypeInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkOutOfBandQueueTypeNV queueType;

	public this(void* pNext, VkOutOfBandQueueTypeNV queueType)
	{
		this.pNext = pNext;
		this.queueType = queueType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkOutOfBandQueueTypeNV : int32
{
	RenderNV = 0,
	PresentNV = 1,
}

[CRepr] struct VkLatencySurfaceCapabilitiesNV
{
	public const VkStructureType SType = .VkLatencySurfaceCapabilitiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 presentModeCount;
	public VkPresentModeKHR* pPresentModes;
	public VulkanSpan<VkPresentModeKHR> presentModes
	{
		[Inline] get => .(presentModeCount, pPresentModes);
		[Inline] set mut { presentModeCount = value.count; pPresentModes = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkPresentModeKHR> presentModes = .()) : this()
	{
		this.pNext = pNext;
		this.presentModes = presentModes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkSetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain, VkLatencySleepModeInfoNV* pSleepModeInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkLatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, VkLatencySleepInfoNV* pSleepInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkSetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain, VkSetLatencyMarkerInfoNV* pLatencyMarkerInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, out VkGetLatencyMarkerInfoNV pLatencyMarkerInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkQueueNotifyOutOfBandNV(VkQueue queue, VkOutOfBandQueueTypeInfoNV* pQueueTypeInfo);

static { public const uint32 VK_KHR_COOPERATIVE_MATRIX_SPEC_VERSION = 2; }
static { public const c_char* VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME = "VK_KHR_cooperative_matrix"; }

[CRepr] struct VkCooperativeMatrixPropertiesKHR
{
	public const VkStructureType SType = .VkCooperativeMatrixPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 MSize;
	public uint32 NSize;
	public uint32 KSize;
	public VkComponentTypeKHR AType;
	public VkComponentTypeKHR BType;
	public VkComponentTypeKHR CType;
	public VkComponentTypeKHR ResultType;
	public VkBool32 saturatingAccumulation;
	public VkScopeKHR @scope;
}

[AllowDuplicates] enum VkScopeKHR : int32
{
	DeviceKHR = 1,
	WorkgroupKHR = 2,
	SubgroupKHR = 3,
	QueueFamilyKHR = 5,
	VkScopeDeviceNV = DeviceKHR,
	VkScopeWorkgroupNV = WorkgroupKHR,
	VkScopeSubgroupNV = SubgroupKHR,
	VkScopeQueueFamilyNV = QueueFamilyKHR,
}

[CRepr] struct VkPhysicalDeviceCooperativeMatrixFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceCooperativeMatrixFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 cooperativeMatrix;
	public VkBool32 cooperativeMatrixRobustBufferAccess;

	public this(void* pNext, VkBool32 cooperativeMatrix, VkBool32 cooperativeMatrixRobustBufferAccess)
	{
		this.pNext = pNext;
		this.cooperativeMatrix = cooperativeMatrix;
		this.cooperativeMatrixRobustBufferAccess = cooperativeMatrixRobustBufferAccess;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceCooperativeMatrixPropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceCooperativeMatrixPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkShaderStageFlags cooperativeMatrixSupportedStages;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice, out uint32 pPropertyCount, VkCooperativeMatrixPropertiesKHR* pProperties = null);

static { public const uint32 VK_ARM_DATA_GRAPH_SPEC_VERSION = 1; }
static { public const c_char* VK_ARM_DATA_GRAPH_EXTENSION_NAME = "VK_ARM_data_graph"; }
static { public const uint32 VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM = 128; }

[CRepr] struct VkPhysicalDeviceDataGraphFeaturesARM
{
	public const VkStructureType SType = .VkPhysicalDeviceDataGraphFeaturesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 dataGraph;
	public VkBool32 dataGraphUpdateAfterBind;
	public VkBool32 dataGraphSpecializationConstants;
	public VkBool32 dataGraphDescriptorBuffer;
	public VkBool32 dataGraphShaderModule;

	public this(void* pNext, VkBool32 dataGraph, VkBool32 dataGraphUpdateAfterBind, VkBool32 dataGraphSpecializationConstants, VkBool32 dataGraphDescriptorBuffer, VkBool32 dataGraphShaderModule)
	{
		this.pNext = pNext;
		this.dataGraph = dataGraph;
		this.dataGraphUpdateAfterBind = dataGraphUpdateAfterBind;
		this.dataGraphSpecializationConstants = dataGraphSpecializationConstants;
		this.dataGraphDescriptorBuffer = dataGraphDescriptorBuffer;
		this.dataGraphShaderModule = dataGraphShaderModule;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

class VkDataGraphPipelineSessionARM { private this() { } }

[AllowDuplicates] enum VkDataGraphPipelineSessionBindPointARM : int32
{
	TransientARM = 0,
}

[AllowDuplicates] enum VkDataGraphPipelineSessionBindPointTypeARM : int32
{
	MemoryARM = 0,
}

[CRepr] struct VkDataGraphPipelineConstantARM
{
	public const VkStructureType SType = .VkDataGraphPipelineConstantARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 id;
	public void* pConstantData;

	public this(void* pNext, uint32 id, void* pConstantData)
	{
		this.pNext = pNext;
		this.id = id;
		this.pConstantData = pConstantData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDataGraphPipelineResourceInfoARM
{
	public const VkStructureType SType = .VkDataGraphPipelineResourceInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 descriptorSet;
	public uint32 binding;
	public uint32 arrayElement;

	public this(void* pNext, uint32 descriptorSet, uint32 binding, uint32 arrayElement = 0)
	{
		this.pNext = pNext;
		this.descriptorSet = descriptorSet;
		this.binding = binding;
		this.arrayElement = arrayElement;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDataGraphPipelineCompilerControlCreateInfoARM
{
	public const VkStructureType SType = .VkDataGraphPipelineCompilerControlCreateInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_char* pVendorOptions;

	public this(void* pNext, c_char* pVendorOptions)
	{
		this.pNext = pNext;
		this.pVendorOptions = pVendorOptions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDataGraphPipelineCreateInfoARM
{
	public const VkStructureType SType = .VkDataGraphPipelineCreateInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipelineCreateFlags2KHR flags;
	public VkPipelineLayout layout;
	public uint32 resourceInfoCount;
	public VkDataGraphPipelineResourceInfoARM* pResourceInfos;
	public VulkanSpan<VkDataGraphPipelineResourceInfoARM> resourceInfos
	{
		[Inline] get => .(resourceInfoCount, pResourceInfos);
		[Inline] set mut { resourceInfoCount = value.count; pResourceInfos = value.ptr; }
	}

	public this(void* pNext, VkPipelineCreateFlags2KHR flags, VkPipelineLayout layout, VulkanSpan<VkDataGraphPipelineResourceInfoARM> resourceInfos) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.layout = layout;
		this.resourceInfos = resourceInfos;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDataGraphPipelineShaderModuleCreateInfoARM
{
	public const VkStructureType SType = .VkDataGraphPipelineShaderModuleCreateInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkShaderModule module;
	public c_char* pName;
	public VkSpecializationInfo* pSpecializationInfo;
	public uint32 constantCount;
	public VkDataGraphPipelineConstantARM* pConstants;
	public VulkanSpan<VkDataGraphPipelineConstantARM> constants
	{
		[Inline] get => .(constantCount, pConstants);
		[Inline] set mut { constantCount = value.count; pConstants = value.ptr; }
	}

	public this(void* pNext, VkShaderModule module, c_char* pName, VkSpecializationInfo* pSpecializationInfo = null, VulkanSpan<VkDataGraphPipelineConstantARM> constants = .()) : this()
	{
		this.pNext = pNext;
		this.module = module;
		this.pName = pName;
		this.pSpecializationInfo = pSpecializationInfo;
		this.constants = constants;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDataGraphPipelineSessionCreateInfoARM
{
	public const VkStructureType SType = .VkDataGraphPipelineSessionCreateInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDataGraphPipelineSessionCreateFlagsARM flags;
	public VkPipeline dataGraphPipeline;

	public this(void* pNext, VkDataGraphPipelineSessionCreateFlagsARM flags, VkPipeline dataGraphPipeline)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.dataGraphPipeline = dataGraphPipeline;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkDataGraphPipelineSessionCreateFlagsARM = VkDataGraphPipelineSessionCreateFlagBitsARM;

[AllowDuplicates] enum VkDataGraphPipelineSessionCreateFlagBitsARM : int64
{
	ProtectedARM = 1 << 0,
}

[CRepr] struct VkDataGraphPipelineSessionBindPointRequirementsInfoARM
{
	public const VkStructureType SType = .VkDataGraphPipelineSessionBindPointRequirementsInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDataGraphPipelineSessionARM session;

	public this(void* pNext, VkDataGraphPipelineSessionARM session)
	{
		this.pNext = pNext;
		this.session = session;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDataGraphPipelineSessionBindPointRequirementARM
{
	public const VkStructureType SType = .VkDataGraphPipelineSessionBindPointRequirementARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDataGraphPipelineSessionBindPointARM bindPoint;
	public VkDataGraphPipelineSessionBindPointTypeARM bindPointType;
	public uint32 numObjects;

	public this(void* pNext, VkDataGraphPipelineSessionBindPointARM bindPoint, VkDataGraphPipelineSessionBindPointTypeARM bindPointType, uint32 numObjects)
	{
		this.pNext = pNext;
		this.bindPoint = bindPoint;
		this.bindPointType = bindPointType;
		this.numObjects = numObjects;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDataGraphPipelineSessionMemoryRequirementsInfoARM
{
	public const VkStructureType SType = .VkDataGraphPipelineSessionMemoryRequirementsInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDataGraphPipelineSessionARM session;
	public VkDataGraphPipelineSessionBindPointARM bindPoint;
	public uint32 objectIndex;

	public this(void* pNext, VkDataGraphPipelineSessionARM session, VkDataGraphPipelineSessionBindPointARM bindPoint, uint32 objectIndex)
	{
		this.pNext = pNext;
		this.session = session;
		this.bindPoint = bindPoint;
		this.objectIndex = objectIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBindDataGraphPipelineSessionMemoryInfoARM
{
	public const VkStructureType SType = .VkBindDataGraphPipelineSessionMemoryInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDataGraphPipelineSessionARM session;
	public VkDataGraphPipelineSessionBindPointARM bindPoint;
	public uint32 objectIndex;
	public VkDeviceMemory memory;
	public VkDeviceSize memoryOffset;

	public this(void* pNext, VkDataGraphPipelineSessionARM session, VkDataGraphPipelineSessionBindPointARM bindPoint, uint32 objectIndex, VkDeviceMemory memory, VkDeviceSize memoryOffset)
	{
		this.pNext = pNext;
		this.session = session;
		this.bindPoint = bindPoint;
		this.objectIndex = objectIndex;
		this.memory = memory;
		this.memoryOffset = memoryOffset;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDataGraphPipelineInfoARM
{
	public const VkStructureType SType = .VkDataGraphPipelineInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipeline dataGraphPipeline;

	public this(void* pNext, VkPipeline dataGraphPipeline)
	{
		this.pNext = pNext;
		this.dataGraphPipeline = dataGraphPipeline;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDataGraphPipelinePropertyQueryResultARM
{
	public const VkStructureType SType = .VkDataGraphPipelinePropertyQueryResultARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDataGraphPipelinePropertyARM property;
	public VkBool32 isText;
	public c_size dataSize;
	public void* pData;

	public this(void* pNext, VkDataGraphPipelinePropertyARM property, VkBool32 isText, c_size dataSize = 0, void* pData = null)
	{
		this.pNext = pNext;
		this.property = property;
		this.isText = isText;
		this.dataSize = dataSize;
		this.pData = pData;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkDataGraphPipelinePropertyARM : int32
{
	CreationLogARM = 0,
	IdentifierARM = 1,
}

[CRepr] struct VkDataGraphPipelineIdentifierCreateInfoARM
{
	public const VkStructureType SType = .VkDataGraphPipelineIdentifierCreateInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 identifierSize;
	public uint8* pIdentifier;
	public VulkanSpan<uint8> identifier
	{
		[Inline] get => .(identifierSize, pIdentifier);
		[Inline] set mut { identifierSize = value.count; pIdentifier = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<uint8> identifier) : this()
	{
		this.pNext = pNext;
		this.identifier = identifier;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkDataGraphPipelineDispatchFlagsARM = VkDataGraphPipelineDispatchFlagBitsARM;

[AllowDuplicates] enum VkDataGraphPipelineDispatchFlagBitsARM : int64
{
}

[CRepr] struct VkDataGraphPipelineDispatchInfoARM
{
	public const VkStructureType SType = .VkDataGraphPipelineDispatchInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDataGraphPipelineDispatchFlagsARM flags;

	public this(void* pNext = null, VkDataGraphPipelineDispatchFlagsARM flags = 0)
	{
		this.pNext = pNext;
		this.flags = flags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkPhysicalDeviceDataGraphProcessingEngineTypeARM : int32
{
	DefaultARM = 0,
}

[AllowDuplicates] enum VkPhysicalDeviceDataGraphOperationTypeARM : int32
{
	SpirvExtendedInstructionSetARM = 0,
}

[CRepr] struct VkPhysicalDeviceDataGraphProcessingEngineARM
{
	public VkPhysicalDeviceDataGraphProcessingEngineTypeARM type;
	public VkBool32 isForeign;

	public this(VkPhysicalDeviceDataGraphProcessingEngineTypeARM type, VkBool32 isForeign)
	{
		this.type = type;
		this.isForeign = isForeign;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkQueueFamilyDataGraphPropertiesARM
{
	public const VkStructureType SType = .VkQueueFamilyDataGraphPropertiesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPhysicalDeviceDataGraphProcessingEngineARM engine;
	public VkPhysicalDeviceDataGraphOperationSupportARM operation;

	public this(void* pNext, VkPhysicalDeviceDataGraphProcessingEngineARM engine, VkPhysicalDeviceDataGraphOperationSupportARM operation)
	{
		this.pNext = pNext;
		this.engine = engine;
		this.operation = operation;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDataGraphProcessingEngineCreateInfoARM
{
	public const VkStructureType SType = .VkDataGraphProcessingEngineCreateInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 processingEngineCount;
	public VkPhysicalDeviceDataGraphProcessingEngineARM* pProcessingEngines;
	public VulkanSpan<VkPhysicalDeviceDataGraphProcessingEngineARM> processingEngines
	{
		[Inline] get => .(processingEngineCount, pProcessingEngines);
		[Inline] set mut { processingEngineCount = value.count; pProcessingEngines = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<VkPhysicalDeviceDataGraphProcessingEngineARM> processingEngines) : this()
	{
		this.pNext = pNext;
		this.processingEngines = processingEngines;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM
{
	public const VkStructureType SType = .VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 queueFamilyIndex;
	public VkPhysicalDeviceDataGraphProcessingEngineTypeARM engineType;

	public this(void* pNext, uint32 queueFamilyIndex, VkPhysicalDeviceDataGraphProcessingEngineTypeARM engineType)
	{
		this.pNext = pNext;
		this.queueFamilyIndex = queueFamilyIndex;
		this.engineType = engineType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkQueueFamilyDataGraphProcessingEnginePropertiesARM
{
	public const VkStructureType SType = .VkQueueFamilyDataGraphProcessingEnginePropertiesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalSemaphoreHandleTypeFlags foreignSemaphoreHandleTypes;
	public VkExternalMemoryHandleTypeFlags foreignMemoryHandleTypes;

	public this(void* pNext, VkExternalSemaphoreHandleTypeFlags foreignSemaphoreHandleTypes, VkExternalMemoryHandleTypeFlags foreignMemoryHandleTypes)
	{
		this.pNext = pNext;
		this.foreignSemaphoreHandleTypes = foreignSemaphoreHandleTypes;
		this.foreignMemoryHandleTypes = foreignMemoryHandleTypes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceDataGraphOperationSupportARM
{
	public VkPhysicalDeviceDataGraphOperationTypeARM operationType;
	public c_char[VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM] name;
	public uint32 version;

	public this(VkPhysicalDeviceDataGraphOperationTypeARM operationType, c_char[VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM] name, uint32 version)
	{
		this.operationType = operationType;
		this.name = name;
		this.version = version;
	}

	public this()
	{
		this = default;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateDataGraphPipelinesARM(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32 createInfoCount, VkDataGraphPipelineCreateInfoARM* pCreateInfos, VkAllocationCallbacks* pAllocator, out VkPipeline pPipelines);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateDataGraphPipelineSessionARM(VkDevice device, VkDataGraphPipelineSessionCreateInfoARM* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkDataGraphPipelineSessionARM pSession);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDataGraphPipelineSessionBindPointRequirementsARM(VkDevice device, VkDataGraphPipelineSessionBindPointRequirementsInfoARM* pInfo, out uint32 pBindPointRequirementCount, VkDataGraphPipelineSessionBindPointRequirementARM* pBindPointRequirements = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetDataGraphPipelineSessionMemoryRequirementsARM(VkDevice device, VkDataGraphPipelineSessionMemoryRequirementsInfoARM* pInfo, out VkMemoryRequirements2 pMemoryRequirements);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkBindDataGraphPipelineSessionMemoryARM(VkDevice device, uint32 bindInfoCount, VkBindDataGraphPipelineSessionMemoryInfoARM* pBindInfos);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyDataGraphPipelineSessionARM(VkDevice device, VkDataGraphPipelineSessionARM session, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdDispatchDataGraphARM(VkCommandBuffer commandBuffer, VkDataGraphPipelineSessionARM session, VkDataGraphPipelineDispatchInfoARM* pInfo = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDataGraphPipelineAvailablePropertiesARM(VkDevice device, VkDataGraphPipelineInfoARM* pPipelineInfo, out uint32 pPropertiesCount, VkDataGraphPipelinePropertyARM* pProperties = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetDataGraphPipelinePropertiesARM(VkDevice device, VkDataGraphPipelineInfoARM* pPipelineInfo, uint32 propertiesCount, out VkDataGraphPipelinePropertyQueryResultARM pProperties);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(VkPhysicalDevice physicalDevice, uint32 queueFamilyIndex, out uint32 pQueueFamilyDataGraphPropertyCount, VkQueueFamilyDataGraphPropertiesARM* pQueueFamilyDataGraphProperties = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(VkPhysicalDevice physicalDevice, VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM* pQueueFamilyDataGraphProcessingEngineInfo, out VkQueueFamilyDataGraphProcessingEnginePropertiesARM pQueueFamilyDataGraphProcessingEngineProperties);

[CRepr] struct VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM
{
	public const VkStructureType SType = .VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 dimension;
	public uint32 zeroCount;
	public uint32 groupSize;

	public this(void* pNext, uint32 dimension, uint32 zeroCount, uint32 groupSize)
	{
		this.pNext = pNext;
		this.dimension = dimension;
		this.zeroCount = zeroCount;
		this.groupSize = groupSize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_SPEC_VERSION = 1; }
static { public const c_char* VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME = "VK_QCOM_multiview_per_view_render_areas"; }

[CRepr] struct VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 multiviewPerViewRenderAreas;

	public this(void* pNext, VkBool32 multiviewPerViewRenderAreas)
	{
		this.pNext = pNext;
		this.multiviewPerViewRenderAreas = multiviewPerViewRenderAreas;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM
{
	public const VkStructureType SType = .VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 perViewRenderAreaCount;
	public VkRect2D* pPerViewRenderAreas;
	public VulkanSpan<VkRect2D> perViewRenderAreas
	{
		[Inline] get => .(perViewRenderAreaCount, pPerViewRenderAreas);
		[Inline] set mut { perViewRenderAreaCount = value.count; pPerViewRenderAreas = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkRect2D> perViewRenderAreas = .()) : this()
	{
		this.pNext = pNext;
		this.perViewRenderAreas = perViewRenderAreas;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME = "VK_KHR_compute_shader_derivatives"; }

[CRepr] struct VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 computeDerivativeGroupQuads;
	public VkBool32 computeDerivativeGroupLinear;

	public this(void* pNext, VkBool32 computeDerivativeGroupQuads, VkBool32 computeDerivativeGroupLinear)
	{
		this.pNext = pNext;
		this.computeDerivativeGroupQuads = computeDerivativeGroupQuads;
		this.computeDerivativeGroupLinear = computeDerivativeGroupLinear;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 meshAndTaskShaderDerivatives;
}

static { public const uint32 VK_KHR_VIDEO_DECODE_AV1_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_VIDEO_DECODE_AV1_EXTENSION_NAME = "VK_KHR_video_decode_av1"; }
static { public const uint32 VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR = 7; }

[CRepr] struct VkVideoDecodeAV1ProfileInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeAv1ProfileInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoAV1Profile stdProfile;
	public VkBool32 filmGrainSupport;

	public this(void* pNext, StdVideoAV1Profile stdProfile, VkBool32 filmGrainSupport)
	{
		this.pNext = pNext;
		this.stdProfile = stdProfile;
		this.filmGrainSupport = filmGrainSupport;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeAV1CapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoDecodeAv1CapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoAV1Level maxLevel;
}

[CRepr] struct VkVideoDecodeAV1SessionParametersCreateInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeAv1SessionParametersCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoAV1SequenceHeader* pStdSequenceHeader;

	public this(void* pNext, StdVideoAV1SequenceHeader* pStdSequenceHeader)
	{
		this.pNext = pNext;
		this.pStdSequenceHeader = pStdSequenceHeader;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeAV1PictureInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeAv1PictureInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoDecodeAV1PictureInfo* pStdPictureInfo;
	public int32[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR] referenceNameSlotIndices;
	public uint32 frameHeaderOffset;
	public uint32 tileCount;
	public uint32* pTileOffsets;
	public uint32* pTileSizes;
	public VulkanDuoSpan<uint32, uint32> tileOffsets_tileSizes
	{
		[Inline] get => .(tileCount, pTileOffsets, pTileSizes);
		[Inline] set mut { tileCount = value.count; pTileOffsets = value.ptr1; pTileSizes = value.ptr2; }
	}

	public this(void* pNext, StdVideoDecodeAV1PictureInfo* pStdPictureInfo, int32[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR] referenceNameSlotIndices, uint32 frameHeaderOffset, VulkanDuoSpan<uint32, uint32> tileOffsets_tileSizes) : this()
	{
		this.pNext = pNext;
		this.pStdPictureInfo = pStdPictureInfo;
		this.referenceNameSlotIndices = referenceNameSlotIndices;
		this.frameHeaderOffset = frameHeaderOffset;
		this.tileOffsets_tileSizes = tileOffsets_tileSizes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeAV1DpbSlotInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeAv1DpbSlotInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoDecodeAV1ReferenceInfo* pStdReferenceInfo;

	public this(void* pNext, StdVideoDecodeAV1ReferenceInfo* pStdReferenceInfo)
	{
		this.pNext = pNext;
		this.pStdReferenceInfo = pStdReferenceInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_VIDEO_ENCODE_AV1_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_VIDEO_ENCODE_AV1_EXTENSION_NAME = "VK_KHR_video_encode_av1"; }
[CRepr] struct VkPhysicalDeviceVideoEncodeAV1FeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceVideoEncodeAv1FeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 videoEncodeAV1;

	public this(void* pNext, VkBool32 videoEncodeAV1)
	{
		this.pNext = pNext;
		this.videoEncodeAV1 = videoEncodeAV1;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkVideoEncodeAV1PredictionModeKHR : int32
{
	VkVideoEncodeAv1PredictionModeIntraOnlyKHR = 0,
	VkVideoEncodeAv1PredictionModeSingleReferenceKHR = 1,
	VkVideoEncodeAv1PredictionModeUnidirectionalCompoundKHR = 2,
	VkVideoEncodeAv1PredictionModeBidirectionalCompoundKHR = 3,
}

[AllowDuplicates] enum VkVideoEncodeAV1RateControlGroupKHR : int32
{
	VkVideoEncodeAv1RateControlGroupIntraKHR = 0,
	VkVideoEncodeAv1RateControlGroupPredictiveKHR = 1,
	VkVideoEncodeAv1RateControlGroupBipredictiveKHR = 2,
}

[AllowDuplicates] enum VkVideoEncodeAV1CapabilityFlagBitsKHR : int32
{
	VkVideoEncodeAv1CapabilityPerRateControlGroupMinMaxQIndexKHR = 1 << 0,
	VkVideoEncodeAv1CapabilityGenerateObuExtensionHeaderKHR = 1 << 1,
	VkVideoEncodeAv1CapabilityPrimaryReferenceCdfOnlyKHR = 1 << 2,
	VkVideoEncodeAv1CapabilityFrameSizeOverrideKHR = 1 << 3,
	VkVideoEncodeAv1CapabilityMotionVectorScalingKHR = 1 << 4,
	VkVideoEncodeAv1CapabilityCompoundPredictionIntraRefreshKHR = 1 << 5,
}

typealias VkVideoEncodeAV1CapabilityFlagsKHR = VkVideoEncodeAV1CapabilityFlagBitsKHR;

[AllowDuplicates] enum VkVideoEncodeAV1StdFlagBitsKHR : int32
{
	VkVideoEncodeAv1StdUniformTileSpacingFlagSetKHR = 1 << 0,
	VkVideoEncodeAv1StdSkipModePresentUnsetKHR = 1 << 1,
	VkVideoEncodeAv1StdPrimaryRefFrameKHR = 1 << 2,
	VkVideoEncodeAv1StdDeltaQKHR = 1 << 3,
}

typealias VkVideoEncodeAV1StdFlagsKHR = VkVideoEncodeAV1StdFlagBitsKHR;

[AllowDuplicates] enum VkVideoEncodeAV1SuperblockSizeFlagBitsKHR : int32
{
	VkVideoEncodeAv1SuperblockSize64KHR = 1 << 0,
	VkVideoEncodeAv1SuperblockSize128KHR = 1 << 1,
}

typealias VkVideoEncodeAV1SuperblockSizeFlagsKHR = VkVideoEncodeAV1SuperblockSizeFlagBitsKHR;

[CRepr] struct VkVideoEncodeAV1CapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoEncodeAv1CapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeAV1CapabilityFlagsKHR flags;
	public StdVideoAV1Level maxLevel;
	public VkExtent2D codedPictureAlignment;
	public VkExtent2D maxTiles;
	public VkExtent2D minTileSize;
	public VkExtent2D maxTileSize;
	public VkVideoEncodeAV1SuperblockSizeFlagsKHR superblockSizes;
	public uint32 maxSingleReferenceCount;
	public uint32 singleReferenceNameMask;
	public uint32 maxUnidirectionalCompoundReferenceCount;
	public uint32 maxUnidirectionalCompoundGroup1ReferenceCount;
	public uint32 unidirectionalCompoundReferenceNameMask;
	public uint32 maxBidirectionalCompoundReferenceCount;
	public uint32 maxBidirectionalCompoundGroup1ReferenceCount;
	public uint32 maxBidirectionalCompoundGroup2ReferenceCount;
	public uint32 bidirectionalCompoundReferenceNameMask;
	public uint32 maxTemporalLayerCount;
	public uint32 maxSpatialLayerCount;
	public uint32 maxOperatingPoints;
	public uint32 minQIndex;
	public uint32 maxQIndex;
	public VkBool32 prefersGopRemainingFrames;
	public VkBool32 requiresGopRemainingFrames;
	public VkVideoEncodeAV1StdFlagsKHR stdSyntaxFlags;
}

[CRepr] struct VkVideoEncodeAV1QualityLevelPropertiesKHR
{
	public const VkStructureType SType = .VkVideoEncodeAv1QualityLevelPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeAV1RateControlFlagsKHR preferredRateControlFlags;
	public uint32 preferredGopFrameCount;
	public uint32 preferredKeyFramePeriod;
	public uint32 preferredConsecutiveBipredictiveFrameCount;
	public uint32 preferredTemporalLayerCount;
	public VkVideoEncodeAV1QIndexKHR preferredConstantQIndex;
	public uint32 preferredMaxSingleReferenceCount;
	public uint32 preferredSingleReferenceNameMask;
	public uint32 preferredMaxUnidirectionalCompoundReferenceCount;
	public uint32 preferredMaxUnidirectionalCompoundGroup1ReferenceCount;
	public uint32 preferredUnidirectionalCompoundReferenceNameMask;
	public uint32 preferredMaxBidirectionalCompoundReferenceCount;
	public uint32 preferredMaxBidirectionalCompoundGroup1ReferenceCount;
	public uint32 preferredMaxBidirectionalCompoundGroup2ReferenceCount;
	public uint32 preferredBidirectionalCompoundReferenceNameMask;
}

[CRepr] struct VkVideoEncodeAV1SessionCreateInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeAv1SessionCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 useMaxLevel;
	public StdVideoAV1Level maxLevel;

	public this(void* pNext, VkBool32 useMaxLevel, StdVideoAV1Level maxLevel)
	{
		this.pNext = pNext;
		this.useMaxLevel = useMaxLevel;
		this.maxLevel = maxLevel;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeAV1SessionParametersCreateInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeAv1SessionParametersCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoAV1SequenceHeader* pStdSequenceHeader;
	public StdVideoEncodeAV1DecoderModelInfo* pStdDecoderModelInfo;
	public uint32 stdOperatingPointCount;
	public StdVideoEncodeAV1OperatingPointInfo* pStdOperatingPoints;
	public VulkanSpan<StdVideoEncodeAV1OperatingPointInfo> stdOperatingPoints
	{
		[Inline] get => .(stdOperatingPointCount, pStdOperatingPoints);
		[Inline] set mut { stdOperatingPointCount = value.count; pStdOperatingPoints = value.ptr; }
	}

	public this(void* pNext, StdVideoAV1SequenceHeader* pStdSequenceHeader, StdVideoEncodeAV1DecoderModelInfo* pStdDecoderModelInfo = null, VulkanSpan<StdVideoEncodeAV1OperatingPointInfo> stdOperatingPoints = .()) : this()
	{
		this.pNext = pNext;
		this.pStdSequenceHeader = pStdSequenceHeader;
		this.pStdDecoderModelInfo = pStdDecoderModelInfo;
		this.stdOperatingPoints = stdOperatingPoints;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeAV1PictureInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeAv1PictureInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeAV1PredictionModeKHR predictionMode;
	public VkVideoEncodeAV1RateControlGroupKHR rateControlGroup;
	public uint32 constantQIndex;
	public StdVideoEncodeAV1PictureInfo* pStdPictureInfo;
	public int32[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR] referenceNameSlotIndices;
	public VkBool32 primaryReferenceCdfOnly;
	public VkBool32 generateObuExtensionHeader;

	public this(void* pNext, VkVideoEncodeAV1PredictionModeKHR predictionMode, VkVideoEncodeAV1RateControlGroupKHR rateControlGroup, uint32 constantQIndex, StdVideoEncodeAV1PictureInfo* pStdPictureInfo, int32[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR] referenceNameSlotIndices, VkBool32 primaryReferenceCdfOnly, VkBool32 generateObuExtensionHeader)
	{
		this.pNext = pNext;
		this.predictionMode = predictionMode;
		this.rateControlGroup = rateControlGroup;
		this.constantQIndex = constantQIndex;
		this.pStdPictureInfo = pStdPictureInfo;
		this.referenceNameSlotIndices = referenceNameSlotIndices;
		this.primaryReferenceCdfOnly = primaryReferenceCdfOnly;
		this.generateObuExtensionHeader = generateObuExtensionHeader;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeAV1DpbSlotInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeAv1DpbSlotInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoEncodeAV1ReferenceInfo* pStdReferenceInfo;

	public this(void* pNext, StdVideoEncodeAV1ReferenceInfo* pStdReferenceInfo)
	{
		this.pNext = pNext;
		this.pStdReferenceInfo = pStdReferenceInfo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeAV1ProfileInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeAv1ProfileInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoAV1Profile stdProfile;

	public this(void* pNext, StdVideoAV1Profile stdProfile)
	{
		this.pNext = pNext;
		this.stdProfile = stdProfile;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeAV1QIndexKHR
{
	public uint32 intraQIndex;
	public uint32 predictiveQIndex;
	public uint32 bipredictiveQIndex;

	public this(uint32 intraQIndex, uint32 predictiveQIndex, uint32 bipredictiveQIndex)
	{
		this.intraQIndex = intraQIndex;
		this.predictiveQIndex = predictiveQIndex;
		this.bipredictiveQIndex = bipredictiveQIndex;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkVideoEncodeAV1FrameSizeKHR
{
	public uint32 intraFrameSize;
	public uint32 predictiveFrameSize;
	public uint32 bipredictiveFrameSize;

	public this(uint32 intraFrameSize, uint32 predictiveFrameSize, uint32 bipredictiveFrameSize)
	{
		this.intraFrameSize = intraFrameSize;
		this.predictiveFrameSize = predictiveFrameSize;
		this.bipredictiveFrameSize = bipredictiveFrameSize;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkVideoEncodeAV1GopRemainingFrameInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeAv1GopRemainingFrameInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 useGopRemainingFrames;
	public uint32 gopRemainingIntra;
	public uint32 gopRemainingPredictive;
	public uint32 gopRemainingBipredictive;

	public this(void* pNext, VkBool32 useGopRemainingFrames, uint32 gopRemainingIntra, uint32 gopRemainingPredictive, uint32 gopRemainingBipredictive)
	{
		this.pNext = pNext;
		this.useGopRemainingFrames = useGopRemainingFrames;
		this.gopRemainingIntra = gopRemainingIntra;
		this.gopRemainingPredictive = gopRemainingPredictive;
		this.gopRemainingBipredictive = gopRemainingBipredictive;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeAV1RateControlInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeAv1RateControlInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeAV1RateControlFlagsKHR flags;
	public uint32 gopFrameCount;
	public uint32 keyFramePeriod;
	public uint32 consecutiveBipredictiveFrameCount;
	public uint32 temporalLayerCount;

	public this(void* pNext, VkVideoEncodeAV1RateControlFlagsKHR flags, uint32 gopFrameCount, uint32 keyFramePeriod, uint32 consecutiveBipredictiveFrameCount, uint32 temporalLayerCount)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.gopFrameCount = gopFrameCount;
		this.keyFramePeriod = keyFramePeriod;
		this.consecutiveBipredictiveFrameCount = consecutiveBipredictiveFrameCount;
		this.temporalLayerCount = temporalLayerCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkVideoEncodeAV1RateControlFlagBitsKHR : int32
{
	VkVideoEncodeAv1RateControlRegularGopKHR = 1 << 0,
	VkVideoEncodeAv1RateControlTemporalLayerPatternDyadicKHR = 1 << 1,
	VkVideoEncodeAv1RateControlReferencePatternFlatKHR = 1 << 2,
	VkVideoEncodeAv1RateControlReferencePatternDyadicKHR = 1 << 3,
}

typealias VkVideoEncodeAV1RateControlFlagsKHR = VkVideoEncodeAV1RateControlFlagBitsKHR;

[CRepr] struct VkVideoEncodeAV1RateControlLayerInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeAv1RateControlLayerInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 useMinQIndex;
	public VkVideoEncodeAV1QIndexKHR minQIndex;
	public VkBool32 useMaxQIndex;
	public VkVideoEncodeAV1QIndexKHR maxQIndex;
	public VkBool32 useMaxFrameSize;
	public VkVideoEncodeAV1FrameSizeKHR maxFrameSize;

	public this(void* pNext, VkBool32 useMinQIndex, VkVideoEncodeAV1QIndexKHR minQIndex, VkBool32 useMaxQIndex, VkVideoEncodeAV1QIndexKHR maxQIndex, VkBool32 useMaxFrameSize, VkVideoEncodeAV1FrameSizeKHR maxFrameSize)
	{
		this.pNext = pNext;
		this.useMinQIndex = useMinQIndex;
		this.minQIndex = minQIndex;
		this.useMaxQIndex = useMaxQIndex;
		this.maxQIndex = maxQIndex;
		this.useMaxFrameSize = useMaxFrameSize;
		this.maxFrameSize = maxFrameSize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_VIDEO_DECODE_VP9_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_VIDEO_DECODE_VP9_EXTENSION_NAME = "VK_KHR_video_decode_vp9"; }
static { public const uint32 VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR = 3; }

[CRepr] struct VkPhysicalDeviceVideoDecodeVP9FeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceVideoDecodeVp9FeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 videoDecodeVP9;

	public this(void* pNext, VkBool32 videoDecodeVP9)
	{
		this.pNext = pNext;
		this.videoDecodeVP9 = videoDecodeVP9;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeVP9ProfileInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeVp9ProfileInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoVP9Profile stdProfile;

	public this(void* pNext, StdVideoVP9Profile stdProfile)
	{
		this.pNext = pNext;
		this.stdProfile = stdProfile;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeVP9CapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoDecodeVp9CapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoVP9Level maxLevel;
}

[CRepr] struct VkVideoDecodeVP9PictureInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeVp9PictureInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoDecodeVP9PictureInfo* pStdPictureInfo;
	public int32[VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR] referenceNameSlotIndices;
	public uint32 uncompressedHeaderOffset;
	public uint32 compressedHeaderOffset;
	public uint32 tilesOffset;

	public this(void* pNext, StdVideoDecodeVP9PictureInfo* pStdPictureInfo, int32[VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR] referenceNameSlotIndices, uint32 uncompressedHeaderOffset, uint32 compressedHeaderOffset, uint32 tilesOffset)
	{
		this.pNext = pNext;
		this.pStdPictureInfo = pStdPictureInfo;
		this.referenceNameSlotIndices = referenceNameSlotIndices;
		this.uncompressedHeaderOffset = uncompressedHeaderOffset;
		this.compressedHeaderOffset = compressedHeaderOffset;
		this.tilesOffset = tilesOffset;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_VIDEO_MAINTENANCE_1_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME = "VK_KHR_video_maintenance1"; }

[CRepr] struct VkPhysicalDeviceVideoMaintenance1FeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceVideoMaintenance1FeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 videoMaintenance1;

	public this(void* pNext, VkBool32 videoMaintenance1)
	{
		this.pNext = pNext;
		this.videoMaintenance1 = videoMaintenance1;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoInlineQueryInfoKHR
{
	public const VkStructureType SType = .VkVideoInlineQueryInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkQueryPool queryPool;
	public uint32 firstQuery;
	public uint32 queryCount;

	public this(void* pNext, VkQueryPool queryPool, uint32 firstQuery, uint32 queryCount)
	{
		this.pNext = pNext;
		this.queryPool = queryPool;
		this.firstQuery = firstQuery;
		this.queryCount = queryCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_PER_STAGE_DESCRIPTOR_SET_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME = "VK_NV_per_stage_descriptor_set"; }

[CRepr] struct VkPhysicalDevicePerStageDescriptorSetFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDevicePerStageDescriptorSetFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 perStageDescriptorSet;
	public VkBool32 dynamicPipelineLayout;

	public this(void* pNext, VkBool32 perStageDescriptorSet, VkBool32 dynamicPipelineLayout)
	{
		this.pNext = pNext;
		this.perStageDescriptorSet = perStageDescriptorSet;
		this.dynamicPipelineLayout = dynamicPipelineLayout;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_QCOM_IMAGE_PROCESSING_2_SPEC_VERSION = 1; }
static { public const c_char* VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME = "VK_QCOM_image_processing2"; }

[CRepr] struct VkPhysicalDeviceImageProcessing2FeaturesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceImageProcessing2FeaturesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 textureBlockMatch2;

	public this(void* pNext, VkBool32 textureBlockMatch2)
	{
		this.pNext = pNext;
		this.textureBlockMatch2 = textureBlockMatch2;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceImageProcessing2PropertiesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceImageProcessing2PropertiesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExtent2D maxBlockMatchWindow;
}

[CRepr] struct VkSamplerBlockMatchWindowCreateInfoQCOM
{
	public const VkStructureType SType = .VkSamplerBlockMatchWindowCreateInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExtent2D windowExtent;
	public VkBlockMatchWindowCompareModeQCOM windowCompareMode;

	public this(void* pNext, VkExtent2D windowExtent, VkBlockMatchWindowCompareModeQCOM windowCompareMode)
	{
		this.pNext = pNext;
		this.windowExtent = windowExtent;
		this.windowCompareMode = windowCompareMode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkBlockMatchWindowCompareModeQCOM : int32
{
	MinQCOM = 0,
	MaxQCOM = 1,
}

static { public const uint32 VK_QCOM_FILTER_CUBIC_WEIGHTS_SPEC_VERSION = 1; }
static { public const c_char* VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME = "VK_QCOM_filter_cubic_weights"; }

[CRepr] struct VkPhysicalDeviceCubicWeightsFeaturesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceCubicWeightsFeaturesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 selectableCubicWeights;

	public this(void* pNext, VkBool32 selectableCubicWeights)
	{
		this.pNext = pNext;
		this.selectableCubicWeights = selectableCubicWeights;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSamplerCubicWeightsCreateInfoQCOM
{
	public const VkStructureType SType = .VkSamplerCubicWeightsCreateInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkCubicFilterWeightsQCOM cubicWeights;

	public this(void* pNext, VkCubicFilterWeightsQCOM cubicWeights)
	{
		this.pNext = pNext;
		this.cubicWeights = cubicWeights;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBlitImageCubicWeightsInfoQCOM
{
	public const VkStructureType SType = .VkBlitImageCubicWeightsInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkCubicFilterWeightsQCOM cubicWeights;

	public this(void* pNext, VkCubicFilterWeightsQCOM cubicWeights)
	{
		this.pNext = pNext;
		this.cubicWeights = cubicWeights;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkCubicFilterWeightsQCOM : int32
{
	CatmullRomQCOM = 0,
	ZeroTangentCardinalQCOM = 1,
	BSplineQCOM = 2,
	MitchellNetravaliQCOM = 3,
}

static { public const uint32 VK_QCOM_YCBCR_DEGAMMA_SPEC_VERSION = 1; }
static { public const c_char* VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME = "VK_QCOM_ycbcr_degamma"; }

[CRepr] struct VkPhysicalDeviceYcbcrDegammaFeaturesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceYcbcrDegammaFeaturesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 ycbcrDegamma;

	public this(void* pNext, VkBool32 ycbcrDegamma)
	{
		this.pNext = pNext;
		this.ycbcrDegamma = ycbcrDegamma;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM
{
	public const VkStructureType SType = .VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 enableYDegamma;
	public VkBool32 enableCbCrDegamma;

	public this(void* pNext, VkBool32 enableYDegamma, VkBool32 enableCbCrDegamma)
	{
		this.pNext = pNext;
		this.enableYDegamma = enableYDegamma;
		this.enableCbCrDegamma = enableCbCrDegamma;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_QCOM_FILTER_CUBIC_CLAMP_SPEC_VERSION = 1; }
static { public const c_char* VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME = "VK_QCOM_filter_cubic_clamp"; }

[CRepr] struct VkPhysicalDeviceCubicClampFeaturesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceCubicClampFeaturesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 cubicRangeClamp;

	public this(void* pNext, VkBool32 cubicRangeClamp)
	{
		this.pNext = pNext;
		this.cubicRangeClamp = cubicRangeClamp;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME = "VK_EXT_attachment_feedback_loop_dynamic_state"; }

[CRepr] struct VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 attachmentFeedbackLoopDynamicState;

	public this(void* pNext, VkBool32 attachmentFeedbackLoopDynamicState)
	{
		this.pNext = pNext;
		this.attachmentFeedbackLoopDynamicState = attachmentFeedbackLoopDynamicState;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask = 0);

static { public const uint32 VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME = "VK_KHR_vertex_attribute_divisor"; }

typealias VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR = VkPhysicalDeviceVertexAttributeDivisorProperties;
typealias VkVertexInputBindingDivisorDescriptionKHR = VkVertexInputBindingDivisorDescription;
typealias VkPipelineVertexInputDivisorStateCreateInfoKHR = VkPipelineVertexInputDivisorStateCreateInfo;
typealias VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR = VkPhysicalDeviceVertexAttributeDivisorFeatures;

static { public const uint32 VK_KHR_LOAD_STORE_OP_NONE_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME = "VK_KHR_load_store_op_none"; }
static { public const uint32 VK_KHR_UNIFIED_IMAGE_LAYOUTS_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_UNIFIED_IMAGE_LAYOUTS_EXTENSION_NAME = "VK_KHR_unified_image_layouts"; }

[CRepr] struct VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 unifiedImageLayouts;
	public VkBool32 unifiedImageLayoutsVideo;

	public this(void* pNext, VkBool32 unifiedImageLayouts, VkBool32 unifiedImageLayoutsVideo)
	{
		this.pNext = pNext;
		this.unifiedImageLayouts = unifiedImageLayouts;
		this.unifiedImageLayoutsVideo = unifiedImageLayoutsVideo;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkAttachmentFeedbackLoopInfoEXT
{
	public const VkStructureType SType = .VkAttachmentFeedbackLoopInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 feedbackLoopEnable;

	public this(void* pNext, VkBool32 feedbackLoopEnable)
	{
		this.pNext = pNext;
		this.feedbackLoopEnable = feedbackLoopEnable;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_SHADER_FLOAT_CONTROLS_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME = "VK_KHR_shader_float_controls2"; }

typealias VkPhysicalDeviceShaderFloatControls2FeaturesKHR = VkPhysicalDeviceShaderFloatControls2Features;

static { public const uint32 VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_SPEC_VERSION = 1; }
static { public const c_char* VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION_NAME = "VK_QNX_external_memory_screen_buffer"; }

[CRepr] struct VkScreenBufferPropertiesQNX
{
	public const VkStructureType SType = .VkScreenBufferPropertiesQNX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize allocationSize;
	public uint32 memoryTypeBits;
}

[CRepr] struct VkScreenBufferFormatPropertiesQNX
{
	public const VkStructureType SType = .VkScreenBufferFormatPropertiesQNX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat format;
	public uint64 externalFormat;
	public uint64 screenUsage;
	public VkFormatFeatureFlags formatFeatures;
	public VkComponentMapping samplerYcbcrConversionComponents;
	public VkSamplerYcbcrModelConversion suggestedYcbcrModel;
	public VkSamplerYcbcrRange suggestedYcbcrRange;
	public VkChromaLocation suggestedXChromaOffset;
	public VkChromaLocation suggestedYChromaOffset;
}

[CRepr] struct VkImportScreenBufferInfoQNX
{
	public const VkStructureType SType = .VkImportScreenBufferInfoQNX;
	public VkStructureType sType = SType;
	public void* pNext;
	public _screen_buffer* buffer;

	public this(void* pNext, _screen_buffer* buffer)
	{
		this.pNext = pNext;
		this.buffer = buffer;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExternalFormatQNX
{
	public const VkStructureType SType = .VkExternalFormatQNX;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint64 externalFormat;

	public this(void* pNext, uint64 externalFormat)
	{
		this.pNext = pNext;
		this.externalFormat = externalFormat;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX
{
	public const VkStructureType SType = .VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 screenBufferImport;

	public this(void* pNext, VkBool32 screenBufferImport)
	{
		this.pNext = pNext;
		this.screenBufferImport = screenBufferImport;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetScreenBufferPropertiesQNX(VkDevice device, _screen_buffer* buffer, out VkScreenBufferPropertiesQNX pProperties);

static { public const uint32 VK_MSFT_LAYERED_DRIVER_SPEC_VERSION = 1; }
static { public const c_char* VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME = "VK_MSFT_layered_driver"; }

[AllowDuplicates] enum VkLayeredDriverUnderlyingApiMSFT : int32
{
	NoneMSFT = 0,
	D3d12MSFT = 1,
}

[CRepr] struct VkPhysicalDeviceLayeredDriverPropertiesMSFT
{
	public const VkStructureType SType = .VkPhysicalDeviceLayeredDriverPropertiesMSFT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkLayeredDriverUnderlyingApiMSFT underlyingAPI;
}

static { public const uint32 VK_KHR_INDEX_TYPE_UINT8_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME = "VK_KHR_index_type_uint8"; }

typealias VkPhysicalDeviceIndexTypeUint8FeaturesKHR = VkPhysicalDeviceIndexTypeUint8Features;

static { public const uint32 VK_KHR_LINE_RASTERIZATION_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME = "VK_KHR_line_rasterization"; }

typealias VkPhysicalDeviceLineRasterizationFeaturesKHR = VkPhysicalDeviceLineRasterizationFeatures;
typealias VkPhysicalDeviceLineRasterizationPropertiesKHR = VkPhysicalDeviceLineRasterizationProperties;
typealias VkPipelineRasterizationLineStateCreateInfoKHR = VkPipelineRasterizationLineStateCreateInfo;
typealias VkLineRasterizationModeKHR = VkLineRasterizationMode;

static { public const uint32 VK_KHR_CALIBRATED_TIMESTAMPS_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME = "VK_KHR_calibrated_timestamps"; }

[AllowDuplicates] enum VkTimeDomainKHR : int32
{
	DeviceKHR = 0,
	ClockMonotonicKHR = 1,
	ClockMonotonicRawKHR = 2,
	QueryPerformanceCounterKHR = 3,
	VkTimeDomainDeviceEXT = DeviceKHR,
	VkTimeDomainClockMonotonicEXT = ClockMonotonicKHR,
	VkTimeDomainClockMonotonicRawEXT = ClockMonotonicRawKHR,
	VkTimeDomainQueryPerformanceCounterEXT = QueryPerformanceCounterKHR,
}

[CRepr] struct VkCalibratedTimestampInfoKHR
{
	public const VkStructureType SType = .VkCalibratedTimestampInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkTimeDomainKHR timeDomain;

	public this(void* pNext, VkTimeDomainKHR timeDomain)
	{
		this.pNext = pNext;
		this.timeDomain = timeDomain;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, out uint32 pTimeDomainCount, VkTimeDomainKHR* pTimeDomains = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetCalibratedTimestampsKHR(VkDevice device, uint32 timestampCount, VkCalibratedTimestampInfoKHR* pTimestampInfos, uint64* pTimestamps, out uint64 pMaxDeviation);

static { public const uint32 VK_KHR_SHADER_EXPECT_ASSUME_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME = "VK_KHR_shader_expect_assume"; }

typealias VkPhysicalDeviceShaderExpectAssumeFeaturesKHR = VkPhysicalDeviceShaderExpectAssumeFeatures;

static { public const uint32 VK_KHR_MAINTENANCE_6_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_MAINTENANCE_6_EXTENSION_NAME = "VK_KHR_maintenance6"; }

typealias VkPhysicalDeviceMaintenance6FeaturesKHR = VkPhysicalDeviceMaintenance6Features;
typealias VkPhysicalDeviceMaintenance6PropertiesKHR = VkPhysicalDeviceMaintenance6Properties;
typealias VkBindMemoryStatusKHR = VkBindMemoryStatus;
typealias VkBindDescriptorSetsInfoKHR = VkBindDescriptorSetsInfo;
typealias VkPushConstantsInfoKHR = VkPushConstantsInfo;
typealias VkPushDescriptorSetInfoKHR = VkPushDescriptorSetInfo;
typealias VkPushDescriptorSetWithTemplateInfoKHR = VkPushDescriptorSetWithTemplateInfo;

[CRepr] struct VkSetDescriptorBufferOffsetsInfoEXT
{
	public const VkStructureType SType = .VkSetDescriptorBufferOffsetsInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkShaderStageFlags stageFlags;
	public VkPipelineLayout layout;
	public uint32 firstSet;
	public uint32 setCount;
	public uint32* pBufferIndices;
	public VkDeviceSize* pOffsets;
	public VulkanDuoSpan<uint32, VkDeviceSize> bufferIndices_offsets
	{
		[Inline] get => .(setCount, pBufferIndices, pOffsets);
		[Inline] set mut { setCount = value.count; pBufferIndices = value.ptr1; pOffsets = value.ptr2; }
	}

	public this(void* pNext, VkShaderStageFlags stageFlags, VkPipelineLayout layout, uint32 firstSet, VulkanDuoSpan<uint32, VkDeviceSize> bufferIndices_offsets) : this()
	{
		this.pNext = pNext;
		this.stageFlags = stageFlags;
		this.layout = layout;
		this.firstSet = firstSet;
		this.bufferIndices_offsets = bufferIndices_offsets;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBindDescriptorBufferEmbeddedSamplersInfoEXT
{
	public const VkStructureType SType = .VkBindDescriptorBufferEmbeddedSamplersInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkShaderStageFlags stageFlags;
	public VkPipelineLayout layout;
	public uint32 set;

	public this(void* pNext, VkShaderStageFlags stageFlags, VkPipelineLayout layout = null, uint32 set = 0)
	{
		this.pNext = pNext;
		this.stageFlags = stageFlags;
		this.layout = layout;
		this.set = set;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdSetDescriptorBufferOffsets2EXT(VkCommandBuffer commandBuffer, VkSetDescriptorBufferOffsetsInfoEXT* pSetDescriptorBufferOffsetsInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(VkCommandBuffer commandBuffer, VkBindDescriptorBufferEmbeddedSamplersInfoEXT* pBindDescriptorBufferEmbeddedSamplersInfo);

// Individual APIs with dependencies on specific versions/extensions should get their own require blocks with depends= attribute set appropriately
static { public const uint32 VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME = "VK_NV_descriptor_pool_overallocation"; }

[CRepr] struct VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 descriptorPoolOverallocation;

	public this(void* pNext, VkBool32 descriptorPoolOverallocation)
	{
		this.pNext = pNext;
		this.descriptorPoolOverallocation = descriptorPoolOverallocation;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_QCOM_TILE_MEMORY_HEAP_SPEC_VERSION = 1; }
static { public const c_char* VK_QCOM_TILE_MEMORY_HEAP_EXTENSION_NAME = "VK_QCOM_tile_memory_heap"; }

[CRepr] struct VkPhysicalDeviceTileMemoryHeapFeaturesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceTileMemoryHeapFeaturesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 tileMemoryHeap;

	public this(void* pNext, VkBool32 tileMemoryHeap)
	{
		this.pNext = pNext;
		this.tileMemoryHeap = tileMemoryHeap;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceTileMemoryHeapPropertiesQCOM
{
	public const VkStructureType SType = .VkPhysicalDeviceTileMemoryHeapPropertiesQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 queueSubmitBoundary;
	public VkBool32 tileBufferTransfers;

	public this(void* pNext, VkBool32 queueSubmitBoundary, VkBool32 tileBufferTransfers)
	{
		this.pNext = pNext;
		this.queueSubmitBoundary = queueSubmitBoundary;
		this.tileBufferTransfers = tileBufferTransfers;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkTileMemoryRequirementsQCOM
{
	public const VkStructureType SType = .VkTileMemoryRequirementsQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize size;
	public VkDeviceSize alignment;

	public this(void* pNext, VkDeviceSize size, VkDeviceSize alignment)
	{
		this.pNext = pNext;
		this.size = size;
		this.alignment = alignment;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkTileMemoryBindInfoQCOM
{
	public const VkStructureType SType = .VkTileMemoryBindInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceMemory memory;

	public this(void* pNext, VkDeviceMemory memory)
	{
		this.pNext = pNext;
		this.memory = memory;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBindTileMemoryQCOM(VkCommandBuffer commandBuffer, VkTileMemoryBindInfoQCOM* pTileMemoryBindInfo = null);

[CRepr] struct VkTileMemorySizeInfoQCOM
{
	public const VkStructureType SType = .VkTileMemorySizeInfoQCOM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize size;

	public this(void* pNext, VkDeviceSize size)
	{
		this.pNext = pNext;
		this.size = size;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_DISPLAY_STEREO_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_DISPLAY_STEREO_EXTENSION_NAME = "VK_NV_display_stereo"; }

[CRepr] struct VkDisplaySurfaceStereoCreateInfoNV
{
	public const VkStructureType SType = .VkDisplaySurfaceStereoCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDisplaySurfaceStereoTypeNV stereoType; // The 3D stereo type to use when presenting this surface.

	public this(void* pNext, VkDisplaySurfaceStereoTypeNV stereoType)
	{
		this.pNext = pNext;
		this.stereoType = stereoType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkDisplaySurfaceStereoTypeNV : int32
{
	NoneNV = 0,
	OnboardDinNV = 1,
	Hdmi3dNV = 2,
	InbandDisplayportNV = 3,
}

[CRepr] struct VkDisplayModeStereoPropertiesNV
{
	public const VkStructureType SType = .VkDisplayModeStereoPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 hdmi3DSupported; // Whether this mode supports HDMI 3D stereo rendering.
}

static { public const uint32 VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_EXTENSION_NAME = "VK_KHR_video_encode_intra_refresh"; }

typealias VkVideoEncodeIntraRefreshModeFlagsKHR = VkVideoEncodeIntraRefreshModeFlagBitsKHR;

[AllowDuplicates] enum VkVideoEncodeIntraRefreshModeFlagBitsKHR : int32
{
	NoneKHR = 0,
	PerPicturePartitionKHR = 1 << 0,
	BlockBasedKHR = 1 << 1,
	BlockRowBasedKHR = 1 << 2,
	BlockColumnBasedKHR = 1 << 3,
}

[CRepr] struct VkVideoEncodeIntraRefreshCapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoEncodeIntraRefreshCapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeIntraRefreshModeFlagsKHR intraRefreshModes;
	public uint32 maxIntraRefreshCycleDuration;
	public uint32 maxIntraRefreshActiveReferencePictures;
	public VkBool32 partitionIndependentIntraRefreshRegions;
	public VkBool32 nonRectangularIntraRefreshRegions;
}

[CRepr] struct VkVideoEncodeSessionIntraRefreshCreateInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeSessionIntraRefreshCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeIntraRefreshModeFlagBitsKHR intraRefreshMode;

	public this(void* pNext = null, VkVideoEncodeIntraRefreshModeFlagBitsKHR intraRefreshMode = 0)
	{
		this.pNext = pNext;
		this.intraRefreshMode = intraRefreshMode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeIntraRefreshInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeIntraRefreshInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 intraRefreshCycleDuration;
	public uint32 intraRefreshIndex;

	public this(void* pNext, uint32 intraRefreshCycleDuration, uint32 intraRefreshIndex)
	{
		this.pNext = pNext;
		this.intraRefreshCycleDuration = intraRefreshCycleDuration;
		this.intraRefreshIndex = intraRefreshIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoReferenceIntraRefreshInfoKHR
{
	public const VkStructureType SType = .VkVideoReferenceIntraRefreshInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 dirtyIntraRefreshRegions;

	public this(void* pNext, uint32 dirtyIntraRefreshRegions)
	{
		this.pNext = pNext;
		this.dirtyIntraRefreshRegions = dirtyIntraRefreshRegions;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 videoEncodeIntraRefresh;

	public this(void* pNext, VkBool32 videoEncodeIntraRefresh)
	{
		this.pNext = pNext;
		this.videoEncodeIntraRefresh = videoEncodeIntraRefresh;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_SPEC_VERSION = 2; }
static { public const c_char* VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_EXTENSION_NAME = "VK_KHR_video_encode_quantization_map"; }

[AllowDuplicates] enum VkVideoEncodeFlagBitsKHR : int32
{
	IntraRefreshKHR = 1 << 2,
	WithQuantizationDeltaMapKHR = 1 << 0,
	WithEmphasisMapKHR = 1 << 1,
}

[AllowDuplicates] enum VkVideoSessionParametersCreateFlagBitsKHR : int32
{
	QuantizationMapCompatibleKHR = 1 << 0,
}

[CRepr] struct VkVideoEncodeQuantizationMapCapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoEncodeQuantizationMapCapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExtent2D maxQuantizationMapExtent;
}

[CRepr] struct VkVideoFormatQuantizationMapPropertiesKHR
{
	public const VkStructureType SType = .VkVideoFormatQuantizationMapPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExtent2D quantizationMapTexelSize;
}

[CRepr] struct VkVideoEncodeQuantizationMapInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeQuantizationMapInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkImageView quantizationMap;
	public VkExtent2D quantizationMapExtent;

	public this(void* pNext, VkImageView quantizationMap, VkExtent2D quantizationMapExtent)
	{
		this.pNext = pNext;
		this.quantizationMap = quantizationMap;
		this.quantizationMapExtent = quantizationMapExtent;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR
{
	public const VkStructureType SType = .VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExtent2D quantizationMapTexelSize;

	public this(void* pNext, VkExtent2D quantizationMapTexelSize)
	{
		this.pNext = pNext;
		this.quantizationMapTexelSize = quantizationMapTexelSize;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 videoEncodeQuantizationMap;

	public this(void* pNext, VkBool32 videoEncodeQuantizationMap)
	{
		this.pNext = pNext;
		this.videoEncodeQuantizationMap = videoEncodeQuantizationMap;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoEncodeH264QuantizationMapCapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoEncodeH264QuantizationMapCapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public int32 minQpDelta;
	public int32 maxQpDelta;
}

[CRepr] struct VkVideoEncodeH265QuantizationMapCapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoEncodeH265QuantizationMapCapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public int32 minQpDelta;
	public int32 maxQpDelta;
}

[CRepr] struct VkVideoFormatH265QuantizationMapPropertiesKHR
{
	public const VkStructureType SType = .VkVideoFormatH265QuantizationMapPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeH265CtbSizeFlagsKHR compatibleCtbSizes;
}

[CRepr] struct VkVideoEncodeAV1QuantizationMapCapabilitiesKHR
{
	public const VkStructureType SType = .VkVideoEncodeAv1QuantizationMapCapabilitiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public int32 minQIndexDelta;
	public int32 maxQIndexDelta;
}

[CRepr] struct VkVideoFormatAV1QuantizationMapPropertiesKHR
{
	public const VkStructureType SType = .VkVideoFormatAv1QuantizationMapPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkVideoEncodeAV1SuperblockSizeFlagsKHR compatibleSuperblockSizes;
}

static { public const uint32 VK_NV_RAW_ACCESS_CHAINS_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME = "VK_NV_raw_access_chains"; }

[CRepr] struct VkPhysicalDeviceRawAccessChainsFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceRawAccessChainsFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderRawAccessChains;

	public this(void* pNext, VkBool32 shaderRawAccessChains)
	{
		this.pNext = pNext;
		this.shaderRawAccessChains = shaderRawAccessChains;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_EXTERNAL_COMPUTE_QUEUE_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_EXTERNAL_COMPUTE_QUEUE_EXTENSION_NAME = "VK_NV_external_compute_queue"; }

class VkExternalComputeQueueNV { private this() { } }

[CRepr] struct VkExternalComputeQueueDeviceCreateInfoNV
{
	public const VkStructureType SType = .VkExternalComputeQueueDeviceCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 reservedExternalQueues;

	public this(void* pNext, uint32 reservedExternalQueues)
	{
		this.pNext = pNext;
		this.reservedExternalQueues = reservedExternalQueues;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExternalComputeQueueCreateInfoNV
{
	public const VkStructureType SType = .VkExternalComputeQueueCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkQueue preferredQueue;

	public this(void* pNext, VkQueue preferredQueue)
	{
		this.pNext = pNext;
		this.preferredQueue = preferredQueue;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkExternalComputeQueueDataParamsNV
{
	public const VkStructureType SType = .VkExternalComputeQueueDataParamsNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 deviceIndex;

	public this(void* pNext, uint32 deviceIndex)
	{
		this.pNext = pNext;
		this.deviceIndex = deviceIndex;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceExternalComputeQueuePropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceExternalComputeQueuePropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 externalDataSize;
	public uint32 maxExternalQueues;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateExternalComputeQueueNV(VkDevice device, VkExternalComputeQueueCreateInfoNV* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkExternalComputeQueueNV pExternalQueue);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyExternalComputeQueueNV(VkDevice device, VkExternalComputeQueueNV externalQueue, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkGetExternalComputeQueueDataNV(VkExternalComputeQueueNV externalQueue, out VkExternalComputeQueueDataParamsNV @params, out void pData);

static { public const uint32 VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_EXTENSION_NAME = "VK_KHR_shader_relaxed_extended_instruction"; }

[CRepr] struct VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderRelaxedExtendedInstruction;

	public this(void* pNext, VkBool32 shaderRelaxedExtendedInstruction)
	{
		this.pNext = pNext;
		this.shaderRelaxedExtendedInstruction = shaderRelaxedExtendedInstruction;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_COMMAND_BUFFER_INHERITANCE_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_COMMAND_BUFFER_INHERITANCE_EXTENSION_NAME = "VK_NV_command_buffer_inheritance"; }

[CRepr] struct VkPhysicalDeviceCommandBufferInheritanceFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceCommandBufferInheritanceFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 commandBufferInheritance;

	public this(void* pNext, VkBool32 commandBufferInheritance)
	{
		this.pNext = pNext;
		this.commandBufferInheritance = commandBufferInheritance;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_MAINTENANCE_7_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_MAINTENANCE_7_EXTENSION_NAME = "VK_KHR_maintenance7"; }

[CRepr] struct VkPhysicalDeviceMaintenance7FeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceMaintenance7FeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 maintenance7;

	public this(void* pNext, VkBool32 maintenance7)
	{
		this.pNext = pNext;
		this.maintenance7 = maintenance7;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceMaintenance7PropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceMaintenance7PropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 robustFragmentShadingRateAttachmentAccess;
	public VkBool32 separateDepthStencilAttachmentAccess;
	public uint32 maxDescriptorSetTotalUniformBuffersDynamic;
	public uint32 maxDescriptorSetTotalStorageBuffersDynamic;
	public uint32 maxDescriptorSetTotalBuffersDynamic;
	public uint32 maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic;
	public uint32 maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic;
	public uint32 maxDescriptorSetUpdateAfterBindTotalBuffersDynamic;
}

[CRepr] struct VkPhysicalDeviceLayeredApiPropertiesListKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceLayeredApiPropertiesListKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 layeredApiCount;
	public VkPhysicalDeviceLayeredApiPropertiesKHR* pLayeredApis; // Output list of layered implementations underneath the physical device
	public VulkanSpan<VkPhysicalDeviceLayeredApiPropertiesKHR> layeredApis
	{
		[Inline] get => .(layeredApiCount, pLayeredApis);
		[Inline] set mut { layeredApiCount = value.count; pLayeredApis = value.ptr; }
	} // Output list of layered implementations underneath the physical device

	public this(void* pNext = null, VulkanSpan<VkPhysicalDeviceLayeredApiPropertiesKHR> layeredApis = .()) : this()
	{
		this.pNext = pNext;
		this.layeredApis = layeredApis;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceLayeredApiPropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceLayeredApiPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 vendorID;
	public uint32 deviceID;
	public VkPhysicalDeviceLayeredApiKHR layeredAPI;
	public c_char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] deviceName;
}

[AllowDuplicates] enum VkPhysicalDeviceLayeredApiKHR : int32
{
	VulkanKHR = 0,
	D3d12KHR = 1,
	MetalKHR = 2,
	OpenglKHR = 3,
	OpenglesKHR = 4,
}

[CRepr] struct VkPhysicalDeviceLayeredApiVulkanPropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceLayeredApiVulkanPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPhysicalDeviceProperties2 properties;
}

static { public const uint32 VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME = "VK_NV_shader_atomic_float16_vector"; }

[CRepr] struct VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderFloat16VectorAtomics;

	public this(void* pNext, VkBool32 shaderFloat16VectorAtomics)
	{
		this.pNext = pNext;
		this.shaderFloat16VectorAtomics = shaderFloat16VectorAtomics;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_SHADER_REPLICATED_COMPOSITES_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME = "VK_EXT_shader_replicated_composites"; }

[CRepr] struct VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderReplicatedComposites;

	public this(void* pNext, VkBool32 shaderReplicatedComposites)
	{
		this.pNext = pNext;
		this.shaderReplicatedComposites = shaderReplicatedComposites;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_SHADER_FLOAT8_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_SHADER_FLOAT8_EXTENSION_NAME = "VK_EXT_shader_float8"; }

[CRepr] struct VkPhysicalDeviceShaderFloat8FeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceShaderFloat8FeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 shaderFloat8;
	public VkBool32 shaderFloat8CooperativeMatrix;

	public this(void* pNext, VkBool32 shaderFloat8, VkBool32 shaderFloat8CooperativeMatrix)
	{
		this.pNext = pNext;
		this.shaderFloat8 = shaderFloat8;
		this.shaderFloat8CooperativeMatrix = shaderFloat8CooperativeMatrix;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_RAY_TRACING_VALIDATION_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME = "VK_NV_ray_tracing_validation"; }

[CRepr] struct VkPhysicalDeviceRayTracingValidationFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceRayTracingValidationFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 rayTracingValidation;

	public this(void* pNext, VkBool32 rayTracingValidation)
	{
		this.pNext = pNext;
		this.rayTracingValidation = rayTracingValidation;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_CLUSTER_ACCELERATION_STRUCTURE_SPEC_VERSION = 3; }
static { public const c_char* VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME = "VK_NV_cluster_acceleration_structure"; }

[CRepr] struct VkPhysicalDeviceClusterAccelerationStructureFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceClusterAccelerationStructureFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 clusterAccelerationStructure;

	public this(void* pNext, VkBool32 clusterAccelerationStructure)
	{
		this.pNext = pNext;
		this.clusterAccelerationStructure = clusterAccelerationStructure;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceClusterAccelerationStructurePropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceClusterAccelerationStructurePropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxVerticesPerCluster;
	public uint32 maxTrianglesPerCluster;
	public uint32 clusterScratchByteAlignment;
	public uint32 clusterByteAlignment;
	public uint32 clusterTemplateByteAlignment;
	public uint32 clusterBottomLevelByteAlignment;
	public uint32 clusterTemplateBoundsByteAlignment;
	public uint32 maxClusterGeometryIndex;
}

[CRepr] struct VkClusterAccelerationStructureClustersBottomLevelInputNV
{
	public const VkStructureType SType = .VkClusterAccelerationStructureClustersBottomLevelInputNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxTotalClusterCount;
	public uint32 maxClusterCountPerAccelerationStructure;

	public this(void* pNext, uint32 maxTotalClusterCount, uint32 maxClusterCountPerAccelerationStructure)
	{
		this.pNext = pNext;
		this.maxTotalClusterCount = maxTotalClusterCount;
		this.maxClusterCountPerAccelerationStructure = maxClusterCountPerAccelerationStructure;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkClusterAccelerationStructureTriangleClusterInputNV
{
	public const VkStructureType SType = .VkClusterAccelerationStructureTriangleClusterInputNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkFormat vertexFormat;
	public uint32 maxGeometryIndexValue;
	public uint32 maxClusterUniqueGeometryCount;
	public uint32 maxClusterTriangleCount;
	public uint32 maxClusterVertexCount;
	public uint32 maxTotalTriangleCount;
	public uint32 maxTotalVertexCount;
	public uint32 minPositionTruncateBitCount;

	public this(void* pNext, VkFormat vertexFormat, uint32 maxGeometryIndexValue, uint32 maxClusterUniqueGeometryCount, uint32 maxClusterTriangleCount, uint32 maxClusterVertexCount, uint32 maxTotalTriangleCount, uint32 maxTotalVertexCount, uint32 minPositionTruncateBitCount)
	{
		this.pNext = pNext;
		this.vertexFormat = vertexFormat;
		this.maxGeometryIndexValue = maxGeometryIndexValue;
		this.maxClusterUniqueGeometryCount = maxClusterUniqueGeometryCount;
		this.maxClusterTriangleCount = maxClusterTriangleCount;
		this.maxClusterVertexCount = maxClusterVertexCount;
		this.maxTotalTriangleCount = maxTotalTriangleCount;
		this.maxTotalVertexCount = maxTotalVertexCount;
		this.minPositionTruncateBitCount = minPositionTruncateBitCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkClusterAccelerationStructureMoveObjectsInputNV
{
	public const VkStructureType SType = .VkClusterAccelerationStructureMoveObjectsInputNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkClusterAccelerationStructureTypeNV type;
	public VkBool32 noMoveOverlap;
	public VkDeviceSize maxMovedBytes;

	public this(void* pNext, VkClusterAccelerationStructureTypeNV type, VkBool32 noMoveOverlap, VkDeviceSize maxMovedBytes)
	{
		this.pNext = pNext;
		this.type = type;
		this.noMoveOverlap = noMoveOverlap;
		this.maxMovedBytes = maxMovedBytes;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[Union, CRepr] struct VkClusterAccelerationStructureOpInputNV
{
	public VkClusterAccelerationStructureClustersBottomLevelInputNV* pClustersBottomLevel;
	public VkClusterAccelerationStructureTriangleClusterInputNV* pTriangleClusters;
	public VkClusterAccelerationStructureMoveObjectsInputNV* pMoveObjects;
}

[CRepr] struct VkClusterAccelerationStructureInputInfoNV
{
	public const VkStructureType SType = .VkClusterAccelerationStructureInputInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxAccelerationStructureCount;
	public VkBuildAccelerationStructureFlagsKHR flags;
	public VkClusterAccelerationStructureOpTypeNV opType;
	public VkClusterAccelerationStructureOpModeNV opMode;
	public VkClusterAccelerationStructureOpInputNV opInput;

	public this(void* pNext, uint32 maxAccelerationStructureCount, VkBuildAccelerationStructureFlagsKHR flags, VkClusterAccelerationStructureOpTypeNV opType, VkClusterAccelerationStructureOpModeNV opMode, VkClusterAccelerationStructureOpInputNV opInput)
	{
		this.pNext = pNext;
		this.maxAccelerationStructureCount = maxAccelerationStructureCount;
		this.flags = flags;
		this.opType = opType;
		this.opMode = opMode;
		this.opInput = opInput;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkClusterAccelerationStructureCommandsInfoNV
{
	public const VkStructureType SType = .VkClusterAccelerationStructureCommandsInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkClusterAccelerationStructureInputInfoNV input;
	public VkDeviceAddress dstImplicitData;
	public VkDeviceAddress scratchData;
	public VkStridedDeviceAddressRegionKHR dstAddressesArray;
	public VkStridedDeviceAddressRegionKHR dstSizesArray;
	public VkStridedDeviceAddressRegionKHR srcInfosArray;
	public VkDeviceAddress srcInfosCount;
	public VkClusterAccelerationStructureAddressResolutionFlagsNV addressResolutionFlags;

	public this(void* pNext, VkClusterAccelerationStructureInputInfoNV input, VkDeviceAddress dstImplicitData, VkDeviceAddress scratchData, VkStridedDeviceAddressRegionKHR dstAddressesArray, VkStridedDeviceAddressRegionKHR dstSizesArray, VkStridedDeviceAddressRegionKHR srcInfosArray, VkDeviceAddress srcInfosCount, VkClusterAccelerationStructureAddressResolutionFlagsNV addressResolutionFlags = 0)
	{
		this.pNext = pNext;
		this.input = input;
		this.dstImplicitData = dstImplicitData;
		this.scratchData = scratchData;
		this.dstAddressesArray = dstAddressesArray;
		this.dstSizesArray = dstSizesArray;
		this.srcInfosArray = srcInfosArray;
		this.srcInfosCount = srcInfosCount;
		this.addressResolutionFlags = addressResolutionFlags;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkStridedDeviceAddressNV
{
	public VkDeviceAddress startAddress;
	public VkDeviceSize strideInBytes; // Specified in bytes

	public this(VkDeviceAddress startAddress, VkDeviceSize strideInBytes)
	{
		this.startAddress = startAddress;
		this.strideInBytes = strideInBytes;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV
{
	// The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.
	[Bitfield(.Public, .Bits(24), "geometryIndex")]
	[Bitfield(.Public, .Bits(5), "reserved")]
	[Bitfield(.Public, .Bits(3), "geometryFlags")]
	private uint32 __bitfields_geometryFlags;

	public this(uint32 geometryIndex, uint32 reserved, uint32 geometryFlags) : this()
	{
		this.geometryIndex = geometryIndex;
		this.reserved = reserved;
		this.geometryFlags = geometryFlags;
	}

	public this()
	{
		this = default;
	}
}

typealias VkClusterAccelerationStructureClusterFlagsNV = VkClusterAccelerationStructureClusterFlagBitsNV;

[AllowDuplicates] enum VkClusterAccelerationStructureClusterFlagBitsNV : int32
{
	AllowDisableOpacityMicromapsNV = 1 << 0,
}

typealias VkClusterAccelerationStructureGeometryFlagsNV = VkClusterAccelerationStructureGeometryFlagBitsNV;

[AllowDuplicates] enum VkClusterAccelerationStructureGeometryFlagBitsNV : int32
{
	CullDisableNV = 1 << 0,
	NoDuplicateAnyhitInvocationNV = 1 << 1,
	OpaqueNV = 1 << 2,
}

typealias VkClusterAccelerationStructureAddressResolutionFlagsNV = VkClusterAccelerationStructureAddressResolutionFlagBitsNV;

[AllowDuplicates] enum VkClusterAccelerationStructureAddressResolutionFlagBitsNV : int32
{
	NoneNV = 0,
	IndirectedDstImplicitDataNV = 1 << 0,
	IndirectedScratchDataNV = 1 << 1,
	IndirectedDstAddressArrayNV = 1 << 2,
	IndirectedDstSizesArrayNV = 1 << 3,
	IndirectedSrcInfosArrayNV = 1 << 4,
	IndirectedSrcInfosCountNV = 1 << 5,
}

[CRepr] struct VkClusterAccelerationStructureMoveObjectsInfoNV
{
	public VkDeviceAddress srcAccelerationStructure;

	public this(VkDeviceAddress srcAccelerationStructure)
	{
		this.srcAccelerationStructure = srcAccelerationStructure;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV
{
	public uint32 clusterReferencesCount;
	public uint32 clusterReferencesStride;
	public VkDeviceAddress clusterReferences;

	public this(uint32 clusterReferencesCount, uint32 clusterReferencesStride, VkDeviceAddress clusterReferences)
	{
		this.clusterReferencesCount = clusterReferencesCount;
		this.clusterReferencesStride = clusterReferencesStride;
		this.clusterReferences = clusterReferences;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkClusterAccelerationStructureBuildTriangleClusterInfoNV
{
	// The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.
	public uint32 clusterID;
	public VkClusterAccelerationStructureClusterFlagsNV clusterFlags;
	[Bitfield(.Public, .Bits(9), "triangleCount")]
	[Bitfield(.Public, .Bits(9), "vertexCount")]
	[Bitfield(.Public, .Bits(6), "positionTruncateBitCount")]
	[Bitfield(.Public, .Bits(4), "indexType")]
	[Bitfield(.Public, .Bits(4), "opacityMicromapIndexType")]
	private uint32 __bitfields_opacityMicromapIndexType;
	public VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV baseGeometryIndexAndGeometryFlags;
	public uint16 indexBufferStride;
	public uint16 vertexBufferStride;
	public uint16 geometryIndexAndFlagsBufferStride;
	public uint16 opacityMicromapIndexBufferStride;
	public VkDeviceAddress indexBuffer;
	public VkDeviceAddress vertexBuffer;
	public VkDeviceAddress geometryIndexAndFlagsBuffer;
	public VkDeviceAddress opacityMicromapArray;
	public VkDeviceAddress opacityMicromapIndexBuffer;

	public this(uint32 clusterID, VkClusterAccelerationStructureClusterFlagsNV clusterFlags, uint32 triangleCount, uint32 vertexCount, uint32 positionTruncateBitCount, uint32 indexType, uint32 opacityMicromapIndexType, VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV baseGeometryIndexAndGeometryFlags, uint16 indexBufferStride, uint16 vertexBufferStride, uint16 geometryIndexAndFlagsBufferStride, uint16 opacityMicromapIndexBufferStride, VkDeviceAddress indexBuffer, VkDeviceAddress vertexBuffer, VkDeviceAddress geometryIndexAndFlagsBuffer, VkDeviceAddress opacityMicromapArray, VkDeviceAddress opacityMicromapIndexBuffer) : this()
	{
		this.clusterID = clusterID;
		this.clusterFlags = clusterFlags;
		this.triangleCount = triangleCount;
		this.vertexCount = vertexCount;
		this.positionTruncateBitCount = positionTruncateBitCount;
		this.indexType = indexType;
		this.opacityMicromapIndexType = opacityMicromapIndexType;
		this.baseGeometryIndexAndGeometryFlags = baseGeometryIndexAndGeometryFlags;
		this.indexBufferStride = indexBufferStride;
		this.vertexBufferStride = vertexBufferStride;
		this.geometryIndexAndFlagsBufferStride = geometryIndexAndFlagsBufferStride;
		this.opacityMicromapIndexBufferStride = opacityMicromapIndexBufferStride;
		this.indexBuffer = indexBuffer;
		this.vertexBuffer = vertexBuffer;
		this.geometryIndexAndFlagsBuffer = geometryIndexAndFlagsBuffer;
		this.opacityMicromapArray = opacityMicromapArray;
		this.opacityMicromapIndexBuffer = opacityMicromapIndexBuffer;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV
{
	// The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.
	public uint32 clusterID;
	public VkClusterAccelerationStructureClusterFlagsNV clusterFlags;
	[Bitfield(.Public, .Bits(9), "triangleCount")]
	[Bitfield(.Public, .Bits(9), "vertexCount")]
	[Bitfield(.Public, .Bits(6), "positionTruncateBitCount")]
	[Bitfield(.Public, .Bits(4), "indexType")]
	[Bitfield(.Public, .Bits(4), "opacityMicromapIndexType")]
	private uint32 __bitfields_opacityMicromapIndexType;
	public VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV baseGeometryIndexAndGeometryFlags;
	public uint16 indexBufferStride;
	public uint16 vertexBufferStride;
	public uint16 geometryIndexAndFlagsBufferStride;
	public uint16 opacityMicromapIndexBufferStride;
	public VkDeviceAddress indexBuffer;
	public VkDeviceAddress vertexBuffer;
	public VkDeviceAddress geometryIndexAndFlagsBuffer;
	public VkDeviceAddress opacityMicromapArray;
	public VkDeviceAddress opacityMicromapIndexBuffer;
	public VkDeviceAddress instantiationBoundingBoxLimit;

	public this(uint32 clusterID, VkClusterAccelerationStructureClusterFlagsNV clusterFlags, uint32 triangleCount, uint32 vertexCount, uint32 positionTruncateBitCount, uint32 indexType, uint32 opacityMicromapIndexType, VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV baseGeometryIndexAndGeometryFlags, uint16 indexBufferStride, uint16 vertexBufferStride, uint16 geometryIndexAndFlagsBufferStride, uint16 opacityMicromapIndexBufferStride, VkDeviceAddress indexBuffer, VkDeviceAddress vertexBuffer, VkDeviceAddress geometryIndexAndFlagsBuffer, VkDeviceAddress opacityMicromapArray, VkDeviceAddress opacityMicromapIndexBuffer, VkDeviceAddress instantiationBoundingBoxLimit) : this()
	{
		this.clusterID = clusterID;
		this.clusterFlags = clusterFlags;
		this.triangleCount = triangleCount;
		this.vertexCount = vertexCount;
		this.positionTruncateBitCount = positionTruncateBitCount;
		this.indexType = indexType;
		this.opacityMicromapIndexType = opacityMicromapIndexType;
		this.baseGeometryIndexAndGeometryFlags = baseGeometryIndexAndGeometryFlags;
		this.indexBufferStride = indexBufferStride;
		this.vertexBufferStride = vertexBufferStride;
		this.geometryIndexAndFlagsBufferStride = geometryIndexAndFlagsBufferStride;
		this.opacityMicromapIndexBufferStride = opacityMicromapIndexBufferStride;
		this.indexBuffer = indexBuffer;
		this.vertexBuffer = vertexBuffer;
		this.geometryIndexAndFlagsBuffer = geometryIndexAndFlagsBuffer;
		this.opacityMicromapArray = opacityMicromapArray;
		this.opacityMicromapIndexBuffer = opacityMicromapIndexBuffer;
		this.instantiationBoundingBoxLimit = instantiationBoundingBoxLimit;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkClusterAccelerationStructureInstantiateClusterInfoNV
{
	public uint32 clusterIdOffset;
	[Bitfield(.Public, .Bits(24), "geometryIndexOffset")]
	[Bitfield(.Public, .Bits(8), "reserved")]
	private uint32 __bitfields_reserved;
	public VkDeviceAddress clusterTemplateAddress;
	public VkStridedDeviceAddressNV vertexBuffer;

	public this(uint32 clusterIdOffset, uint32 geometryIndexOffset, uint32 reserved, VkDeviceAddress clusterTemplateAddress, VkStridedDeviceAddressNV vertexBuffer) : this()
	{
		this.clusterIdOffset = clusterIdOffset;
		this.geometryIndexOffset = geometryIndexOffset;
		this.reserved = reserved;
		this.clusterTemplateAddress = clusterTemplateAddress;
		this.vertexBuffer = vertexBuffer;
	}

	public this()
	{
		this = default;
	}
}

[AllowDuplicates] enum VkClusterAccelerationStructureIndexFormatFlagBitsNV : int32
{
	VK_8bitNV = 1 << 0,
	VK_16bitNV = 1 << 1,
	VK_32bitNV = 1 << 2,
}

typealias VkClusterAccelerationStructureIndexFormatFlagsNV = VkClusterAccelerationStructureIndexFormatFlagBitsNV;

[AllowDuplicates] enum VkClusterAccelerationStructureTypeNV : int32
{
	ClustersBottomLevelNV = 0,
	TriangleClusterNV = 1,
	TriangleClusterTemplateNV = 2,
}

[AllowDuplicates] enum VkClusterAccelerationStructureOpTypeNV : int32
{
	MoveObjectsNV = 0,
	BuildClustersBottomLevelNV = 1,
	BuildTriangleClusterNV = 2,
	BuildTriangleClusterTemplateNV = 3,
	InstantiateTriangleClusterNV = 4,
	GetClusterTemplateIndicesNV = 5,
}

[AllowDuplicates] enum VkClusterAccelerationStructureOpModeNV : int32
{
	ImplicitDestinationsNV = 0,
	ExplicitDestinationsNV = 1,
	ComputeSizesNV = 2,
}

[CRepr] struct VkClusterAccelerationStructureGetTemplateIndicesInfoNV
{
	public VkDeviceAddress clusterTemplateAddress;

	public this(VkDeviceAddress clusterTemplateAddress)
	{
		this.clusterTemplateAddress = clusterTemplateAddress;
	}

	public this()
	{
		this = default;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetClusterAccelerationStructureBuildSizesNV(VkDevice device, VkClusterAccelerationStructureInputInfoNV* pInfo, out VkAccelerationStructureBuildSizesInfoKHR pSizeInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBuildClusterAccelerationStructureIndirectNV(VkCommandBuffer commandBuffer, VkClusterAccelerationStructureCommandsInfoNV* pCommandInfos);

[CRepr] struct VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV
{
	public const VkStructureType SType = .VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 allowClusterAccelerationStructure;

	public this(void* pNext, VkBool32 allowClusterAccelerationStructure)
	{
		this.pNext = pNext;
		this.allowClusterAccelerationStructure = allowClusterAccelerationStructure;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_EXTENSION_NAME = "VK_NV_partitioned_acceleration_structure"; }
static { public const uint32 VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV = (.)(~0U); }

[CRepr] struct VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 partitionedAccelerationStructure;

	public this(void* pNext, VkBool32 partitionedAccelerationStructure)
	{
		this.pNext = pNext;
		this.partitionedAccelerationStructure = partitionedAccelerationStructure;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxPartitionCount;
}

[CRepr] struct VkPartitionedAccelerationStructureFlagsNV
{
	public const VkStructureType SType = .VkPartitionedAccelerationStructureFlagsNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 enablePartitionTranslation;

	public this(void* pNext, VkBool32 enablePartitionTranslation)
	{
		this.pNext = pNext;
		this.enablePartitionTranslation = enablePartitionTranslation;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkPartitionedAccelerationStructureOpTypeNV : int32
{
	WriteInstanceNV = 0,
	UpdateInstanceNV = 1,
	WritePartitionTranslationNV = 2,
}

[CRepr] struct VkBuildPartitionedAccelerationStructureIndirectCommandNV
{
	public VkPartitionedAccelerationStructureOpTypeNV opType;
	public uint32 argCount;
	public VkStridedDeviceAddressNV argData;

	public this(VkPartitionedAccelerationStructureOpTypeNV opType, uint32 argCount, VkStridedDeviceAddressNV argData)
	{
		this.opType = opType;
		this.argCount = argCount;
		this.argData = argData;
	}

	public this()
	{
		this = default;
	}
}

typealias VkPartitionedAccelerationStructureInstanceFlagsNV = VkPartitionedAccelerationStructureInstanceFlagBitsNV;

[AllowDuplicates] enum VkPartitionedAccelerationStructureInstanceFlagBitsNV : int32
{
	FlagTriangleFacingCullDisableNV = 1 << 0,
	FlagTriangleFlipFacingNV = 1 << 1,
	FlagForceOpaqueNV = 1 << 2,
	FlagForceNoOpaqueNV = 1 << 3,
	FlagEnableExplicitBoundingBoxNV = 1 << 4,
}

[CRepr] struct VkPartitionedAccelerationStructureWriteInstanceDataNV
{
	public VkTransformMatrixKHR transform;
	public float[6] explicitAABB;
	public uint32 instanceID;
	public uint32 instanceMask;
	public uint32 instanceContributionToHitGroupIndex;
	public VkPartitionedAccelerationStructureInstanceFlagsNV instanceFlags;
	public uint32 instanceIndex;
	public uint32 partitionIndex;
	public VkDeviceAddress accelerationStructure;

	public this(VkTransformMatrixKHR transform, float[6] explicitAABB, uint32 instanceID, uint32 instanceMask, uint32 instanceContributionToHitGroupIndex, VkPartitionedAccelerationStructureInstanceFlagsNV instanceFlags, uint32 instanceIndex, uint32 partitionIndex, VkDeviceAddress accelerationStructure)
	{
		this.transform = transform;
		this.explicitAABB = explicitAABB;
		this.instanceID = instanceID;
		this.instanceMask = instanceMask;
		this.instanceContributionToHitGroupIndex = instanceContributionToHitGroupIndex;
		this.instanceFlags = instanceFlags;
		this.instanceIndex = instanceIndex;
		this.partitionIndex = partitionIndex;
		this.accelerationStructure = accelerationStructure;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkPartitionedAccelerationStructureUpdateInstanceDataNV
{
	public uint32 instanceIndex;
	public uint32 instanceContributionToHitGroupIndex;
	public VkDeviceAddress accelerationStructure;

	public this(uint32 instanceIndex, uint32 instanceContributionToHitGroupIndex, VkDeviceAddress accelerationStructure)
	{
		this.instanceIndex = instanceIndex;
		this.instanceContributionToHitGroupIndex = instanceContributionToHitGroupIndex;
		this.accelerationStructure = accelerationStructure;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkPartitionedAccelerationStructureWritePartitionTranslationDataNV
{
	public uint32 partitionIndex;
	public float[3] partitionTranslation;

	public this(uint32 partitionIndex, float[3] partitionTranslation)
	{
		this.partitionIndex = partitionIndex;
		this.partitionTranslation = partitionTranslation;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkWriteDescriptorSetPartitionedAccelerationStructureNV
{
	public const VkStructureType SType = .VkWriteDescriptorSetPartitionedAccelerationStructureNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 accelerationStructureCount;
	public VkDeviceAddress* pAccelerationStructures;
	public VulkanSpan<VkDeviceAddress> accelerationStructures
	{
		[Inline] get => .(accelerationStructureCount, pAccelerationStructures);
		[Inline] set mut { accelerationStructureCount = value.count; pAccelerationStructures = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<VkDeviceAddress> accelerationStructures) : this()
	{
		this.pNext = pNext;
		this.accelerationStructures = accelerationStructures;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPartitionedAccelerationStructureInstancesInputNV
{
	public const VkStructureType SType = .VkPartitionedAccelerationStructureInstancesInputNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBuildAccelerationStructureFlagsKHR flags;
	public uint32 instanceCount;
	public uint32 maxInstancePerPartitionCount;
	public uint32 partitionCount;
	public uint32 maxInstanceInGlobalPartitionCount;

	public this(void* pNext, VkBuildAccelerationStructureFlagsKHR flags, uint32 instanceCount, uint32 maxInstancePerPartitionCount, uint32 partitionCount, uint32 maxInstanceInGlobalPartitionCount)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.instanceCount = instanceCount;
		this.maxInstancePerPartitionCount = maxInstancePerPartitionCount;
		this.partitionCount = partitionCount;
		this.maxInstanceInGlobalPartitionCount = maxInstanceInGlobalPartitionCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkBuildPartitionedAccelerationStructureInfoNV
{
	public const VkStructureType SType = .VkBuildPartitionedAccelerationStructureInfoNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPartitionedAccelerationStructureInstancesInputNV input;
	public VkDeviceAddress srcAccelerationStructureData;
	public VkDeviceAddress dstAccelerationStructureData;
	public VkDeviceAddress scratchData;
	public VkDeviceAddress srcInfos;
	public VkDeviceAddress srcInfosCount;

	public this(void* pNext, VkPartitionedAccelerationStructureInstancesInputNV input, VkDeviceAddress srcAccelerationStructureData, VkDeviceAddress dstAccelerationStructureData, VkDeviceAddress scratchData, VkDeviceAddress srcInfos, VkDeviceAddress srcInfosCount)
	{
		this.pNext = pNext;
		this.input = input;
		this.srcAccelerationStructureData = srcAccelerationStructureData;
		this.dstAccelerationStructureData = dstAccelerationStructureData;
		this.scratchData = scratchData;
		this.srcInfos = srcInfos;
		this.srcInfosCount = srcInfosCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV(VkDevice device, VkPartitionedAccelerationStructureInstancesInputNV* pInfo, out VkAccelerationStructureBuildSizesInfoKHR pSizeInfo);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdBuildPartitionedAccelerationStructuresNV(VkCommandBuffer commandBuffer, VkBuildPartitionedAccelerationStructureInfoNV* pBuildInfo);

static { public const uint32 VK_EXT_DEVICE_GENERATED_COMMANDS_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = "VK_EXT_device_generated_commands"; }

[CRepr] struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 deviceGeneratedCommands;
	public VkBool32 dynamicGeneratedPipelineLayout;

	public this(void* pNext, VkBool32 deviceGeneratedCommands, VkBool32 dynamicGeneratedPipelineLayout)
	{
		this.pNext = pNext;
		this.deviceGeneratedCommands = deviceGeneratedCommands;
		this.dynamicGeneratedPipelineLayout = dynamicGeneratedPipelineLayout;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxIndirectPipelineCount;
	public uint32 maxIndirectShaderObjectCount;
	public uint32 maxIndirectSequenceCount;
	public uint32 maxIndirectCommandsTokenCount;
	public uint32 maxIndirectCommandsTokenOffset;
	public uint32 maxIndirectCommandsIndirectStride;
	public VkIndirectCommandsInputModeFlagsEXT supportedIndirectCommandsInputModes;
	public VkShaderStageFlags supportedIndirectCommandsShaderStages;
	public VkShaderStageFlags supportedIndirectCommandsShaderStagesPipelineBinding;
	public VkShaderStageFlags supportedIndirectCommandsShaderStagesShaderBinding;
	public VkBool32 deviceGeneratedCommandsTransformFeedback;
	public VkBool32 deviceGeneratedCommandsMultiDrawIndirectCount;
}

[CRepr] struct VkGeneratedCommandsMemoryRequirementsInfoEXT
{
	public const VkStructureType SType = .VkGeneratedCommandsMemoryRequirementsInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkIndirectExecutionSetEXT indirectExecutionSet;
	public VkIndirectCommandsLayoutEXT indirectCommandsLayout;
	public uint32 maxSequenceCount;
	public uint32 maxDrawCount;

	public this(void* pNext, VkIndirectExecutionSetEXT indirectExecutionSet, VkIndirectCommandsLayoutEXT indirectCommandsLayout, uint32 maxSequenceCount, uint32 maxDrawCount)
	{
		this.pNext = pNext;
		this.indirectExecutionSet = indirectExecutionSet;
		this.indirectCommandsLayout = indirectCommandsLayout;
		this.maxSequenceCount = maxSequenceCount;
		this.maxDrawCount = maxDrawCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkIndirectExecutionSetCreateInfoEXT
{
	public const VkStructureType SType = .VkIndirectExecutionSetCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkIndirectExecutionSetInfoTypeEXT type;
	public VkIndirectExecutionSetInfoEXT info;

	public this(void* pNext, VkIndirectExecutionSetInfoTypeEXT type, VkIndirectExecutionSetInfoEXT info)
	{
		this.pNext = pNext;
		this.type = type;
		this.info = info;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[Union, CRepr] struct VkIndirectExecutionSetInfoEXT
{
	public VkIndirectExecutionSetPipelineInfoEXT* pPipelineInfo;
	public VkIndirectExecutionSetShaderInfoEXT* pShaderInfo;
}

[CRepr] struct VkIndirectExecutionSetPipelineInfoEXT
{
	public const VkStructureType SType = .VkIndirectExecutionSetPipelineInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipeline initialPipeline;
	public uint32 maxPipelineCount;

	public this(void* pNext, VkPipeline initialPipeline, uint32 maxPipelineCount)
	{
		this.pNext = pNext;
		this.initialPipeline = initialPipeline;
		this.maxPipelineCount = maxPipelineCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkIndirectExecutionSetShaderInfoEXT
{
	public const VkStructureType SType = .VkIndirectExecutionSetShaderInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 shaderCount;
	public VkShaderEXT* pInitialShaders;
	public VkIndirectExecutionSetShaderLayoutInfoEXT* pSetLayoutInfos;
	public VulkanDuoSpan<VkShaderEXT, VkIndirectExecutionSetShaderLayoutInfoEXT> initialShaders_setLayoutInfos
	{
		[Inline] get => .(shaderCount, pInitialShaders, pSetLayoutInfos);
		[Inline] set mut { shaderCount = value.count; pInitialShaders = value.ptr1; pSetLayoutInfos = value.ptr2; }
	}
	public uint32 maxShaderCount;
	public uint32 pushConstantRangeCount;
	public VkPushConstantRange* pPushConstantRanges;
	public VulkanSpan<VkPushConstantRange> pushConstantRanges
	{
		[Inline] get => .(pushConstantRangeCount, pPushConstantRanges);
		[Inline] set mut { pushConstantRangeCount = value.count; pPushConstantRanges = value.ptr; }
	}

	public this(void* pNext, VulkanDuoSpan<VkShaderEXT, VkIndirectExecutionSetShaderLayoutInfoEXT> initialShaders_setLayoutInfos, uint32 maxShaderCount, VulkanSpan<VkPushConstantRange> pushConstantRanges = .()) : this()
	{
		this.pNext = pNext;
		this.initialShaders_setLayoutInfos = initialShaders_setLayoutInfos;
		this.maxShaderCount = maxShaderCount;
		this.pushConstantRanges = pushConstantRanges;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkGeneratedCommandsInfoEXT
{
	public const VkStructureType SType = .VkGeneratedCommandsInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkShaderStageFlags shaderStages;
	public VkIndirectExecutionSetEXT indirectExecutionSet;
	public VkIndirectCommandsLayoutEXT indirectCommandsLayout;
	public VkDeviceAddress indirectAddress;
	public VkDeviceSize indirectAddressSize;
	public VkDeviceAddress preprocessAddress;
	public VkDeviceSize preprocessSize;
	public uint32 maxSequenceCount;
	public VkDeviceAddress sequenceCountAddress;
	public uint32 maxDrawCount;

	public this(void* pNext, VkShaderStageFlags shaderStages, VkIndirectExecutionSetEXT indirectExecutionSet, VkIndirectCommandsLayoutEXT indirectCommandsLayout, VkDeviceAddress indirectAddress, VkDeviceSize indirectAddressSize, VkDeviceAddress preprocessAddress, VkDeviceSize preprocessSize, uint32 maxSequenceCount, VkDeviceAddress sequenceCountAddress, uint32 maxDrawCount)
	{
		this.pNext = pNext;
		this.shaderStages = shaderStages;
		this.indirectExecutionSet = indirectExecutionSet;
		this.indirectCommandsLayout = indirectCommandsLayout;
		this.indirectAddress = indirectAddress;
		this.indirectAddressSize = indirectAddressSize;
		this.preprocessAddress = preprocessAddress;
		this.preprocessSize = preprocessSize;
		this.maxSequenceCount = maxSequenceCount;
		this.sequenceCountAddress = sequenceCountAddress;
		this.maxDrawCount = maxDrawCount;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkWriteIndirectExecutionSetPipelineEXT
{
	public const VkStructureType SType = .VkWriteIndirectExecutionSetPipelineEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 index;
	public VkPipeline pipeline;

	public this(void* pNext, uint32 index, VkPipeline pipeline)
	{
		this.pNext = pNext;
		this.index = index;
		this.pipeline = pipeline;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkIndirectCommandsLayoutCreateInfoEXT
{
	public const VkStructureType SType = .VkIndirectCommandsLayoutCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkIndirectCommandsLayoutUsageFlagsEXT flags;
	public VkShaderStageFlags shaderStages;
	public uint32 indirectStride;
	public VkPipelineLayout pipelineLayout;
	public uint32 tokenCount;
	public VkIndirectCommandsLayoutTokenEXT* pTokens;
	public VulkanSpan<VkIndirectCommandsLayoutTokenEXT> tokens
	{
		[Inline] get => .(tokenCount, pTokens);
		[Inline] set mut { tokenCount = value.count; pTokens = value.ptr; }
	}

	public this(void* pNext, VkIndirectCommandsLayoutUsageFlagsEXT flags, VkShaderStageFlags shaderStages, uint32 indirectStride, VkPipelineLayout pipelineLayout, VulkanSpan<VkIndirectCommandsLayoutTokenEXT> tokens) : this()
	{
		this.pNext = pNext;
		this.flags = flags;
		this.shaderStages = shaderStages;
		this.indirectStride = indirectStride;
		this.pipelineLayout = pipelineLayout;
		this.tokens = tokens;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkIndirectCommandsLayoutTokenEXT
{
	public const VkStructureType SType = .VkIndirectCommandsLayoutTokenEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkIndirectCommandsTokenTypeEXT type;
	public VkIndirectCommandsTokenDataEXT data;
	public uint32 offset;

	public this(void* pNext, VkIndirectCommandsTokenTypeEXT type, VkIndirectCommandsTokenDataEXT data, uint32 offset)
	{
		this.pNext = pNext;
		this.type = type;
		this.data = data;
		this.offset = offset;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkDrawIndirectCountIndirectCommandEXT
{
	public VkDeviceAddress bufferAddress;
	public uint32 stride;
	public uint32 commandCount;

	public this(VkDeviceAddress bufferAddress, uint32 stride, uint32 commandCount)
	{
		this.bufferAddress = bufferAddress;
		this.stride = stride;
		this.commandCount = commandCount;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkIndirectCommandsVertexBufferTokenEXT
{
	public uint32 vertexBindingUnit;

	public this(uint32 vertexBindingUnit)
	{
		this.vertexBindingUnit = vertexBindingUnit;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkBindVertexBufferIndirectCommandEXT
{
	public VkDeviceAddress bufferAddress;
	public uint32 size;
	public uint32 stride;

	public this(VkDeviceAddress bufferAddress, uint32 size, uint32 stride)
	{
		this.bufferAddress = bufferAddress;
		this.size = size;
		this.stride = stride;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkIndirectCommandsIndexBufferTokenEXT
{
	public VkIndirectCommandsInputModeFlagBitsEXT mode;

	public this(VkIndirectCommandsInputModeFlagBitsEXT mode)
	{
		this.mode = mode;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkBindIndexBufferIndirectCommandEXT
{
	public VkDeviceAddress bufferAddress;
	public uint32 size;
	public VkIndexType indexType;

	public this(VkDeviceAddress bufferAddress, uint32 size, VkIndexType indexType)
	{
		this.bufferAddress = bufferAddress;
		this.size = size;
		this.indexType = indexType;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkIndirectCommandsPushConstantTokenEXT
{
	public VkPushConstantRange updateRange;

	public this(VkPushConstantRange updateRange)
	{
		this.updateRange = updateRange;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct VkIndirectCommandsExecutionSetTokenEXT
{
	public VkIndirectExecutionSetInfoTypeEXT type;
	public VkShaderStageFlags shaderStages;

	public this(VkIndirectExecutionSetInfoTypeEXT type, VkShaderStageFlags shaderStages)
	{
		this.type = type;
		this.shaderStages = shaderStages;
	}

	public this()
	{
		this = default;
	}
}

[Union, CRepr] struct VkIndirectCommandsTokenDataEXT
{
	public VkIndirectCommandsPushConstantTokenEXT* pPushConstant;
	public VkIndirectCommandsVertexBufferTokenEXT* pVertexBuffer;
	public VkIndirectCommandsIndexBufferTokenEXT* pIndexBuffer;
	public VkIndirectCommandsExecutionSetTokenEXT* pExecutionSet;
}

class VkIndirectCommandsLayoutEXT { private this() { } }
class VkIndirectExecutionSetEXT { private this() { } }

[AllowDuplicates] enum VkIndirectCommandsTokenTypeEXT : int32
{
	ExecutionSetEXT = 0,
	PushConstantEXT = 1,
	SequenceIndexEXT = 2,
	IndexBufferEXT = 3,
	VertexBufferEXT = 4,
	DrawIndexedEXT = 5,
	DrawEXT = 6,
	DrawIndexedCountEXT = 7,
	DrawCountEXT = 8,
	DispatchEXT = 9,
	DrawMeshTasksNvEXT = 1000202002,
	DrawMeshTasksCountNvEXT = 1000202003,
	DrawMeshTasksEXT = 1000328000,
	DrawMeshTasksCountEXT = 1000328001,
	TraceRays2EXT = 1000386004,
}

[AllowDuplicates] enum VkIndirectExecutionSetInfoTypeEXT : int32
{
	PipelinesEXT = 0,
	ShaderObjectsEXT = 1,
}

typealias VkIndirectCommandsLayoutUsageFlagsEXT = VkIndirectCommandsLayoutUsageFlagBitsEXT;

[AllowDuplicates] enum VkIndirectCommandsLayoutUsageFlagBitsEXT : int32
{
	ExplicitPreprocessEXT = 1 << 0,
	UnorderedSequencesEXT = 1 << 1,
}

typealias VkIndirectCommandsInputModeFlagsEXT = VkIndirectCommandsInputModeFlagBitsEXT;

[AllowDuplicates] enum VkIndirectCommandsInputModeFlagBitsEXT : int32
{
	VulkanIndexBufferEXT = 1 << 0,
	DxgiIndexBufferEXT = 1 << 1,
}

[CRepr] struct VkIndirectExecutionSetShaderLayoutInfoEXT
{
	public const VkStructureType SType = .VkIndirectExecutionSetShaderLayoutInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 setLayoutCount;
	public VkDescriptorSetLayout* pSetLayouts;
	public VulkanSpan<VkDescriptorSetLayout> setLayouts
	{
		[Inline] get => .(setLayoutCount, pSetLayouts);
		[Inline] set mut { setLayoutCount = value.count; pSetLayouts = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkDescriptorSetLayout> setLayouts = .()) : this()
	{
		this.pNext = pNext;
		this.setLayouts = setLayouts;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkGeneratedCommandsPipelineInfoEXT
{
	public const VkStructureType SType = .VkGeneratedCommandsPipelineInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkPipeline pipeline;

	public this(void* pNext, VkPipeline pipeline)
	{
		this.pNext = pNext;
		this.pipeline = pipeline;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkGeneratedCommandsShaderInfoEXT
{
	public const VkStructureType SType = .VkGeneratedCommandsShaderInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 shaderCount;
	public VkShaderEXT* pShaders;
	public VulkanSpan<VkShaderEXT> shaders
	{
		[Inline] get => .(shaderCount, pShaders);
		[Inline] set mut { shaderCount = value.count; pShaders = value.ptr; }
	}

	public this(void* pNext, VulkanSpan<VkShaderEXT> shaders) : this()
	{
		this.pNext = pNext;
		this.shaders = shaders;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkGetGeneratedCommandsMemoryRequirementsEXT(VkDevice device, VkGeneratedCommandsMemoryRequirementsInfoEXT* pInfo, out VkMemoryRequirements2 pMemoryRequirements);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdPreprocessGeneratedCommandsEXT(VkCommandBuffer commandBuffer, VkGeneratedCommandsInfoEXT* pGeneratedCommandsInfo, VkCommandBuffer stateCommandBuffer);
[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdExecuteGeneratedCommandsEXT(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, VkGeneratedCommandsInfoEXT* pGeneratedCommandsInfo);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateIndirectCommandsLayoutEXT(VkDevice device, VkIndirectCommandsLayoutCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkIndirectCommandsLayoutEXT pIndirectCommandsLayout);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyIndirectCommandsLayoutEXT(VkDevice device, VkIndirectCommandsLayoutEXT indirectCommandsLayout = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateIndirectExecutionSetEXT(VkDevice device, VkIndirectExecutionSetCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkIndirectExecutionSetEXT pIndirectExecutionSet);
[CallingConvention(VKAPI_PTR)] function void PFN_vkDestroyIndirectExecutionSetEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet = null, VkAllocationCallbacks* pAllocator = null);
[CallingConvention(VKAPI_PTR)] function void PFN_vkUpdateIndirectExecutionSetPipelineEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32 executionSetWriteCount, VkWriteIndirectExecutionSetPipelineEXT* pExecutionSetWrites);
[CallingConvention(VKAPI_PTR)] function void PFN_vkUpdateIndirectExecutionSetShaderEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32 executionSetWriteCount, VkWriteIndirectExecutionSetShaderEXT* pExecutionSetWrites);

[CRepr] struct VkWriteIndirectExecutionSetShaderEXT
{
	public const VkStructureType SType = .VkWriteIndirectExecutionSetShaderEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 index;
	public VkShaderEXT shader;

	public this(void* pNext, uint32 index, VkShaderEXT shader)
	{
		this.pNext = pNext;
		this.index = index;
		this.shader = shader;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_MAINTENANCE_8_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_MAINTENANCE_8_EXTENSION_NAME = "VK_KHR_maintenance8"; }

[CRepr] struct VkPhysicalDeviceMaintenance8FeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceMaintenance8FeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 maintenance8;

	public this(void* pNext, VkBool32 maintenance8)
	{
		this.pNext = pNext;
		this.maintenance8 = maintenance8;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryBarrierAccessFlags3KHR
{
	public const VkStructureType SType = .VkMemoryBarrierAccessFlags3KHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkAccessFlags3KHR srcAccessMask3;
	public VkAccessFlags3KHR dstAccessMask3;

	public this(void* pNext = null, VkAccessFlags3KHR srcAccessMask3 = 0, VkAccessFlags3KHR dstAccessMask3 = 0)
	{
		this.pNext = pNext;
		this.srcAccessMask3 = srcAccessMask3;
		this.dstAccessMask3 = dstAccessMask3;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkAccessFlagBits3KHR : int64
{
	NoneKHR = 0,
}

typealias VkAccessFlags3KHR = VkAccessFlagBits3KHR;

static { public const uint32 VK_MESA_IMAGE_ALIGNMENT_CONTROL_SPEC_VERSION = 1; }
static { public const c_char* VK_MESA_IMAGE_ALIGNMENT_CONTROL_EXTENSION_NAME = "VK_MESA_image_alignment_control"; }

[CRepr] struct VkPhysicalDeviceImageAlignmentControlFeaturesMESA
{
	public const VkStructureType SType = .VkPhysicalDeviceImageAlignmentControlFeaturesMESA;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 imageAlignmentControl;

	public this(void* pNext, VkBool32 imageAlignmentControl)
	{
		this.pNext = pNext;
		this.imageAlignmentControl = imageAlignmentControl;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceImageAlignmentControlPropertiesMESA
{
	public const VkStructureType SType = .VkPhysicalDeviceImageAlignmentControlPropertiesMESA;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 supportedImageAlignmentMask;
}

[CRepr] struct VkImageAlignmentControlCreateInfoMESA
{
	public const VkStructureType SType = .VkImageAlignmentControlCreateInfoMESA;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maximumRequestedAlignment;

	public this(void* pNext, uint32 maximumRequestedAlignment)
	{
		this.pNext = pNext;
		this.maximumRequestedAlignment = maximumRequestedAlignment;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_DEPTH_CLAMP_CONTROL_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_DEPTH_CLAMP_CONTROL_EXTENSION_NAME = "VK_EXT_depth_clamp_control"; }

[CRepr] struct VkPhysicalDeviceDepthClampControlFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceDepthClampControlFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 depthClampControl;

	public this(void* pNext, VkBool32 depthClampControl)
	{
		this.pNext = pNext;
		this.depthClampControl = depthClampControl;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPipelineViewportDepthClampControlCreateInfoEXT
{
	public const VkStructureType SType = .VkPipelineViewportDepthClampControlCreateInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDepthClampModeEXT depthClampMode;
	public VkDepthClampRangeEXT* pDepthClampRange;

	public this(void* pNext, VkDepthClampModeEXT depthClampMode, VkDepthClampRangeEXT* pDepthClampRange = null)
	{
		this.pNext = pNext;
		this.depthClampMode = depthClampMode;
		this.pDepthClampRange = pDepthClampRange;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[AllowDuplicates] enum VkDepthClampModeEXT : int32
{
	ViewportRangeEXT = 0,
	UserDefinedRangeEXT = 1,
}

[CRepr] struct VkDepthClampRangeEXT
{
	public float minDepthClamp;
	public float maxDepthClamp;

	public this(float minDepthClamp, float maxDepthClamp)
	{
		this.minDepthClamp = minDepthClamp;
		this.maxDepthClamp = maxDepthClamp;
	}

	public this()
	{
		this = default;
	}
}

static { public const uint32 VK_KHR_MAINTENANCE_9_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_MAINTENANCE_9_EXTENSION_NAME = "VK_KHR_maintenance9"; }

[CRepr] struct VkPhysicalDeviceMaintenance9FeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceMaintenance9FeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 maintenance9;

	public this(void* pNext, VkBool32 maintenance9)
	{
		this.pNext = pNext;
		this.maintenance9 = maintenance9;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceMaintenance9PropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceMaintenance9PropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 image2DViewOf3DSparse;
	public VkDefaultVertexAttributeValueKHR defaultVertexAttributeValue;
}

[CRepr] struct VkQueueFamilyOwnershipTransferPropertiesKHR
{
	public const VkStructureType SType = .VkQueueFamilyOwnershipTransferPropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 optimalImageTransferToQueueFamilies;
}

[AllowDuplicates] enum VkDefaultVertexAttributeValueKHR : int32
{
	ZeroZeroZeroZeroKHR = 0,
	ZeroZeroZeroOneKHR = 1,
}

// Individual APIs with dependencies on specific versions/extensions should get their own require blocks with depends= attribute set appropriately
static { public const uint32 VK_KHR_VIDEO_MAINTENANCE_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_VIDEO_MAINTENANCE_2_EXTENSION_NAME = "VK_KHR_video_maintenance2"; }

[CRepr] struct VkPhysicalDeviceVideoMaintenance2FeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceVideoMaintenance2FeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 videoMaintenance2;

	public this(void* pNext, VkBool32 videoMaintenance2)
	{
		this.pNext = pNext;
		this.videoMaintenance2 = videoMaintenance2;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeH264InlineSessionParametersInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeH264InlineSessionParametersInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoH264SequenceParameterSet* pStdSPS;
	public StdVideoH264PictureParameterSet* pStdPPS;

	public this(void* pNext = null, StdVideoH264SequenceParameterSet* pStdSPS = null, StdVideoH264PictureParameterSet* pStdPPS = null)
	{
		this.pNext = pNext;
		this.pStdSPS = pStdSPS;
		this.pStdPPS = pStdPPS;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeH265InlineSessionParametersInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeH265InlineSessionParametersInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoH265VideoParameterSet* pStdVPS;
	public StdVideoH265SequenceParameterSet* pStdSPS;
	public StdVideoH265PictureParameterSet* pStdPPS;

	public this(void* pNext = null, StdVideoH265VideoParameterSet* pStdVPS = null, StdVideoH265SequenceParameterSet* pStdSPS = null, StdVideoH265PictureParameterSet* pStdPPS = null)
	{
		this.pNext = pNext;
		this.pStdVPS = pStdVPS;
		this.pStdSPS = pStdSPS;
		this.pStdPPS = pStdPPS;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkVideoDecodeAV1InlineSessionParametersInfoKHR
{
	public const VkStructureType SType = .VkVideoDecodeAv1InlineSessionParametersInfoKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public StdVideoAV1SequenceHeader* pStdSequenceHeader;

	public this(void* pNext = null, StdVideoAV1SequenceHeader* pStdSequenceHeader = null)
	{
		this.pNext = pNext;
		this.pStdSequenceHeader = pStdSequenceHeader;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_OHOS_SURFACE_SPEC_VERSION = 1; }
static { public const c_char* VK_OHOS_SURFACE_EXTENSION_NAME = "VK_OHOS_surface"; }

typealias VkSurfaceCreateFlagsOHOS = VkFlags;

[CRepr] struct VkOHSurfaceCreateInfoOHOS
{
	public const VkStructureType SType = .VkOhSurfaceCreateInfoOHOS;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkSurfaceCreateFlagsOHOS flags;
	public OHNativeWindow* window;

	public this(void* pNext, VkSurfaceCreateFlagsOHOS flags, OHNativeWindow* window)
	{
		this.pNext = pNext;
		this.flags = flags;
		this.window = window;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias VkSurfaceCreateInfoOHOS = VkOHSurfaceCreateInfoOHOS;

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkCreateSurfaceOHOS(VkInstance instance, VkSurfaceCreateInfoOHOS* pCreateInfo, VkAllocationCallbacks* pAllocator, out VkSurfaceKHR pSurface);

static { public const uint32 VK_HUAWEI_HDR_VIVID_SPEC_VERSION = 1; }
static { public const c_char* VK_HUAWEI_HDR_VIVID_EXTENSION_NAME = "VK_HUAWEI_hdr_vivid"; }

[CRepr] struct VkPhysicalDeviceHdrVividFeaturesHUAWEI
{
	public const VkStructureType SType = .VkPhysicalDeviceHdrVividFeaturesHUAWEI;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 hdrVivid;

	public this(void* pNext, VkBool32 hdrVivid)
	{
		this.pNext = pNext;
		this.hdrVivid = hdrVivid;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkHdrVividDynamicMetadataHUAWEI
{
	public const VkStructureType SType = .VkHdrVividDynamicMetadataHUAWEI;
	public VkStructureType sType = SType;
	public void* pNext;
	public c_size dynamicMetadataSize; // Specified in bytes
	public void* pDynamicMetadata; // Binary code of size dynamicMetadataSize

	public this(void* pNext, c_size dynamicMetadataSize, void* pDynamicMetadata)
	{
		this.pNext = pNext;
		this.dynamicMetadataSize = dynamicMetadataSize;
		this.pDynamicMetadata = pDynamicMetadata;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_NV_COOPERATIVE_MATRIX_2_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME = "VK_NV_cooperative_matrix2"; }

[CRepr] struct VkCooperativeMatrixFlexibleDimensionsPropertiesNV
{
	public const VkStructureType SType = .VkCooperativeMatrixFlexibleDimensionsPropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 MGranularity;
	public uint32 NGranularity;
	public uint32 KGranularity;
	public VkComponentTypeKHR AType;
	public VkComponentTypeKHR BType;
	public VkComponentTypeKHR CType;
	public VkComponentTypeKHR ResultType;
	public VkBool32 saturatingAccumulation;
	public VkScopeKHR @scope;
	public uint32 workgroupInvocations;
}

[CRepr] struct VkPhysicalDeviceCooperativeMatrix2FeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceCooperativeMatrix2FeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 cooperativeMatrixWorkgroupScope;
	public VkBool32 cooperativeMatrixFlexibleDimensions;
	public VkBool32 cooperativeMatrixReductions;
	public VkBool32 cooperativeMatrixConversions;
	public VkBool32 cooperativeMatrixPerElementOperations;
	public VkBool32 cooperativeMatrixTensorAddressing;
	public VkBool32 cooperativeMatrixBlockLoads;

	public this(void* pNext, VkBool32 cooperativeMatrixWorkgroupScope, VkBool32 cooperativeMatrixFlexibleDimensions, VkBool32 cooperativeMatrixReductions, VkBool32 cooperativeMatrixConversions, VkBool32 cooperativeMatrixPerElementOperations, VkBool32 cooperativeMatrixTensorAddressing, VkBool32 cooperativeMatrixBlockLoads)
	{
		this.pNext = pNext;
		this.cooperativeMatrixWorkgroupScope = cooperativeMatrixWorkgroupScope;
		this.cooperativeMatrixFlexibleDimensions = cooperativeMatrixFlexibleDimensions;
		this.cooperativeMatrixReductions = cooperativeMatrixReductions;
		this.cooperativeMatrixConversions = cooperativeMatrixConversions;
		this.cooperativeMatrixPerElementOperations = cooperativeMatrixPerElementOperations;
		this.cooperativeMatrixTensorAddressing = cooperativeMatrixTensorAddressing;
		this.cooperativeMatrixBlockLoads = cooperativeMatrixBlockLoads;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceCooperativeMatrix2PropertiesNV
{
	public const VkStructureType SType = .VkPhysicalDeviceCooperativeMatrix2PropertiesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 cooperativeMatrixWorkgroupScopeMaxWorkgroupSize;
	public uint32 cooperativeMatrixFlexibleDimensionsMaxDimension;
	public uint32 cooperativeMatrixWorkgroupScopeReservedSharedMemory;
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(VkPhysicalDevice physicalDevice, out uint32 pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV* pProperties = null);

static { public const uint32 VK_ARM_PIPELINE_OPACITY_MICROMAP_SPEC_VERSION = 1; }
static { public const c_char* VK_ARM_PIPELINE_OPACITY_MICROMAP_EXTENSION_NAME = "VK_ARM_pipeline_opacity_micromap"; }

[CRepr] struct VkPhysicalDevicePipelineOpacityMicromapFeaturesARM
{
	public const VkStructureType SType = .VkPhysicalDevicePipelineOpacityMicromapFeaturesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 pipelineOpacityMicromap;

	public this(void* pNext, VkBool32 pipelineOpacityMicromap)
	{
		this.pNext = pNext;
		this.pipelineOpacityMicromap = pipelineOpacityMicromap;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_EXTERNAL_MEMORY_METAL_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME = "VK_EXT_external_memory_metal"; }

[CRepr] struct VkImportMemoryMetalHandleInfoEXT
{
	public const VkStructureType SType = .VkImportMemoryMetalHandleInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExternalMemoryHandleTypeFlagBits handleType;
	public void* handle;

	public this(void* pNext = null, VkExternalMemoryHandleTypeFlagBits handleType = 0, void* handle = null)
	{
		this.pNext = pNext;
		this.handleType = handleType;
		this.handle = handle;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkMemoryMetalHandlePropertiesEXT
{
	public const VkStructureType SType = .VkMemoryMetalHandlePropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 memoryTypeBits;
}

[CRepr] struct VkMemoryGetMetalHandleInfoEXT
{
	public const VkStructureType SType = .VkMemoryGetMetalHandleInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceMemory memory;
	public VkExternalMemoryHandleTypeFlagBits handleType;

	public this(void* pNext, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagBits handleType)
	{
		this.pNext = pNext;
		this.memory = memory;
		this.handleType = handleType;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetMemoryMetalHandleEXT(VkDevice device, VkMemoryGetMetalHandleInfoEXT* pGetMetalHandleInfo, out void* pHandle);
[CallingConvention(VKAPI_PTR)] function VkResult PFN_vkGetMemoryMetalHandlePropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, void* pHandle, out VkMemoryMetalHandlePropertiesEXT pMemoryMetalHandleProperties);

static { public const uint32 VK_KHR_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME = "VK_KHR_depth_clamp_zero_one"; }

[CRepr] struct VkPhysicalDeviceDepthClampZeroOneFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceDepthClampZeroOneFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 depthClampZeroOne;

	public this(void* pNext, VkBool32 depthClampZeroOne)
	{
		this.pNext = pNext;
		this.depthClampZeroOne = depthClampZeroOne;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_EXTENSION_NAME = "VK_EXT_vertex_attribute_robustness"; }

[CRepr] struct VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 vertexAttributeRobustness;

	public this(void* pNext, VkBool32 vertexAttributeRobustness)
	{
		this.pNext = pNext;
		this.vertexAttributeRobustness = vertexAttributeRobustness;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_ARM_FORMAT_PACK_SPEC_VERSION = 1; }
static { public const c_char* VK_ARM_FORMAT_PACK_EXTENSION_NAME = "VK_ARM_format_pack"; }

[CRepr] struct VkPhysicalDeviceFormatPackFeaturesARM
{
	public const VkStructureType SType = .VkPhysicalDeviceFormatPackFeaturesARM;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 formatPack;

	public this(void* pNext, VkBool32 formatPack)
	{
		this.pNext = pNext;
		this.formatPack = formatPack;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_SPEC_VERSION = 1; }
static { public const c_char* VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_EXTENSION_NAME = "VK_VALVE_fragment_density_map_layered"; }

[CRepr] struct VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 fragmentDensityMapLayered;
}

[CRepr] struct VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxFragmentDensityMapLayers;
}

[CRepr] struct VkPipelineFragmentDensityMapLayeredCreateInfoVALVE
{
	public const VkStructureType SType = .VkPipelineFragmentDensityMapLayeredCreateInfoVALVE;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 maxFragmentDensityMapLayers;

	public this(void* pNext, uint32 maxFragmentDensityMapLayers)
	{
		this.pNext = pNext;
		this.maxFragmentDensityMapLayers = maxFragmentDensityMapLayers;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_ROBUSTNESS_2_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_ROBUSTNESS_2_EXTENSION_NAME = "VK_KHR_robustness2"; }

[CRepr] struct VkPhysicalDeviceRobustness2FeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceRobustness2FeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 robustBufferAccess2;
	public VkBool32 robustImageAccess2;
	public VkBool32 nullDescriptor;

	public this(void* pNext, VkBool32 robustBufferAccess2, VkBool32 robustImageAccess2, VkBool32 nullDescriptor)
	{
		this.pNext = pNext;
		this.robustBufferAccess2 = robustBufferAccess2;
		this.robustImageAccess2 = robustImageAccess2;
		this.nullDescriptor = nullDescriptor;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceRobustness2PropertiesKHR
{
	public const VkStructureType SType = .VkPhysicalDeviceRobustness2PropertiesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkDeviceSize robustStorageBufferAccessSizeAlignment;
	public VkDeviceSize robustUniformBufferAccessSizeAlignment;
}

static { public const uint32 VK_NV_PRESENT_METERING_SPEC_VERSION = 1; }
static { public const c_char* VK_NV_PRESENT_METERING_EXTENSION_NAME = "VK_NV_present_metering"; }

[CRepr] struct VkSetPresentConfigNV
{
	public const VkStructureType SType = .VkSetPresentConfigNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 numFramesPerBatch;
	public uint32 presentConfigFeedback;

	public this(void* pNext, uint32 numFramesPerBatch, uint32 presentConfigFeedback)
	{
		this.pNext = pNext;
		this.numFramesPerBatch = numFramesPerBatch;
		this.presentConfigFeedback = presentConfigFeedback;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDevicePresentMeteringFeaturesNV
{
	public const VkStructureType SType = .VkPhysicalDevicePresentMeteringFeaturesNV;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 presentMetering;

	public this(void* pNext, VkBool32 presentMetering)
	{
		this.pNext = pNext;
		this.presentMetering = presentMetering;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME = "VK_EXT_fragment_density_map_offset"; }

[CRepr] struct VkRenderingEndInfoEXT
{
	public const VkStructureType SType = .VkRenderingEndInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;

	public this(void* pNext = null)
	{
		this.pNext = pNext;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 fragmentDensityMapOffset;

	public this(void* pNext, VkBool32 fragmentDensityMapOffset)
	{
		this.pNext = pNext;
		this.fragmentDensityMapOffset = fragmentDensityMapOffset;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CRepr] struct VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkExtent2D fragmentDensityOffsetGranularity;
}

[CRepr] struct VkRenderPassFragmentDensityMapOffsetEndInfoEXT
{
	public const VkStructureType SType = .VkRenderPassFragmentDensityMapOffsetEndInfoEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public uint32 fragmentDensityOffsetCount;
	public VkOffset2D* pFragmentDensityOffsets;
	public VulkanSpan<VkOffset2D> fragmentDensityOffsets
	{
		[Inline] get => .(fragmentDensityOffsetCount, pFragmentDensityOffsets);
		[Inline] set mut { fragmentDensityOffsetCount = value.count; pFragmentDensityOffsets = value.ptr; }
	}

	public this(void* pNext = null, VulkanSpan<VkOffset2D> fragmentDensityOffsets = .()) : this()
	{
		this.pNext = pNext;
		this.fragmentDensityOffsets = fragmentDensityOffsets;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

[CallingConvention(VKAPI_PTR)] function void PFN_vkCmdEndRendering2EXT(VkCommandBuffer commandBuffer, VkRenderingEndInfoEXT* pRenderingEndInfo = null);

static { public const uint32 VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_SPEC_VERSION = 1; }
static { public const c_char* VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_EXTENSION_NAME = "VK_EXT_zero_initialize_device_memory"; }

[CRepr] struct VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT
{
	public const VkStructureType SType = .VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 zeroInitializeDeviceMemory;

	public this(void* pNext, VkBool32 zeroInitializeDeviceMemory)
	{
		this.pNext = pNext;
		this.zeroInitializeDeviceMemory = zeroInitializeDeviceMemory;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION = 1; }
static { public const c_char* VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME = "VK_KHR_present_mode_fifo_latest_ready"; }

[CRepr] struct VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR
{
	public const VkStructureType SType = .VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 presentModeFifoLatestReady;

	public this(void* pNext, VkBool32 presentModeFifoLatestReady)
	{
		this.pNext = pNext;
		this.presentModeFifoLatestReady = presentModeFifoLatestReady;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

static { public const uint32 VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_SPEC_VERSION = 1; }
static { public const c_char* VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_EXTENSION_NAME = "VK_SEC_pipeline_cache_incremental_mode"; }

[CRepr] struct VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC
{
	public const VkStructureType SType = .VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC;
	public VkStructureType sType = SType;
	public void* pNext;
	public VkBool32 pipelineCacheIncrementalMode;

	public this(void* pNext, VkBool32 pipelineCacheIncrementalMode)
	{
		this.pNext = pNext;
		this.pipelineCacheIncrementalMode = pipelineCacheIncrementalMode;
	}

	public this()
	{
		this = default;
		sType = SType;
	}
}

typealias ANativeWindow = void*;
typealias wl_display = void*;
typealias wl_surface = void*;
typealias HINSTANCE = void*;
typealias HWND = void*;
typealias Display = void*;
typealias Window = void*;
typealias xcb_connection_t = void*;
typealias xcb_window_t = void*;
typealias IDirectFB = void*;
typealias IDirectFBSurface = void*;
typealias zx_handle_t = void*;
typealias GgpStreamDescriptor = void*;
typealias _screen_context = void*;
typealias _screen_window = void*;
typealias HANDLE = void*;
typealias SECURITY_ATTRIBUTES = void*;
typealias NvSciBufAttrList = void*;
typealias NvSciBufObj = void*;
typealias LPCWSTR = void*;
typealias NvSciSyncAttrList = void*;
typealias NvSciSyncObj = void*;
typealias NvSciSyncFence = void*;
typealias CAMetalLayer = void*;
typealias AHardwareBuffer = void*;
typealias GgpFrameToken = void*;
typealias HMONITOR = void*;
typealias MTLDevice_id = void*;
typealias MTLCommandQueue_id = void*;
typealias MTLBuffer_id = void*;
typealias MTLTexture_id = void*;
typealias IOSurfaceRef = void*;
typealias MTLSharedEvent_id = void*;
typealias _screen_buffer = void*;
typealias OHNativeWindow = void*;
typealias VisualID = void*;
typealias xcb_visualid_t = void*;
typealias RROutput = void*;
