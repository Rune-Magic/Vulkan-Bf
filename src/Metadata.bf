/*  Auto Generated by Setup/Program.bf
 *  DO NOT EDIT
 */

using System;
using System.Interop;

using Vulkan;
using Vulkan.Metadata;

namespace Vulkan.Metadata;

enum VulkanApiVersion
{
	VK_VERSION_1_0 = VK_API_VERSION_1_0,
	VK_VERSION_1_1 = VK_API_VERSION_1_1,
	VK_VERSION_1_2 = VK_API_VERSION_1_2,
	VK_VERSION_1_3 = VK_API_VERSION_1_3,
	VK_VERSION_1_4 = VK_API_VERSION_1_4,
}

enum VulkanExtension
{
	case VK_KHR_surface = 1;
	case VK_KHR_swapchain = 2;
	case VK_KHR_display = 3;
	case VK_KHR_display_swapchain = 4;
	case VK_EXT_debug_report = 12;
	case VK_NV_glsl_shader = 13;
	case VK_EXT_depth_range_unrestricted = 14;
	case VK_KHR_sampler_mirror_clamp_to_edge = 15;
	case VK_IMG_filter_cubic = 16;
	case VK_AMD_rasterization_order = 19;
	case VK_AMD_shader_trinary_minmax = 21;
	case VK_AMD_shader_explicit_vertex_parameter = 22;
	case VK_EXT_debug_marker = 23;
	case VK_KHR_video_queue = 24;
	case VK_KHR_video_decode_queue = 25;
	case VK_AMD_gcn_shader = 26;
	case VK_NV_dedicated_allocation = 27;
	case VK_EXT_transform_feedback = 29;
	case VK_NVX_binary_import = 30;
	case VK_NVX_image_view_handle = 31;
	case VK_AMD_draw_indirect_count = 34;
	case VK_AMD_negative_viewport_height = 36;
	case VK_AMD_gpu_shader_half_float = 37;
	case VK_AMD_shader_ballot = 38;
	case VK_KHR_video_encode_h264 = 39;
	case VK_KHR_video_encode_h265 = 40;
	case VK_KHR_video_decode_h264 = 41;
	case VK_AMD_texture_gather_bias_lod = 42;
	case VK_AMD_shader_info = 43;
	case VK_KHR_dynamic_rendering = 45;
	case VK_AMD_shader_image_load_store_lod = 47;
	case VK_NV_corner_sampled_image = 51;
	case VK_KHR_multiview = 54;
	case VK_IMG_format_pvrtc = 55;
	case VK_NV_external_memory_capabilities = 56;
	case VK_NV_external_memory = 57;
	case VK_KHR_get_physical_device_properties2 = 60;
	case VK_KHR_device_group = 61;
	case VK_EXT_validation_flags = 62;
	case VK_KHR_shader_draw_parameters = 64;
	case VK_EXT_shader_subgroup_ballot = 65;
	case VK_EXT_shader_subgroup_vote = 66;
	case VK_EXT_texture_compression_astc_hdr = 67;
	case VK_EXT_astc_decode_mode = 68;
	case VK_EXT_pipeline_robustness = 69;
	case VK_KHR_maintenance1 = 70;
	case VK_KHR_device_group_creation = 71;
	case VK_KHR_external_memory_capabilities = 72;
	case VK_KHR_external_memory = 73;
	case VK_KHR_external_memory_fd = 75;
	case VK_KHR_external_semaphore_capabilities = 77;
	case VK_KHR_external_semaphore = 78;
	case VK_KHR_external_semaphore_fd = 80;
	case VK_KHR_push_descriptor = 81;
	case VK_EXT_conditional_rendering = 82;
	case VK_KHR_shader_float16_int8 = 83;
	case VK_KHR_16bit_storage = 84;
	case VK_KHR_incremental_present = 85;
	case VK_KHR_descriptor_update_template = 86;
	case VK_NV_clip_space_w_scaling = 88;
	case VK_EXT_direct_mode_display = 89;
	case VK_EXT_display_surface_counter = 91;
	case VK_EXT_display_control = 92;
	case VK_GOOGLE_display_timing = 93;
	case VK_NV_sample_mask_override_coverage = 95;
	case VK_NV_geometry_shader_passthrough = 96;
	case VK_NV_viewport_array2 = 97;
	case VK_NVX_multiview_per_view_attributes = 98;
	case VK_NV_viewport_swizzle = 99;
	case VK_EXT_discard_rectangles = 100;
	case VK_EXT_conservative_rasterization = 102;
	case VK_EXT_depth_clip_enable = 103;
	case VK_EXT_swapchain_colorspace = 105;
	case VK_EXT_hdr_metadata = 106;
	case VK_KHR_imageless_framebuffer = 109;
	case VK_KHR_create_renderpass2 = 110;
	case VK_IMG_relaxed_line_rasterization = 111;
	case VK_KHR_shared_presentable_image = 112;
	case VK_KHR_external_fence_capabilities = 113;
	case VK_KHR_external_fence = 114;
	case VK_KHR_external_fence_fd = 116;
	case VK_KHR_performance_query = 117;
	case VK_KHR_maintenance2 = 118;
	case VK_KHR_get_surface_capabilities2 = 120;
	case VK_KHR_variable_pointers = 121;
	case VK_KHR_get_display_properties2 = 122;
	case VK_EXT_external_memory_dma_buf = 126;
	case VK_EXT_queue_family_foreign = 127;
	case VK_KHR_dedicated_allocation = 128;
	case VK_EXT_debug_utils = 129;
	case VK_EXT_sampler_filter_minmax = 131;
	case VK_KHR_storage_buffer_storage_class = 132;
	case VK_AMD_gpu_shader_int16 = 133;
	case VK_AMD_mixed_attachment_samples = 137;
	case VK_AMD_shader_fragment_mask = 138;
	case VK_EXT_inline_uniform_block = 139;
	case VK_EXT_shader_stencil_export = 141;
	case VK_EXT_sample_locations = 144;
	case VK_KHR_relaxed_block_layout = 145;
	case VK_KHR_get_memory_requirements2 = 147;
	case VK_KHR_image_format_list = 148;
	case VK_EXT_blend_operation_advanced = 149;
	case VK_NV_fragment_coverage_to_color = 150;
	case VK_KHR_acceleration_structure = 151;
	case VK_KHR_ray_tracing_pipeline = 348;
	case VK_KHR_ray_query = 349;
	case VK_NV_framebuffer_mixed_samples = 153;
	case VK_NV_fill_rectangle = 154;
	case VK_NV_shader_sm_builtins = 155;
	case VK_EXT_post_depth_coverage = 156;
	case VK_KHR_sampler_ycbcr_conversion = 157;
	case VK_KHR_bind_memory2 = 158;
	case VK_EXT_image_drm_format_modifier = 159;
	case VK_EXT_validation_cache = 161;
	case VK_EXT_descriptor_indexing = 162;
	case VK_EXT_shader_viewport_index_layer = 163;
	case VK_NV_shading_rate_image = 165;
	case VK_NV_ray_tracing = 166;
	case VK_NV_representative_fragment_test = 167;
	case VK_KHR_maintenance3 = 169;
	case VK_KHR_draw_indirect_count = 170;
	case VK_EXT_filter_cubic = 171;
	case VK_QCOM_render_pass_shader_resolve = 172;
	case VK_EXT_global_priority = 175;
	case VK_KHR_shader_subgroup_extended_types = 176;
	case VK_KHR_8bit_storage = 178;
	case VK_EXT_external_memory_host = 179;
	case VK_AMD_buffer_marker = 180;
	case VK_KHR_shader_atomic_int64 = 181;
	case VK_KHR_shader_clock = 182;
	case VK_AMD_pipeline_compiler_control = 184;
	case VK_EXT_calibrated_timestamps = 185;
	case VK_AMD_shader_core_properties = 186;
	case VK_KHR_video_decode_h265 = 188;
	case VK_KHR_global_priority = 189;
	case VK_AMD_memory_overallocation_behavior = 190;
	case VK_EXT_vertex_attribute_divisor = 191;
	case VK_EXT_pipeline_creation_feedback = 193;
	case VK_KHR_driver_properties = 197;
	case VK_KHR_shader_float_controls = 198;
	case VK_NV_shader_subgroup_partitioned = 199;
	case VK_KHR_depth_stencil_resolve = 200;
	case VK_KHR_swapchain_mutable_format = 201;
	case VK_NV_compute_shader_derivatives = 202;
	case VK_NV_mesh_shader = 203;
	case VK_NV_fragment_shader_barycentric = 204;
	case VK_NV_shader_image_footprint = 205;
	case VK_NV_scissor_exclusive = 206;
	case VK_NV_device_diagnostic_checkpoints = 207;
	case VK_KHR_timeline_semaphore = 208;
	case VK_INTEL_shader_integer_functions2 = 210;
	case VK_INTEL_performance_query = 211;
	case VK_KHR_vulkan_memory_model = 212;
	case VK_EXT_pci_bus_info = 213;
	case VK_AMD_display_native_hdr = 214;
	case VK_KHR_shader_terminate_invocation = 216;
	case VK_EXT_fragment_density_map = 219;
	case VK_EXT_scalar_block_layout = 222;
	case VK_GOOGLE_hlsl_functionality1 = 224;
	case VK_GOOGLE_decorate_string = 225;
	case VK_EXT_subgroup_size_control = 226;
	case VK_KHR_fragment_shading_rate = 227;
	case VK_AMD_shader_core_properties2 = 228;
	case VK_AMD_device_coherent_memory = 230;
	case VK_KHR_dynamic_rendering_local_read = 233;
	case VK_EXT_shader_image_atomic_int64 = 235;
	case VK_KHR_shader_quad_control = 236;
	case VK_KHR_spirv_1_4 = 237;
	case VK_EXT_memory_budget = 238;
	case VK_EXT_memory_priority = 239;
	case VK_KHR_surface_protected_capabilities = 240;
	case VK_NV_dedicated_allocation_image_aliasing = 241;
	case VK_KHR_separate_depth_stencil_layouts = 242;
	case VK_EXT_buffer_device_address = 245;
	case VK_EXT_tooling_info = 246;
	case VK_EXT_separate_stencil_usage = 247;
	case VK_EXT_validation_features = 248;
	case VK_KHR_present_wait = 249;
	case VK_NV_cooperative_matrix = 250;
	case VK_NV_coverage_reduction_mode = 251;
	case VK_EXT_fragment_shader_interlock = 252;
	case VK_EXT_ycbcr_image_arrays = 253;
	case VK_KHR_uniform_buffer_standard_layout = 254;
	case VK_EXT_provoking_vertex = 255;
	case VK_EXT_headless_surface = 257;
	case VK_KHR_buffer_device_address = 258;
	case VK_EXT_line_rasterization = 260;
	case VK_EXT_shader_atomic_float = 261;
	case VK_EXT_host_query_reset = 262;
	case VK_EXT_index_type_uint8 = 266;
	case VK_EXT_extended_dynamic_state = 268;
	case VK_KHR_deferred_host_operations = 269;
	case VK_KHR_pipeline_executable_properties = 270;
	case VK_EXT_host_image_copy = 271;
	case VK_KHR_map_memory2 = 272;
	case VK_EXT_map_memory_placed = 273;
	case VK_EXT_shader_atomic_float2 = 274;
	case VK_EXT_surface_maintenance1 = 275;
	case VK_EXT_swapchain_maintenance1 = 276;
	case VK_EXT_shader_demote_to_helper_invocation = 277;
	case VK_NV_device_generated_commands = 278;
	case VK_NV_inherited_viewport_scissor = 279;
	case VK_KHR_shader_integer_dot_product = 281;
	case VK_EXT_texel_buffer_alignment = 282;
	case VK_QCOM_render_pass_transform = 283;
	case VK_EXT_depth_bias_control = 284;
	case VK_EXT_device_memory_report = 285;
	case VK_EXT_acquire_drm_display = 286;
	case VK_EXT_robustness2 = 287;
	case VK_EXT_custom_border_color = 288;
	case VK_GOOGLE_user_type = 290;
	case VK_KHR_pipeline_library = 291;
	case VK_NV_present_barrier = 293;
	case VK_KHR_shader_non_semantic_info = 294;
	case VK_KHR_present_id = 295;
	case VK_EXT_private_data = 296;
	case VK_EXT_pipeline_creation_cache_control = 298;
	case VK_KHR_video_encode_queue = 300;
	case VK_NV_device_diagnostics_config = 301;
	case VK_QCOM_render_pass_store_ops = 302;
	case VK_NV_cuda_kernel_launch = 308;
	case VK_NV_low_latency = 311;
	case VK_KHR_synchronization2 = 315;
	case VK_EXT_descriptor_buffer = 317;
	case VK_EXT_graphics_pipeline_library = 321;
	case VK_AMD_shader_early_and_late_fragment_tests = 322;
	case VK_KHR_fragment_shader_barycentric = 323;
	case VK_KHR_shader_subgroup_uniform_control_flow = 324;
	case VK_KHR_zero_initialize_workgroup_memory = 326;
	case VK_NV_fragment_shading_rate_enums = 327;
	case VK_NV_ray_tracing_motion_blur = 328;
	case VK_EXT_mesh_shader = 329;
	case VK_EXT_ycbcr_2plane_444_formats = 331;
	case VK_EXT_fragment_density_map2 = 333;
	case VK_QCOM_rotated_copy_commands = 334;
	case VK_EXT_image_robustness = 336;
	case VK_KHR_workgroup_memory_explicit_layout = 337;
	case VK_KHR_copy_commands2 = 338;
	case VK_EXT_image_compression_control = 339;
	case VK_EXT_attachment_feedback_loop_layout = 340;
	case VK_EXT_4444_formats = 341;
	case VK_EXT_device_fault = 342;
	case VK_ARM_rasterization_order_attachment_access = 343;
	case VK_EXT_rgba10x6_formats = 345;
	case VK_VALVE_mutable_descriptor_type = 352;
	case VK_EXT_vertex_input_dynamic_state = 353;
	case VK_EXT_physical_device_drm = 354;
	case VK_EXT_device_address_binding_report = 355;
	case VK_EXT_depth_clip_control = 356;
	case VK_EXT_primitive_topology_list_restart = 357;
	case VK_KHR_format_feature_flags2 = 361;
	case VK_EXT_present_mode_fifo_latest_ready = 362;
	case VK_HUAWEI_subpass_shading = 370;
	case VK_HUAWEI_invocation_mask = 371;
	case VK_NV_external_memory_rdma = 372;
	case VK_EXT_pipeline_properties = 373;
	case VK_EXT_frame_boundary = 376;
	case VK_EXT_multisampled_render_to_single_sampled = 377;
	case VK_EXT_extended_dynamic_state2 = 378;
	case VK_EXT_color_write_enable = 382;
	case VK_EXT_primitives_generated_query = 383;
	case VK_KHR_ray_tracing_maintenance1 = 387;
	case VK_EXT_global_priority_query = 389;
	case VK_EXT_image_view_min_lod = 392;
	case VK_EXT_multi_draw = 393;
	case VK_EXT_image_2d_view_of_3d = 394;
	case VK_KHR_portability_enumeration = 395;
	case VK_EXT_shader_tile_image = 396;
	case VK_EXT_opacity_micromap = 397;
	case VK_EXT_load_store_op_none = 401;
	case VK_HUAWEI_cluster_culling_shader = 405;
	case VK_EXT_border_color_swizzle = 412;
	case VK_EXT_pageable_device_local_memory = 413;
	case VK_KHR_maintenance4 = 414;
	case VK_ARM_shader_core_properties = 416;
	case VK_KHR_shader_subgroup_rotate = 417;
	case VK_ARM_scheduling_controls = 418;
	case VK_EXT_image_sliced_view_of_3d = 419;
	case VK_VALVE_descriptor_set_host_mapping = 421;
	case VK_EXT_depth_clamp_zero_one = 422;
	case VK_EXT_non_seamless_cube_map = 423;
	case VK_ARM_render_pass_striped = 425;
	case VK_QCOM_fragment_density_map_offset = 426;
	case VK_NV_copy_memory_indirect = 427;
	case VK_NV_memory_decompression = 428;
	case VK_NV_device_generated_commands_compute = 429;
	case VK_NV_linear_color_attachment = 431;
	case VK_GOOGLE_surfaceless_query = 434;
	case VK_KHR_shader_maximal_reconvergence = 435;
	case VK_EXT_image_compression_control_swapchain = 438;
	case VK_QCOM_image_processing = 441;
	case VK_EXT_nested_command_buffer = 452;
	case VK_EXT_external_memory_acquire_unmodified = 454;
	case VK_EXT_extended_dynamic_state3 = 456;
	case VK_EXT_subpass_merge_feedback = 459;
	case VK_LUNARG_direct_driver_loading = 460;
	case VK_EXT_shader_module_identifier = 463;
	case VK_EXT_rasterization_order_attachment_access = 464;
	case VK_NV_optical_flow = 465;
	case VK_EXT_legacy_dithering = 466;
	case VK_EXT_pipeline_protected_access = 467;
	case VK_KHR_maintenance5 = 471;
	case VK_AMD_anti_lag = 477;
	case VK_KHR_ray_tracing_position_fetch = 482;
	case VK_EXT_shader_object = 483;
	case VK_KHR_pipeline_binary = 484;
	case VK_QCOM_tile_properties = 485;
	case VK_SEC_amigo_profiling = 486;
	case VK_QCOM_multiview_per_view_viewports = 489;
	case VK_NV_ray_tracing_invocation_reorder = 491;
	case VK_NV_extended_sparse_address_space = 493;
	case VK_EXT_mutable_descriptor_type = 495;
	case VK_EXT_legacy_vertex_attributes = 496;
	case VK_EXT_layer_settings = 497;
	case VK_ARM_shader_core_builtins = 498;
	case VK_EXT_pipeline_library_group_handles = 499;
	case VK_EXT_dynamic_rendering_unused_attachments = 500;
	case VK_NV_low_latency2 = 506;
	case VK_KHR_cooperative_matrix = 507;
	case VK_QCOM_multiview_per_view_render_areas = 511;
	case VK_KHR_compute_shader_derivatives = 512;
	case VK_KHR_video_decode_av1 = 513;
	case VK_KHR_video_encode_av1 = 514;
	case VK_KHR_video_maintenance1 = 516;
	case VK_NV_per_stage_descriptor_set = 517;
	case VK_QCOM_image_processing2 = 519;
	case VK_QCOM_filter_cubic_weights = 520;
	case VK_QCOM_ycbcr_degamma = 521;
	case VK_QCOM_filter_cubic_clamp = 522;
	case VK_EXT_attachment_feedback_loop_dynamic_state = 525;
	case VK_KHR_vertex_attribute_divisor = 526;
	case VK_KHR_load_store_op_none = 527;
	case VK_KHR_shader_float_controls2 = 529;
	case VK_MSFT_layered_driver = 531;
	case VK_KHR_index_type_uint8 = 534;
	case VK_KHR_line_rasterization = 535;
	case VK_KHR_calibrated_timestamps = 544;
	case VK_KHR_shader_expect_assume = 545;
	case VK_KHR_maintenance6 = 546;
	case VK_NV_descriptor_pool_overallocation = 547;
	case VK_NV_display_stereo = 552;
	case VK_KHR_video_encode_quantization_map = 554;
	case VK_NV_raw_access_chains = 556;
	case VK_KHR_shader_relaxed_extended_instruction = 559;
	case VK_NV_command_buffer_inheritance = 560;
	case VK_KHR_maintenance7 = 563;
	case VK_NV_shader_atomic_float16_vector = 564;
	case VK_EXT_shader_replicated_composites = 565;
	case VK_NV_ray_tracing_validation = 569;
	case VK_EXT_device_generated_commands = 573;
	case VK_MESA_image_alignment_control = 576;
	case VK_EXT_depth_clamp_control = 583;
	case VK_HUAWEI_hdr_vivid = 591;
	case VK_NV_cooperative_matrix2 = 594;
	case VK_EXT_vertex_attribute_robustness = 609;

	public char8* Name
	{
		get
		{
			switch (this)
			{
			case .VK_KHR_surface: return nameof(VK_KHR_surface);
			case .VK_KHR_swapchain: return nameof(VK_KHR_swapchain);
			case .VK_KHR_display: return nameof(VK_KHR_display);
			case .VK_KHR_display_swapchain: return nameof(VK_KHR_display_swapchain);
			case .VK_EXT_debug_report: return nameof(VK_EXT_debug_report);
			case .VK_NV_glsl_shader: return nameof(VK_NV_glsl_shader);
			case .VK_EXT_depth_range_unrestricted: return nameof(VK_EXT_depth_range_unrestricted);
			case .VK_KHR_sampler_mirror_clamp_to_edge: return nameof(VK_KHR_sampler_mirror_clamp_to_edge);
			case .VK_IMG_filter_cubic: return nameof(VK_IMG_filter_cubic);
			case .VK_AMD_rasterization_order: return nameof(VK_AMD_rasterization_order);
			case .VK_AMD_shader_trinary_minmax: return nameof(VK_AMD_shader_trinary_minmax);
			case .VK_AMD_shader_explicit_vertex_parameter: return nameof(VK_AMD_shader_explicit_vertex_parameter);
			case .VK_EXT_debug_marker: return nameof(VK_EXT_debug_marker);
			case .VK_KHR_video_queue: return nameof(VK_KHR_video_queue);
			case .VK_KHR_video_decode_queue: return nameof(VK_KHR_video_decode_queue);
			case .VK_AMD_gcn_shader: return nameof(VK_AMD_gcn_shader);
			case .VK_NV_dedicated_allocation: return nameof(VK_NV_dedicated_allocation);
			case .VK_EXT_transform_feedback: return nameof(VK_EXT_transform_feedback);
			case .VK_NVX_binary_import: return nameof(VK_NVX_binary_import);
			case .VK_NVX_image_view_handle: return nameof(VK_NVX_image_view_handle);
			case .VK_AMD_draw_indirect_count: return nameof(VK_AMD_draw_indirect_count);
			case .VK_AMD_negative_viewport_height: return nameof(VK_AMD_negative_viewport_height);
			case .VK_AMD_gpu_shader_half_float: return nameof(VK_AMD_gpu_shader_half_float);
			case .VK_AMD_shader_ballot: return nameof(VK_AMD_shader_ballot);
			case .VK_KHR_video_encode_h264: return nameof(VK_KHR_video_encode_h264);
			case .VK_KHR_video_encode_h265: return nameof(VK_KHR_video_encode_h265);
			case .VK_KHR_video_decode_h264: return nameof(VK_KHR_video_decode_h264);
			case .VK_AMD_texture_gather_bias_lod: return nameof(VK_AMD_texture_gather_bias_lod);
			case .VK_AMD_shader_info: return nameof(VK_AMD_shader_info);
			case .VK_KHR_dynamic_rendering: return nameof(VK_KHR_dynamic_rendering);
			case .VK_AMD_shader_image_load_store_lod: return nameof(VK_AMD_shader_image_load_store_lod);
			case .VK_NV_corner_sampled_image: return nameof(VK_NV_corner_sampled_image);
			case .VK_KHR_multiview: return nameof(VK_KHR_multiview);
			case .VK_IMG_format_pvrtc: return nameof(VK_IMG_format_pvrtc);
			case .VK_NV_external_memory_capabilities: return nameof(VK_NV_external_memory_capabilities);
			case .VK_NV_external_memory: return nameof(VK_NV_external_memory);
			case .VK_KHR_get_physical_device_properties2: return nameof(VK_KHR_get_physical_device_properties2);
			case .VK_KHR_device_group: return nameof(VK_KHR_device_group);
			case .VK_EXT_validation_flags: return nameof(VK_EXT_validation_flags);
			case .VK_KHR_shader_draw_parameters: return nameof(VK_KHR_shader_draw_parameters);
			case .VK_EXT_shader_subgroup_ballot: return nameof(VK_EXT_shader_subgroup_ballot);
			case .VK_EXT_shader_subgroup_vote: return nameof(VK_EXT_shader_subgroup_vote);
			case .VK_EXT_texture_compression_astc_hdr: return nameof(VK_EXT_texture_compression_astc_hdr);
			case .VK_EXT_astc_decode_mode: return nameof(VK_EXT_astc_decode_mode);
			case .VK_EXT_pipeline_robustness: return nameof(VK_EXT_pipeline_robustness);
			case .VK_KHR_maintenance1: return nameof(VK_KHR_maintenance1);
			case .VK_KHR_device_group_creation: return nameof(VK_KHR_device_group_creation);
			case .VK_KHR_external_memory_capabilities: return nameof(VK_KHR_external_memory_capabilities);
			case .VK_KHR_external_memory: return nameof(VK_KHR_external_memory);
			case .VK_KHR_external_memory_fd: return nameof(VK_KHR_external_memory_fd);
			case .VK_KHR_external_semaphore_capabilities: return nameof(VK_KHR_external_semaphore_capabilities);
			case .VK_KHR_external_semaphore: return nameof(VK_KHR_external_semaphore);
			case .VK_KHR_external_semaphore_fd: return nameof(VK_KHR_external_semaphore_fd);
			case .VK_KHR_push_descriptor: return nameof(VK_KHR_push_descriptor);
			case .VK_EXT_conditional_rendering: return nameof(VK_EXT_conditional_rendering);
			case .VK_KHR_shader_float16_int8: return nameof(VK_KHR_shader_float16_int8);
			case .VK_KHR_16bit_storage: return nameof(VK_KHR_16bit_storage);
			case .VK_KHR_incremental_present: return nameof(VK_KHR_incremental_present);
			case .VK_KHR_descriptor_update_template: return nameof(VK_KHR_descriptor_update_template);
			case .VK_NV_clip_space_w_scaling: return nameof(VK_NV_clip_space_w_scaling);
			case .VK_EXT_direct_mode_display: return nameof(VK_EXT_direct_mode_display);
			case .VK_EXT_display_surface_counter: return nameof(VK_EXT_display_surface_counter);
			case .VK_EXT_display_control: return nameof(VK_EXT_display_control);
			case .VK_GOOGLE_display_timing: return nameof(VK_GOOGLE_display_timing);
			case .VK_NV_sample_mask_override_coverage: return nameof(VK_NV_sample_mask_override_coverage);
			case .VK_NV_geometry_shader_passthrough: return nameof(VK_NV_geometry_shader_passthrough);
			case .VK_NV_viewport_array2: return nameof(VK_NV_viewport_array2);
			case .VK_NVX_multiview_per_view_attributes: return nameof(VK_NVX_multiview_per_view_attributes);
			case .VK_NV_viewport_swizzle: return nameof(VK_NV_viewport_swizzle);
			case .VK_EXT_discard_rectangles: return nameof(VK_EXT_discard_rectangles);
			case .VK_EXT_conservative_rasterization: return nameof(VK_EXT_conservative_rasterization);
			case .VK_EXT_depth_clip_enable: return nameof(VK_EXT_depth_clip_enable);
			case .VK_EXT_swapchain_colorspace: return nameof(VK_EXT_swapchain_colorspace);
			case .VK_EXT_hdr_metadata: return nameof(VK_EXT_hdr_metadata);
			case .VK_KHR_imageless_framebuffer: return nameof(VK_KHR_imageless_framebuffer);
			case .VK_KHR_create_renderpass2: return nameof(VK_KHR_create_renderpass2);
			case .VK_IMG_relaxed_line_rasterization: return nameof(VK_IMG_relaxed_line_rasterization);
			case .VK_KHR_shared_presentable_image: return nameof(VK_KHR_shared_presentable_image);
			case .VK_KHR_external_fence_capabilities: return nameof(VK_KHR_external_fence_capabilities);
			case .VK_KHR_external_fence: return nameof(VK_KHR_external_fence);
			case .VK_KHR_external_fence_fd: return nameof(VK_KHR_external_fence_fd);
			case .VK_KHR_performance_query: return nameof(VK_KHR_performance_query);
			case .VK_KHR_maintenance2: return nameof(VK_KHR_maintenance2);
			case .VK_KHR_get_surface_capabilities2: return nameof(VK_KHR_get_surface_capabilities2);
			case .VK_KHR_variable_pointers: return nameof(VK_KHR_variable_pointers);
			case .VK_KHR_get_display_properties2: return nameof(VK_KHR_get_display_properties2);
			case .VK_EXT_external_memory_dma_buf: return nameof(VK_EXT_external_memory_dma_buf);
			case .VK_EXT_queue_family_foreign: return nameof(VK_EXT_queue_family_foreign);
			case .VK_KHR_dedicated_allocation: return nameof(VK_KHR_dedicated_allocation);
			case .VK_EXT_debug_utils: return nameof(VK_EXT_debug_utils);
			case .VK_EXT_sampler_filter_minmax: return nameof(VK_EXT_sampler_filter_minmax);
			case .VK_KHR_storage_buffer_storage_class: return nameof(VK_KHR_storage_buffer_storage_class);
			case .VK_AMD_gpu_shader_int16: return nameof(VK_AMD_gpu_shader_int16);
			case .VK_AMD_mixed_attachment_samples: return nameof(VK_AMD_mixed_attachment_samples);
			case .VK_AMD_shader_fragment_mask: return nameof(VK_AMD_shader_fragment_mask);
			case .VK_EXT_inline_uniform_block: return nameof(VK_EXT_inline_uniform_block);
			case .VK_EXT_shader_stencil_export: return nameof(VK_EXT_shader_stencil_export);
			case .VK_EXT_sample_locations: return nameof(VK_EXT_sample_locations);
			case .VK_KHR_relaxed_block_layout: return nameof(VK_KHR_relaxed_block_layout);
			case .VK_KHR_get_memory_requirements2: return nameof(VK_KHR_get_memory_requirements2);
			case .VK_KHR_image_format_list: return nameof(VK_KHR_image_format_list);
			case .VK_EXT_blend_operation_advanced: return nameof(VK_EXT_blend_operation_advanced);
			case .VK_NV_fragment_coverage_to_color: return nameof(VK_NV_fragment_coverage_to_color);
			case .VK_KHR_acceleration_structure: return nameof(VK_KHR_acceleration_structure);
			case .VK_KHR_ray_tracing_pipeline: return nameof(VK_KHR_ray_tracing_pipeline);
			case .VK_KHR_ray_query: return nameof(VK_KHR_ray_query);
			case .VK_NV_framebuffer_mixed_samples: return nameof(VK_NV_framebuffer_mixed_samples);
			case .VK_NV_fill_rectangle: return nameof(VK_NV_fill_rectangle);
			case .VK_NV_shader_sm_builtins: return nameof(VK_NV_shader_sm_builtins);
			case .VK_EXT_post_depth_coverage: return nameof(VK_EXT_post_depth_coverage);
			case .VK_KHR_sampler_ycbcr_conversion: return nameof(VK_KHR_sampler_ycbcr_conversion);
			case .VK_KHR_bind_memory2: return nameof(VK_KHR_bind_memory2);
			case .VK_EXT_image_drm_format_modifier: return nameof(VK_EXT_image_drm_format_modifier);
			case .VK_EXT_validation_cache: return nameof(VK_EXT_validation_cache);
			case .VK_EXT_descriptor_indexing: return nameof(VK_EXT_descriptor_indexing);
			case .VK_EXT_shader_viewport_index_layer: return nameof(VK_EXT_shader_viewport_index_layer);
			case .VK_NV_shading_rate_image: return nameof(VK_NV_shading_rate_image);
			case .VK_NV_ray_tracing: return nameof(VK_NV_ray_tracing);
			case .VK_NV_representative_fragment_test: return nameof(VK_NV_representative_fragment_test);
			case .VK_KHR_maintenance3: return nameof(VK_KHR_maintenance3);
			case .VK_KHR_draw_indirect_count: return nameof(VK_KHR_draw_indirect_count);
			case .VK_EXT_filter_cubic: return nameof(VK_EXT_filter_cubic);
			case .VK_QCOM_render_pass_shader_resolve: return nameof(VK_QCOM_render_pass_shader_resolve);
			case .VK_EXT_global_priority: return nameof(VK_EXT_global_priority);
			case .VK_KHR_shader_subgroup_extended_types: return nameof(VK_KHR_shader_subgroup_extended_types);
			case .VK_KHR_8bit_storage: return nameof(VK_KHR_8bit_storage);
			case .VK_EXT_external_memory_host: return nameof(VK_EXT_external_memory_host);
			case .VK_AMD_buffer_marker: return nameof(VK_AMD_buffer_marker);
			case .VK_KHR_shader_atomic_int64: return nameof(VK_KHR_shader_atomic_int64);
			case .VK_KHR_shader_clock: return nameof(VK_KHR_shader_clock);
			case .VK_AMD_pipeline_compiler_control: return nameof(VK_AMD_pipeline_compiler_control);
			case .VK_EXT_calibrated_timestamps: return nameof(VK_EXT_calibrated_timestamps);
			case .VK_AMD_shader_core_properties: return nameof(VK_AMD_shader_core_properties);
			case .VK_KHR_video_decode_h265: return nameof(VK_KHR_video_decode_h265);
			case .VK_KHR_global_priority: return nameof(VK_KHR_global_priority);
			case .VK_AMD_memory_overallocation_behavior: return nameof(VK_AMD_memory_overallocation_behavior);
			case .VK_EXT_vertex_attribute_divisor: return nameof(VK_EXT_vertex_attribute_divisor);
			case .VK_EXT_pipeline_creation_feedback: return nameof(VK_EXT_pipeline_creation_feedback);
			case .VK_KHR_driver_properties: return nameof(VK_KHR_driver_properties);
			case .VK_KHR_shader_float_controls: return nameof(VK_KHR_shader_float_controls);
			case .VK_NV_shader_subgroup_partitioned: return nameof(VK_NV_shader_subgroup_partitioned);
			case .VK_KHR_depth_stencil_resolve: return nameof(VK_KHR_depth_stencil_resolve);
			case .VK_KHR_swapchain_mutable_format: return nameof(VK_KHR_swapchain_mutable_format);
			case .VK_NV_compute_shader_derivatives: return nameof(VK_NV_compute_shader_derivatives);
			case .VK_NV_mesh_shader: return nameof(VK_NV_mesh_shader);
			case .VK_NV_fragment_shader_barycentric: return nameof(VK_NV_fragment_shader_barycentric);
			case .VK_NV_shader_image_footprint: return nameof(VK_NV_shader_image_footprint);
			case .VK_NV_scissor_exclusive: return nameof(VK_NV_scissor_exclusive);
			case .VK_NV_device_diagnostic_checkpoints: return nameof(VK_NV_device_diagnostic_checkpoints);
			case .VK_KHR_timeline_semaphore: return nameof(VK_KHR_timeline_semaphore);
			case .VK_INTEL_shader_integer_functions2: return nameof(VK_INTEL_shader_integer_functions2);
			case .VK_INTEL_performance_query: return nameof(VK_INTEL_performance_query);
			case .VK_KHR_vulkan_memory_model: return nameof(VK_KHR_vulkan_memory_model);
			case .VK_EXT_pci_bus_info: return nameof(VK_EXT_pci_bus_info);
			case .VK_AMD_display_native_hdr: return nameof(VK_AMD_display_native_hdr);
			case .VK_KHR_shader_terminate_invocation: return nameof(VK_KHR_shader_terminate_invocation);
			case .VK_EXT_fragment_density_map: return nameof(VK_EXT_fragment_density_map);
			case .VK_EXT_scalar_block_layout: return nameof(VK_EXT_scalar_block_layout);
			case .VK_GOOGLE_hlsl_functionality1: return nameof(VK_GOOGLE_hlsl_functionality1);
			case .VK_GOOGLE_decorate_string: return nameof(VK_GOOGLE_decorate_string);
			case .VK_EXT_subgroup_size_control: return nameof(VK_EXT_subgroup_size_control);
			case .VK_KHR_fragment_shading_rate: return nameof(VK_KHR_fragment_shading_rate);
			case .VK_AMD_shader_core_properties2: return nameof(VK_AMD_shader_core_properties2);
			case .VK_AMD_device_coherent_memory: return nameof(VK_AMD_device_coherent_memory);
			case .VK_KHR_dynamic_rendering_local_read: return nameof(VK_KHR_dynamic_rendering_local_read);
			case .VK_EXT_shader_image_atomic_int64: return nameof(VK_EXT_shader_image_atomic_int64);
			case .VK_KHR_shader_quad_control: return nameof(VK_KHR_shader_quad_control);
			case .VK_KHR_spirv_1_4: return nameof(VK_KHR_spirv_1_4);
			case .VK_EXT_memory_budget: return nameof(VK_EXT_memory_budget);
			case .VK_EXT_memory_priority: return nameof(VK_EXT_memory_priority);
			case .VK_KHR_surface_protected_capabilities: return nameof(VK_KHR_surface_protected_capabilities);
			case .VK_NV_dedicated_allocation_image_aliasing: return nameof(VK_NV_dedicated_allocation_image_aliasing);
			case .VK_KHR_separate_depth_stencil_layouts: return nameof(VK_KHR_separate_depth_stencil_layouts);
			case .VK_EXT_buffer_device_address: return nameof(VK_EXT_buffer_device_address);
			case .VK_EXT_tooling_info: return nameof(VK_EXT_tooling_info);
			case .VK_EXT_separate_stencil_usage: return nameof(VK_EXT_separate_stencil_usage);
			case .VK_EXT_validation_features: return nameof(VK_EXT_validation_features);
			case .VK_KHR_present_wait: return nameof(VK_KHR_present_wait);
			case .VK_NV_cooperative_matrix: return nameof(VK_NV_cooperative_matrix);
			case .VK_NV_coverage_reduction_mode: return nameof(VK_NV_coverage_reduction_mode);
			case .VK_EXT_fragment_shader_interlock: return nameof(VK_EXT_fragment_shader_interlock);
			case .VK_EXT_ycbcr_image_arrays: return nameof(VK_EXT_ycbcr_image_arrays);
			case .VK_KHR_uniform_buffer_standard_layout: return nameof(VK_KHR_uniform_buffer_standard_layout);
			case .VK_EXT_provoking_vertex: return nameof(VK_EXT_provoking_vertex);
			case .VK_EXT_headless_surface: return nameof(VK_EXT_headless_surface);
			case .VK_KHR_buffer_device_address: return nameof(VK_KHR_buffer_device_address);
			case .VK_EXT_line_rasterization: return nameof(VK_EXT_line_rasterization);
			case .VK_EXT_shader_atomic_float: return nameof(VK_EXT_shader_atomic_float);
			case .VK_EXT_host_query_reset: return nameof(VK_EXT_host_query_reset);
			case .VK_EXT_index_type_uint8: return nameof(VK_EXT_index_type_uint8);
			case .VK_EXT_extended_dynamic_state: return nameof(VK_EXT_extended_dynamic_state);
			case .VK_KHR_deferred_host_operations: return nameof(VK_KHR_deferred_host_operations);
			case .VK_KHR_pipeline_executable_properties: return nameof(VK_KHR_pipeline_executable_properties);
			case .VK_EXT_host_image_copy: return nameof(VK_EXT_host_image_copy);
			case .VK_KHR_map_memory2: return nameof(VK_KHR_map_memory2);
			case .VK_EXT_map_memory_placed: return nameof(VK_EXT_map_memory_placed);
			case .VK_EXT_shader_atomic_float2: return nameof(VK_EXT_shader_atomic_float2);
			case .VK_EXT_surface_maintenance1: return nameof(VK_EXT_surface_maintenance1);
			case .VK_EXT_swapchain_maintenance1: return nameof(VK_EXT_swapchain_maintenance1);
			case .VK_EXT_shader_demote_to_helper_invocation: return nameof(VK_EXT_shader_demote_to_helper_invocation);
			case .VK_NV_device_generated_commands: return nameof(VK_NV_device_generated_commands);
			case .VK_NV_inherited_viewport_scissor: return nameof(VK_NV_inherited_viewport_scissor);
			case .VK_KHR_shader_integer_dot_product: return nameof(VK_KHR_shader_integer_dot_product);
			case .VK_EXT_texel_buffer_alignment: return nameof(VK_EXT_texel_buffer_alignment);
			case .VK_QCOM_render_pass_transform: return nameof(VK_QCOM_render_pass_transform);
			case .VK_EXT_depth_bias_control: return nameof(VK_EXT_depth_bias_control);
			case .VK_EXT_device_memory_report: return nameof(VK_EXT_device_memory_report);
			case .VK_EXT_acquire_drm_display: return nameof(VK_EXT_acquire_drm_display);
			case .VK_EXT_robustness2: return nameof(VK_EXT_robustness2);
			case .VK_EXT_custom_border_color: return nameof(VK_EXT_custom_border_color);
			case .VK_GOOGLE_user_type: return nameof(VK_GOOGLE_user_type);
			case .VK_KHR_pipeline_library: return nameof(VK_KHR_pipeline_library);
			case .VK_NV_present_barrier: return nameof(VK_NV_present_barrier);
			case .VK_KHR_shader_non_semantic_info: return nameof(VK_KHR_shader_non_semantic_info);
			case .VK_KHR_present_id: return nameof(VK_KHR_present_id);
			case .VK_EXT_private_data: return nameof(VK_EXT_private_data);
			case .VK_EXT_pipeline_creation_cache_control: return nameof(VK_EXT_pipeline_creation_cache_control);
			case .VK_KHR_video_encode_queue: return nameof(VK_KHR_video_encode_queue);
			case .VK_NV_device_diagnostics_config: return nameof(VK_NV_device_diagnostics_config);
			case .VK_QCOM_render_pass_store_ops: return nameof(VK_QCOM_render_pass_store_ops);
			case .VK_NV_cuda_kernel_launch: return nameof(VK_NV_cuda_kernel_launch);
			case .VK_NV_low_latency: return nameof(VK_NV_low_latency);
			case .VK_KHR_synchronization2: return nameof(VK_KHR_synchronization2);
			case .VK_EXT_descriptor_buffer: return nameof(VK_EXT_descriptor_buffer);
			case .VK_EXT_graphics_pipeline_library: return nameof(VK_EXT_graphics_pipeline_library);
			case .VK_AMD_shader_early_and_late_fragment_tests: return nameof(VK_AMD_shader_early_and_late_fragment_tests);
			case .VK_KHR_fragment_shader_barycentric: return nameof(VK_KHR_fragment_shader_barycentric);
			case .VK_KHR_shader_subgroup_uniform_control_flow: return nameof(VK_KHR_shader_subgroup_uniform_control_flow);
			case .VK_KHR_zero_initialize_workgroup_memory: return nameof(VK_KHR_zero_initialize_workgroup_memory);
			case .VK_NV_fragment_shading_rate_enums: return nameof(VK_NV_fragment_shading_rate_enums);
			case .VK_NV_ray_tracing_motion_blur: return nameof(VK_NV_ray_tracing_motion_blur);
			case .VK_EXT_mesh_shader: return nameof(VK_EXT_mesh_shader);
			case .VK_EXT_ycbcr_2plane_444_formats: return nameof(VK_EXT_ycbcr_2plane_444_formats);
			case .VK_EXT_fragment_density_map2: return nameof(VK_EXT_fragment_density_map2);
			case .VK_QCOM_rotated_copy_commands: return nameof(VK_QCOM_rotated_copy_commands);
			case .VK_EXT_image_robustness: return nameof(VK_EXT_image_robustness);
			case .VK_KHR_workgroup_memory_explicit_layout: return nameof(VK_KHR_workgroup_memory_explicit_layout);
			case .VK_KHR_copy_commands2: return nameof(VK_KHR_copy_commands2);
			case .VK_EXT_image_compression_control: return nameof(VK_EXT_image_compression_control);
			case .VK_EXT_attachment_feedback_loop_layout: return nameof(VK_EXT_attachment_feedback_loop_layout);
			case .VK_EXT_4444_formats: return nameof(VK_EXT_4444_formats);
			case .VK_EXT_device_fault: return nameof(VK_EXT_device_fault);
			case .VK_ARM_rasterization_order_attachment_access: return nameof(VK_ARM_rasterization_order_attachment_access);
			case .VK_EXT_rgba10x6_formats: return nameof(VK_EXT_rgba10x6_formats);
			case .VK_VALVE_mutable_descriptor_type: return nameof(VK_VALVE_mutable_descriptor_type);
			case .VK_EXT_vertex_input_dynamic_state: return nameof(VK_EXT_vertex_input_dynamic_state);
			case .VK_EXT_physical_device_drm: return nameof(VK_EXT_physical_device_drm);
			case .VK_EXT_device_address_binding_report: return nameof(VK_EXT_device_address_binding_report);
			case .VK_EXT_depth_clip_control: return nameof(VK_EXT_depth_clip_control);
			case .VK_EXT_primitive_topology_list_restart: return nameof(VK_EXT_primitive_topology_list_restart);
			case .VK_KHR_format_feature_flags2: return nameof(VK_KHR_format_feature_flags2);
			case .VK_EXT_present_mode_fifo_latest_ready: return nameof(VK_EXT_present_mode_fifo_latest_ready);
			case .VK_HUAWEI_subpass_shading: return nameof(VK_HUAWEI_subpass_shading);
			case .VK_HUAWEI_invocation_mask: return nameof(VK_HUAWEI_invocation_mask);
			case .VK_NV_external_memory_rdma: return nameof(VK_NV_external_memory_rdma);
			case .VK_EXT_pipeline_properties: return nameof(VK_EXT_pipeline_properties);
			case .VK_EXT_frame_boundary: return nameof(VK_EXT_frame_boundary);
			case .VK_EXT_multisampled_render_to_single_sampled: return nameof(VK_EXT_multisampled_render_to_single_sampled);
			case .VK_EXT_extended_dynamic_state2: return nameof(VK_EXT_extended_dynamic_state2);
			case .VK_EXT_color_write_enable: return nameof(VK_EXT_color_write_enable);
			case .VK_EXT_primitives_generated_query: return nameof(VK_EXT_primitives_generated_query);
			case .VK_KHR_ray_tracing_maintenance1: return nameof(VK_KHR_ray_tracing_maintenance1);
			case .VK_EXT_global_priority_query: return nameof(VK_EXT_global_priority_query);
			case .VK_EXT_image_view_min_lod: return nameof(VK_EXT_image_view_min_lod);
			case .VK_EXT_multi_draw: return nameof(VK_EXT_multi_draw);
			case .VK_EXT_image_2d_view_of_3d: return nameof(VK_EXT_image_2d_view_of_3d);
			case .VK_KHR_portability_enumeration: return nameof(VK_KHR_portability_enumeration);
			case .VK_EXT_shader_tile_image: return nameof(VK_EXT_shader_tile_image);
			case .VK_EXT_opacity_micromap: return nameof(VK_EXT_opacity_micromap);
			case .VK_EXT_load_store_op_none: return nameof(VK_EXT_load_store_op_none);
			case .VK_HUAWEI_cluster_culling_shader: return nameof(VK_HUAWEI_cluster_culling_shader);
			case .VK_EXT_border_color_swizzle: return nameof(VK_EXT_border_color_swizzle);
			case .VK_EXT_pageable_device_local_memory: return nameof(VK_EXT_pageable_device_local_memory);
			case .VK_KHR_maintenance4: return nameof(VK_KHR_maintenance4);
			case .VK_ARM_shader_core_properties: return nameof(VK_ARM_shader_core_properties);
			case .VK_KHR_shader_subgroup_rotate: return nameof(VK_KHR_shader_subgroup_rotate);
			case .VK_ARM_scheduling_controls: return nameof(VK_ARM_scheduling_controls);
			case .VK_EXT_image_sliced_view_of_3d: return nameof(VK_EXT_image_sliced_view_of_3d);
			case .VK_VALVE_descriptor_set_host_mapping: return nameof(VK_VALVE_descriptor_set_host_mapping);
			case .VK_EXT_depth_clamp_zero_one: return nameof(VK_EXT_depth_clamp_zero_one);
			case .VK_EXT_non_seamless_cube_map: return nameof(VK_EXT_non_seamless_cube_map);
			case .VK_ARM_render_pass_striped: return nameof(VK_ARM_render_pass_striped);
			case .VK_QCOM_fragment_density_map_offset: return nameof(VK_QCOM_fragment_density_map_offset);
			case .VK_NV_copy_memory_indirect: return nameof(VK_NV_copy_memory_indirect);
			case .VK_NV_memory_decompression: return nameof(VK_NV_memory_decompression);
			case .VK_NV_device_generated_commands_compute: return nameof(VK_NV_device_generated_commands_compute);
			case .VK_NV_linear_color_attachment: return nameof(VK_NV_linear_color_attachment);
			case .VK_GOOGLE_surfaceless_query: return nameof(VK_GOOGLE_surfaceless_query);
			case .VK_KHR_shader_maximal_reconvergence: return nameof(VK_KHR_shader_maximal_reconvergence);
			case .VK_EXT_image_compression_control_swapchain: return nameof(VK_EXT_image_compression_control_swapchain);
			case .VK_QCOM_image_processing: return nameof(VK_QCOM_image_processing);
			case .VK_EXT_nested_command_buffer: return nameof(VK_EXT_nested_command_buffer);
			case .VK_EXT_external_memory_acquire_unmodified: return nameof(VK_EXT_external_memory_acquire_unmodified);
			case .VK_EXT_extended_dynamic_state3: return nameof(VK_EXT_extended_dynamic_state3);
			case .VK_EXT_subpass_merge_feedback: return nameof(VK_EXT_subpass_merge_feedback);
			case .VK_LUNARG_direct_driver_loading: return nameof(VK_LUNARG_direct_driver_loading);
			case .VK_EXT_shader_module_identifier: return nameof(VK_EXT_shader_module_identifier);
			case .VK_EXT_rasterization_order_attachment_access: return nameof(VK_EXT_rasterization_order_attachment_access);
			case .VK_NV_optical_flow: return nameof(VK_NV_optical_flow);
			case .VK_EXT_legacy_dithering: return nameof(VK_EXT_legacy_dithering);
			case .VK_EXT_pipeline_protected_access: return nameof(VK_EXT_pipeline_protected_access);
			case .VK_KHR_maintenance5: return nameof(VK_KHR_maintenance5);
			case .VK_AMD_anti_lag: return nameof(VK_AMD_anti_lag);
			case .VK_KHR_ray_tracing_position_fetch: return nameof(VK_KHR_ray_tracing_position_fetch);
			case .VK_EXT_shader_object: return nameof(VK_EXT_shader_object);
			case .VK_KHR_pipeline_binary: return nameof(VK_KHR_pipeline_binary);
			case .VK_QCOM_tile_properties: return nameof(VK_QCOM_tile_properties);
			case .VK_SEC_amigo_profiling: return nameof(VK_SEC_amigo_profiling);
			case .VK_QCOM_multiview_per_view_viewports: return nameof(VK_QCOM_multiview_per_view_viewports);
			case .VK_NV_ray_tracing_invocation_reorder: return nameof(VK_NV_ray_tracing_invocation_reorder);
			case .VK_NV_extended_sparse_address_space: return nameof(VK_NV_extended_sparse_address_space);
			case .VK_EXT_mutable_descriptor_type: return nameof(VK_EXT_mutable_descriptor_type);
			case .VK_EXT_legacy_vertex_attributes: return nameof(VK_EXT_legacy_vertex_attributes);
			case .VK_EXT_layer_settings: return nameof(VK_EXT_layer_settings);
			case .VK_ARM_shader_core_builtins: return nameof(VK_ARM_shader_core_builtins);
			case .VK_EXT_pipeline_library_group_handles: return nameof(VK_EXT_pipeline_library_group_handles);
			case .VK_EXT_dynamic_rendering_unused_attachments: return nameof(VK_EXT_dynamic_rendering_unused_attachments);
			case .VK_NV_low_latency2: return nameof(VK_NV_low_latency2);
			case .VK_KHR_cooperative_matrix: return nameof(VK_KHR_cooperative_matrix);
			case .VK_QCOM_multiview_per_view_render_areas: return nameof(VK_QCOM_multiview_per_view_render_areas);
			case .VK_KHR_compute_shader_derivatives: return nameof(VK_KHR_compute_shader_derivatives);
			case .VK_KHR_video_decode_av1: return nameof(VK_KHR_video_decode_av1);
			case .VK_KHR_video_encode_av1: return nameof(VK_KHR_video_encode_av1);
			case .VK_KHR_video_maintenance1: return nameof(VK_KHR_video_maintenance1);
			case .VK_NV_per_stage_descriptor_set: return nameof(VK_NV_per_stage_descriptor_set);
			case .VK_QCOM_image_processing2: return nameof(VK_QCOM_image_processing2);
			case .VK_QCOM_filter_cubic_weights: return nameof(VK_QCOM_filter_cubic_weights);
			case .VK_QCOM_ycbcr_degamma: return nameof(VK_QCOM_ycbcr_degamma);
			case .VK_QCOM_filter_cubic_clamp: return nameof(VK_QCOM_filter_cubic_clamp);
			case .VK_EXT_attachment_feedback_loop_dynamic_state: return nameof(VK_EXT_attachment_feedback_loop_dynamic_state);
			case .VK_KHR_vertex_attribute_divisor: return nameof(VK_KHR_vertex_attribute_divisor);
			case .VK_KHR_load_store_op_none: return nameof(VK_KHR_load_store_op_none);
			case .VK_KHR_shader_float_controls2: return nameof(VK_KHR_shader_float_controls2);
			case .VK_MSFT_layered_driver: return nameof(VK_MSFT_layered_driver);
			case .VK_KHR_index_type_uint8: return nameof(VK_KHR_index_type_uint8);
			case .VK_KHR_line_rasterization: return nameof(VK_KHR_line_rasterization);
			case .VK_KHR_calibrated_timestamps: return nameof(VK_KHR_calibrated_timestamps);
			case .VK_KHR_shader_expect_assume: return nameof(VK_KHR_shader_expect_assume);
			case .VK_KHR_maintenance6: return nameof(VK_KHR_maintenance6);
			case .VK_NV_descriptor_pool_overallocation: return nameof(VK_NV_descriptor_pool_overallocation);
			case .VK_NV_display_stereo: return nameof(VK_NV_display_stereo);
			case .VK_KHR_video_encode_quantization_map: return nameof(VK_KHR_video_encode_quantization_map);
			case .VK_NV_raw_access_chains: return nameof(VK_NV_raw_access_chains);
			case .VK_KHR_shader_relaxed_extended_instruction: return nameof(VK_KHR_shader_relaxed_extended_instruction);
			case .VK_NV_command_buffer_inheritance: return nameof(VK_NV_command_buffer_inheritance);
			case .VK_KHR_maintenance7: return nameof(VK_KHR_maintenance7);
			case .VK_NV_shader_atomic_float16_vector: return nameof(VK_NV_shader_atomic_float16_vector);
			case .VK_EXT_shader_replicated_composites: return nameof(VK_EXT_shader_replicated_composites);
			case .VK_NV_ray_tracing_validation: return nameof(VK_NV_ray_tracing_validation);
			case .VK_EXT_device_generated_commands: return nameof(VK_EXT_device_generated_commands);
			case .VK_MESA_image_alignment_control: return nameof(VK_MESA_image_alignment_control);
			case .VK_EXT_depth_clamp_control: return nameof(VK_EXT_depth_clamp_control);
			case .VK_HUAWEI_hdr_vivid: return nameof(VK_HUAWEI_hdr_vivid);
			case .VK_NV_cooperative_matrix2: return nameof(VK_NV_cooperative_matrix2);
			case .VK_EXT_vertex_attribute_robustness: return nameof(VK_EXT_vertex_attribute_robustness);
			}
		}
	}

	public Kind Kind
	{
		get
		{
			switch (this)
			{
			case .VK_KHR_surface: return .Instance;
			case .VK_KHR_swapchain: return .Device;
			case .VK_KHR_display: return .Instance;
			case .VK_KHR_display_swapchain: return .Device;
			case .VK_EXT_debug_report: return .Instance;
			case .VK_NV_glsl_shader: return .Device;
			case .VK_EXT_depth_range_unrestricted: return .Device;
			case .VK_KHR_sampler_mirror_clamp_to_edge: return .Device;
			case .VK_IMG_filter_cubic: return .Device;
			case .VK_AMD_rasterization_order: return .Device;
			case .VK_AMD_shader_trinary_minmax: return .Device;
			case .VK_AMD_shader_explicit_vertex_parameter: return .Device;
			case .VK_EXT_debug_marker: return .Device;
			case .VK_KHR_video_queue: return .Device;
			case .VK_KHR_video_decode_queue: return .Device;
			case .VK_AMD_gcn_shader: return .Device;
			case .VK_NV_dedicated_allocation: return .Device;
			case .VK_EXT_transform_feedback: return .Device;
			case .VK_NVX_binary_import: return .Device;
			case .VK_NVX_image_view_handle: return .Device;
			case .VK_AMD_draw_indirect_count: return .Device;
			case .VK_AMD_negative_viewport_height: return .Device;
			case .VK_AMD_gpu_shader_half_float: return .Device;
			case .VK_AMD_shader_ballot: return .Device;
			case .VK_KHR_video_encode_h264: return .Device;
			case .VK_KHR_video_encode_h265: return .Device;
			case .VK_KHR_video_decode_h264: return .Device;
			case .VK_AMD_texture_gather_bias_lod: return .Device;
			case .VK_AMD_shader_info: return .Device;
			case .VK_KHR_dynamic_rendering: return .Device;
			case .VK_AMD_shader_image_load_store_lod: return .Device;
			case .VK_NV_corner_sampled_image: return .Device;
			case .VK_KHR_multiview: return .Device;
			case .VK_IMG_format_pvrtc: return .Device;
			case .VK_NV_external_memory_capabilities: return .Instance;
			case .VK_NV_external_memory: return .Device;
			case .VK_KHR_get_physical_device_properties2: return .Instance;
			case .VK_KHR_device_group: return .Device;
			case .VK_EXT_validation_flags: return .Instance;
			case .VK_KHR_shader_draw_parameters: return .Device;
			case .VK_EXT_shader_subgroup_ballot: return .Device;
			case .VK_EXT_shader_subgroup_vote: return .Device;
			case .VK_EXT_texture_compression_astc_hdr: return .Device;
			case .VK_EXT_astc_decode_mode: return .Device;
			case .VK_EXT_pipeline_robustness: return .Device;
			case .VK_KHR_maintenance1: return .Device;
			case .VK_KHR_device_group_creation: return .Instance;
			case .VK_KHR_external_memory_capabilities: return .Instance;
			case .VK_KHR_external_memory: return .Device;
			case .VK_KHR_external_memory_fd: return .Device;
			case .VK_KHR_external_semaphore_capabilities: return .Instance;
			case .VK_KHR_external_semaphore: return .Device;
			case .VK_KHR_external_semaphore_fd: return .Device;
			case .VK_KHR_push_descriptor: return .Device;
			case .VK_EXT_conditional_rendering: return .Device;
			case .VK_KHR_shader_float16_int8: return .Device;
			case .VK_KHR_16bit_storage: return .Device;
			case .VK_KHR_incremental_present: return .Device;
			case .VK_KHR_descriptor_update_template: return .Device;
			case .VK_NV_clip_space_w_scaling: return .Device;
			case .VK_EXT_direct_mode_display: return .Instance;
			case .VK_EXT_display_surface_counter: return .Instance;
			case .VK_EXT_display_control: return .Device;
			case .VK_GOOGLE_display_timing: return .Device;
			case .VK_NV_sample_mask_override_coverage: return .Device;
			case .VK_NV_geometry_shader_passthrough: return .Device;
			case .VK_NV_viewport_array2: return .Device;
			case .VK_NVX_multiview_per_view_attributes: return .Device;
			case .VK_NV_viewport_swizzle: return .Device;
			case .VK_EXT_discard_rectangles: return .Device;
			case .VK_EXT_conservative_rasterization: return .Device;
			case .VK_EXT_depth_clip_enable: return .Device;
			case .VK_EXT_swapchain_colorspace: return .Instance;
			case .VK_EXT_hdr_metadata: return .Device;
			case .VK_KHR_imageless_framebuffer: return .Device;
			case .VK_KHR_create_renderpass2: return .Device;
			case .VK_IMG_relaxed_line_rasterization: return .Device;
			case .VK_KHR_shared_presentable_image: return .Device;
			case .VK_KHR_external_fence_capabilities: return .Instance;
			case .VK_KHR_external_fence: return .Device;
			case .VK_KHR_external_fence_fd: return .Device;
			case .VK_KHR_performance_query: return .Device;
			case .VK_KHR_maintenance2: return .Device;
			case .VK_KHR_get_surface_capabilities2: return .Instance;
			case .VK_KHR_variable_pointers: return .Device;
			case .VK_KHR_get_display_properties2: return .Instance;
			case .VK_EXT_external_memory_dma_buf: return .Device;
			case .VK_EXT_queue_family_foreign: return .Device;
			case .VK_KHR_dedicated_allocation: return .Device;
			case .VK_EXT_debug_utils: return .Instance;
			case .VK_EXT_sampler_filter_minmax: return .Device;
			case .VK_KHR_storage_buffer_storage_class: return .Device;
			case .VK_AMD_gpu_shader_int16: return .Device;
			case .VK_AMD_mixed_attachment_samples: return .Device;
			case .VK_AMD_shader_fragment_mask: return .Device;
			case .VK_EXT_inline_uniform_block: return .Device;
			case .VK_EXT_shader_stencil_export: return .Device;
			case .VK_EXT_sample_locations: return .Device;
			case .VK_KHR_relaxed_block_layout: return .Device;
			case .VK_KHR_get_memory_requirements2: return .Device;
			case .VK_KHR_image_format_list: return .Device;
			case .VK_EXT_blend_operation_advanced: return .Device;
			case .VK_NV_fragment_coverage_to_color: return .Device;
			case .VK_KHR_acceleration_structure: return .Device;
			case .VK_KHR_ray_tracing_pipeline: return .Device;
			case .VK_KHR_ray_query: return .Device;
			case .VK_NV_framebuffer_mixed_samples: return .Device;
			case .VK_NV_fill_rectangle: return .Device;
			case .VK_NV_shader_sm_builtins: return .Device;
			case .VK_EXT_post_depth_coverage: return .Device;
			case .VK_KHR_sampler_ycbcr_conversion: return .Device;
			case .VK_KHR_bind_memory2: return .Device;
			case .VK_EXT_image_drm_format_modifier: return .Device;
			case .VK_EXT_validation_cache: return .Device;
			case .VK_EXT_descriptor_indexing: return .Device;
			case .VK_EXT_shader_viewport_index_layer: return .Device;
			case .VK_NV_shading_rate_image: return .Device;
			case .VK_NV_ray_tracing: return .Device;
			case .VK_NV_representative_fragment_test: return .Device;
			case .VK_KHR_maintenance3: return .Device;
			case .VK_KHR_draw_indirect_count: return .Device;
			case .VK_EXT_filter_cubic: return .Device;
			case .VK_QCOM_render_pass_shader_resolve: return .Device;
			case .VK_EXT_global_priority: return .Device;
			case .VK_KHR_shader_subgroup_extended_types: return .Device;
			case .VK_KHR_8bit_storage: return .Device;
			case .VK_EXT_external_memory_host: return .Device;
			case .VK_AMD_buffer_marker: return .Device;
			case .VK_KHR_shader_atomic_int64: return .Device;
			case .VK_KHR_shader_clock: return .Device;
			case .VK_AMD_pipeline_compiler_control: return .Device;
			case .VK_EXT_calibrated_timestamps: return .Device;
			case .VK_AMD_shader_core_properties: return .Device;
			case .VK_KHR_video_decode_h265: return .Device;
			case .VK_KHR_global_priority: return .Device;
			case .VK_AMD_memory_overallocation_behavior: return .Device;
			case .VK_EXT_vertex_attribute_divisor: return .Device;
			case .VK_EXT_pipeline_creation_feedback: return .Device;
			case .VK_KHR_driver_properties: return .Device;
			case .VK_KHR_shader_float_controls: return .Device;
			case .VK_NV_shader_subgroup_partitioned: return .Device;
			case .VK_KHR_depth_stencil_resolve: return .Device;
			case .VK_KHR_swapchain_mutable_format: return .Device;
			case .VK_NV_compute_shader_derivatives: return .Device;
			case .VK_NV_mesh_shader: return .Device;
			case .VK_NV_fragment_shader_barycentric: return .Device;
			case .VK_NV_shader_image_footprint: return .Device;
			case .VK_NV_scissor_exclusive: return .Device;
			case .VK_NV_device_diagnostic_checkpoints: return .Device;
			case .VK_KHR_timeline_semaphore: return .Device;
			case .VK_INTEL_shader_integer_functions2: return .Device;
			case .VK_INTEL_performance_query: return .Device;
			case .VK_KHR_vulkan_memory_model: return .Device;
			case .VK_EXT_pci_bus_info: return .Device;
			case .VK_AMD_display_native_hdr: return .Device;
			case .VK_KHR_shader_terminate_invocation: return .Device;
			case .VK_EXT_fragment_density_map: return .Device;
			case .VK_EXT_scalar_block_layout: return .Device;
			case .VK_GOOGLE_hlsl_functionality1: return .Device;
			case .VK_GOOGLE_decorate_string: return .Device;
			case .VK_EXT_subgroup_size_control: return .Device;
			case .VK_KHR_fragment_shading_rate: return .Device;
			case .VK_AMD_shader_core_properties2: return .Device;
			case .VK_AMD_device_coherent_memory: return .Device;
			case .VK_KHR_dynamic_rendering_local_read: return .Device;
			case .VK_EXT_shader_image_atomic_int64: return .Device;
			case .VK_KHR_shader_quad_control: return .Device;
			case .VK_KHR_spirv_1_4: return .Device;
			case .VK_EXT_memory_budget: return .Device;
			case .VK_EXT_memory_priority: return .Device;
			case .VK_KHR_surface_protected_capabilities: return .Instance;
			case .VK_NV_dedicated_allocation_image_aliasing: return .Device;
			case .VK_KHR_separate_depth_stencil_layouts: return .Device;
			case .VK_EXT_buffer_device_address: return .Device;
			case .VK_EXT_tooling_info: return .Device;
			case .VK_EXT_separate_stencil_usage: return .Device;
			case .VK_EXT_validation_features: return .Instance;
			case .VK_KHR_present_wait: return .Device;
			case .VK_NV_cooperative_matrix: return .Device;
			case .VK_NV_coverage_reduction_mode: return .Device;
			case .VK_EXT_fragment_shader_interlock: return .Device;
			case .VK_EXT_ycbcr_image_arrays: return .Device;
			case .VK_KHR_uniform_buffer_standard_layout: return .Device;
			case .VK_EXT_provoking_vertex: return .Device;
			case .VK_EXT_headless_surface: return .Instance;
			case .VK_KHR_buffer_device_address: return .Device;
			case .VK_EXT_line_rasterization: return .Device;
			case .VK_EXT_shader_atomic_float: return .Device;
			case .VK_EXT_host_query_reset: return .Device;
			case .VK_EXT_index_type_uint8: return .Device;
			case .VK_EXT_extended_dynamic_state: return .Device;
			case .VK_KHR_deferred_host_operations: return .Device;
			case .VK_KHR_pipeline_executable_properties: return .Device;
			case .VK_EXT_host_image_copy: return .Device;
			case .VK_KHR_map_memory2: return .Device;
			case .VK_EXT_map_memory_placed: return .Device;
			case .VK_EXT_shader_atomic_float2: return .Device;
			case .VK_EXT_surface_maintenance1: return .Instance;
			case .VK_EXT_swapchain_maintenance1: return .Device;
			case .VK_EXT_shader_demote_to_helper_invocation: return .Device;
			case .VK_NV_device_generated_commands: return .Device;
			case .VK_NV_inherited_viewport_scissor: return .Device;
			case .VK_KHR_shader_integer_dot_product: return .Device;
			case .VK_EXT_texel_buffer_alignment: return .Device;
			case .VK_QCOM_render_pass_transform: return .Device;
			case .VK_EXT_depth_bias_control: return .Device;
			case .VK_EXT_device_memory_report: return .Device;
			case .VK_EXT_acquire_drm_display: return .Instance;
			case .VK_EXT_robustness2: return .Device;
			case .VK_EXT_custom_border_color: return .Device;
			case .VK_GOOGLE_user_type: return .Device;
			case .VK_KHR_pipeline_library: return .Device;
			case .VK_NV_present_barrier: return .Device;
			case .VK_KHR_shader_non_semantic_info: return .Device;
			case .VK_KHR_present_id: return .Device;
			case .VK_EXT_private_data: return .Device;
			case .VK_EXT_pipeline_creation_cache_control: return .Device;
			case .VK_KHR_video_encode_queue: return .Device;
			case .VK_NV_device_diagnostics_config: return .Device;
			case .VK_QCOM_render_pass_store_ops: return .Device;
			case .VK_NV_cuda_kernel_launch: return .Device;
			case .VK_NV_low_latency: return .Device;
			case .VK_KHR_synchronization2: return .Device;
			case .VK_EXT_descriptor_buffer: return .Device;
			case .VK_EXT_graphics_pipeline_library: return .Device;
			case .VK_AMD_shader_early_and_late_fragment_tests: return .Device;
			case .VK_KHR_fragment_shader_barycentric: return .Device;
			case .VK_KHR_shader_subgroup_uniform_control_flow: return .Device;
			case .VK_KHR_zero_initialize_workgroup_memory: return .Device;
			case .VK_NV_fragment_shading_rate_enums: return .Device;
			case .VK_NV_ray_tracing_motion_blur: return .Device;
			case .VK_EXT_mesh_shader: return .Device;
			case .VK_EXT_ycbcr_2plane_444_formats: return .Device;
			case .VK_EXT_fragment_density_map2: return .Device;
			case .VK_QCOM_rotated_copy_commands: return .Device;
			case .VK_EXT_image_robustness: return .Device;
			case .VK_KHR_workgroup_memory_explicit_layout: return .Device;
			case .VK_KHR_copy_commands2: return .Device;
			case .VK_EXT_image_compression_control: return .Device;
			case .VK_EXT_attachment_feedback_loop_layout: return .Device;
			case .VK_EXT_4444_formats: return .Device;
			case .VK_EXT_device_fault: return .Device;
			case .VK_ARM_rasterization_order_attachment_access: return .Device;
			case .VK_EXT_rgba10x6_formats: return .Device;
			case .VK_VALVE_mutable_descriptor_type: return .Device;
			case .VK_EXT_vertex_input_dynamic_state: return .Device;
			case .VK_EXT_physical_device_drm: return .Device;
			case .VK_EXT_device_address_binding_report: return .Device;
			case .VK_EXT_depth_clip_control: return .Device;
			case .VK_EXT_primitive_topology_list_restart: return .Device;
			case .VK_KHR_format_feature_flags2: return .Device;
			case .VK_EXT_present_mode_fifo_latest_ready: return .Device;
			case .VK_HUAWEI_subpass_shading: return .Device;
			case .VK_HUAWEI_invocation_mask: return .Device;
			case .VK_NV_external_memory_rdma: return .Device;
			case .VK_EXT_pipeline_properties: return .Device;
			case .VK_EXT_frame_boundary: return .Device;
			case .VK_EXT_multisampled_render_to_single_sampled: return .Device;
			case .VK_EXT_extended_dynamic_state2: return .Device;
			case .VK_EXT_color_write_enable: return .Device;
			case .VK_EXT_primitives_generated_query: return .Device;
			case .VK_KHR_ray_tracing_maintenance1: return .Device;
			case .VK_EXT_global_priority_query: return .Device;
			case .VK_EXT_image_view_min_lod: return .Device;
			case .VK_EXT_multi_draw: return .Device;
			case .VK_EXT_image_2d_view_of_3d: return .Device;
			case .VK_KHR_portability_enumeration: return .Instance;
			case .VK_EXT_shader_tile_image: return .Device;
			case .VK_EXT_opacity_micromap: return .Device;
			case .VK_EXT_load_store_op_none: return .Device;
			case .VK_HUAWEI_cluster_culling_shader: return .Device;
			case .VK_EXT_border_color_swizzle: return .Device;
			case .VK_EXT_pageable_device_local_memory: return .Device;
			case .VK_KHR_maintenance4: return .Device;
			case .VK_ARM_shader_core_properties: return .Device;
			case .VK_KHR_shader_subgroup_rotate: return .Device;
			case .VK_ARM_scheduling_controls: return .Device;
			case .VK_EXT_image_sliced_view_of_3d: return .Device;
			case .VK_VALVE_descriptor_set_host_mapping: return .Device;
			case .VK_EXT_depth_clamp_zero_one: return .Device;
			case .VK_EXT_non_seamless_cube_map: return .Device;
			case .VK_ARM_render_pass_striped: return .Device;
			case .VK_QCOM_fragment_density_map_offset: return .Device;
			case .VK_NV_copy_memory_indirect: return .Device;
			case .VK_NV_memory_decompression: return .Device;
			case .VK_NV_device_generated_commands_compute: return .Device;
			case .VK_NV_linear_color_attachment: return .Device;
			case .VK_GOOGLE_surfaceless_query: return .Instance;
			case .VK_KHR_shader_maximal_reconvergence: return .Device;
			case .VK_EXT_image_compression_control_swapchain: return .Device;
			case .VK_QCOM_image_processing: return .Device;
			case .VK_EXT_nested_command_buffer: return .Device;
			case .VK_EXT_external_memory_acquire_unmodified: return .Device;
			case .VK_EXT_extended_dynamic_state3: return .Device;
			case .VK_EXT_subpass_merge_feedback: return .Device;
			case .VK_LUNARG_direct_driver_loading: return .Instance;
			case .VK_EXT_shader_module_identifier: return .Device;
			case .VK_EXT_rasterization_order_attachment_access: return .Device;
			case .VK_NV_optical_flow: return .Device;
			case .VK_EXT_legacy_dithering: return .Device;
			case .VK_EXT_pipeline_protected_access: return .Device;
			case .VK_KHR_maintenance5: return .Device;
			case .VK_AMD_anti_lag: return .Device;
			case .VK_KHR_ray_tracing_position_fetch: return .Device;
			case .VK_EXT_shader_object: return .Device;
			case .VK_KHR_pipeline_binary: return .Device;
			case .VK_QCOM_tile_properties: return .Device;
			case .VK_SEC_amigo_profiling: return .Device;
			case .VK_QCOM_multiview_per_view_viewports: return .Device;
			case .VK_NV_ray_tracing_invocation_reorder: return .Device;
			case .VK_NV_extended_sparse_address_space: return .Device;
			case .VK_EXT_mutable_descriptor_type: return .Device;
			case .VK_EXT_legacy_vertex_attributes: return .Device;
			case .VK_EXT_layer_settings: return .Instance;
			case .VK_ARM_shader_core_builtins: return .Device;
			case .VK_EXT_pipeline_library_group_handles: return .Device;
			case .VK_EXT_dynamic_rendering_unused_attachments: return .Device;
			case .VK_NV_low_latency2: return .Device;
			case .VK_KHR_cooperative_matrix: return .Device;
			case .VK_QCOM_multiview_per_view_render_areas: return .Device;
			case .VK_KHR_compute_shader_derivatives: return .Device;
			case .VK_KHR_video_decode_av1: return .Device;
			case .VK_KHR_video_encode_av1: return .Device;
			case .VK_KHR_video_maintenance1: return .Device;
			case .VK_NV_per_stage_descriptor_set: return .Device;
			case .VK_QCOM_image_processing2: return .Device;
			case .VK_QCOM_filter_cubic_weights: return .Device;
			case .VK_QCOM_ycbcr_degamma: return .Device;
			case .VK_QCOM_filter_cubic_clamp: return .Device;
			case .VK_EXT_attachment_feedback_loop_dynamic_state: return .Device;
			case .VK_KHR_vertex_attribute_divisor: return .Device;
			case .VK_KHR_load_store_op_none: return .Device;
			case .VK_KHR_shader_float_controls2: return .Device;
			case .VK_MSFT_layered_driver: return .Device;
			case .VK_KHR_index_type_uint8: return .Device;
			case .VK_KHR_line_rasterization: return .Device;
			case .VK_KHR_calibrated_timestamps: return .Device;
			case .VK_KHR_shader_expect_assume: return .Device;
			case .VK_KHR_maintenance6: return .Device;
			case .VK_NV_descriptor_pool_overallocation: return .Device;
			case .VK_NV_display_stereo: return .Instance;
			case .VK_KHR_video_encode_quantization_map: return .Device;
			case .VK_NV_raw_access_chains: return .Device;
			case .VK_KHR_shader_relaxed_extended_instruction: return .Device;
			case .VK_NV_command_buffer_inheritance: return .Device;
			case .VK_KHR_maintenance7: return .Device;
			case .VK_NV_shader_atomic_float16_vector: return .Device;
			case .VK_EXT_shader_replicated_composites: return .Device;
			case .VK_NV_ray_tracing_validation: return .Device;
			case .VK_EXT_device_generated_commands: return .Device;
			case .VK_MESA_image_alignment_control: return .Device;
			case .VK_EXT_depth_clamp_control: return .Device;
			case .VK_HUAWEI_hdr_vivid: return .Device;
			case .VK_NV_cooperative_matrix2: return .Device;
			case .VK_EXT_vertex_attribute_robustness: return .Device;
			}
		}
	}

	public StringView Tag
	{
		get
		{
			switch (this)
			{
			case .VK_KHR_surface: return "KHR";
			case .VK_KHR_swapchain: return "KHR";
			case .VK_KHR_display: return "KHR";
			case .VK_KHR_display_swapchain: return "KHR";
			case .VK_EXT_debug_report: return "GOOGLE";
			case .VK_NV_glsl_shader: return "NV";
			case .VK_EXT_depth_range_unrestricted: return "NV";
			case .VK_KHR_sampler_mirror_clamp_to_edge: return "KHR";
			case .VK_IMG_filter_cubic: return "IMG";
			case .VK_AMD_rasterization_order: return "AMD";
			case .VK_AMD_shader_trinary_minmax: return "AMD";
			case .VK_AMD_shader_explicit_vertex_parameter: return "AMD";
			case .VK_EXT_debug_marker: return "Baldur Karlsson";
			case .VK_KHR_video_queue: return "KHR";
			case .VK_KHR_video_decode_queue: return "KHR";
			case .VK_AMD_gcn_shader: return "AMD";
			case .VK_NV_dedicated_allocation: return "NV";
			case .VK_EXT_transform_feedback: return "NV";
			case .VK_NVX_binary_import: return "NVX";
			case .VK_NVX_image_view_handle: return "NVX";
			case .VK_AMD_draw_indirect_count: return "AMD";
			case .VK_AMD_negative_viewport_height: return "AMD";
			case .VK_AMD_gpu_shader_half_float: return "AMD";
			case .VK_AMD_shader_ballot: return "AMD";
			case .VK_KHR_video_encode_h264: return "KHR";
			case .VK_KHR_video_encode_h265: return "KHR";
			case .VK_KHR_video_decode_h264: return "KHR";
			case .VK_AMD_texture_gather_bias_lod: return "AMD";
			case .VK_AMD_shader_info: return "AMD";
			case .VK_KHR_dynamic_rendering: return "KHR";
			case .VK_AMD_shader_image_load_store_lod: return "AMD";
			case .VK_NV_corner_sampled_image: return "NV";
			case .VK_KHR_multiview: return "KHR";
			case .VK_IMG_format_pvrtc: return "IMG";
			case .VK_NV_external_memory_capabilities: return "NV";
			case .VK_NV_external_memory: return "NV";
			case .VK_KHR_get_physical_device_properties2: return "KHR";
			case .VK_KHR_device_group: return "KHR";
			case .VK_EXT_validation_flags: return "GOOGLE";
			case .VK_KHR_shader_draw_parameters: return "KHR";
			case .VK_EXT_shader_subgroup_ballot: return "NV";
			case .VK_EXT_shader_subgroup_vote: return "NV";
			case .VK_EXT_texture_compression_astc_hdr: return "ARM";
			case .VK_EXT_astc_decode_mode: return "ARM";
			case .VK_EXT_pipeline_robustness: return "IMG";
			case .VK_KHR_maintenance1: return "KHR";
			case .VK_KHR_device_group_creation: return "KHR";
			case .VK_KHR_external_memory_capabilities: return "KHR";
			case .VK_KHR_external_memory: return "KHR";
			case .VK_KHR_external_memory_fd: return "KHR";
			case .VK_KHR_external_semaphore_capabilities: return "KHR";
			case .VK_KHR_external_semaphore: return "KHR";
			case .VK_KHR_external_semaphore_fd: return "KHR";
			case .VK_KHR_push_descriptor: return "KHR";
			case .VK_EXT_conditional_rendering: return "NV";
			case .VK_KHR_shader_float16_int8: return "KHR";
			case .VK_KHR_16bit_storage: return "KHR";
			case .VK_KHR_incremental_present: return "KHR";
			case .VK_KHR_descriptor_update_template: return "KHR";
			case .VK_NV_clip_space_w_scaling: return "NV";
			case .VK_EXT_direct_mode_display: return "NV";
			case .VK_EXT_display_surface_counter: return "NV";
			case .VK_EXT_display_control: return "NV";
			case .VK_GOOGLE_display_timing: return "GOOGLE";
			case .VK_NV_sample_mask_override_coverage: return "NV";
			case .VK_NV_geometry_shader_passthrough: return "NV";
			case .VK_NV_viewport_array2: return "NV";
			case .VK_NVX_multiview_per_view_attributes: return "NVX";
			case .VK_NV_viewport_swizzle: return "NV";
			case .VK_EXT_discard_rectangles: return "NV";
			case .VK_EXT_conservative_rasterization: return "NV";
			case .VK_EXT_depth_clip_enable: return "EXT";
			case .VK_EXT_swapchain_colorspace: return "GOOGLE";
			case .VK_EXT_hdr_metadata: return "GOOGLE";
			case .VK_KHR_imageless_framebuffer: return "KHR";
			case .VK_KHR_create_renderpass2: return "KHR";
			case .VK_IMG_relaxed_line_rasterization: return "IMG";
			case .VK_KHR_shared_presentable_image: return "KHR";
			case .VK_KHR_external_fence_capabilities: return "KHR";
			case .VK_KHR_external_fence: return "KHR";
			case .VK_KHR_external_fence_fd: return "KHR";
			case .VK_KHR_performance_query: return "KHR";
			case .VK_KHR_maintenance2: return "KHR";
			case .VK_KHR_get_surface_capabilities2: return "KHR";
			case .VK_KHR_variable_pointers: return "KHR";
			case .VK_KHR_get_display_properties2: return "KHR";
			case .VK_EXT_external_memory_dma_buf: return "EXT";
			case .VK_EXT_queue_family_foreign: return "EXT";
			case .VK_KHR_dedicated_allocation: return "KHR";
			case .VK_EXT_debug_utils: return "EXT";
			case .VK_EXT_sampler_filter_minmax: return "NV";
			case .VK_KHR_storage_buffer_storage_class: return "KHR";
			case .VK_AMD_gpu_shader_int16: return "AMD";
			case .VK_AMD_mixed_attachment_samples: return "AMD";
			case .VK_AMD_shader_fragment_mask: return "AMD";
			case .VK_EXT_inline_uniform_block: return "EXT";
			case .VK_EXT_shader_stencil_export: return "EXT";
			case .VK_EXT_sample_locations: return "AMD";
			case .VK_KHR_relaxed_block_layout: return "KHR";
			case .VK_KHR_get_memory_requirements2: return "KHR";
			case .VK_KHR_image_format_list: return "KHR";
			case .VK_EXT_blend_operation_advanced: return "NV";
			case .VK_NV_fragment_coverage_to_color: return "NV";
			case .VK_KHR_acceleration_structure: return "KHR";
			case .VK_KHR_ray_tracing_pipeline: return "KHR";
			case .VK_KHR_ray_query: return "KHR";
			case .VK_NV_framebuffer_mixed_samples: return "NV";
			case .VK_NV_fill_rectangle: return "NV";
			case .VK_NV_shader_sm_builtins: return "NV";
			case .VK_EXT_post_depth_coverage: return "NV";
			case .VK_KHR_sampler_ycbcr_conversion: return "KHR";
			case .VK_KHR_bind_memory2: return "KHR";
			case .VK_EXT_image_drm_format_modifier: return "EXT";
			case .VK_EXT_validation_cache: return "GOOGLE";
			case .VK_EXT_descriptor_indexing: return "NV";
			case .VK_EXT_shader_viewport_index_layer: return "NV";
			case .VK_NV_shading_rate_image: return "NV";
			case .VK_NV_ray_tracing: return "NV";
			case .VK_NV_representative_fragment_test: return "NV";
			case .VK_KHR_maintenance3: return "KHR";
			case .VK_KHR_draw_indirect_count: return "KHR";
			case .VK_EXT_filter_cubic: return "QCOM";
			case .VK_QCOM_render_pass_shader_resolve: return "QCOM";
			case .VK_EXT_global_priority: return "EXT";
			case .VK_KHR_shader_subgroup_extended_types: return "KHR";
			case .VK_KHR_8bit_storage: return "KHR";
			case .VK_EXT_external_memory_host: return "EXT";
			case .VK_AMD_buffer_marker: return "AMD";
			case .VK_KHR_shader_atomic_int64: return "KHR";
			case .VK_KHR_shader_clock: return "KHR";
			case .VK_AMD_pipeline_compiler_control: return "AMD";
			case .VK_EXT_calibrated_timestamps: return "EXT";
			case .VK_AMD_shader_core_properties: return "AMD";
			case .VK_KHR_video_decode_h265: return "KHR";
			case .VK_KHR_global_priority: return "KHR";
			case .VK_AMD_memory_overallocation_behavior: return "AMD";
			case .VK_EXT_vertex_attribute_divisor: return "NV";
			case .VK_EXT_pipeline_creation_feedback: return "GOOGLE";
			case .VK_KHR_driver_properties: return "KHR";
			case .VK_KHR_shader_float_controls: return "KHR";
			case .VK_NV_shader_subgroup_partitioned: return "NV";
			case .VK_KHR_depth_stencil_resolve: return "KHR";
			case .VK_KHR_swapchain_mutable_format: return "KHR";
			case .VK_NV_compute_shader_derivatives: return "NV";
			case .VK_NV_mesh_shader: return "NV";
			case .VK_NV_fragment_shader_barycentric: return "NV";
			case .VK_NV_shader_image_footprint: return "NV";
			case .VK_NV_scissor_exclusive: return "NV";
			case .VK_NV_device_diagnostic_checkpoints: return "NVIDIA";
			case .VK_KHR_timeline_semaphore: return "KHR";
			case .VK_INTEL_shader_integer_functions2: return "INTEL";
			case .VK_INTEL_performance_query: return "INTEL";
			case .VK_KHR_vulkan_memory_model: return "KHR";
			case .VK_EXT_pci_bus_info: return "EXT";
			case .VK_AMD_display_native_hdr: return "AMD";
			case .VK_KHR_shader_terminate_invocation: return "KHR";
			case .VK_EXT_fragment_density_map: return "EXT";
			case .VK_EXT_scalar_block_layout: return "EXT";
			case .VK_GOOGLE_hlsl_functionality1: return "GOOGLE";
			case .VK_GOOGLE_decorate_string: return "GOOGLE";
			case .VK_EXT_subgroup_size_control: return "EXT";
			case .VK_KHR_fragment_shading_rate: return "KHR";
			case .VK_AMD_shader_core_properties2: return "AMD";
			case .VK_AMD_device_coherent_memory: return "AMD";
			case .VK_KHR_dynamic_rendering_local_read: return "AMD";
			case .VK_EXT_shader_image_atomic_int64: return "EXT";
			case .VK_KHR_shader_quad_control: return "KHR";
			case .VK_KHR_spirv_1_4: return "KHR";
			case .VK_EXT_memory_budget: return "EXT";
			case .VK_EXT_memory_priority: return "EXT";
			case .VK_KHR_surface_protected_capabilities: return "KHR";
			case .VK_NV_dedicated_allocation_image_aliasing: return "NVIDIA";
			case .VK_KHR_separate_depth_stencil_layouts: return "KHR";
			case .VK_EXT_buffer_device_address: return "NV";
			case .VK_EXT_tooling_info: return "EXT";
			case .VK_EXT_separate_stencil_usage: return "EXT";
			case .VK_EXT_validation_features: return "LUNARG";
			case .VK_KHR_present_wait: return "KHR";
			case .VK_NV_cooperative_matrix: return "NV";
			case .VK_NV_coverage_reduction_mode: return "NV";
			case .VK_EXT_fragment_shader_interlock: return "EXT";
			case .VK_EXT_ycbcr_image_arrays: return "EXT";
			case .VK_KHR_uniform_buffer_standard_layout: return "KHR";
			case .VK_EXT_provoking_vertex: return "EXT";
			case .VK_EXT_headless_surface: return "EXT";
			case .VK_KHR_buffer_device_address: return "KHR";
			case .VK_EXT_line_rasterization: return "EXT";
			case .VK_EXT_shader_atomic_float: return "NV";
			case .VK_EXT_host_query_reset: return "EXT";
			case .VK_EXT_index_type_uint8: return "EXT";
			case .VK_EXT_extended_dynamic_state: return "EXT";
			case .VK_KHR_deferred_host_operations: return "KHR";
			case .VK_KHR_pipeline_executable_properties: return "KHR";
			case .VK_EXT_host_image_copy: return "EXT";
			case .VK_KHR_map_memory2: return "KHR";
			case .VK_EXT_map_memory_placed: return "EXT";
			case .VK_EXT_shader_atomic_float2: return "EXT";
			case .VK_EXT_surface_maintenance1: return "EXT";
			case .VK_EXT_swapchain_maintenance1: return "EXT";
			case .VK_EXT_shader_demote_to_helper_invocation: return "EXT";
			case .VK_NV_device_generated_commands: return "NV";
			case .VK_NV_inherited_viewport_scissor: return "NV";
			case .VK_KHR_shader_integer_dot_product: return "KHR";
			case .VK_EXT_texel_buffer_alignment: return "EXT";
			case .VK_QCOM_render_pass_transform: return "QCOM";
			case .VK_EXT_depth_bias_control: return "EXT";
			case .VK_EXT_device_memory_report: return "EXT";
			case .VK_EXT_acquire_drm_display: return "EXT";
			case .VK_EXT_robustness2: return "EXT";
			case .VK_EXT_custom_border_color: return "EXT";
			case .VK_GOOGLE_user_type: return "GOOGLE";
			case .VK_KHR_pipeline_library: return "KHR";
			case .VK_NV_present_barrier: return "NV";
			case .VK_KHR_shader_non_semantic_info: return "KHR";
			case .VK_KHR_present_id: return "KHR";
			case .VK_EXT_private_data: return "NV";
			case .VK_EXT_pipeline_creation_cache_control: return "AMD";
			case .VK_KHR_video_encode_queue: return "KHR";
			case .VK_NV_device_diagnostics_config: return "NV";
			case .VK_QCOM_render_pass_store_ops: return "QCOM";
			case .VK_NV_cuda_kernel_launch: return "NV";
			case .VK_NV_low_latency: return "NV";
			case .VK_KHR_synchronization2: return "KHR";
			case .VK_EXT_descriptor_buffer: return "EXT";
			case .VK_EXT_graphics_pipeline_library: return "AMD";
			case .VK_AMD_shader_early_and_late_fragment_tests: return "EXT";
			case .VK_KHR_fragment_shader_barycentric: return "KHR";
			case .VK_KHR_shader_subgroup_uniform_control_flow: return "KHR";
			case .VK_KHR_zero_initialize_workgroup_memory: return "KHR";
			case .VK_NV_fragment_shading_rate_enums: return "NV";
			case .VK_NV_ray_tracing_motion_blur: return "NV";
			case .VK_EXT_mesh_shader: return "EXT";
			case .VK_EXT_ycbcr_2plane_444_formats: return "EXT";
			case .VK_EXT_fragment_density_map2: return "EXT";
			case .VK_QCOM_rotated_copy_commands: return "QCOM";
			case .VK_EXT_image_robustness: return "EXT";
			case .VK_KHR_workgroup_memory_explicit_layout: return "KHR";
			case .VK_KHR_copy_commands2: return "KHR";
			case .VK_EXT_image_compression_control: return "EXT";
			case .VK_EXT_attachment_feedback_loop_layout: return "EXT";
			case .VK_EXT_4444_formats: return "EXT";
			case .VK_EXT_device_fault: return "EXT";
			case .VK_ARM_rasterization_order_attachment_access: return "ARM";
			case .VK_EXT_rgba10x6_formats: return "EXT";
			case .VK_VALVE_mutable_descriptor_type: return "VALVE";
			case .VK_EXT_vertex_input_dynamic_state: return "EXT";
			case .VK_EXT_physical_device_drm: return "EXT";
			case .VK_EXT_device_address_binding_report: return "EXT";
			case .VK_EXT_depth_clip_control: return "EXT";
			case .VK_EXT_primitive_topology_list_restart: return "EXT";
			case .VK_KHR_format_feature_flags2: return "KHR";
			case .VK_EXT_present_mode_fifo_latest_ready: return "EXT";
			case .VK_HUAWEI_subpass_shading: return "HUAWEI";
			case .VK_HUAWEI_invocation_mask: return "Huawei";
			case .VK_NV_external_memory_rdma: return "NV";
			case .VK_EXT_pipeline_properties: return "EXT";
			case .VK_EXT_frame_boundary: return "EXT";
			case .VK_EXT_multisampled_render_to_single_sampled: return "EXT";
			case .VK_EXT_extended_dynamic_state2: return "EXT";
			case .VK_EXT_color_write_enable: return "EXT";
			case .VK_EXT_primitives_generated_query: return "EXT";
			case .VK_KHR_ray_tracing_maintenance1: return "KHR";
			case .VK_EXT_global_priority_query: return "EXT";
			case .VK_EXT_image_view_min_lod: return "EXT";
			case .VK_EXT_multi_draw: return "EXT";
			case .VK_EXT_image_2d_view_of_3d: return "EXT";
			case .VK_KHR_portability_enumeration: return "KHR";
			case .VK_EXT_shader_tile_image: return "EXT";
			case .VK_EXT_opacity_micromap: return "EXT";
			case .VK_EXT_load_store_op_none: return "EXT";
			case .VK_HUAWEI_cluster_culling_shader: return "HUAWEI";
			case .VK_EXT_border_color_swizzle: return "EXT";
			case .VK_EXT_pageable_device_local_memory: return "EXT";
			case .VK_KHR_maintenance4: return "KHR";
			case .VK_ARM_shader_core_properties: return "ARM";
			case .VK_KHR_shader_subgroup_rotate: return "KHR";
			case .VK_ARM_scheduling_controls: return "ARM";
			case .VK_EXT_image_sliced_view_of_3d: return "EXT";
			case .VK_VALVE_descriptor_set_host_mapping: return "VALVE";
			case .VK_EXT_depth_clamp_zero_one: return "EXT";
			case .VK_EXT_non_seamless_cube_map: return "EXT";
			case .VK_ARM_render_pass_striped: return "ARM";
			case .VK_QCOM_fragment_density_map_offset: return "QCOM";
			case .VK_NV_copy_memory_indirect: return "NV";
			case .VK_NV_memory_decompression: return "NV";
			case .VK_NV_device_generated_commands_compute: return "NV";
			case .VK_NV_linear_color_attachment: return "NVIDIA";
			case .VK_GOOGLE_surfaceless_query: return "GOOGLE";
			case .VK_KHR_shader_maximal_reconvergence: return "KHR";
			case .VK_EXT_image_compression_control_swapchain: return "EXT";
			case .VK_QCOM_image_processing: return "QCOM";
			case .VK_EXT_nested_command_buffer: return "EXT";
			case .VK_EXT_external_memory_acquire_unmodified: return "EXT";
			case .VK_EXT_extended_dynamic_state3: return "NV";
			case .VK_EXT_subpass_merge_feedback: return "EXT";
			case .VK_LUNARG_direct_driver_loading: return "LUNARG";
			case .VK_EXT_shader_module_identifier: return "EXT";
			case .VK_EXT_rasterization_order_attachment_access: return "ARM";
			case .VK_NV_optical_flow: return "NV";
			case .VK_EXT_legacy_dithering: return "EXT";
			case .VK_EXT_pipeline_protected_access: return "EXT";
			case .VK_KHR_maintenance5: return "KHR";
			case .VK_AMD_anti_lag: return "AMD";
			case .VK_KHR_ray_tracing_position_fetch: return "KHR";
			case .VK_EXT_shader_object: return "EXT";
			case .VK_KHR_pipeline_binary: return "KHR";
			case .VK_QCOM_tile_properties: return "QCOM";
			case .VK_SEC_amigo_profiling: return "SEC";
			case .VK_QCOM_multiview_per_view_viewports: return "QCOM";
			case .VK_NV_ray_tracing_invocation_reorder: return "NV";
			case .VK_NV_extended_sparse_address_space: return "NV";
			case .VK_EXT_mutable_descriptor_type: return "EXT";
			case .VK_EXT_legacy_vertex_attributes: return "EXT";
			case .VK_EXT_layer_settings: return "EXT";
			case .VK_ARM_shader_core_builtins: return "ARM";
			case .VK_EXT_pipeline_library_group_handles: return "EXT";
			case .VK_EXT_dynamic_rendering_unused_attachments: return "EXT";
			case .VK_NV_low_latency2: return "NV";
			case .VK_KHR_cooperative_matrix: return "KHR";
			case .VK_QCOM_multiview_per_view_render_areas: return "QCOM";
			case .VK_KHR_compute_shader_derivatives: return "KHR";
			case .VK_KHR_video_decode_av1: return "KHR";
			case .VK_KHR_video_encode_av1: return "KHR";
			case .VK_KHR_video_maintenance1: return "KHR";
			case .VK_NV_per_stage_descriptor_set: return "NV";
			case .VK_QCOM_image_processing2: return "QCOM";
			case .VK_QCOM_filter_cubic_weights: return "QCOM";
			case .VK_QCOM_ycbcr_degamma: return "QCOM";
			case .VK_QCOM_filter_cubic_clamp: return "QCOM";
			case .VK_EXT_attachment_feedback_loop_dynamic_state: return "EXT";
			case .VK_KHR_vertex_attribute_divisor: return "KHR";
			case .VK_KHR_load_store_op_none: return "KHR";
			case .VK_KHR_shader_float_controls2: return "KHR";
			case .VK_MSFT_layered_driver: return "MSFT";
			case .VK_KHR_index_type_uint8: return "KHR";
			case .VK_KHR_line_rasterization: return "KHR";
			case .VK_KHR_calibrated_timestamps: return "KHR";
			case .VK_KHR_shader_expect_assume: return "KHR";
			case .VK_KHR_maintenance6: return "KHR";
			case .VK_NV_descriptor_pool_overallocation: return "NV";
			case .VK_NV_display_stereo: return "NV";
			case .VK_KHR_video_encode_quantization_map: return "KHR";
			case .VK_NV_raw_access_chains: return "NV";
			case .VK_KHR_shader_relaxed_extended_instruction: return "KHR";
			case .VK_NV_command_buffer_inheritance: return "NV";
			case .VK_KHR_maintenance7: return "KHR";
			case .VK_NV_shader_atomic_float16_vector: return "NV";
			case .VK_EXT_shader_replicated_composites: return "EXT";
			case .VK_NV_ray_tracing_validation: return "NV";
			case .VK_EXT_device_generated_commands: return "EXT";
			case .VK_MESA_image_alignment_control: return "MESA";
			case .VK_EXT_depth_clamp_control: return "EXT";
			case .VK_HUAWEI_hdr_vivid: return "HUAWEI";
			case .VK_NV_cooperative_matrix2: return "NV";
			case .VK_EXT_vertex_attribute_robustness: return "EXT";
			}
		}
	}

	public VulkanFeature? PromotedTo
	{
		get
		{
			switch (this)
			{
			case .VK_KHR_sampler_mirror_clamp_to_edge: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_EXT_debug_marker: return VulkanFeature.Extension(.VK_EXT_debug_utils);
			case .VK_AMD_draw_indirect_count: return VulkanFeature.Extension(.VK_KHR_draw_indirect_count);
			case .VK_KHR_dynamic_rendering: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_KHR_multiview: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_get_physical_device_properties2: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_device_group: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_shader_draw_parameters: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_EXT_shader_subgroup_ballot: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_EXT_shader_subgroup_vote: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_EXT_texture_compression_astc_hdr: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_EXT_pipeline_robustness: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_KHR_maintenance1: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_device_group_creation: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_external_memory_capabilities: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_external_memory: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_external_semaphore_capabilities: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_external_semaphore: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_push_descriptor: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_KHR_shader_float16_int8: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_16bit_storage: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_descriptor_update_template: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_imageless_framebuffer: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_create_renderpass2: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_external_fence_capabilities: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_external_fence: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_maintenance2: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_variable_pointers: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_dedicated_allocation: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_EXT_sampler_filter_minmax: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_storage_buffer_storage_class: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_EXT_inline_uniform_block: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_KHR_relaxed_block_layout: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_get_memory_requirements2: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_image_format_list: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_sampler_ycbcr_conversion: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_bind_memory2: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_EXT_descriptor_indexing: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_EXT_shader_viewport_index_layer: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_maintenance3: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case .VK_KHR_draw_indirect_count: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_EXT_global_priority: return VulkanFeature.Extension(.VK_KHR_global_priority);
			case .VK_KHR_shader_subgroup_extended_types: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_8bit_storage: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_shader_atomic_int64: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_EXT_calibrated_timestamps: return VulkanFeature.Extension(.VK_KHR_calibrated_timestamps);
			case .VK_KHR_global_priority: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_EXT_vertex_attribute_divisor: return VulkanFeature.Extension(.VK_KHR_vertex_attribute_divisor);
			case .VK_EXT_pipeline_creation_feedback: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_KHR_driver_properties: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_shader_float_controls: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_depth_stencil_resolve: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_NV_compute_shader_derivatives: return VulkanFeature.Extension(.VK_KHR_compute_shader_derivatives);
			case .VK_NV_fragment_shader_barycentric: return VulkanFeature.Extension(.VK_KHR_fragment_shader_barycentric);
			case .VK_KHR_timeline_semaphore: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_vulkan_memory_model: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_shader_terminate_invocation: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_EXT_scalar_block_layout: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_EXT_subgroup_size_control: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_KHR_dynamic_rendering_local_read: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_KHR_spirv_1_4: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_separate_depth_stencil_layouts: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_EXT_tooling_info: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_EXT_separate_stencil_usage: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_uniform_buffer_standard_layout: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_KHR_buffer_device_address: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_EXT_line_rasterization: return VulkanFeature.Extension(.VK_KHR_line_rasterization);
			case .VK_EXT_host_query_reset: return VulkanFeature.ApiVersion(.VK_VERSION_1_2);
			case .VK_EXT_index_type_uint8: return VulkanFeature.Extension(.VK_KHR_index_type_uint8);
			case .VK_EXT_extended_dynamic_state: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_EXT_host_image_copy: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_KHR_map_memory2: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_EXT_shader_demote_to_helper_invocation: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_KHR_shader_integer_dot_product: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_EXT_texel_buffer_alignment: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_KHR_shader_non_semantic_info: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_EXT_private_data: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_EXT_pipeline_creation_cache_control: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_KHR_synchronization2: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_KHR_zero_initialize_workgroup_memory: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_EXT_ycbcr_2plane_444_formats: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_EXT_image_robustness: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_KHR_copy_commands2: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_EXT_4444_formats: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_ARM_rasterization_order_attachment_access: return VulkanFeature.Extension(.VK_EXT_rasterization_order_attachment_access);
			case .VK_VALVE_mutable_descriptor_type: return VulkanFeature.Extension(.VK_EXT_mutable_descriptor_type);
			case .VK_KHR_format_feature_flags2: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_EXT_extended_dynamic_state2: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_EXT_global_priority_query: return VulkanFeature.Extension(.VK_KHR_global_priority);
			case .VK_EXT_load_store_op_none: return VulkanFeature.Extension(.VK_KHR_load_store_op_none);
			case .VK_KHR_maintenance4: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			case .VK_KHR_shader_subgroup_rotate: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_EXT_pipeline_protected_access: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_KHR_maintenance5: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_KHR_vertex_attribute_divisor: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_KHR_load_store_op_none: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_KHR_shader_float_controls2: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_KHR_index_type_uint8: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_KHR_line_rasterization: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_KHR_shader_expect_assume: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			case .VK_KHR_maintenance6: return VulkanFeature.ApiVersion(.VK_VERSION_1_4);
			default: return null;
			}
		}
	}

	public VulkanExtension? DeprecatedBy
	{
		get
		{
			switch (this)
			{
			case .VK_EXT_debug_report: return VK_EXT_debug_utils;
			case .VK_NV_dedicated_allocation: return VK_KHR_dedicated_allocation;
			case .VK_AMD_negative_viewport_height: return VK_KHR_maintenance1;
			case .VK_AMD_gpu_shader_half_float: return VK_KHR_shader_float16_int8;
			case .VK_NV_external_memory_capabilities: return VK_KHR_external_memory_capabilities;
			case .VK_NV_external_memory: return VK_KHR_external_memory;
			case .VK_EXT_validation_flags: return VK_EXT_layer_settings;
			case .VK_AMD_gpu_shader_int16: return VK_KHR_shader_float16_int8;
			case .VK_NV_ray_tracing: return VK_KHR_ray_tracing_pipeline;
			case .VK_EXT_buffer_device_address: return VK_KHR_buffer_device_address;
			case .VK_EXT_validation_features: return VK_EXT_layer_settings;
			default: return null;
			}
		}
	}

	public StringView SpirVExtension
	{
		get
		{
			switch (this)
			{
			case .VK_AMD_shader_trinary_minmax: return "SPV_AMD_shader_trinary_minmax";
			case .VK_AMD_shader_explicit_vertex_parameter: return "SPV_AMD_shader_explicit_vertex_parameter";
			case .VK_AMD_gcn_shader: return "SPV_AMD_gcn_shader";
			case .VK_AMD_gpu_shader_half_float: return "SPV_AMD_gpu_shader_half_float";
			case .VK_AMD_shader_ballot: return "SPV_AMD_shader_ballot";
			case .VK_AMD_texture_gather_bias_lod: return "SPV_AMD_texture_gather_bias_lod";
			case .VK_AMD_shader_image_load_store_lod: return "SPV_AMD_shader_image_load_store_lod";
			case .VK_KHR_multiview: return "SPV_KHR_multiview";
			case .VK_KHR_device_group: return "SPV_KHR_device_group";
			case .VK_KHR_shader_draw_parameters: return "SPV_KHR_shader_draw_parameters";
			case .VK_EXT_shader_subgroup_ballot: return "SPV_KHR_shader_ballot";
			case .VK_EXT_shader_subgroup_vote: return "SPV_KHR_subgroup_vote";
			case .VK_KHR_16bit_storage: return "SPV_KHR_16bit_storage";
			case .VK_NV_sample_mask_override_coverage: return "SPV_NV_sample_mask_override_coverage";
			case .VK_NV_geometry_shader_passthrough: return "SPV_NV_geometry_shader_passthrough";
			case .VK_NV_viewport_array2: return "SPV_NV_viewport_array2";
			case .VK_NVX_multiview_per_view_attributes: return "SPV_NVX_multiview_per_view_attributes";
			case .VK_EXT_conservative_rasterization: return "SPV_EXT_fragment_fully_covered";
			case .VK_KHR_variable_pointers: return "SPV_KHR_variable_pointers";
			case .VK_KHR_storage_buffer_storage_class: return "SPV_KHR_storage_buffer_storage_class";
			case .VK_AMD_gpu_shader_int16: return "SPV_AMD_gpu_shader_int16";
			case .VK_AMD_shader_fragment_mask: return "SPV_AMD_shader_fragment_mask";
			case .VK_EXT_shader_stencil_export: return "SPV_EXT_shader_stencil_export";
			case .VK_KHR_ray_tracing_pipeline: return "SPV_KHR_ray_tracing";
			case .VK_KHR_ray_query: return "SPV_KHR_ray_query";
			case .VK_NV_shader_sm_builtins: return "SPV_NV_shader_sm_builtins";
			case .VK_EXT_post_depth_coverage: return "SPV_KHR_post_depth_coverage";
			case .VK_EXT_descriptor_indexing: return "SPV_EXT_descriptor_indexing";
			case .VK_EXT_shader_viewport_index_layer: return "SPV_EXT_shader_viewport_index_layer";
			case .VK_NV_shading_rate_image: return "SPV_NV_shading_rate";
			case .VK_NV_ray_tracing: return "SPV_NV_ray_tracing";
			case .VK_KHR_8bit_storage: return "SPV_KHR_8bit_storage";
			case .VK_KHR_shader_clock: return "SPV_KHR_shader_clock";
			case .VK_KHR_shader_float_controls: return "SPV_KHR_float_controls";
			case .VK_NV_shader_subgroup_partitioned: return "SPV_NV_shader_subgroup_partitioned";
			case .VK_NV_compute_shader_derivatives: return "SPV_NV_compute_shader_derivatives";
			case .VK_NV_mesh_shader: return "SPV_NV_mesh_shader";
			case .VK_NV_fragment_shader_barycentric: return "SPV_NV_fragment_shader_barycentric";
			case .VK_NV_shader_image_footprint: return "SPV_NV_shader_image_footprint";
			case .VK_INTEL_shader_integer_functions2: return "SPV_INTEL_shader_integer_functions2";
			case .VK_KHR_vulkan_memory_model: return "SPV_KHR_vulkan_memory_model";
			case .VK_KHR_shader_terminate_invocation: return "SPV_KHR_terminate_invocation";
			case .VK_EXT_fragment_density_map: return "SPV_EXT_fragment_invocation_density";
			case .VK_GOOGLE_hlsl_functionality1: return "SPV_GOOGLE_hlsl_functionality1";
			case .VK_GOOGLE_decorate_string: return "SPV_GOOGLE_decorate_string";
			case .VK_KHR_fragment_shading_rate: return "SPV_KHR_fragment_shading_rate";
			case .VK_EXT_shader_image_atomic_int64: return "SPV_EXT_shader_image_int64";
			case .VK_KHR_shader_quad_control: return "SPV_KHR_quad_control";
			case .VK_EXT_buffer_device_address: return "SPV_EXT_physical_storage_buffer";
			case .VK_NV_cooperative_matrix: return "SPV_NV_cooperative_matrix";
			case .VK_EXT_fragment_shader_interlock: return "SPV_EXT_fragment_shader_interlock";
			case .VK_KHR_buffer_device_address: return "SPV_KHR_physical_storage_buffer";
			case .VK_EXT_shader_atomic_float: return "SPV_EXT_shader_atomic_float_add";
			case .VK_EXT_shader_atomic_float2: return "SPV_EXT_shader_atomic_float16_add";
			case .VK_EXT_shader_demote_to_helper_invocation: return "SPV_EXT_demote_to_helper_invocation";
			case .VK_KHR_shader_integer_dot_product: return "SPV_KHR_integer_dot_product";
			case .VK_GOOGLE_user_type: return "SPV_GOOGLE_user_type";
			case .VK_KHR_shader_non_semantic_info: return "SPV_KHR_non_semantic_info";
			case .VK_AMD_shader_early_and_late_fragment_tests: return "SPV_AMD_shader_early_and_late_fragment_tests";
			case .VK_KHR_fragment_shader_barycentric: return "SPV_KHR_fragment_shader_barycentric";
			case .VK_KHR_shader_subgroup_uniform_control_flow: return "SPV_KHR_subgroup_uniform_control_flow";
			case .VK_NV_ray_tracing_motion_blur: return "SPV_NV_ray_tracing_motion_blur";
			case .VK_EXT_mesh_shader: return "SPV_EXT_mesh_shader";
			case .VK_KHR_workgroup_memory_explicit_layout: return "SPV_KHR_workgroup_memory_explicit_layout";
			case .VK_HUAWEI_subpass_shading: return "SPV_HUAWEI_subpass_shading";
			case .VK_KHR_ray_tracing_maintenance1: return "SPV_KHR_ray_cull_mask";
			case .VK_EXT_shader_tile_image: return "SPV_EXT_shader_tile_image";
			case .VK_EXT_opacity_micromap: return "SPV_EXT_opacity_micromap";
			case .VK_HUAWEI_cluster_culling_shader: return "SPV_HUAWEI_cluster_culling_shader";
			case .VK_KHR_shader_subgroup_rotate: return "SPV_KHR_subgroup_rotate";
			case .VK_KHR_shader_maximal_reconvergence: return "SPV_KHR_maximal_reconvergence";
			case .VK_QCOM_image_processing: return "SPV_QCOM_image_processing";
			case .VK_KHR_ray_tracing_position_fetch: return "SPV_KHR_ray_tracing_position_fetch";
			case .VK_NV_ray_tracing_invocation_reorder: return "SPV_NV_shader_invocation_reorder";
			case .VK_ARM_shader_core_builtins: return "SPV_ARM_core_builtins";
			case .VK_KHR_cooperative_matrix: return "SPV_KHR_cooperative_matrix";
			case .VK_KHR_compute_shader_derivatives: return "SPV_KHR_compute_shader_derivatives";
			case .VK_QCOM_image_processing2: return "SPV_QCOM_image_processing2";
			case .VK_KHR_shader_float_controls2: return "SPV_KHR_float_controls2";
			case .VK_KHR_shader_expect_assume: return "SPV_KHR_expect_assume";
			case .VK_NV_raw_access_chains: return "SPV_NV_raw_access_chains";
			case .VK_KHR_shader_relaxed_extended_instruction: return "SPV_KHR_relaxed_extended_instruction";
			case .VK_NV_shader_atomic_float16_vector: return "SPV_NV_shader_atomic_fp16_vector";
			case .VK_EXT_shader_replicated_composites: return "SPV_EXT_replicated_composites";
			case .VK_NV_cooperative_matrix2: return "SPV_NV_tensor_addressing";
			default: return null;
			}
		}
	}

	public static Self? GetRequiredVulkanExtensionForSpirV(StringView spirvExtension)
	{
		switch (spirvExtension.GetHashCode())
		{
		case 3756332955175665402 when spirvExtension == "SPV_AMD_shader_trinary_minmax": return VK_AMD_shader_trinary_minmax;
		case -4891408983697502087 when spirvExtension == "SPV_AMD_shader_explicit_vertex_parameter": return VK_AMD_shader_explicit_vertex_parameter;
		case 6550886093993416957 when spirvExtension == "SPV_AMD_gcn_shader": return VK_AMD_gcn_shader;
		case -2916850308841686463 when spirvExtension == "SPV_AMD_gpu_shader_half_float": return VK_AMD_gpu_shader_half_float;
		case -8074763835126897641 when spirvExtension == "SPV_AMD_shader_ballot": return VK_AMD_shader_ballot;
		case -7577810065236501415 when spirvExtension == "SPV_AMD_texture_gather_bias_lod": return VK_AMD_texture_gather_bias_lod;
		case -2949652960762591208 when spirvExtension == "SPV_AMD_shader_image_load_store_lod": return VK_AMD_shader_image_load_store_lod;
		case -1141099449012430311 when spirvExtension == "SPV_KHR_multiview": return VK_KHR_multiview;
		case -200167011645988128 when spirvExtension == "SPV_KHR_device_group": return VK_KHR_device_group;
		case 6291206114759454950 when spirvExtension == "SPV_KHR_shader_draw_parameters": return VK_KHR_shader_draw_parameters;
		case -132682144415276009 when spirvExtension == "SPV_KHR_shader_ballot": return VK_EXT_shader_subgroup_ballot;
		case -938160122051146569 when spirvExtension == "SPV_KHR_subgroup_vote": return VK_EXT_shader_subgroup_vote;
		case 2301540414108688213 when spirvExtension == "SPV_KHR_16bit_storage": return VK_KHR_16bit_storage;
		case -5929783114448200405 when spirvExtension == "SPV_NV_sample_mask_override_coverage": return VK_NV_sample_mask_override_coverage;
		case 6813397465387368243 when spirvExtension == "SPV_NV_geometry_shader_passthrough": return VK_NV_geometry_shader_passthrough;
		case -1608739964102583933 when spirvExtension == "SPV_NV_viewport_array2": return VK_NV_viewport_array2;
		case -5032540960600248639 when spirvExtension == "SPV_NVX_multiview_per_view_attributes": return VK_NVX_multiview_per_view_attributes;
		case -7535895524081372325 when spirvExtension == "SPV_EXT_fragment_fully_covered": return VK_EXT_conservative_rasterization;
		case -7737067537225194459 when spirvExtension == "SPV_KHR_variable_pointers": return VK_KHR_variable_pointers;
		case 7425979768969522084 when spirvExtension == "SPV_KHR_storage_buffer_storage_class": return VK_KHR_storage_buffer_storage_class;
		case -1330403930211020129 when spirvExtension == "SPV_AMD_gpu_shader_int16": return VK_AMD_gpu_shader_int16;
		case 1800713547621171110 when spirvExtension == "SPV_AMD_shader_fragment_mask": return VK_AMD_shader_fragment_mask;
		case 8142135915646196216 when spirvExtension == "SPV_EXT_shader_stencil_export": return VK_EXT_shader_stencil_export;
		case -6418196440321592522 when spirvExtension == "SPV_KHR_ray_tracing": return VK_KHR_ray_tracing_pipeline;
		case 6678244492218520214 when spirvExtension == "SPV_KHR_ray_query": return VK_KHR_ray_query;
		case 6178148494314338521 when spirvExtension == "SPV_NV_shader_sm_builtins": return VK_NV_shader_sm_builtins;
		case 5561097125826012292 when spirvExtension == "SPV_KHR_post_depth_coverage": return VK_EXT_post_depth_coverage;
		case -5627259374114843983 when spirvExtension == "SPV_EXT_descriptor_indexing": return VK_EXT_descriptor_indexing;
		case -3136246235098502995 when spirvExtension == "SPV_EXT_shader_viewport_index_layer": return VK_EXT_shader_viewport_index_layer;
		case 4242374404006328284 when spirvExtension == "SPV_NV_shading_rate": return VK_NV_shading_rate_image;
		case -3800648774650332805 when spirvExtension == "SPV_NV_ray_tracing": return VK_NV_ray_tracing;
		case 360424069223792820 when spirvExtension == "SPV_KHR_8bit_storage": return VK_KHR_8bit_storage;
		case -5134315876976594071 when spirvExtension == "SPV_KHR_shader_clock": return VK_KHR_shader_clock;
		case -2819723172347585634 when spirvExtension == "SPV_KHR_float_controls": return VK_KHR_shader_float_controls;
		case 558440027508714089 when spirvExtension == "SPV_NV_shader_subgroup_partitioned": return VK_NV_shader_subgroup_partitioned;
		case 1751895923090470334 when spirvExtension == "SPV_NV_compute_shader_derivatives": return VK_NV_compute_shader_derivatives;
		case 2440295911819051263 when spirvExtension == "SPV_NV_mesh_shader": return VK_NV_mesh_shader;
		case -8490892579253498517 when spirvExtension == "SPV_NV_fragment_shader_barycentric": return VK_NV_fragment_shader_barycentric;
		case -7529378136800496753 when spirvExtension == "SPV_NV_shader_image_footprint": return VK_NV_shader_image_footprint;
		case -6734259107514333357 when spirvExtension == "SPV_INTEL_shader_integer_functions2": return VK_INTEL_shader_integer_functions2;
		case -867250645577157749 when spirvExtension == "SPV_KHR_vulkan_memory_model": return VK_KHR_vulkan_memory_model;
		case -2483500102639986011 when spirvExtension == "SPV_KHR_terminate_invocation": return VK_KHR_shader_terminate_invocation;
		case -8320847131486162259 when spirvExtension == "SPV_EXT_fragment_invocation_density": return VK_EXT_fragment_density_map;
		case -3381503166883124794 when spirvExtension == "SPV_GOOGLE_hlsl_functionality1": return VK_GOOGLE_hlsl_functionality1;
		case 922463163697364129 when spirvExtension == "SPV_GOOGLE_decorate_string": return VK_GOOGLE_decorate_string;
		case 4666144235410625925 when spirvExtension == "SPV_KHR_fragment_shading_rate": return VK_KHR_fragment_shading_rate;
		case 7342525768265761679 when spirvExtension == "SPV_EXT_shader_image_int64": return VK_EXT_shader_image_atomic_int64;
		case -4530536774902475925 when spirvExtension == "SPV_KHR_quad_control": return VK_KHR_shader_quad_control;
		case 1618754195958064777 when spirvExtension == "SPV_EXT_physical_storage_buffer": return VK_EXT_buffer_device_address;
		case -7707206431235625682 when spirvExtension == "SPV_NV_cooperative_matrix": return VK_NV_cooperative_matrix;
		case -1667719782684638899 when spirvExtension == "SPV_EXT_fragment_shader_interlock": return VK_EXT_fragment_shader_interlock;
		case -2964085447719852407 when spirvExtension == "SPV_KHR_physical_storage_buffer": return VK_KHR_buffer_device_address;
		case 6902025909341978456 when spirvExtension == "SPV_EXT_shader_atomic_float_add": return VK_EXT_shader_atomic_float;
		case 3529049812729277217 when spirvExtension == "SPV_EXT_shader_atomic_float16_add": return VK_EXT_shader_atomic_float2;
		case -8245522993970170381 when spirvExtension == "SPV_EXT_demote_to_helper_invocation": return VK_EXT_shader_demote_to_helper_invocation;
		case -5919115207591959584 when spirvExtension == "SPV_KHR_integer_dot_product": return VK_KHR_shader_integer_dot_product;
		case 4599950423718421768 when spirvExtension == "SPV_GOOGLE_user_type": return VK_GOOGLE_user_type;
		case -8182227334327661562 when spirvExtension == "SPV_KHR_non_semantic_info": return VK_KHR_shader_non_semantic_info;
		case -2687254198240773469 when spirvExtension == "SPV_AMD_shader_early_and_late_fragment_tests": return VK_AMD_shader_early_and_late_fragment_tests;
		case -6804737987158284922 when spirvExtension == "SPV_KHR_fragment_shader_barycentric": return VK_KHR_fragment_shader_barycentric;
		case 6376106423490267151 when spirvExtension == "SPV_KHR_subgroup_uniform_control_flow": return VK_KHR_shader_subgroup_uniform_control_flow;
		case 5886335017475435254 when spirvExtension == "SPV_NV_ray_tracing_motion_blur": return VK_NV_ray_tracing_motion_blur;
		case 957676047598203801 when spirvExtension == "SPV_EXT_mesh_shader": return VK_EXT_mesh_shader;
		case -2533320792726253832 when spirvExtension == "SPV_KHR_workgroup_memory_explicit_layout": return VK_KHR_workgroup_memory_explicit_layout;
		case -189994866909334631 when spirvExtension == "SPV_HUAWEI_subpass_shading": return VK_HUAWEI_subpass_shading;
		case 5944659086493185110 when spirvExtension == "SPV_KHR_ray_cull_mask": return VK_KHR_ray_tracing_maintenance1;
		case 6565442009520114869 when spirvExtension == "SPV_EXT_shader_tile_image": return VK_EXT_shader_tile_image;
		case 5853447062041999879 when spirvExtension == "SPV_EXT_opacity_micromap": return VK_EXT_opacity_micromap;
		case -1371409709764441838 when spirvExtension == "SPV_HUAWEI_cluster_culling_shader": return VK_HUAWEI_cluster_culling_shader;
		case 2318582324280597719 when spirvExtension == "SPV_KHR_subgroup_rotate": return VK_KHR_shader_subgroup_rotate;
		case -1504433725478369850 when spirvExtension == "SPV_KHR_maximal_reconvergence": return VK_KHR_shader_maximal_reconvergence;
		case -1132285373050108054 when spirvExtension == "SPV_QCOM_image_processing": return VK_QCOM_image_processing;
		case -4977056365570695192 when spirvExtension == "SPV_KHR_ray_tracing_position_fetch": return VK_KHR_ray_tracing_position_fetch;
		case 5280783401519523963 when spirvExtension == "SPV_NV_shader_invocation_reorder": return VK_NV_ray_tracing_invocation_reorder;
		case -6357969829631605625 when spirvExtension == "SPV_ARM_core_builtins": return VK_ARM_shader_core_builtins;
		case 7476455058448592299 when spirvExtension == "SPV_KHR_cooperative_matrix": return VK_KHR_cooperative_matrix;
		case -993891013320677953 when spirvExtension == "SPV_KHR_compute_shader_derivatives": return VK_KHR_compute_shader_derivatives;
		case 1792641582865752982 when spirvExtension == "SPV_QCOM_image_processing2": return VK_QCOM_image_processing2;
		case 4822302025772603874 when spirvExtension == "SPV_KHR_float_controls2": return VK_KHR_shader_float_controls2;
		case -244612085740659871 when spirvExtension == "SPV_KHR_expect_assume": return VK_KHR_shader_expect_assume;
		case 6482087525749357161 when spirvExtension == "SPV_NV_raw_access_chains": return VK_NV_raw_access_chains;
		case -1224030135683479351 when spirvExtension == "SPV_KHR_relaxed_extended_instruction": return VK_KHR_shader_relaxed_extended_instruction;
		case 825034983689393814 when spirvExtension == "SPV_NV_shader_atomic_fp16_vector": return VK_NV_shader_atomic_float16_vector;
		case 3755238009648166387 when spirvExtension == "SPV_EXT_replicated_composites": return VK_EXT_shader_replicated_composites;
		case -5977891045829627448 when spirvExtension == "SPV_NV_tensor_addressing": return VK_NV_cooperative_matrix2;
		default: return null;
		}
	}

	public int DependencyCount
	{
		get
		{
			switch (this)
			{
			case .VK_KHR_swapchain: return 1;
			case .VK_KHR_display: return 1;
			case .VK_KHR_display_swapchain: return 2;
			case .VK_EXT_debug_marker: return 1;
			case .VK_KHR_video_queue: return 2;
			case .VK_KHR_video_decode_queue: return 2;
			case .VK_EXT_transform_feedback: return 1;
			case .VK_KHR_video_encode_h264: return 1;
			case .VK_KHR_video_encode_h265: return 1;
			case .VK_KHR_video_decode_h264: return 1;
			case .VK_AMD_texture_gather_bias_lod: return 1;
			case .VK_KHR_dynamic_rendering: return 2;
			case .VK_NV_corner_sampled_image: return 1;
			case .VK_KHR_multiview: return 1;
			case .VK_NV_external_memory: return 1;
			case .VK_KHR_device_group: return 1;
			case .VK_EXT_texture_compression_astc_hdr: return 1;
			case .VK_EXT_astc_decode_mode: return 1;
			case .VK_EXT_pipeline_robustness: return 1;
			case .VK_KHR_external_memory_capabilities: return 1;
			case .VK_KHR_external_memory: return 1;
			case .VK_KHR_external_memory_fd: return 1;
			case .VK_KHR_external_semaphore_capabilities: return 1;
			case .VK_KHR_external_semaphore: return 1;
			case .VK_KHR_external_semaphore_fd: return 1;
			case .VK_KHR_push_descriptor: return 1;
			case .VK_EXT_conditional_rendering: return 1;
			case .VK_KHR_shader_float16_int8: return 1;
			case .VK_KHR_16bit_storage: return 2;
			case .VK_KHR_incremental_present: return 1;
			case .VK_EXT_direct_mode_display: return 1;
			case .VK_EXT_display_surface_counter: return 1;
			case .VK_EXT_display_control: return 2;
			case .VK_GOOGLE_display_timing: return 1;
			case .VK_NVX_multiview_per_view_attributes: return 1;
			case .VK_EXT_discard_rectangles: return 1;
			case .VK_EXT_conservative_rasterization: return 1;
			case .VK_EXT_depth_clip_enable: return 1;
			case .VK_EXT_swapchain_colorspace: return 1;
			case .VK_EXT_hdr_metadata: return 1;
			case .VK_KHR_imageless_framebuffer: return 3;
			case .VK_KHR_create_renderpass2: return 2;
			case .VK_IMG_relaxed_line_rasterization: return 1;
			case .VK_KHR_shared_presentable_image: return 3;
			case .VK_KHR_external_fence_capabilities: return 1;
			case .VK_KHR_external_fence: return 1;
			case .VK_KHR_external_fence_fd: return 1;
			case .VK_KHR_performance_query: return 1;
			case .VK_KHR_get_surface_capabilities2: return 1;
			case .VK_KHR_variable_pointers: return 2;
			case .VK_KHR_get_display_properties2: return 1;
			case .VK_EXT_external_memory_dma_buf: return 1;
			case .VK_EXT_queue_family_foreign: return 1;
			case .VK_KHR_dedicated_allocation: return 1;
			case .VK_EXT_sampler_filter_minmax: return 1;
			case .VK_EXT_inline_uniform_block: return 2;
			case .VK_EXT_sample_locations: return 1;
			case .VK_EXT_blend_operation_advanced: return 1;
			case .VK_KHR_acceleration_structure: return 4;
			case .VK_KHR_ray_tracing_pipeline: return 2;
			case .VK_KHR_ray_query: return 2;
			case .VK_NV_shader_sm_builtins: return 1;
			case .VK_KHR_sampler_ycbcr_conversion: return 4;
			case .VK_EXT_image_drm_format_modifier: return 4;
			case .VK_EXT_descriptor_indexing: return 2;
			case .VK_NV_shading_rate_image: return 1;
			case .VK_NV_ray_tracing: return 2;
			case .VK_NV_representative_fragment_test: return 1;
			case .VK_KHR_maintenance3: return 1;
			case .VK_KHR_shader_subgroup_extended_types: return 1;
			case .VK_KHR_8bit_storage: return 2;
			case .VK_EXT_external_memory_host: return 1;
			case .VK_KHR_shader_atomic_int64: return 1;
			case .VK_KHR_shader_clock: return 1;
			case .VK_EXT_calibrated_timestamps: return 1;
			case .VK_AMD_shader_core_properties: return 1;
			case .VK_KHR_video_decode_h265: return 1;
			case .VK_KHR_global_priority: return 1;
			case .VK_EXT_vertex_attribute_divisor: return 1;
			case .VK_KHR_driver_properties: return 1;
			case .VK_KHR_shader_float_controls: return 1;
			case .VK_NV_shader_subgroup_partitioned: return 1;
			case .VK_KHR_depth_stencil_resolve: return 1;
			case .VK_KHR_swapchain_mutable_format: return 3;
			case .VK_NV_compute_shader_derivatives: return 1;
			case .VK_NV_mesh_shader: return 1;
			case .VK_NV_fragment_shader_barycentric: return 1;
			case .VK_NV_shader_image_footprint: return 1;
			case .VK_NV_scissor_exclusive: return 1;
			case .VK_NV_device_diagnostic_checkpoints: return 1;
			case .VK_KHR_timeline_semaphore: return 1;
			case .VK_INTEL_shader_integer_functions2: return 1;
			case .VK_KHR_vulkan_memory_model: return 1;
			case .VK_EXT_pci_bus_info: return 1;
			case .VK_AMD_display_native_hdr: return 3;
			case .VK_KHR_shader_terminate_invocation: return 1;
			case .VK_EXT_fragment_density_map: return 1;
			case .VK_EXT_scalar_block_layout: return 1;
			case .VK_EXT_subgroup_size_control: return 1;
			case .VK_KHR_fragment_shading_rate: return 2;
			case .VK_AMD_shader_core_properties2: return 1;
			case .VK_AMD_device_coherent_memory: return 1;
			case .VK_KHR_dynamic_rendering_local_read: return 1;
			case .VK_EXT_shader_image_atomic_int64: return 1;
			case .VK_KHR_shader_quad_control: return 3;
			case .VK_KHR_spirv_1_4: return 2;
			case .VK_EXT_memory_budget: return 1;
			case .VK_EXT_memory_priority: return 1;
			case .VK_KHR_surface_protected_capabilities: return 2;
			case .VK_NV_dedicated_allocation_image_aliasing: return 2;
			case .VK_KHR_separate_depth_stencil_layouts: return 2;
			case .VK_EXT_buffer_device_address: return 1;
			case .VK_KHR_present_wait: return 2;
			case .VK_NV_cooperative_matrix: return 1;
			case .VK_NV_coverage_reduction_mode: return 2;
			case .VK_EXT_fragment_shader_interlock: return 1;
			case .VK_EXT_ycbcr_image_arrays: return 1;
			case .VK_KHR_uniform_buffer_standard_layout: return 1;
			case .VK_EXT_provoking_vertex: return 1;
			case .VK_EXT_headless_surface: return 1;
			case .VK_KHR_buffer_device_address: return 2;
			case .VK_EXT_line_rasterization: return 1;
			case .VK_EXT_shader_atomic_float: return 1;
			case .VK_EXT_host_query_reset: return 1;
			case .VK_EXT_index_type_uint8: return 1;
			case .VK_EXT_extended_dynamic_state: return 1;
			case .VK_KHR_pipeline_executable_properties: return 1;
			case .VK_EXT_host_image_copy: return 3;
			case .VK_EXT_map_memory_placed: return 1;
			case .VK_EXT_shader_atomic_float2: return 1;
			case .VK_EXT_surface_maintenance1: return 2;
			case .VK_EXT_swapchain_maintenance1: return 3;
			case .VK_EXT_shader_demote_to_helper_invocation: return 1;
			case .VK_NV_device_generated_commands: return 2;
			case .VK_NV_inherited_viewport_scissor: return 1;
			case .VK_KHR_shader_integer_dot_product: return 1;
			case .VK_EXT_texel_buffer_alignment: return 1;
			case .VK_EXT_depth_bias_control: return 1;
			case .VK_EXT_device_memory_report: return 1;
			case .VK_EXT_acquire_drm_display: return 1;
			case .VK_EXT_robustness2: return 1;
			case .VK_EXT_custom_border_color: return 1;
			case .VK_NV_present_barrier: return 4;
			case .VK_KHR_present_id: return 2;
			case .VK_EXT_private_data: return 1;
			case .VK_EXT_pipeline_creation_cache_control: return 1;
			case .VK_KHR_video_encode_queue: return 2;
			case .VK_NV_device_diagnostics_config: return 1;
			case .VK_KHR_synchronization2: return 1;
			case .VK_EXT_descriptor_buffer: return 4;
			case .VK_EXT_graphics_pipeline_library: return 2;
			case .VK_AMD_shader_early_and_late_fragment_tests: return 1;
			case .VK_KHR_fragment_shader_barycentric: return 1;
			case .VK_KHR_shader_subgroup_uniform_control_flow: return 1;
			case .VK_KHR_zero_initialize_workgroup_memory: return 1;
			case .VK_NV_fragment_shading_rate_enums: return 1;
			case .VK_NV_ray_tracing_motion_blur: return 1;
			case .VK_EXT_mesh_shader: return 1;
			case .VK_EXT_ycbcr_2plane_444_formats: return 1;
			case .VK_EXT_fragment_density_map2: return 1;
			case .VK_QCOM_rotated_copy_commands: return 1;
			case .VK_EXT_image_robustness: return 1;
			case .VK_KHR_workgroup_memory_explicit_layout: return 1;
			case .VK_KHR_copy_commands2: return 1;
			case .VK_EXT_image_compression_control: return 1;
			case .VK_EXT_attachment_feedback_loop_layout: return 1;
			case .VK_EXT_4444_formats: return 1;
			case .VK_EXT_device_fault: return 1;
			case .VK_ARM_rasterization_order_attachment_access: return 1;
			case .VK_EXT_rgba10x6_formats: return 1;
			case .VK_VALVE_mutable_descriptor_type: return 1;
			case .VK_EXT_vertex_input_dynamic_state: return 1;
			case .VK_EXT_physical_device_drm: return 1;
			case .VK_EXT_device_address_binding_report: return 2;
			case .VK_EXT_depth_clip_control: return 1;
			case .VK_EXT_primitive_topology_list_restart: return 1;
			case .VK_KHR_format_feature_flags2: return 1;
			case .VK_EXT_present_mode_fifo_latest_ready: return 1;
			case .VK_HUAWEI_subpass_shading: return 2;
			case .VK_HUAWEI_invocation_mask: return 2;
			case .VK_NV_external_memory_rdma: return 1;
			case .VK_EXT_pipeline_properties: return 1;
			case .VK_EXT_multisampled_render_to_single_sampled: return 2;
			case .VK_EXT_extended_dynamic_state2: return 1;
			case .VK_EXT_color_write_enable: return 1;
			case .VK_EXT_primitives_generated_query: return 1;
			case .VK_KHR_ray_tracing_maintenance1: return 1;
			case .VK_EXT_global_priority_query: return 2;
			case .VK_EXT_image_view_min_lod: return 1;
			case .VK_EXT_multi_draw: return 1;
			case .VK_EXT_image_2d_view_of_3d: return 2;
			case .VK_EXT_shader_tile_image: return 1;
			case .VK_EXT_opacity_micromap: return 2;
			case .VK_HUAWEI_cluster_culling_shader: return 1;
			case .VK_EXT_border_color_swizzle: return 1;
			case .VK_EXT_pageable_device_local_memory: return 1;
			case .VK_KHR_maintenance4: return 1;
			case .VK_ARM_shader_core_properties: return 1;
			case .VK_ARM_scheduling_controls: return 1;
			case .VK_EXT_image_sliced_view_of_3d: return 2;
			case .VK_VALVE_descriptor_set_host_mapping: return 1;
			case .VK_EXT_depth_clamp_zero_one: return 1;
			case .VK_EXT_non_seamless_cube_map: return 1;
			case .VK_ARM_render_pass_striped: return 2;
			case .VK_QCOM_fragment_density_map_offset: return 2;
			case .VK_NV_copy_memory_indirect: return 2;
			case .VK_NV_memory_decompression: return 2;
			case .VK_NV_device_generated_commands_compute: return 1;
			case .VK_NV_linear_color_attachment: return 1;
			case .VK_GOOGLE_surfaceless_query: return 1;
			case .VK_KHR_shader_maximal_reconvergence: return 1;
			case .VK_EXT_image_compression_control_swapchain: return 1;
			case .VK_QCOM_image_processing: return 1;
			case .VK_EXT_nested_command_buffer: return 1;
			case .VK_EXT_external_memory_acquire_unmodified: return 1;
			case .VK_EXT_extended_dynamic_state3: return 1;
			case .VK_EXT_subpass_merge_feedback: return 1;
			case .VK_EXT_shader_module_identifier: return 2;
			case .VK_EXT_rasterization_order_attachment_access: return 1;
			case .VK_NV_optical_flow: return 3;
			case .VK_EXT_legacy_dithering: return 1;
			case .VK_EXT_pipeline_protected_access: return 1;
			case .VK_KHR_maintenance5: return 2;
			case .VK_KHR_ray_tracing_position_fetch: return 1;
			case .VK_EXT_shader_object: return 2;
			case .VK_KHR_pipeline_binary: return 1;
			case .VK_QCOM_tile_properties: return 1;
			case .VK_SEC_amigo_profiling: return 1;
			case .VK_QCOM_multiview_per_view_viewports: return 1;
			case .VK_NV_ray_tracing_invocation_reorder: return 1;
			case .VK_EXT_mutable_descriptor_type: return 1;
			case .VK_EXT_legacy_vertex_attributes: return 1;
			case .VK_ARM_shader_core_builtins: return 1;
			case .VK_EXT_pipeline_library_group_handles: return 2;
			case .VK_EXT_dynamic_rendering_unused_attachments: return 2;
			case .VK_NV_low_latency2: return 1;
			case .VK_KHR_cooperative_matrix: return 1;
			case .VK_KHR_compute_shader_derivatives: return 1;
			case .VK_KHR_video_decode_av1: return 1;
			case .VK_KHR_video_encode_av1: return 1;
			case .VK_KHR_video_maintenance1: return 1;
			case .VK_NV_per_stage_descriptor_set: return 1;
			case .VK_QCOM_image_processing2: return 1;
			case .VK_QCOM_filter_cubic_weights: return 1;
			case .VK_QCOM_filter_cubic_clamp: return 2;
			case .VK_EXT_attachment_feedback_loop_dynamic_state: return 2;
			case .VK_KHR_vertex_attribute_divisor: return 1;
			case .VK_KHR_shader_float_controls2: return 2;
			case .VK_MSFT_layered_driver: return 1;
			case .VK_KHR_index_type_uint8: return 1;
			case .VK_KHR_line_rasterization: return 1;
			case .VK_KHR_calibrated_timestamps: return 1;
			case .VK_KHR_shader_expect_assume: return 1;
			case .VK_KHR_maintenance6: return 1;
			case .VK_NV_descriptor_pool_overallocation: return 1;
			case .VK_NV_display_stereo: return 2;
			case .VK_KHR_video_encode_quantization_map: return 2;
			case .VK_KHR_maintenance7: return 1;
			case .VK_EXT_device_generated_commands: return 2;
			case .VK_MESA_image_alignment_control: return 1;
			case .VK_EXT_depth_clamp_control: return 1;
			case .VK_HUAWEI_hdr_vivid: return 3;
			case .VK_NV_cooperative_matrix2: return 1;
			case .VK_EXT_vertex_attribute_robustness: return 1;
			default: return 0;
			}
		}
	}

	public VulkanFeature GetDependency(int idx)
	{
		switch (this)
		{
		case .VK_KHR_swapchain:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_surface);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_display:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_surface);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_display_swapchain:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_swapchain);
			case 1: return VulkanFeature.Extension(.VK_KHR_display);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_debug_marker:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_EXT_debug_report);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_video_queue:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case 1: return VulkanFeature.Extension(.VK_KHR_synchronization2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_video_decode_queue:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_video_queue);
			case 1: return VulkanFeature.Extension(.VK_KHR_synchronization2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_transform_feedback:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_video_encode_h264:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_video_encode_queue);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_video_encode_h265:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_video_encode_queue);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_video_decode_h264:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_video_decode_queue);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_AMD_texture_gather_bias_lod:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_dynamic_rendering:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_depth_stencil_resolve);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_corner_sampled_image:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_multiview:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_external_memory:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_NV_external_memory_capabilities);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_device_group:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_device_group_creation);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_texture_compression_astc_hdr:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_astc_decode_mode:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_pipeline_robustness:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_external_memory_capabilities:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_external_memory:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_external_memory_capabilities);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_external_memory_fd:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_external_memory);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_external_semaphore_capabilities:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_external_semaphore:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_external_semaphore_capabilities);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_external_semaphore_fd:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_external_semaphore);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_push_descriptor:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_conditional_rendering:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_shader_float16_int8:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_16bit_storage:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_storage_buffer_storage_class);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_incremental_present:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_swapchain);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_direct_mode_display:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_display);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_display_surface_counter:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_display);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_display_control:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_EXT_display_surface_counter);
			case 1: return VulkanFeature.Extension(.VK_KHR_swapchain);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_GOOGLE_display_timing:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_swapchain);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NVX_multiview_per_view_attributes:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_multiview);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_discard_rectangles:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_conservative_rasterization:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_depth_clip_enable:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_swapchain_colorspace:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_surface);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_hdr_metadata:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_swapchain);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_imageless_framebuffer:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_maintenance2);
			case 2: return VulkanFeature.Extension(.VK_KHR_image_format_list);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_create_renderpass2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_multiview);
			case 1: return VulkanFeature.Extension(.VK_KHR_maintenance2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_IMG_relaxed_line_rasterization:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_shared_presentable_image:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_swapchain);
			case 1: return VulkanFeature.Extension(.VK_KHR_get_surface_capabilities2);
			case 2: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_external_fence_capabilities:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_external_fence:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_external_fence_capabilities);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_external_fence_fd:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_external_fence);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_performance_query:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_get_surface_capabilities2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_surface);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_variable_pointers:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_storage_buffer_storage_class);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_get_display_properties2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_display);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_external_memory_dma_buf:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_external_memory_fd);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_queue_family_foreign:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_external_memory);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_dedicated_allocation:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_memory_requirements2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_sampler_filter_minmax:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_inline_uniform_block:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_maintenance1);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_sample_locations:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_blend_operation_advanced:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_acceleration_structure:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case 1: return VulkanFeature.Extension(.VK_EXT_descriptor_indexing);
			case 2: return VulkanFeature.Extension(.VK_KHR_buffer_device_address);
			case 3: return VulkanFeature.Extension(.VK_KHR_deferred_host_operations);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_ray_tracing_pipeline:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_spirv_1_4);
			case 1: return VulkanFeature.Extension(.VK_KHR_acceleration_structure);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_ray_query:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_spirv_1_4);
			case 1: return VulkanFeature.Extension(.VK_KHR_acceleration_structure);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_shader_sm_builtins:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_sampler_ycbcr_conversion:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_maintenance1);
			case 1: return VulkanFeature.Extension(.VK_KHR_bind_memory2);
			case 2: return VulkanFeature.Extension(.VK_KHR_get_memory_requirements2);
			case 3: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_image_drm_format_modifier:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_bind_memory2);
			case 1: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 2: return VulkanFeature.Extension(.VK_KHR_sampler_ycbcr_conversion);
			case 3: return VulkanFeature.Extension(.VK_KHR_image_format_list);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_descriptor_indexing:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_maintenance3);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_shading_rate_image:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_ray_tracing:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_get_memory_requirements2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_representative_fragment_test:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_maintenance3:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_shader_subgroup_extended_types:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_8bit_storage:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_storage_buffer_storage_class);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_external_memory_host:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_external_memory);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_shader_atomic_int64:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_shader_clock:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_calibrated_timestamps:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_AMD_shader_core_properties:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_video_decode_h265:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_video_decode_queue);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_global_priority:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_vertex_attribute_divisor:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_driver_properties:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_shader_float_controls:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_shader_subgroup_partitioned:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_depth_stencil_resolve:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_create_renderpass2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_swapchain_mutable_format:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_swapchain);
			case 1: return VulkanFeature.Extension(.VK_KHR_maintenance2);
			case 2: return VulkanFeature.Extension(.VK_KHR_image_format_list);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_compute_shader_derivatives:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_mesh_shader:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_fragment_shader_barycentric:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_shader_image_footprint:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_scissor_exclusive:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_device_diagnostic_checkpoints:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_timeline_semaphore:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_INTEL_shader_integer_functions2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_vulkan_memory_model:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_pci_bus_info:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_AMD_display_native_hdr:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_get_surface_capabilities2);
			case 2: return VulkanFeature.Extension(.VK_KHR_swapchain);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_shader_terminate_invocation:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_fragment_density_map:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_scalar_block_layout:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_subgroup_size_control:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_fragment_shading_rate:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_create_renderpass2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_AMD_shader_core_properties2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_AMD_shader_core_properties);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_AMD_device_coherent_memory:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_dynamic_rendering_local_read:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_dynamic_rendering);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_shader_image_atomic_int64:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_shader_quad_control:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case 1: return VulkanFeature.Extension(.VK_KHR_vulkan_memory_model);
			case 2: return VulkanFeature.Extension(.VK_KHR_shader_maximal_reconvergence);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_spirv_1_4:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case 1: return VulkanFeature.Extension(.VK_KHR_shader_float_controls);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_memory_budget:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_memory_priority:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_surface_protected_capabilities:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case 1: return VulkanFeature.Extension(.VK_KHR_get_surface_capabilities2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_dedicated_allocation_image_aliasing:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_dedicated_allocation);
			case 1: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_separate_depth_stencil_layouts:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_create_renderpass2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_buffer_device_address:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_present_wait:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_swapchain);
			case 1: return VulkanFeature.Extension(.VK_KHR_present_id);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_cooperative_matrix:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_coverage_reduction_mode:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_NV_framebuffer_mixed_samples);
			case 1: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_fragment_shader_interlock:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_ycbcr_image_arrays:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_sampler_ycbcr_conversion);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_uniform_buffer_standard_layout:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_provoking_vertex:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_headless_surface:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_surface);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_buffer_device_address:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_device_group);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_line_rasterization:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_shader_atomic_float:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_host_query_reset:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_index_type_uint8:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_extended_dynamic_state:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_pipeline_executable_properties:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_host_image_copy:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_copy_commands2);
			case 2: return VulkanFeature.Extension(.VK_KHR_format_feature_flags2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_map_memory_placed:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_map_memory2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_shader_atomic_float2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_EXT_shader_atomic_float);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_surface_maintenance1:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_surface);
			case 1: return VulkanFeature.Extension(.VK_KHR_get_surface_capabilities2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_swapchain_maintenance1:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_swapchain);
			case 1: return VulkanFeature.Extension(.VK_EXT_surface_maintenance1);
			case 2: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_shader_demote_to_helper_invocation:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_device_generated_commands:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case 1: return VulkanFeature.Extension(.VK_KHR_buffer_device_address);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_inherited_viewport_scissor:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_shader_integer_dot_product:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_texel_buffer_alignment:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_depth_bias_control:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_device_memory_report:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_acquire_drm_display:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_EXT_direct_mode_display);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_robustness2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_custom_border_color:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_present_barrier:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_surface);
			case 2: return VulkanFeature.Extension(.VK_KHR_get_surface_capabilities2);
			case 3: return VulkanFeature.Extension(.VK_KHR_swapchain);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_present_id:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_swapchain);
			case 1: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_private_data:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_pipeline_creation_cache_control:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_video_encode_queue:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_video_queue);
			case 1: return VulkanFeature.Extension(.VK_KHR_synchronization2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_device_diagnostics_config:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_synchronization2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_descriptor_buffer:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_buffer_device_address);
			case 2: return VulkanFeature.Extension(.VK_EXT_descriptor_indexing);
			case 3: return VulkanFeature.Extension(.VK_KHR_synchronization2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_graphics_pipeline_library:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_pipeline_library);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_AMD_shader_early_and_late_fragment_tests:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_fragment_shader_barycentric:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_shader_subgroup_uniform_control_flow:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_zero_initialize_workgroup_memory:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_fragment_shading_rate_enums:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_fragment_shading_rate);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_ray_tracing_motion_blur:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_ray_tracing_pipeline);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_mesh_shader:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_spirv_1_4);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_ycbcr_2plane_444_formats:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_sampler_ycbcr_conversion);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_fragment_density_map2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_EXT_fragment_density_map);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_QCOM_rotated_copy_commands:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_copy_commands2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_image_robustness:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_workgroup_memory_explicit_layout:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_copy_commands2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_image_compression_control:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_attachment_feedback_loop_layout:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_4444_formats:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_device_fault:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_ARM_rasterization_order_attachment_access:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_rgba10x6_formats:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_sampler_ycbcr_conversion);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_VALVE_mutable_descriptor_type:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_maintenance3);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_vertex_input_dynamic_state:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_physical_device_drm:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_device_address_binding_report:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_EXT_debug_utils);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_depth_clip_control:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_primitive_topology_list_restart:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_format_feature_flags2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_present_mode_fifo_latest_ready:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_swapchain);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_HUAWEI_subpass_shading:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_create_renderpass2);
			case 1: return VulkanFeature.Extension(.VK_KHR_synchronization2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_HUAWEI_invocation_mask:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_ray_tracing_pipeline);
			case 1: return VulkanFeature.Extension(.VK_KHR_synchronization2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_external_memory_rdma:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_external_memory);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_pipeline_properties:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_multisampled_render_to_single_sampled:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_create_renderpass2);
			case 1: return VulkanFeature.Extension(.VK_KHR_depth_stencil_resolve);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_extended_dynamic_state2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_color_write_enable:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_primitives_generated_query:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_EXT_transform_feedback);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_ray_tracing_maintenance1:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_acceleration_structure);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_global_priority_query:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_EXT_global_priority);
			case 1: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_image_view_min_lod:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_multi_draw:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_image_2d_view_of_3d:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_maintenance1);
			case 1: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_shader_tile_image:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_3);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_opacity_micromap:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_acceleration_structure);
			case 1: return VulkanFeature.Extension(.VK_KHR_synchronization2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_HUAWEI_cluster_culling_shader:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_border_color_swizzle:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_EXT_custom_border_color);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_pageable_device_local_memory:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_EXT_memory_priority);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_maintenance4:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_ARM_shader_core_properties:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_ARM_scheduling_controls:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_ARM_shader_core_builtins);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_image_sliced_view_of_3d:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_maintenance1);
			case 1: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_VALVE_descriptor_set_host_mapping:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_depth_clamp_zero_one:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_non_seamless_cube_map:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_ARM_render_pass_striped:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_synchronization2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_QCOM_fragment_density_map_offset:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_EXT_fragment_density_map);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_copy_memory_indirect:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_buffer_device_address);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_memory_decompression:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_buffer_device_address);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_device_generated_commands_compute:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_NV_device_generated_commands);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_linear_color_attachment:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_GOOGLE_surfaceless_query:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_surface);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_shader_maximal_reconvergence:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_image_compression_control_swapchain:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_EXT_image_compression_control);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_QCOM_image_processing:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_format_feature_flags2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_nested_command_buffer:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_external_memory_acquire_unmodified:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_external_memory);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_extended_dynamic_state3:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_subpass_merge_feedback:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_shader_module_identifier:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_EXT_pipeline_creation_cache_control);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_rasterization_order_attachment_access:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_optical_flow:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_format_feature_flags2);
			case 2: return VulkanFeature.Extension(.VK_KHR_synchronization2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_legacy_dithering:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_pipeline_protected_access:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_maintenance5:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case 1: return VulkanFeature.Extension(.VK_KHR_dynamic_rendering);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_ray_tracing_position_fetch:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_acceleration_structure);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_shader_object:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_dynamic_rendering);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_pipeline_binary:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_maintenance5);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_QCOM_tile_properties:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_SEC_amigo_profiling:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_QCOM_multiview_per_view_viewports:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_ray_tracing_invocation_reorder:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_ray_tracing_pipeline);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_mutable_descriptor_type:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_maintenance3);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_legacy_vertex_attributes:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_EXT_vertex_input_dynamic_state);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_ARM_shader_core_builtins:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_pipeline_library_group_handles:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_ray_tracing_pipeline);
			case 1: return VulkanFeature.Extension(.VK_KHR_pipeline_library);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_dynamic_rendering_unused_attachments:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_dynamic_rendering);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_low_latency2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_timeline_semaphore);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_cooperative_matrix:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_compute_shader_derivatives:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_video_decode_av1:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_video_decode_queue);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_video_encode_av1:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_video_encode_queue);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_video_maintenance1:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_video_queue);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_per_stage_descriptor_set:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_maintenance6);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_QCOM_image_processing2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_QCOM_image_processing);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_QCOM_filter_cubic_weights:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_EXT_filter_cubic);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_QCOM_filter_cubic_clamp:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_EXT_filter_cubic);
			case 1: return VulkanFeature.Extension(.VK_EXT_sampler_filter_minmax);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_attachment_feedback_loop_dynamic_state:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_EXT_attachment_feedback_loop_layout);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_vertex_attribute_divisor:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_shader_float_controls2:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			case 1: return VulkanFeature.Extension(.VK_KHR_shader_float_controls);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_MSFT_layered_driver:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_index_type_uint8:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_line_rasterization:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_calibrated_timestamps:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_shader_expect_assume:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_maintenance6:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_descriptor_pool_overallocation:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_display_stereo:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_display);
			case 1: return VulkanFeature.Extension(.VK_KHR_get_display_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_video_encode_quantization_map:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_video_encode_queue);
			case 1: return VulkanFeature.Extension(.VK_KHR_format_feature_flags2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_KHR_maintenance7:
			switch (idx)
			{
			case 0: return VulkanFeature.ApiVersion(.VK_VERSION_1_1);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_device_generated_commands:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_buffer_device_address);
			case 1: return VulkanFeature.Extension(.VK_KHR_maintenance5);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_MESA_image_alignment_control:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_depth_clamp_control:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_HUAWEI_hdr_vivid:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			case 1: return VulkanFeature.Extension(.VK_KHR_swapchain);
			case 2: return VulkanFeature.Extension(.VK_EXT_hdr_metadata);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_NV_cooperative_matrix2:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_cooperative_matrix);
			default:
				Runtime.FatalError("Index out of range");
			}
		case .VK_EXT_vertex_attribute_robustness:
			switch (idx)
			{
			case 0: return VulkanFeature.Extension(.VK_KHR_get_physical_device_properties2);
			default:
				Runtime.FatalError("Index out of range");
			}
		default:
			Runtime.FatalError("Index out of range");
		}
	}
}

namespace Vulkan;

extension VkFormat
{
	public enum FormatClass
	{
		VK_8BIT,
		VK_16BIT,
		VK_8BIT_ALPHA,
		VK_24BIT,
		VK_32BIT,
		VK_48BIT,
		VK_64BIT,
		VK_96BIT,
		VK_128BIT,
		VK_192BIT,
		VK_256BIT,
		D16,
		D24,
		D32,
		S8,
		D16S8,
		D24S8,
		D32S8,
		BC1_RGB,
		BC1_RGBA,
		BC2,
		BC3,
		BC4,
		BC5,
		BC6H,
		BC7,
		ETC2_RGB,
		ETC2_RGBA,
		ETC2_EAC_RGBA,
		EAC_R,
		EAC_RG,
		ASTC_4X4,
		ASTC_5X4,
		ASTC_5X5,
		ASTC_6X5,
		ASTC_6X6,
		ASTC_8X5,
		ASTC_8X6,
		ASTC_8X8,
		ASTC_10X5,
		ASTC_10X6,
		ASTC_10X8,
		ASTC_10X10,
		ASTC_12X10,
		ASTC_12X12,
		VK_32BIT_G8B8G8R8,
		VK_32BIT_B8G8R8G8,
		VK_8BIT_3PLANE_420,
		VK_8BIT_2PLANE_420,
		VK_8BIT_3PLANE_422,
		VK_8BIT_2PLANE_422,
		VK_8BIT_3PLANE_444,
		VK_64BIT_R10G10B10A10,
		VK_64BIT_G10B10G10R10,
		VK_64BIT_B10G10R10G10,
		VK_10BIT_3PLANE_420,
		VK_10BIT_2PLANE_420,
		VK_10BIT_3PLANE_422,
		VK_10BIT_2PLANE_422,
		VK_10BIT_3PLANE_444,
		VK_64BIT_R12G12B12A12,
		VK_64BIT_G12B12G12R12,
		VK_64BIT_B12G12R12G12,
		VK_12BIT_3PLANE_420,
		VK_12BIT_2PLANE_420,
		VK_12BIT_3PLANE_422,
		VK_12BIT_2PLANE_422,
		VK_12BIT_3PLANE_444,
		VK_64BIT_G16B16G16R16,
		VK_64BIT_B16G16R16G16,
		VK_16BIT_3PLANE_420,
		VK_16BIT_2PLANE_420,
		VK_16BIT_3PLANE_422,
		VK_16BIT_2PLANE_422,
		VK_16BIT_3PLANE_444,
		PVRTC1_2BPP,
		PVRTC1_4BPP,
		PVRTC2_2BPP,
		PVRTC2_4BPP,
		VK_8BIT_2PLANE_444,
		VK_10BIT_2PLANE_444,
		VK_12BIT_2PLANE_444,
		VK_16BIT_2PLANE_444,
	}

	public enum CompressionMode
	{
		NONE = 0,
		BC,
		ETC2,
		EAC,
		ASTC_LDR,
		PVRTC,
		ASTC_HDR,
	}

	[Inline]
	private static BasicMetadata GetBasicMetadata(Self self)
	{
		switch (self)
		{
		case .UNDEFINED: Runtime.FatalError("Attempted to access format metadata for VK_FORMAT_UNDEFINED");
		case .R4G4_UNORM_PACK8: return .(.VK_8BIT, 1, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R4G4B4A4_UNORM_PACK16: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B4G4R4A4_UNORM_PACK16: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R5G6B5_UNORM_PACK16: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B5G6R5_UNORM_PACK16: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R5G5B5A1_UNORM_PACK16: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B5G5R5A1_UNORM_PACK16: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A1R5G5B5_UNORM_PACK16: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A1B5G5R5_UNORM_PACK16: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A8_UNORM: return .(.VK_8BIT_ALPHA, 1, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8_UNORM: return .(.VK_8BIT, 1, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8_SNORM: return .(.VK_8BIT, 1, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8_USCALED: return .(.VK_8BIT, 1, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8_SSCALED: return .(.VK_8BIT, 1, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8_UINT: return .(.VK_8BIT, 1, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8_SINT: return .(.VK_8BIT, 1, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8_SRGB: return .(.VK_8BIT, 1, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8_UNORM: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8_SNORM: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8_USCALED: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8_SSCALED: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8_UINT: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8_SINT: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8_SRGB: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8_UNORM: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8_SNORM: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8_USCALED: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8_SSCALED: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8_UINT: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8_SINT: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8_SRGB: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8_UNORM: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8_SNORM: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8_USCALED: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8_SSCALED: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8_UINT: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8_SINT: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8_SRGB: return .(.VK_24BIT, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8A8_UNORM: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8A8_SNORM: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8A8_USCALED: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8A8_SSCALED: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8A8_UINT: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8A8_SINT: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R8G8B8A8_SRGB: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8A8_UNORM: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8A8_SNORM: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8A8_USCALED: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8A8_SSCALED: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8A8_UINT: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8A8_SINT: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B8G8R8A8_SRGB: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A8B8G8R8_UNORM_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A8B8G8R8_SNORM_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A8B8G8R8_USCALED_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A8B8G8R8_SSCALED_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A8B8G8R8_UINT_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A8B8G8R8_SINT_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A8B8G8R8_SRGB_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A2R10G10B10_UNORM_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A2R10G10B10_SNORM_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A2R10G10B10_USCALED_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A2R10G10B10_SSCALED_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A2R10G10B10_UINT_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A2R10G10B10_SINT_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A2B10G10R10_UNORM_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A2B10G10R10_SNORM_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A2B10G10R10_USCALED_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A2B10G10R10_SSCALED_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A2B10G10R10_UINT_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A2B10G10R10_SINT_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16_UNORM: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16_SNORM: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16_USCALED: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16_SSCALED: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16_UINT: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16_SINT: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16_SFLOAT: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16_UNORM: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16_SNORM: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16_USCALED: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16_SSCALED: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16_UINT: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16_SINT: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16_SFLOAT: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16_UNORM: return .(.VK_48BIT, 6, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16_SNORM: return .(.VK_48BIT, 6, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16_USCALED: return .(.VK_48BIT, 6, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16_SSCALED: return .(.VK_48BIT, 6, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16_UINT: return .(.VK_48BIT, 6, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16_SINT: return .(.VK_48BIT, 6, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16_SFLOAT: return .(.VK_48BIT, 6, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16A16_UNORM: return .(.VK_64BIT, 8, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16A16_SNORM: return .(.VK_64BIT, 8, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16A16_USCALED: return .(.VK_64BIT, 8, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16A16_SSCALED: return .(.VK_64BIT, 8, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16A16_UINT: return .(.VK_64BIT, 8, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16A16_SINT: return .(.VK_64BIT, 8, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16B16A16_SFLOAT: return .(.VK_64BIT, 8, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R32_UINT: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R32_SINT: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R32_SFLOAT: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R32G32_UINT: return .(.VK_64BIT, 8, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R32G32_SINT: return .(.VK_64BIT, 8, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R32G32_SFLOAT: return .(.VK_64BIT, 8, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R32G32B32_UINT: return .(.VK_96BIT, 12, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R32G32B32_SINT: return .(.VK_96BIT, 12, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R32G32B32_SFLOAT: return .(.VK_96BIT, 12, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R32G32B32A32_UINT: return .(.VK_128BIT, 16, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R32G32B32A32_SINT: return .(.VK_128BIT, 16, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R32G32B32A32_SFLOAT: return .(.VK_128BIT, 16, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R64_UINT: return .(.VK_64BIT, 8, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R64_SINT: return .(.VK_64BIT, 8, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R64_SFLOAT: return .(.VK_64BIT, 8, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R64G64_UINT: return .(.VK_128BIT, 16, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R64G64_SINT: return .(.VK_128BIT, 16, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R64G64_SFLOAT: return .(.VK_128BIT, 16, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R64G64B64_UINT: return .(.VK_192BIT, 24, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R64G64B64_SINT: return .(.VK_192BIT, 24, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R64G64B64_SFLOAT: return .(.VK_192BIT, 24, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R64G64B64A64_UINT: return .(.VK_256BIT, 32, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R64G64B64A64_SINT: return .(.VK_256BIT, 32, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R64G64B64A64_SFLOAT: return .(.VK_256BIT, 32, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .B10G11R11_UFLOAT_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .E5B9G9R9_UFLOAT_PACK32: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .D16_UNORM: return .(.D16, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .X8_D24_UNORM_PACK32: return .(.D24, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .D32_SFLOAT: return .(.D32, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .S8_UINT: return .(.S8, 1, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .D16_UNORM_S8_UINT: return .(.D16S8, 3, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .D24_UNORM_S8_UINT: return .(.D24S8, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .D32_SFLOAT_S8_UINT: return .(.D32S8, 5, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .BC1_RGB_UNORM_BLOCK: return .(.BC1_RGB, 8, 16, .(4,4,1), -1, .BC, -1);
		case .BC1_RGB_SRGB_BLOCK: return .(.BC1_RGB, 8, 16, .(4,4,1), -1, .BC, -1);
		case .BC1_RGBA_UNORM_BLOCK: return .(.BC1_RGBA, 8, 16, .(4,4,1), -1, .BC, -1);
		case .BC1_RGBA_SRGB_BLOCK: return .(.BC1_RGBA, 8, 16, .(4,4,1), -1, .BC, -1);
		case .BC2_UNORM_BLOCK: return .(.BC2, 16, 16, .(4,4,1), -1, .BC, -1);
		case .BC2_SRGB_BLOCK: return .(.BC2, 16, 16, .(4,4,1), -1, .BC, -1);
		case .BC3_UNORM_BLOCK: return .(.BC3, 16, 16, .(4,4,1), -1, .BC, -1);
		case .BC3_SRGB_BLOCK: return .(.BC3, 16, 16, .(4,4,1), -1, .BC, -1);
		case .BC4_UNORM_BLOCK: return .(.BC4, 8, 16, .(4,4,1), -1, .BC, -1);
		case .BC4_SNORM_BLOCK: return .(.BC4, 8, 16, .(4,4,1), -1, .BC, -1);
		case .BC5_UNORM_BLOCK: return .(.BC5, 16, 16, .(4,4,1), -1, .BC, -1);
		case .BC5_SNORM_BLOCK: return .(.BC5, 16, 16, .(4,4,1), -1, .BC, -1);
		case .BC6H_UFLOAT_BLOCK: return .(.BC6H, 16, 16, .(4,4,1), -1, .BC, -1);
		case .BC6H_SFLOAT_BLOCK: return .(.BC6H, 16, 16, .(4,4,1), -1, .BC, -1);
		case .BC7_UNORM_BLOCK: return .(.BC7, 16, 16, .(4,4,1), -1, .BC, -1);
		case .BC7_SRGB_BLOCK: return .(.BC7, 16, 16, .(4,4,1), -1, .BC, -1);
		case .ETC2_R8G8B8_UNORM_BLOCK: return .(.ETC2_RGB, 8, 16, .(4,4,1), -1, .ETC2, -1);
		case .ETC2_R8G8B8_SRGB_BLOCK: return .(.ETC2_RGB, 8, 16, .(4,4,1), -1, .ETC2, -1);
		case .ETC2_R8G8B8A1_UNORM_BLOCK: return .(.ETC2_RGBA, 8, 16, .(4,4,1), -1, .ETC2, -1);
		case .ETC2_R8G8B8A1_SRGB_BLOCK: return .(.ETC2_RGBA, 8, 16, .(4,4,1), -1, .ETC2, -1);
		case .ETC2_R8G8B8A8_UNORM_BLOCK: return .(.ETC2_EAC_RGBA, 16, 16, .(4,4,1), -1, .ETC2, -1);
		case .ETC2_R8G8B8A8_SRGB_BLOCK: return .(.ETC2_EAC_RGBA, 16, 16, .(4,4,1), -1, .ETC2, -1);
		case .EAC_R11_UNORM_BLOCK: return .(.EAC_R, 8, 16, .(4,4,1), -1, .EAC, -1);
		case .EAC_R11_SNORM_BLOCK: return .(.EAC_R, 8, 16, .(4,4,1), -1, .EAC, -1);
		case .EAC_R11G11_UNORM_BLOCK: return .(.EAC_RG, 16, 16, .(4,4,1), -1, .EAC, -1);
		case .EAC_R11G11_SNORM_BLOCK: return .(.EAC_RG, 16, 16, .(4,4,1), -1, .EAC, -1);
		case .ASTC_4x4_UNORM_BLOCK: return .(.ASTC_4X4, 16, 16, .(4,4,1), -1, .ASTC_LDR, -1);
		case .ASTC_4x4_SRGB_BLOCK: return .(.ASTC_4X4, 16, 16, .(4,4,1), -1, .ASTC_LDR, -1);
		case .ASTC_5x4_UNORM_BLOCK: return .(.ASTC_5X4, 16, 20, .(5,4,1), -1, .ASTC_LDR, -1);
		case .ASTC_5x4_SRGB_BLOCK: return .(.ASTC_5X4, 16, 20, .(5,4,1), -1, .ASTC_LDR, -1);
		case .ASTC_5x5_UNORM_BLOCK: return .(.ASTC_5X5, 16, 25, .(5,5,1), -1, .ASTC_LDR, -1);
		case .ASTC_5x5_SRGB_BLOCK: return .(.ASTC_5X5, 16, 25, .(5,5,1), -1, .ASTC_LDR, -1);
		case .ASTC_6x5_UNORM_BLOCK: return .(.ASTC_6X5, 16, 30, .(6,5,1), -1, .ASTC_LDR, -1);
		case .ASTC_6x5_SRGB_BLOCK: return .(.ASTC_6X5, 16, 30, .(6,5,1), -1, .ASTC_LDR, -1);
		case .ASTC_6x6_UNORM_BLOCK: return .(.ASTC_6X6, 16, 36, .(6,6,1), -1, .ASTC_LDR, -1);
		case .ASTC_6x6_SRGB_BLOCK: return .(.ASTC_6X6, 16, 36, .(6,6,1), -1, .ASTC_LDR, -1);
		case .ASTC_8x5_UNORM_BLOCK: return .(.ASTC_8X5, 16, 40, .(8,5,1), -1, .ASTC_LDR, -1);
		case .ASTC_8x5_SRGB_BLOCK: return .(.ASTC_8X5, 16, 40, .(8,5,1), -1, .ASTC_LDR, -1);
		case .ASTC_8x6_UNORM_BLOCK: return .(.ASTC_8X6, 16, 48, .(8,6,1), -1, .ASTC_LDR, -1);
		case .ASTC_8x6_SRGB_BLOCK: return .(.ASTC_8X6, 16, 48, .(8,6,1), -1, .ASTC_LDR, -1);
		case .ASTC_8x8_UNORM_BLOCK: return .(.ASTC_8X8, 16, 64, .(8,8,1), -1, .ASTC_LDR, -1);
		case .ASTC_8x8_SRGB_BLOCK: return .(.ASTC_8X8, 16, 64, .(8,8,1), -1, .ASTC_LDR, -1);
		case .ASTC_10x5_UNORM_BLOCK: return .(.ASTC_10X5, 16, 50, .(10,5,1), -1, .ASTC_LDR, -1);
		case .ASTC_10x5_SRGB_BLOCK: return .(.ASTC_10X5, 16, 50, .(10,5,1), -1, .ASTC_LDR, -1);
		case .ASTC_10x6_UNORM_BLOCK: return .(.ASTC_10X6, 16, 60, .(10,6,1), -1, .ASTC_LDR, -1);
		case .ASTC_10x6_SRGB_BLOCK: return .(.ASTC_10X6, 16, 60, .(10,6,1), -1, .ASTC_LDR, -1);
		case .ASTC_10x8_UNORM_BLOCK: return .(.ASTC_10X8, 16, 80, .(10,8,1), -1, .ASTC_LDR, -1);
		case .ASTC_10x8_SRGB_BLOCK: return .(.ASTC_10X8, 16, 80, .(10,8,1), -1, .ASTC_LDR, -1);
		case .ASTC_10x10_UNORM_BLOCK: return .(.ASTC_10X10, 16, 100, .(10,10,1), -1, .ASTC_LDR, -1);
		case .ASTC_10x10_SRGB_BLOCK: return .(.ASTC_10X10, 16, 100, .(10,10,1), -1, .ASTC_LDR, -1);
		case .ASTC_12x10_UNORM_BLOCK: return .(.ASTC_12X10, 16, 120, .(12,10,1), -1, .ASTC_LDR, -1);
		case .ASTC_12x10_SRGB_BLOCK: return .(.ASTC_12X10, 16, 120, .(12,10,1), -1, .ASTC_LDR, -1);
		case .ASTC_12x12_UNORM_BLOCK: return .(.ASTC_12X12, 16, 144, .(12,12,1), -1, .ASTC_LDR, -1);
		case .ASTC_12x12_SRGB_BLOCK: return .(.ASTC_12X12, 16, 144, .(12,12,1), -1, .ASTC_LDR, -1);
		case .G8B8G8R8_422_UNORM: return .(.VK_32BIT_G8B8G8R8, 4, 1, .(2,1,1), -1, .NONE, 422);
		case .B8G8R8G8_422_UNORM: return .(.VK_32BIT_B8G8R8G8, 4, 1, .(2,1,1), -1, .NONE, 422);
		case .G8_B8_R8_3PLANE_420_UNORM: return .(.VK_8BIT_3PLANE_420, 3, 1, .(/**/ 1,1,1), -1, .NONE, 420);
		case .G8_B8R8_2PLANE_420_UNORM: return .(.VK_8BIT_2PLANE_420, 3, 1, .(/**/ 1,1,1), -1, .NONE, 420);
		case .G8_B8_R8_3PLANE_422_UNORM: return .(.VK_8BIT_3PLANE_422, 3, 1, .(/**/ 1,1,1), -1, .NONE, 422);
		case .G8_B8R8_2PLANE_422_UNORM: return .(.VK_8BIT_2PLANE_422, 3, 1, .(/**/ 1,1,1), -1, .NONE, 422);
		case .G8_B8_R8_3PLANE_444_UNORM: return .(.VK_8BIT_3PLANE_444, 3, 1, .(/**/ 1,1,1), -1, .NONE, 444);
		case .R10X6_UNORM_PACK16: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R10X6G10X6_UNORM_2PACK16: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R10X6G10X6B10X6A10X6_UNORM_4PACK16: return .(.VK_64BIT_R10G10B10A10, 8, 1, .(/**/ 1,1,1), -1, .NONE, 444);
		case .G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: return .(.VK_64BIT_G10B10G10R10, 8, 1, .(2,1,1), -1, .NONE, 422);
		case .B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: return .(.VK_64BIT_B10G10R10G10, 8, 1, .(2,1,1), -1, .NONE, 422);
		case .G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: return .(.VK_10BIT_3PLANE_420, 6, 1, .(/**/ 1,1,1), -1, .NONE, 420);
		case .G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: return .(.VK_10BIT_2PLANE_420, 6, 1, .(/**/ 1,1,1), -1, .NONE, 420);
		case .G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: return .(.VK_10BIT_3PLANE_422, 6, 1, .(/**/ 1,1,1), -1, .NONE, 422);
		case .G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: return .(.VK_10BIT_2PLANE_422, 6, 1, .(/**/ 1,1,1), -1, .NONE, 422);
		case .G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: return .(.VK_10BIT_3PLANE_444, 6, 1, .(/**/ 1,1,1), -1, .NONE, 444);
		case .R12X4_UNORM_PACK16: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R12X4G12X4_UNORM_2PACK16: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R12X4G12X4B12X4A12X4_UNORM_4PACK16: return .(.VK_64BIT_R12G12B12A12, 8, 1, .(/**/ 1,1,1), -1, .NONE, 444);
		case .G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: return .(.VK_64BIT_G12B12G12R12, 8, 1, .(2,1,1), -1, .NONE, 422);
		case .B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: return .(.VK_64BIT_B12G12R12G12, 8, 1, .(2,1,1), -1, .NONE, 422);
		case .G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: return .(.VK_12BIT_3PLANE_420, 6, 1, .(/**/ 1,1,1), -1, .NONE, 420);
		case .G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: return .(.VK_12BIT_2PLANE_420, 6, 1, .(/**/ 1,1,1), -1, .NONE, 420);
		case .G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: return .(.VK_12BIT_3PLANE_422, 6, 1, .(/**/ 1,1,1), -1, .NONE, 422);
		case .G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: return .(.VK_12BIT_2PLANE_422, 6, 1, .(/**/ 1,1,1), -1, .NONE, 422);
		case .G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: return .(.VK_12BIT_3PLANE_444, 6, 1, .(/**/ 1,1,1), -1, .NONE, 444);
		case .G16B16G16R16_422_UNORM: return .(.VK_64BIT_G16B16G16R16, 8, 1, .(2,1,1), -1, .NONE, 422);
		case .B16G16R16G16_422_UNORM: return .(.VK_64BIT_B16G16R16G16, 8, 1, .(2,1,1), -1, .NONE, 422);
		case .G16_B16_R16_3PLANE_420_UNORM: return .(.VK_16BIT_3PLANE_420, 6, 1, .(/**/ 1,1,1), -1, .NONE, 420);
		case .G16_B16R16_2PLANE_420_UNORM: return .(.VK_16BIT_2PLANE_420, 6, 1, .(/**/ 1,1,1), -1, .NONE, 420);
		case .G16_B16_R16_3PLANE_422_UNORM: return .(.VK_16BIT_3PLANE_422, 6, 1, .(/**/ 1,1,1), -1, .NONE, 422);
		case .G16_B16R16_2PLANE_422_UNORM: return .(.VK_16BIT_2PLANE_422, 6, 1, .(/**/ 1,1,1), -1, .NONE, 422);
		case .G16_B16_R16_3PLANE_444_UNORM: return .(.VK_16BIT_3PLANE_444, 6, 1, .(/**/ 1,1,1), -1, .NONE, 444);
		case .PVRTC1_2BPP_UNORM_BLOCK_IMG: return .(.PVRTC1_2BPP, 8, 1, .(8,4,1), -1, .PVRTC, -1);
		case .PVRTC1_4BPP_UNORM_BLOCK_IMG: return .(.PVRTC1_4BPP, 8, 1, .(4,4,1), -1, .PVRTC, -1);
		case .PVRTC2_2BPP_UNORM_BLOCK_IMG: return .(.PVRTC2_2BPP, 8, 1, .(8,4,1), -1, .PVRTC, -1);
		case .PVRTC2_4BPP_UNORM_BLOCK_IMG: return .(.PVRTC2_4BPP, 8, 1, .(4,4,1), -1, .PVRTC, -1);
		case .PVRTC1_2BPP_SRGB_BLOCK_IMG: return .(.PVRTC1_2BPP, 8, 1, .(8,4,1), -1, .PVRTC, -1);
		case .PVRTC1_4BPP_SRGB_BLOCK_IMG: return .(.PVRTC1_4BPP, 8, 1, .(4,4,1), -1, .PVRTC, -1);
		case .PVRTC2_2BPP_SRGB_BLOCK_IMG: return .(.PVRTC2_2BPP, 8, 1, .(8,4,1), -1, .PVRTC, -1);
		case .PVRTC2_4BPP_SRGB_BLOCK_IMG: return .(.PVRTC2_4BPP, 8, 1, .(4,4,1), -1, .PVRTC, -1);
		case .ASTC_4x4_SFLOAT_BLOCK: return .(.ASTC_4X4, 16, 16, .(4,4,1), -1, .ASTC_HDR, -1);
		case .ASTC_5x4_SFLOAT_BLOCK: return .(.ASTC_5X4, 16, 20, .(5,4,1), -1, .ASTC_HDR, -1);
		case .ASTC_5x5_SFLOAT_BLOCK: return .(.ASTC_5X5, 16, 25, .(5,5,1), -1, .ASTC_HDR, -1);
		case .ASTC_6x5_SFLOAT_BLOCK: return .(.ASTC_6X5, 16, 30, .(6,5,1), -1, .ASTC_HDR, -1);
		case .ASTC_6x6_SFLOAT_BLOCK: return .(.ASTC_6X6, 16, 36, .(6,6,1), -1, .ASTC_HDR, -1);
		case .ASTC_8x5_SFLOAT_BLOCK: return .(.ASTC_8X5, 16, 40, .(8,5,1), -1, .ASTC_HDR, -1);
		case .ASTC_8x6_SFLOAT_BLOCK: return .(.ASTC_8X6, 16, 48, .(8,6,1), -1, .ASTC_HDR, -1);
		case .ASTC_8x8_SFLOAT_BLOCK: return .(.ASTC_8X8, 16, 64, .(8,8,1), -1, .ASTC_HDR, -1);
		case .ASTC_10x5_SFLOAT_BLOCK: return .(.ASTC_10X5, 16, 50, .(10,5,1), -1, .ASTC_HDR, -1);
		case .ASTC_10x6_SFLOAT_BLOCK: return .(.ASTC_10X6, 16, 60, .(10,6,1), -1, .ASTC_HDR, -1);
		case .ASTC_10x8_SFLOAT_BLOCK: return .(.ASTC_10X8, 16, 80, .(10,8,1), -1, .ASTC_HDR, -1);
		case .ASTC_10x10_SFLOAT_BLOCK: return .(.ASTC_10X10, 16, 100, .(10,10,1), -1, .ASTC_HDR, -1);
		case .ASTC_12x10_SFLOAT_BLOCK: return .(.ASTC_12X10, 16, 120, .(12,10,1), -1, .ASTC_HDR, -1);
		case .ASTC_12x12_SFLOAT_BLOCK: return .(.ASTC_12X12, 16, 144, .(12,12,1), -1, .ASTC_HDR, -1);
		case .G8_B8R8_2PLANE_444_UNORM: return .(.VK_8BIT_2PLANE_444, 3, 1, .(/**/ 1,1,1), -1, .NONE, 444);
		case .G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16: return .(.VK_10BIT_2PLANE_444, 6, 1, .(/**/ 1,1,1), -1, .NONE, 444);
		case .G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16: return .(.VK_12BIT_2PLANE_444, 6, 1, .(/**/ 1,1,1), -1, .NONE, 444);
		case .G16_B16R16_2PLANE_444_UNORM: return .(.VK_16BIT_2PLANE_444, 6, 1, .(/**/ 1,1,1), -1, .NONE, 444);
		case .A4R4G4B4_UNORM_PACK16: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .A4B4G4R4_UNORM_PACK16: return .(.VK_16BIT, 2, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		case .R16G16_SFIXED5_NV: return .(.VK_32BIT, 4, 1, .(/**/ 1,1,1), -1, .NONE, -1);
		}
	}

	public enum ComponentBits
	{
		VK_4 = 4,
		VK_5 = 5,
		VK_6 = 6,
		VK_1 = 1,
		VK_8 = 8,
		VK_2 = 2,
		VK_10 = 10,
		VK_16 = 16,
		VK_32 = 32,
		VK_64 = 64,
		VK_11 = 11,
		VK_9 = 9,
		VK_24 = 24,
		COMPRESSED = 2147483648,
		VK_12 = 12,
	}

	public enum NumericFormat
	{
		UNORM,
		SNORM,
		USCALED,
		SSCALED,
		UINT,
		SINT,
		SRGB,
		SFLOAT,
		UFLOAT,
		SFIXED5,
	}

	public int ComponentCount
	{
		get
		{
			switch (this)
			{
			case .UNDEFINED: Runtime.FatalError("Attempted to access format metadata for VK_FORMAT_UNDEFINED");
			case .R4G4_UNORM_PACK8: return 2;
			case .R4G4B4A4_UNORM_PACK16: return 4;
			case .B4G4R4A4_UNORM_PACK16: return 4;
			case .R5G6B5_UNORM_PACK16: return 3;
			case .B5G6R5_UNORM_PACK16: return 3;
			case .R5G5B5A1_UNORM_PACK16: return 4;
			case .B5G5R5A1_UNORM_PACK16: return 4;
			case .A1R5G5B5_UNORM_PACK16: return 4;
			case .A1B5G5R5_UNORM_PACK16: return 4;
			case .A8_UNORM: return 1;
			case .R8_UNORM: return 1;
			case .R8_SNORM: return 1;
			case .R8_USCALED: return 1;
			case .R8_SSCALED: return 1;
			case .R8_UINT: return 1;
			case .R8_SINT: return 1;
			case .R8_SRGB: return 1;
			case .R8G8_UNORM: return 2;
			case .R8G8_SNORM: return 2;
			case .R8G8_USCALED: return 2;
			case .R8G8_SSCALED: return 2;
			case .R8G8_UINT: return 2;
			case .R8G8_SINT: return 2;
			case .R8G8_SRGB: return 2;
			case .R8G8B8_UNORM: return 3;
			case .R8G8B8_SNORM: return 3;
			case .R8G8B8_USCALED: return 3;
			case .R8G8B8_SSCALED: return 3;
			case .R8G8B8_UINT: return 3;
			case .R8G8B8_SINT: return 3;
			case .R8G8B8_SRGB: return 3;
			case .B8G8R8_UNORM: return 3;
			case .B8G8R8_SNORM: return 3;
			case .B8G8R8_USCALED: return 3;
			case .B8G8R8_SSCALED: return 3;
			case .B8G8R8_UINT: return 3;
			case .B8G8R8_SINT: return 3;
			case .B8G8R8_SRGB: return 3;
			case .R8G8B8A8_UNORM: return 4;
			case .R8G8B8A8_SNORM: return 4;
			case .R8G8B8A8_USCALED: return 4;
			case .R8G8B8A8_SSCALED: return 4;
			case .R8G8B8A8_UINT: return 4;
			case .R8G8B8A8_SINT: return 4;
			case .R8G8B8A8_SRGB: return 4;
			case .B8G8R8A8_UNORM: return 4;
			case .B8G8R8A8_SNORM: return 4;
			case .B8G8R8A8_USCALED: return 4;
			case .B8G8R8A8_SSCALED: return 4;
			case .B8G8R8A8_UINT: return 4;
			case .B8G8R8A8_SINT: return 4;
			case .B8G8R8A8_SRGB: return 4;
			case .A8B8G8R8_UNORM_PACK32: return 4;
			case .A8B8G8R8_SNORM_PACK32: return 4;
			case .A8B8G8R8_USCALED_PACK32: return 4;
			case .A8B8G8R8_SSCALED_PACK32: return 4;
			case .A8B8G8R8_UINT_PACK32: return 4;
			case .A8B8G8R8_SINT_PACK32: return 4;
			case .A8B8G8R8_SRGB_PACK32: return 4;
			case .A2R10G10B10_UNORM_PACK32: return 4;
			case .A2R10G10B10_SNORM_PACK32: return 4;
			case .A2R10G10B10_USCALED_PACK32: return 4;
			case .A2R10G10B10_SSCALED_PACK32: return 4;
			case .A2R10G10B10_UINT_PACK32: return 4;
			case .A2R10G10B10_SINT_PACK32: return 4;
			case .A2B10G10R10_UNORM_PACK32: return 4;
			case .A2B10G10R10_SNORM_PACK32: return 4;
			case .A2B10G10R10_USCALED_PACK32: return 4;
			case .A2B10G10R10_SSCALED_PACK32: return 4;
			case .A2B10G10R10_UINT_PACK32: return 4;
			case .A2B10G10R10_SINT_PACK32: return 4;
			case .R16_UNORM: return 1;
			case .R16_SNORM: return 1;
			case .R16_USCALED: return 1;
			case .R16_SSCALED: return 1;
			case .R16_UINT: return 1;
			case .R16_SINT: return 1;
			case .R16_SFLOAT: return 1;
			case .R16G16_UNORM: return 2;
			case .R16G16_SNORM: return 2;
			case .R16G16_USCALED: return 2;
			case .R16G16_SSCALED: return 2;
			case .R16G16_UINT: return 2;
			case .R16G16_SINT: return 2;
			case .R16G16_SFLOAT: return 2;
			case .R16G16B16_UNORM: return 3;
			case .R16G16B16_SNORM: return 3;
			case .R16G16B16_USCALED: return 3;
			case .R16G16B16_SSCALED: return 3;
			case .R16G16B16_UINT: return 3;
			case .R16G16B16_SINT: return 3;
			case .R16G16B16_SFLOAT: return 3;
			case .R16G16B16A16_UNORM: return 4;
			case .R16G16B16A16_SNORM: return 4;
			case .R16G16B16A16_USCALED: return 4;
			case .R16G16B16A16_SSCALED: return 4;
			case .R16G16B16A16_UINT: return 4;
			case .R16G16B16A16_SINT: return 4;
			case .R16G16B16A16_SFLOAT: return 4;
			case .R32_UINT: return 1;
			case .R32_SINT: return 1;
			case .R32_SFLOAT: return 1;
			case .R32G32_UINT: return 2;
			case .R32G32_SINT: return 2;
			case .R32G32_SFLOAT: return 2;
			case .R32G32B32_UINT: return 3;
			case .R32G32B32_SINT: return 3;
			case .R32G32B32_SFLOAT: return 3;
			case .R32G32B32A32_UINT: return 4;
			case .R32G32B32A32_SINT: return 4;
			case .R32G32B32A32_SFLOAT: return 4;
			case .R64_UINT: return 1;
			case .R64_SINT: return 1;
			case .R64_SFLOAT: return 1;
			case .R64G64_UINT: return 2;
			case .R64G64_SINT: return 2;
			case .R64G64_SFLOAT: return 2;
			case .R64G64B64_UINT: return 3;
			case .R64G64B64_SINT: return 3;
			case .R64G64B64_SFLOAT: return 3;
			case .R64G64B64A64_UINT: return 4;
			case .R64G64B64A64_SINT: return 4;
			case .R64G64B64A64_SFLOAT: return 4;
			case .B10G11R11_UFLOAT_PACK32: return 3;
			case .E5B9G9R9_UFLOAT_PACK32: return 3;
			case .D16_UNORM: return 1;
			case .X8_D24_UNORM_PACK32: return 1;
			case .D32_SFLOAT: return 1;
			case .S8_UINT: return 1;
			case .D16_UNORM_S8_UINT: return 2;
			case .D24_UNORM_S8_UINT: return 2;
			case .D32_SFLOAT_S8_UINT: return 2;
			case .BC1_RGB_UNORM_BLOCK: return 3;
			case .BC1_RGB_SRGB_BLOCK: return 3;
			case .BC1_RGBA_UNORM_BLOCK: return 4;
			case .BC1_RGBA_SRGB_BLOCK: return 4;
			case .BC2_UNORM_BLOCK: return 4;
			case .BC2_SRGB_BLOCK: return 4;
			case .BC3_UNORM_BLOCK: return 4;
			case .BC3_SRGB_BLOCK: return 4;
			case .BC4_UNORM_BLOCK: return 1;
			case .BC4_SNORM_BLOCK: return 1;
			case .BC5_UNORM_BLOCK: return 2;
			case .BC5_SNORM_BLOCK: return 2;
			case .BC6H_UFLOAT_BLOCK: return 3;
			case .BC6H_SFLOAT_BLOCK: return 3;
			case .BC7_UNORM_BLOCK: return 4;
			case .BC7_SRGB_BLOCK: return 4;
			case .ETC2_R8G8B8_UNORM_BLOCK: return 3;
			case .ETC2_R8G8B8_SRGB_BLOCK: return 3;
			case .ETC2_R8G8B8A1_UNORM_BLOCK: return 4;
			case .ETC2_R8G8B8A1_SRGB_BLOCK: return 4;
			case .ETC2_R8G8B8A8_UNORM_BLOCK: return 4;
			case .ETC2_R8G8B8A8_SRGB_BLOCK: return 4;
			case .EAC_R11_UNORM_BLOCK: return 1;
			case .EAC_R11_SNORM_BLOCK: return 1;
			case .EAC_R11G11_UNORM_BLOCK: return 2;
			case .EAC_R11G11_SNORM_BLOCK: return 2;
			case .ASTC_4x4_UNORM_BLOCK: return 4;
			case .ASTC_4x4_SRGB_BLOCK: return 4;
			case .ASTC_5x4_UNORM_BLOCK: return 4;
			case .ASTC_5x4_SRGB_BLOCK: return 4;
			case .ASTC_5x5_UNORM_BLOCK: return 4;
			case .ASTC_5x5_SRGB_BLOCK: return 4;
			case .ASTC_6x5_UNORM_BLOCK: return 4;
			case .ASTC_6x5_SRGB_BLOCK: return 4;
			case .ASTC_6x6_UNORM_BLOCK: return 4;
			case .ASTC_6x6_SRGB_BLOCK: return 4;
			case .ASTC_8x5_UNORM_BLOCK: return 4;
			case .ASTC_8x5_SRGB_BLOCK: return 4;
			case .ASTC_8x6_UNORM_BLOCK: return 4;
			case .ASTC_8x6_SRGB_BLOCK: return 4;
			case .ASTC_8x8_UNORM_BLOCK: return 4;
			case .ASTC_8x8_SRGB_BLOCK: return 4;
			case .ASTC_10x5_UNORM_BLOCK: return 4;
			case .ASTC_10x5_SRGB_BLOCK: return 4;
			case .ASTC_10x6_UNORM_BLOCK: return 4;
			case .ASTC_10x6_SRGB_BLOCK: return 4;
			case .ASTC_10x8_UNORM_BLOCK: return 4;
			case .ASTC_10x8_SRGB_BLOCK: return 4;
			case .ASTC_10x10_UNORM_BLOCK: return 4;
			case .ASTC_10x10_SRGB_BLOCK: return 4;
			case .ASTC_12x10_UNORM_BLOCK: return 4;
			case .ASTC_12x10_SRGB_BLOCK: return 4;
			case .ASTC_12x12_UNORM_BLOCK: return 4;
			case .ASTC_12x12_SRGB_BLOCK: return 4;
			case .G8B8G8R8_422_UNORM: return 4;
			case .B8G8R8G8_422_UNORM: return 4;
			case .G8_B8_R8_3PLANE_420_UNORM: return 3;
			case .G8_B8R8_2PLANE_420_UNORM: return 3;
			case .G8_B8_R8_3PLANE_422_UNORM: return 3;
			case .G8_B8R8_2PLANE_422_UNORM: return 3;
			case .G8_B8_R8_3PLANE_444_UNORM: return 3;
			case .R10X6_UNORM_PACK16: return 1;
			case .R10X6G10X6_UNORM_2PACK16: return 2;
			case .R10X6G10X6B10X6A10X6_UNORM_4PACK16: return 4;
			case .G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: return 4;
			case .B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: return 4;
			case .G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: return 3;
			case .G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: return 3;
			case .G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: return 3;
			case .G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: return 3;
			case .G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: return 3;
			case .R12X4_UNORM_PACK16: return 1;
			case .R12X4G12X4_UNORM_2PACK16: return 2;
			case .R12X4G12X4B12X4A12X4_UNORM_4PACK16: return 4;
			case .G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: return 4;
			case .B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: return 4;
			case .G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: return 3;
			case .G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: return 3;
			case .G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: return 3;
			case .G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: return 3;
			case .G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: return 3;
			case .G16B16G16R16_422_UNORM: return 4;
			case .B16G16R16G16_422_UNORM: return 4;
			case .G16_B16_R16_3PLANE_420_UNORM: return 3;
			case .G16_B16R16_2PLANE_420_UNORM: return 3;
			case .G16_B16_R16_3PLANE_422_UNORM: return 3;
			case .G16_B16R16_2PLANE_422_UNORM: return 3;
			case .G16_B16_R16_3PLANE_444_UNORM: return 3;
			case .PVRTC1_2BPP_UNORM_BLOCK_IMG: return 4;
			case .PVRTC1_4BPP_UNORM_BLOCK_IMG: return 4;
			case .PVRTC2_2BPP_UNORM_BLOCK_IMG: return 4;
			case .PVRTC2_4BPP_UNORM_BLOCK_IMG: return 4;
			case .PVRTC1_2BPP_SRGB_BLOCK_IMG: return 4;
			case .PVRTC1_4BPP_SRGB_BLOCK_IMG: return 4;
			case .PVRTC2_2BPP_SRGB_BLOCK_IMG: return 4;
			case .PVRTC2_4BPP_SRGB_BLOCK_IMG: return 4;
			case .ASTC_4x4_SFLOAT_BLOCK: return 4;
			case .ASTC_5x4_SFLOAT_BLOCK: return 4;
			case .ASTC_5x5_SFLOAT_BLOCK: return 4;
			case .ASTC_6x5_SFLOAT_BLOCK: return 4;
			case .ASTC_6x6_SFLOAT_BLOCK: return 4;
			case .ASTC_8x5_SFLOAT_BLOCK: return 4;
			case .ASTC_8x6_SFLOAT_BLOCK: return 4;
			case .ASTC_8x8_SFLOAT_BLOCK: return 4;
			case .ASTC_10x5_SFLOAT_BLOCK: return 4;
			case .ASTC_10x6_SFLOAT_BLOCK: return 4;
			case .ASTC_10x8_SFLOAT_BLOCK: return 4;
			case .ASTC_10x10_SFLOAT_BLOCK: return 4;
			case .ASTC_12x10_SFLOAT_BLOCK: return 4;
			case .ASTC_12x12_SFLOAT_BLOCK: return 4;
			case .G8_B8R8_2PLANE_444_UNORM: return 3;
			case .G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16: return 3;
			case .G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16: return 3;
			case .G16_B16R16_2PLANE_444_UNORM: return 3;
			case .A4R4G4B4_UNORM_PACK16: return 4;
			case .A4B4G4R4_UNORM_PACK16: return 4;
			case .R16G16_SFIXED5_NV: return 2;
			}
		}
	}

	public ComponentMetadata GetComponent(int idx)
	{
		switch (this)
		{
		case .UNDEFINED: Runtime.FatalError("Attempted to access format metadata for VK_FORMAT_UNDEFINED");
		case .R4G4_UNORM_PACK8:
			switch (idx)
			{
			case 0: return .('R', .VK_4, .UNORM, -1);
			case 1: return .('G', .VK_4, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R4G4B4A4_UNORM_PACK16:
			switch (idx)
			{
			case 0: return .('R', .VK_4, .UNORM, -1);
			case 1: return .('G', .VK_4, .UNORM, -1);
			case 2: return .('B', .VK_4, .UNORM, -1);
			case 3: return .('A', .VK_4, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B4G4R4A4_UNORM_PACK16:
			switch (idx)
			{
			case 0: return .('B', .VK_4, .UNORM, -1);
			case 1: return .('G', .VK_4, .UNORM, -1);
			case 2: return .('R', .VK_4, .UNORM, -1);
			case 3: return .('A', .VK_4, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R5G6B5_UNORM_PACK16:
			switch (idx)
			{
			case 0: return .('R', .VK_5, .UNORM, -1);
			case 1: return .('G', .VK_6, .UNORM, -1);
			case 2: return .('B', .VK_5, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B5G6R5_UNORM_PACK16:
			switch (idx)
			{
			case 0: return .('B', .VK_5, .UNORM, -1);
			case 1: return .('G', .VK_6, .UNORM, -1);
			case 2: return .('R', .VK_5, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R5G5B5A1_UNORM_PACK16:
			switch (idx)
			{
			case 0: return .('R', .VK_5, .UNORM, -1);
			case 1: return .('G', .VK_5, .UNORM, -1);
			case 2: return .('B', .VK_5, .UNORM, -1);
			case 3: return .('A', .VK_1, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B5G5R5A1_UNORM_PACK16:
			switch (idx)
			{
			case 0: return .('B', .VK_5, .UNORM, -1);
			case 1: return .('G', .VK_5, .UNORM, -1);
			case 2: return .('R', .VK_5, .UNORM, -1);
			case 3: return .('A', .VK_1, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A1R5G5B5_UNORM_PACK16:
			switch (idx)
			{
			case 0: return .('A', .VK_1, .UNORM, -1);
			case 1: return .('R', .VK_5, .UNORM, -1);
			case 2: return .('G', .VK_5, .UNORM, -1);
			case 3: return .('B', .VK_5, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A1B5G5R5_UNORM_PACK16:
			switch (idx)
			{
			case 0: return .('A', .VK_1, .UNORM, -1);
			case 1: return .('B', .VK_5, .UNORM, -1);
			case 2: return .('G', .VK_5, .UNORM, -1);
			case 3: return .('R', .VK_5, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A8_UNORM:
			switch (idx)
			{
			case 0: return .('A', .VK_8, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8_UNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8_SNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8_USCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .USCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8_SSCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SSCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8_SRGB:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8_UNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .UNORM, -1);
			case 1: return .('G', .VK_8, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8_SNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SNORM, -1);
			case 1: return .('G', .VK_8, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8_USCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .USCALED, -1);
			case 1: return .('G', .VK_8, .USCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8_SSCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SSCALED, -1);
			case 1: return .('G', .VK_8, .SSCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .UINT, -1);
			case 1: return .('G', .VK_8, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SINT, -1);
			case 1: return .('G', .VK_8, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8_SRGB:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SRGB, -1);
			case 1: return .('G', .VK_8, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8_UNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .UNORM, -1);
			case 1: return .('G', .VK_8, .UNORM, -1);
			case 2: return .('B', .VK_8, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8_SNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SNORM, -1);
			case 1: return .('G', .VK_8, .SNORM, -1);
			case 2: return .('B', .VK_8, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8_USCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .USCALED, -1);
			case 1: return .('G', .VK_8, .USCALED, -1);
			case 2: return .('B', .VK_8, .USCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8_SSCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SSCALED, -1);
			case 1: return .('G', .VK_8, .SSCALED, -1);
			case 2: return .('B', .VK_8, .SSCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .UINT, -1);
			case 1: return .('G', .VK_8, .UINT, -1);
			case 2: return .('B', .VK_8, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SINT, -1);
			case 1: return .('G', .VK_8, .SINT, -1);
			case 2: return .('B', .VK_8, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8_SRGB:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SRGB, -1);
			case 1: return .('G', .VK_8, .SRGB, -1);
			case 2: return .('B', .VK_8, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8_UNORM:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .UNORM, -1);
			case 1: return .('G', .VK_8, .UNORM, -1);
			case 2: return .('R', .VK_8, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8_SNORM:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .SNORM, -1);
			case 1: return .('G', .VK_8, .SNORM, -1);
			case 2: return .('R', .VK_8, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8_USCALED:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .USCALED, -1);
			case 1: return .('G', .VK_8, .USCALED, -1);
			case 2: return .('R', .VK_8, .USCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8_SSCALED:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .SSCALED, -1);
			case 1: return .('G', .VK_8, .SSCALED, -1);
			case 2: return .('R', .VK_8, .SSCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8_UINT:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .UINT, -1);
			case 1: return .('G', .VK_8, .UINT, -1);
			case 2: return .('R', .VK_8, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8_SINT:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .SINT, -1);
			case 1: return .('G', .VK_8, .SINT, -1);
			case 2: return .('R', .VK_8, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8_SRGB:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .SRGB, -1);
			case 1: return .('G', .VK_8, .SRGB, -1);
			case 2: return .('R', .VK_8, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8A8_UNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .UNORM, -1);
			case 1: return .('G', .VK_8, .UNORM, -1);
			case 2: return .('B', .VK_8, .UNORM, -1);
			case 3: return .('A', .VK_8, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8A8_SNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SNORM, -1);
			case 1: return .('G', .VK_8, .SNORM, -1);
			case 2: return .('B', .VK_8, .SNORM, -1);
			case 3: return .('A', .VK_8, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8A8_USCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .USCALED, -1);
			case 1: return .('G', .VK_8, .USCALED, -1);
			case 2: return .('B', .VK_8, .USCALED, -1);
			case 3: return .('A', .VK_8, .USCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8A8_SSCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SSCALED, -1);
			case 1: return .('G', .VK_8, .SSCALED, -1);
			case 2: return .('B', .VK_8, .SSCALED, -1);
			case 3: return .('A', .VK_8, .SSCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8A8_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .UINT, -1);
			case 1: return .('G', .VK_8, .UINT, -1);
			case 2: return .('B', .VK_8, .UINT, -1);
			case 3: return .('A', .VK_8, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8A8_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SINT, -1);
			case 1: return .('G', .VK_8, .SINT, -1);
			case 2: return .('B', .VK_8, .SINT, -1);
			case 3: return .('A', .VK_8, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R8G8B8A8_SRGB:
			switch (idx)
			{
			case 0: return .('R', .VK_8, .SRGB, -1);
			case 1: return .('G', .VK_8, .SRGB, -1);
			case 2: return .('B', .VK_8, .SRGB, -1);
			case 3: return .('A', .VK_8, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8A8_UNORM:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .UNORM, -1);
			case 1: return .('G', .VK_8, .UNORM, -1);
			case 2: return .('R', .VK_8, .UNORM, -1);
			case 3: return .('A', .VK_8, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8A8_SNORM:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .SNORM, -1);
			case 1: return .('G', .VK_8, .SNORM, -1);
			case 2: return .('R', .VK_8, .SNORM, -1);
			case 3: return .('A', .VK_8, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8A8_USCALED:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .USCALED, -1);
			case 1: return .('G', .VK_8, .USCALED, -1);
			case 2: return .('R', .VK_8, .USCALED, -1);
			case 3: return .('A', .VK_8, .USCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8A8_SSCALED:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .SSCALED, -1);
			case 1: return .('G', .VK_8, .SSCALED, -1);
			case 2: return .('R', .VK_8, .SSCALED, -1);
			case 3: return .('A', .VK_8, .SSCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8A8_UINT:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .UINT, -1);
			case 1: return .('G', .VK_8, .UINT, -1);
			case 2: return .('R', .VK_8, .UINT, -1);
			case 3: return .('A', .VK_8, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8A8_SINT:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .SINT, -1);
			case 1: return .('G', .VK_8, .SINT, -1);
			case 2: return .('R', .VK_8, .SINT, -1);
			case 3: return .('A', .VK_8, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8A8_SRGB:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .SRGB, -1);
			case 1: return .('G', .VK_8, .SRGB, -1);
			case 2: return .('R', .VK_8, .SRGB, -1);
			case 3: return .('A', .VK_8, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A8B8G8R8_UNORM_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_8, .UNORM, -1);
			case 1: return .('B', .VK_8, .UNORM, -1);
			case 2: return .('G', .VK_8, .UNORM, -1);
			case 3: return .('R', .VK_8, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A8B8G8R8_SNORM_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_8, .SNORM, -1);
			case 1: return .('B', .VK_8, .SNORM, -1);
			case 2: return .('G', .VK_8, .SNORM, -1);
			case 3: return .('R', .VK_8, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A8B8G8R8_USCALED_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_8, .USCALED, -1);
			case 1: return .('B', .VK_8, .USCALED, -1);
			case 2: return .('G', .VK_8, .USCALED, -1);
			case 3: return .('R', .VK_8, .USCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A8B8G8R8_SSCALED_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_8, .SSCALED, -1);
			case 1: return .('B', .VK_8, .SSCALED, -1);
			case 2: return .('G', .VK_8, .SSCALED, -1);
			case 3: return .('R', .VK_8, .SSCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A8B8G8R8_UINT_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_8, .UINT, -1);
			case 1: return .('B', .VK_8, .UINT, -1);
			case 2: return .('G', .VK_8, .UINT, -1);
			case 3: return .('R', .VK_8, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A8B8G8R8_SINT_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_8, .SINT, -1);
			case 1: return .('B', .VK_8, .SINT, -1);
			case 2: return .('G', .VK_8, .SINT, -1);
			case 3: return .('R', .VK_8, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A8B8G8R8_SRGB_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_8, .SRGB, -1);
			case 1: return .('B', .VK_8, .SRGB, -1);
			case 2: return .('G', .VK_8, .SRGB, -1);
			case 3: return .('R', .VK_8, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A2R10G10B10_UNORM_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_2, .UNORM, -1);
			case 1: return .('R', .VK_10, .UNORM, -1);
			case 2: return .('G', .VK_10, .UNORM, -1);
			case 3: return .('B', .VK_10, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A2R10G10B10_SNORM_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_2, .SNORM, -1);
			case 1: return .('R', .VK_10, .SNORM, -1);
			case 2: return .('G', .VK_10, .SNORM, -1);
			case 3: return .('B', .VK_10, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A2R10G10B10_USCALED_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_2, .USCALED, -1);
			case 1: return .('R', .VK_10, .USCALED, -1);
			case 2: return .('G', .VK_10, .USCALED, -1);
			case 3: return .('B', .VK_10, .USCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A2R10G10B10_SSCALED_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_2, .SSCALED, -1);
			case 1: return .('R', .VK_10, .SSCALED, -1);
			case 2: return .('G', .VK_10, .SSCALED, -1);
			case 3: return .('B', .VK_10, .SSCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A2R10G10B10_UINT_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_2, .UINT, -1);
			case 1: return .('R', .VK_10, .UINT, -1);
			case 2: return .('G', .VK_10, .UINT, -1);
			case 3: return .('B', .VK_10, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A2R10G10B10_SINT_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_2, .SINT, -1);
			case 1: return .('R', .VK_10, .SINT, -1);
			case 2: return .('G', .VK_10, .SINT, -1);
			case 3: return .('B', .VK_10, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A2B10G10R10_UNORM_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_2, .UNORM, -1);
			case 1: return .('B', .VK_10, .UNORM, -1);
			case 2: return .('G', .VK_10, .UNORM, -1);
			case 3: return .('R', .VK_10, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A2B10G10R10_SNORM_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_2, .SNORM, -1);
			case 1: return .('B', .VK_10, .SNORM, -1);
			case 2: return .('G', .VK_10, .SNORM, -1);
			case 3: return .('R', .VK_10, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A2B10G10R10_USCALED_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_2, .USCALED, -1);
			case 1: return .('B', .VK_10, .USCALED, -1);
			case 2: return .('G', .VK_10, .USCALED, -1);
			case 3: return .('R', .VK_10, .USCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A2B10G10R10_SSCALED_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_2, .SSCALED, -1);
			case 1: return .('B', .VK_10, .SSCALED, -1);
			case 2: return .('G', .VK_10, .SSCALED, -1);
			case 3: return .('R', .VK_10, .SSCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A2B10G10R10_UINT_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_2, .UINT, -1);
			case 1: return .('B', .VK_10, .UINT, -1);
			case 2: return .('G', .VK_10, .UINT, -1);
			case 3: return .('R', .VK_10, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A2B10G10R10_SINT_PACK32:
			switch (idx)
			{
			case 0: return .('A', .VK_2, .SINT, -1);
			case 1: return .('B', .VK_10, .SINT, -1);
			case 2: return .('G', .VK_10, .SINT, -1);
			case 3: return .('R', .VK_10, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16_UNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16_SNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16_USCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .USCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16_SSCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SSCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16_SFLOAT:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16_UNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .UNORM, -1);
			case 1: return .('G', .VK_16, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16_SNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SNORM, -1);
			case 1: return .('G', .VK_16, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16_USCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .USCALED, -1);
			case 1: return .('G', .VK_16, .USCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16_SSCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SSCALED, -1);
			case 1: return .('G', .VK_16, .SSCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .UINT, -1);
			case 1: return .('G', .VK_16, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SINT, -1);
			case 1: return .('G', .VK_16, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16_SFLOAT:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SFLOAT, -1);
			case 1: return .('G', .VK_16, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16_UNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .UNORM, -1);
			case 1: return .('G', .VK_16, .UNORM, -1);
			case 2: return .('B', .VK_16, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16_SNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SNORM, -1);
			case 1: return .('G', .VK_16, .SNORM, -1);
			case 2: return .('B', .VK_16, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16_USCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .USCALED, -1);
			case 1: return .('G', .VK_16, .USCALED, -1);
			case 2: return .('B', .VK_16, .USCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16_SSCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SSCALED, -1);
			case 1: return .('G', .VK_16, .SSCALED, -1);
			case 2: return .('B', .VK_16, .SSCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .UINT, -1);
			case 1: return .('G', .VK_16, .UINT, -1);
			case 2: return .('B', .VK_16, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SINT, -1);
			case 1: return .('G', .VK_16, .SINT, -1);
			case 2: return .('B', .VK_16, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16_SFLOAT:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SFLOAT, -1);
			case 1: return .('G', .VK_16, .SFLOAT, -1);
			case 2: return .('B', .VK_16, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16A16_UNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .UNORM, -1);
			case 1: return .('G', .VK_16, .UNORM, -1);
			case 2: return .('B', .VK_16, .UNORM, -1);
			case 3: return .('A', .VK_16, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16A16_SNORM:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SNORM, -1);
			case 1: return .('G', .VK_16, .SNORM, -1);
			case 2: return .('B', .VK_16, .SNORM, -1);
			case 3: return .('A', .VK_16, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16A16_USCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .USCALED, -1);
			case 1: return .('G', .VK_16, .USCALED, -1);
			case 2: return .('B', .VK_16, .USCALED, -1);
			case 3: return .('A', .VK_16, .USCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16A16_SSCALED:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SSCALED, -1);
			case 1: return .('G', .VK_16, .SSCALED, -1);
			case 2: return .('B', .VK_16, .SSCALED, -1);
			case 3: return .('A', .VK_16, .SSCALED, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16A16_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .UINT, -1);
			case 1: return .('G', .VK_16, .UINT, -1);
			case 2: return .('B', .VK_16, .UINT, -1);
			case 3: return .('A', .VK_16, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16A16_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SINT, -1);
			case 1: return .('G', .VK_16, .SINT, -1);
			case 2: return .('B', .VK_16, .SINT, -1);
			case 3: return .('A', .VK_16, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16B16A16_SFLOAT:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SFLOAT, -1);
			case 1: return .('G', .VK_16, .SFLOAT, -1);
			case 2: return .('B', .VK_16, .SFLOAT, -1);
			case 3: return .('A', .VK_16, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R32_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_32, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R32_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_32, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R32_SFLOAT:
			switch (idx)
			{
			case 0: return .('R', .VK_32, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R32G32_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_32, .UINT, -1);
			case 1: return .('G', .VK_32, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R32G32_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_32, .SINT, -1);
			case 1: return .('G', .VK_32, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R32G32_SFLOAT:
			switch (idx)
			{
			case 0: return .('R', .VK_32, .SFLOAT, -1);
			case 1: return .('G', .VK_32, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R32G32B32_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_32, .UINT, -1);
			case 1: return .('G', .VK_32, .UINT, -1);
			case 2: return .('B', .VK_32, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R32G32B32_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_32, .SINT, -1);
			case 1: return .('G', .VK_32, .SINT, -1);
			case 2: return .('B', .VK_32, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R32G32B32_SFLOAT:
			switch (idx)
			{
			case 0: return .('R', .VK_32, .SFLOAT, -1);
			case 1: return .('G', .VK_32, .SFLOAT, -1);
			case 2: return .('B', .VK_32, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R32G32B32A32_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_32, .UINT, -1);
			case 1: return .('G', .VK_32, .UINT, -1);
			case 2: return .('B', .VK_32, .UINT, -1);
			case 3: return .('A', .VK_32, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R32G32B32A32_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_32, .SINT, -1);
			case 1: return .('G', .VK_32, .SINT, -1);
			case 2: return .('B', .VK_32, .SINT, -1);
			case 3: return .('A', .VK_32, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R32G32B32A32_SFLOAT:
			switch (idx)
			{
			case 0: return .('R', .VK_32, .SFLOAT, -1);
			case 1: return .('G', .VK_32, .SFLOAT, -1);
			case 2: return .('B', .VK_32, .SFLOAT, -1);
			case 3: return .('A', .VK_32, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R64_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_64, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R64_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_64, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R64_SFLOAT:
			switch (idx)
			{
			case 0: return .('R', .VK_64, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R64G64_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_64, .UINT, -1);
			case 1: return .('G', .VK_64, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R64G64_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_64, .SINT, -1);
			case 1: return .('G', .VK_64, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R64G64_SFLOAT:
			switch (idx)
			{
			case 0: return .('R', .VK_64, .SFLOAT, -1);
			case 1: return .('G', .VK_64, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R64G64B64_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_64, .UINT, -1);
			case 1: return .('G', .VK_64, .UINT, -1);
			case 2: return .('B', .VK_64, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R64G64B64_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_64, .SINT, -1);
			case 1: return .('G', .VK_64, .SINT, -1);
			case 2: return .('B', .VK_64, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R64G64B64_SFLOAT:
			switch (idx)
			{
			case 0: return .('R', .VK_64, .SFLOAT, -1);
			case 1: return .('G', .VK_64, .SFLOAT, -1);
			case 2: return .('B', .VK_64, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R64G64B64A64_UINT:
			switch (idx)
			{
			case 0: return .('R', .VK_64, .UINT, -1);
			case 1: return .('G', .VK_64, .UINT, -1);
			case 2: return .('B', .VK_64, .UINT, -1);
			case 3: return .('A', .VK_64, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R64G64B64A64_SINT:
			switch (idx)
			{
			case 0: return .('R', .VK_64, .SINT, -1);
			case 1: return .('G', .VK_64, .SINT, -1);
			case 2: return .('B', .VK_64, .SINT, -1);
			case 3: return .('A', .VK_64, .SINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R64G64B64A64_SFLOAT:
			switch (idx)
			{
			case 0: return .('R', .VK_64, .SFLOAT, -1);
			case 1: return .('G', .VK_64, .SFLOAT, -1);
			case 2: return .('B', .VK_64, .SFLOAT, -1);
			case 3: return .('A', .VK_64, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B10G11R11_UFLOAT_PACK32:
			switch (idx)
			{
			case 0: return .('B', .VK_10, .UFLOAT, -1);
			case 1: return .('G', .VK_11, .UFLOAT, -1);
			case 2: return .('R', .VK_11, .UFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .E5B9G9R9_UFLOAT_PACK32:
			switch (idx)
			{
			case 0: return .('B', .VK_9, .UFLOAT, -1);
			case 1: return .('G', .VK_9, .UFLOAT, -1);
			case 2: return .('R', .VK_9, .UFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .D16_UNORM:
			switch (idx)
			{
			case 0: return .('D', .VK_16, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .X8_D24_UNORM_PACK32:
			switch (idx)
			{
			case 0: return .('D', .VK_24, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .D32_SFLOAT:
			switch (idx)
			{
			case 0: return .('D', .VK_32, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .S8_UINT:
			switch (idx)
			{
			case 0: return .('S', .VK_8, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .D16_UNORM_S8_UINT:
			switch (idx)
			{
			case 0: return .('D', .VK_16, .UNORM, -1);
			case 1: return .('S', .VK_8, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .D24_UNORM_S8_UINT:
			switch (idx)
			{
			case 0: return .('D', .VK_24, .UNORM, -1);
			case 1: return .('S', .VK_8, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .D32_SFLOAT_S8_UINT:
			switch (idx)
			{
			case 0: return .('D', .VK_32, .SFLOAT, -1);
			case 1: return .('S', .VK_8, .UINT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC1_RGB_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC1_RGB_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC1_RGBA_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC1_RGBA_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC2_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC2_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC3_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC3_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC4_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC4_SNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC5_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC5_SNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SNORM, -1);
			case 1: return .('G', .COMPRESSED, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC6H_UFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .UFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .UFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC6H_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC7_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .BC7_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ETC2_R8G8B8_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ETC2_R8G8B8_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ETC2_R8G8B8A1_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ETC2_R8G8B8A1_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ETC2_R8G8B8A8_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ETC2_R8G8B8A8_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .EAC_R11_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .VK_11, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .EAC_R11_SNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .VK_11, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .EAC_R11G11_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .VK_11, .UNORM, -1);
			case 1: return .('G', .VK_11, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .EAC_R11G11_SNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .VK_11, .SNORM, -1);
			case 1: return .('G', .VK_11, .SNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_4x4_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_4x4_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_5x4_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_5x4_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_5x5_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_5x5_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_6x5_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_6x5_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_6x6_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_6x6_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_8x5_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_8x5_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_8x6_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_8x6_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_8x8_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_8x8_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_10x5_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_10x5_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_10x6_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_10x6_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_10x8_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_10x8_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_10x10_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_10x10_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_12x10_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_12x10_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_12x12_UNORM_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_12x12_SRGB_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .G8B8G8R8_422_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_8, .UNORM, -1);
			case 1: return .('B', .VK_8, .UNORM, -1);
			case 2: return .('G', .VK_8, .UNORM, -1);
			case 3: return .('R', .VK_8, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B8G8R8G8_422_UNORM:
			switch (idx)
			{
			case 0: return .('B', .VK_8, .UNORM, -1);
			case 1: return .('G', .VK_8, .UNORM, -1);
			case 2: return .('R', .VK_8, .UNORM, -1);
			case 3: return .('G', .VK_8, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .G8_B8_R8_3PLANE_420_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_8, .UNORM, 0);
			case 1: return .('B', .VK_8, .UNORM, 1);
			case 2: return .('R', .VK_8, .UNORM, 2);
			default: Runtime.FatalError("No such component");
			}
		case .G8_B8R8_2PLANE_420_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_8, .UNORM, 0);
			case 1: return .('B', .VK_8, .UNORM, 1);
			case 2: return .('R', .VK_8, .UNORM, 1);
			default: Runtime.FatalError("No such component");
			}
		case .G8_B8_R8_3PLANE_422_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_8, .UNORM, 0);
			case 1: return .('B', .VK_8, .UNORM, 1);
			case 2: return .('R', .VK_8, .UNORM, 2);
			default: Runtime.FatalError("No such component");
			}
		case .G8_B8R8_2PLANE_422_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_8, .UNORM, 0);
			case 1: return .('B', .VK_8, .UNORM, 1);
			case 2: return .('R', .VK_8, .UNORM, 1);
			default: Runtime.FatalError("No such component");
			}
		case .G8_B8_R8_3PLANE_444_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_8, .UNORM, 0);
			case 1: return .('B', .VK_8, .UNORM, 1);
			case 2: return .('R', .VK_8, .UNORM, 2);
			default: Runtime.FatalError("No such component");
			}
		case .R10X6_UNORM_PACK16:
			switch (idx)
			{
			case 0: return .('R', .VK_10, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R10X6G10X6_UNORM_2PACK16:
			switch (idx)
			{
			case 0: return .('R', .VK_10, .UNORM, -1);
			case 1: return .('G', .VK_10, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R10X6G10X6B10X6A10X6_UNORM_4PACK16:
			switch (idx)
			{
			case 0: return .('R', .VK_10, .UNORM, -1);
			case 1: return .('G', .VK_10, .UNORM, -1);
			case 2: return .('B', .VK_10, .UNORM, -1);
			case 3: return .('A', .VK_10, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .G10X6B10X6G10X6R10X6_422_UNORM_4PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_10, .UNORM, -1);
			case 1: return .('B', .VK_10, .UNORM, -1);
			case 2: return .('G', .VK_10, .UNORM, -1);
			case 3: return .('R', .VK_10, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B10X6G10X6R10X6G10X6_422_UNORM_4PACK16:
			switch (idx)
			{
			case 0: return .('B', .VK_10, .UNORM, -1);
			case 1: return .('G', .VK_10, .UNORM, -1);
			case 2: return .('R', .VK_10, .UNORM, -1);
			case 3: return .('G', .VK_10, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_10, .UNORM, 0);
			case 1: return .('B', .VK_10, .UNORM, 1);
			case 2: return .('R', .VK_10, .UNORM, 2);
			default: Runtime.FatalError("No such component");
			}
		case .G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_10, .UNORM, 0);
			case 1: return .('B', .VK_10, .UNORM, 1);
			case 2: return .('R', .VK_10, .UNORM, 1);
			default: Runtime.FatalError("No such component");
			}
		case .G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_10, .UNORM, 0);
			case 1: return .('B', .VK_10, .UNORM, 1);
			case 2: return .('R', .VK_10, .UNORM, 2);
			default: Runtime.FatalError("No such component");
			}
		case .G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_10, .UNORM, 0);
			case 1: return .('B', .VK_10, .UNORM, 1);
			case 2: return .('R', .VK_10, .UNORM, 1);
			default: Runtime.FatalError("No such component");
			}
		case .G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_10, .UNORM, 0);
			case 1: return .('B', .VK_10, .UNORM, 1);
			case 2: return .('R', .VK_10, .UNORM, 2);
			default: Runtime.FatalError("No such component");
			}
		case .R12X4_UNORM_PACK16:
			switch (idx)
			{
			case 0: return .('R', .VK_12, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R12X4G12X4_UNORM_2PACK16:
			switch (idx)
			{
			case 0: return .('R', .VK_12, .UNORM, -1);
			case 1: return .('G', .VK_12, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R12X4G12X4B12X4A12X4_UNORM_4PACK16:
			switch (idx)
			{
			case 0: return .('R', .VK_12, .UNORM, -1);
			case 1: return .('G', .VK_12, .UNORM, -1);
			case 2: return .('B', .VK_12, .UNORM, -1);
			case 3: return .('A', .VK_12, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .G12X4B12X4G12X4R12X4_422_UNORM_4PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_12, .UNORM, -1);
			case 1: return .('B', .VK_12, .UNORM, -1);
			case 2: return .('G', .VK_12, .UNORM, -1);
			case 3: return .('R', .VK_12, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B12X4G12X4R12X4G12X4_422_UNORM_4PACK16:
			switch (idx)
			{
			case 0: return .('B', .VK_12, .UNORM, -1);
			case 1: return .('G', .VK_12, .UNORM, -1);
			case 2: return .('R', .VK_12, .UNORM, -1);
			case 3: return .('G', .VK_12, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_12, .UNORM, 0);
			case 1: return .('B', .VK_12, .UNORM, 1);
			case 2: return .('R', .VK_12, .UNORM, 2);
			default: Runtime.FatalError("No such component");
			}
		case .G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_12, .UNORM, 0);
			case 1: return .('B', .VK_12, .UNORM, 1);
			case 2: return .('R', .VK_12, .UNORM, 1);
			default: Runtime.FatalError("No such component");
			}
		case .G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_12, .UNORM, 0);
			case 1: return .('B', .VK_12, .UNORM, 1);
			case 2: return .('R', .VK_12, .UNORM, 2);
			default: Runtime.FatalError("No such component");
			}
		case .G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_12, .UNORM, 0);
			case 1: return .('B', .VK_12, .UNORM, 1);
			case 2: return .('R', .VK_12, .UNORM, 1);
			default: Runtime.FatalError("No such component");
			}
		case .G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_12, .UNORM, 0);
			case 1: return .('B', .VK_12, .UNORM, 1);
			case 2: return .('R', .VK_12, .UNORM, 2);
			default: Runtime.FatalError("No such component");
			}
		case .G16B16G16R16_422_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_16, .UNORM, -1);
			case 1: return .('B', .VK_16, .UNORM, -1);
			case 2: return .('G', .VK_16, .UNORM, -1);
			case 3: return .('R', .VK_16, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .B16G16R16G16_422_UNORM:
			switch (idx)
			{
			case 0: return .('B', .VK_16, .UNORM, -1);
			case 1: return .('G', .VK_16, .UNORM, -1);
			case 2: return .('R', .VK_16, .UNORM, -1);
			case 3: return .('G', .VK_16, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .G16_B16_R16_3PLANE_420_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_16, .UNORM, 0);
			case 1: return .('B', .VK_16, .UNORM, 1);
			case 2: return .('R', .VK_16, .UNORM, 2);
			default: Runtime.FatalError("No such component");
			}
		case .G16_B16R16_2PLANE_420_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_16, .UNORM, 0);
			case 1: return .('B', .VK_16, .UNORM, 1);
			case 2: return .('R', .VK_16, .UNORM, 1);
			default: Runtime.FatalError("No such component");
			}
		case .G16_B16_R16_3PLANE_422_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_16, .UNORM, 0);
			case 1: return .('B', .VK_16, .UNORM, 1);
			case 2: return .('R', .VK_16, .UNORM, 2);
			default: Runtime.FatalError("No such component");
			}
		case .G16_B16R16_2PLANE_422_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_16, .UNORM, 0);
			case 1: return .('B', .VK_16, .UNORM, 1);
			case 2: return .('R', .VK_16, .UNORM, 1);
			default: Runtime.FatalError("No such component");
			}
		case .G16_B16_R16_3PLANE_444_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_16, .UNORM, 0);
			case 1: return .('B', .VK_16, .UNORM, 1);
			case 2: return .('R', .VK_16, .UNORM, 2);
			default: Runtime.FatalError("No such component");
			}
		case .PVRTC1_2BPP_UNORM_BLOCK_IMG:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .PVRTC1_4BPP_UNORM_BLOCK_IMG:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .PVRTC2_2BPP_UNORM_BLOCK_IMG:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .PVRTC2_4BPP_UNORM_BLOCK_IMG:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .UNORM, -1);
			case 1: return .('G', .COMPRESSED, .UNORM, -1);
			case 2: return .('B', .COMPRESSED, .UNORM, -1);
			case 3: return .('A', .COMPRESSED, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .PVRTC1_2BPP_SRGB_BLOCK_IMG:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .PVRTC1_4BPP_SRGB_BLOCK_IMG:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .PVRTC2_2BPP_SRGB_BLOCK_IMG:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .PVRTC2_4BPP_SRGB_BLOCK_IMG:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SRGB, -1);
			case 1: return .('G', .COMPRESSED, .SRGB, -1);
			case 2: return .('B', .COMPRESSED, .SRGB, -1);
			case 3: return .('A', .COMPRESSED, .SRGB, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_4x4_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_5x4_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_5x5_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_6x5_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_6x6_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_8x5_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_8x6_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_8x8_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_10x5_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_10x6_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_10x8_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_10x10_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_12x10_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .ASTC_12x12_SFLOAT_BLOCK:
			switch (idx)
			{
			case 0: return .('R', .COMPRESSED, .SFLOAT, -1);
			case 1: return .('G', .COMPRESSED, .SFLOAT, -1);
			case 2: return .('B', .COMPRESSED, .SFLOAT, -1);
			case 3: return .('A', .COMPRESSED, .SFLOAT, -1);
			default: Runtime.FatalError("No such component");
			}
		case .G8_B8R8_2PLANE_444_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_8, .UNORM, 0);
			case 1: return .('B', .VK_8, .UNORM, 1);
			case 2: return .('R', .VK_8, .UNORM, 1);
			default: Runtime.FatalError("No such component");
			}
		case .G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_10, .UNORM, 0);
			case 1: return .('B', .VK_10, .UNORM, 1);
			case 2: return .('R', .VK_10, .UNORM, 1);
			default: Runtime.FatalError("No such component");
			}
		case .G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .('G', .VK_12, .UNORM, 0);
			case 1: return .('B', .VK_12, .UNORM, 1);
			case 2: return .('R', .VK_12, .UNORM, 1);
			default: Runtime.FatalError("No such component");
			}
		case .G16_B16R16_2PLANE_444_UNORM:
			switch (idx)
			{
			case 0: return .('G', .VK_16, .UNORM, 0);
			case 1: return .('B', .VK_16, .UNORM, 1);
			case 2: return .('R', .VK_16, .UNORM, 1);
			default: Runtime.FatalError("No such component");
			}
		case .A4R4G4B4_UNORM_PACK16:
			switch (idx)
			{
			case 0: return .('A', .VK_4, .UNORM, -1);
			case 1: return .('R', .VK_4, .UNORM, -1);
			case 2: return .('G', .VK_4, .UNORM, -1);
			case 3: return .('B', .VK_4, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .A4B4G4R4_UNORM_PACK16:
			switch (idx)
			{
			case 0: return .('A', .VK_4, .UNORM, -1);
			case 1: return .('B', .VK_4, .UNORM, -1);
			case 2: return .('G', .VK_4, .UNORM, -1);
			case 3: return .('R', .VK_4, .UNORM, -1);
			default: Runtime.FatalError("No such component");
			}
		case .R16G16_SFIXED5_NV:
			switch (idx)
			{
			case 0: return .('R', .VK_16, .SFIXED5, -1);
			case 1: return .('G', .VK_16, .SFIXED5, -1);
			default: Runtime.FatalError("No such component");
			}
		}
	}

	public ComponentMetadata GetComponent(char8 name)
	{
		switch (this)
		{
		case .UNDEFINED: Runtime.FatalError("Attempted to access format metadata for VK_FORMAT_UNDEFINED");
		case .R4G4_UNORM_PACK8:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R4G4B4A4_UNORM_PACK16:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B4G4R4A4_UNORM_PACK16:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R5G6B5_UNORM_PACK16:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .B5G6R5_UNORM_PACK16:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R5G5B5A1_UNORM_PACK16:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B5G5R5A1_UNORM_PACK16:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A1R5G5B5_UNORM_PACK16:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'R': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'B': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A1B5G5R5_UNORM_PACK16:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A8_UNORM:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8_UNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8_SNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8_USCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8_SSCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8_SRGB:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8_UNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8_SNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8_USCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8_SSCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8_SRGB:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8_UNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8_SNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8_USCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8_SSCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8_SRGB:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8_UNORM:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8_SNORM:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8_USCALED:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8_SSCALED:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8_UINT:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8_SINT:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8_SRGB:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8A8_UNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8A8_SNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8A8_USCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8A8_SSCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8A8_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8A8_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R8G8B8A8_SRGB:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8A8_UNORM:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8A8_SNORM:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8A8_USCALED:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8A8_SSCALED:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8A8_UINT:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8A8_SINT:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8A8_SRGB:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A8B8G8R8_UNORM_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A8B8G8R8_SNORM_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A8B8G8R8_USCALED_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A8B8G8R8_SSCALED_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A8B8G8R8_UINT_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A8B8G8R8_SINT_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A8B8G8R8_SRGB_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A2R10G10B10_UNORM_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'R': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'B': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A2R10G10B10_SNORM_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'R': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'B': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A2R10G10B10_USCALED_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'R': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'B': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A2R10G10B10_SSCALED_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'R': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'B': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A2R10G10B10_UINT_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'R': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'B': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A2R10G10B10_SINT_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'R': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'B': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A2B10G10R10_UNORM_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A2B10G10R10_SNORM_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A2B10G10R10_USCALED_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A2B10G10R10_SSCALED_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A2B10G10R10_UINT_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A2B10G10R10_SINT_PACK32:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16_UNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16_SNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16_USCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16_SSCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16_SFLOAT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16_UNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16_SNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16_USCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16_SSCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16_SFLOAT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16_UNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16_SNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16_USCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16_SSCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16_SFLOAT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16A16_UNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16A16_SNORM:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16A16_USCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16A16_SSCALED:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16A16_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16A16_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16B16A16_SFLOAT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R32_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R32_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R32_SFLOAT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R32G32_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R32G32_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R32G32_SFLOAT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R32G32B32_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R32G32B32_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R32G32B32_SFLOAT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R32G32B32A32_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R32G32B32A32_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R32G32B32A32_SFLOAT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R64_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R64_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R64_SFLOAT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R64G64_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R64G64_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R64G64_SFLOAT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R64G64B64_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R64G64B64_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R64G64B64_SFLOAT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R64G64B64A64_UINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R64G64B64A64_SINT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R64G64B64A64_SFLOAT:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B10G11R11_UFLOAT_PACK32:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .E5B9G9R9_UFLOAT_PACK32:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .D16_UNORM:
			switch (name)
			{
			case 'D': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .X8_D24_UNORM_PACK32:
			switch (name)
			{
			case 'D': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .D32_SFLOAT:
			switch (name)
			{
			case 'D': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .S8_UINT:
			switch (name)
			{
			case 'S': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .D16_UNORM_S8_UINT:
			switch (name)
			{
			case 'D': return [Inline]GetComponent(0);
			case 'S': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .D24_UNORM_S8_UINT:
			switch (name)
			{
			case 'D': return [Inline]GetComponent(0);
			case 'S': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .D32_SFLOAT_S8_UINT:
			switch (name)
			{
			case 'D': return [Inline]GetComponent(0);
			case 'S': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC1_RGB_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC1_RGB_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC1_RGBA_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC1_RGBA_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC2_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC2_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC3_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC3_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC4_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC4_SNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC5_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC5_SNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC6H_UFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC6H_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC7_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .BC7_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ETC2_R8G8B8_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .ETC2_R8G8B8_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .ETC2_R8G8B8A1_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ETC2_R8G8B8A1_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ETC2_R8G8B8A8_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ETC2_R8G8B8A8_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .EAC_R11_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .EAC_R11_SNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .EAC_R11G11_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .EAC_R11G11_SNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_4x4_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_4x4_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_5x4_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_5x4_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_5x5_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_5x5_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_6x5_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_6x5_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_6x6_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_6x6_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_8x5_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_8x5_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_8x6_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_8x6_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_8x8_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_8x8_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_10x5_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_10x5_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_10x6_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_10x6_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_10x8_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_10x8_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_10x10_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_10x10_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_12x10_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_12x10_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_12x12_UNORM_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_12x12_SRGB_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .G8B8G8R8_422_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B8G8R8G8_422_UNORM:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G8_B8_R8_3PLANE_420_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G8_B8R8_2PLANE_420_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G8_B8_R8_3PLANE_422_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G8_B8R8_2PLANE_422_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G8_B8_R8_3PLANE_444_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R10X6_UNORM_PACK16:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R10X6G10X6_UNORM_2PACK16:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R10X6G10X6B10X6A10X6_UNORM_4PACK16:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .G10X6B10X6G10X6R10X6_422_UNORM_4PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B10X6G10X6R10X6G10X6_422_UNORM_4PACK16:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .R12X4_UNORM_PACK16:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			default: Runtime.FatalError("Index out of range");
			}
		case .R12X4G12X4_UNORM_2PACK16:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		case .R12X4G12X4B12X4A12X4_UNORM_4PACK16:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .G12X4B12X4G12X4R12X4_422_UNORM_4PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B12X4G12X4R12X4G12X4_422_UNORM_4PACK16:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G16B16G16R16_422_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .B16G16R16G16_422_UNORM:
			switch (name)
			{
			case 'B': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G16_B16_R16_3PLANE_420_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G16_B16R16_2PLANE_420_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G16_B16_R16_3PLANE_422_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G16_B16R16_2PLANE_422_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G16_B16_R16_3PLANE_444_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .PVRTC1_2BPP_UNORM_BLOCK_IMG:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .PVRTC1_4BPP_UNORM_BLOCK_IMG:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .PVRTC2_2BPP_UNORM_BLOCK_IMG:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .PVRTC2_4BPP_UNORM_BLOCK_IMG:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .PVRTC1_2BPP_SRGB_BLOCK_IMG:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .PVRTC1_4BPP_SRGB_BLOCK_IMG:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .PVRTC2_2BPP_SRGB_BLOCK_IMG:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .PVRTC2_4BPP_SRGB_BLOCK_IMG:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_4x4_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_5x4_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_5x5_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_6x5_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_6x6_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_8x5_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_8x6_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_8x8_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_10x5_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_10x6_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_10x8_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_10x10_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_12x10_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .ASTC_12x12_SFLOAT_BLOCK:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			case 'B': return [Inline]GetComponent(2);
			case 'A': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .G8_B8R8_2PLANE_444_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .G16_B16R16_2PLANE_444_UNORM:
			switch (name)
			{
			case 'G': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'R': return [Inline]GetComponent(2);
			default: Runtime.FatalError("Index out of range");
			}
		case .A4R4G4B4_UNORM_PACK16:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'R': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'B': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .A4B4G4R4_UNORM_PACK16:
			switch (name)
			{
			case 'A': return [Inline]GetComponent(0);
			case 'B': return [Inline]GetComponent(1);
			case 'G': return [Inline]GetComponent(2);
			case 'R': return [Inline]GetComponent(3);
			default: Runtime.FatalError("Index out of range");
			}
		case .R16G16_SFIXED5_NV:
			switch (name)
			{
			case 'R': return [Inline]GetComponent(0);
			case 'G': return [Inline]GetComponent(1);
			default: Runtime.FatalError("Index out of range");
			}
		}
	}

	public int PlaneCount
	{
		get
		{
			switch (this)
			{
			case .UNDEFINED: Runtime.FatalError("Attempted to access format metadata for VK_FORMAT_UNDEFINED");
			case .G8_B8_R8_3PLANE_420_UNORM: return 3;
			case .G8_B8R8_2PLANE_420_UNORM: return 2;
			case .G8_B8_R8_3PLANE_422_UNORM: return 3;
			case .G8_B8R8_2PLANE_422_UNORM: return 2;
			case .G8_B8_R8_3PLANE_444_UNORM: return 3;
			case .G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: return 3;
			case .G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: return 2;
			case .G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: return 3;
			case .G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: return 2;
			case .G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: return 3;
			case .G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: return 3;
			case .G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: return 2;
			case .G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: return 3;
			case .G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: return 2;
			case .G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: return 3;
			case .G16_B16_R16_3PLANE_420_UNORM: return 3;
			case .G16_B16R16_2PLANE_420_UNORM: return 2;
			case .G16_B16_R16_3PLANE_422_UNORM: return 3;
			case .G16_B16R16_2PLANE_422_UNORM: return 2;
			case .G16_B16_R16_3PLANE_444_UNORM: return 3;
			case .G8_B8R8_2PLANE_444_UNORM: return 2;
			case .G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16: return 2;
			case .G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16: return 2;
			case .G16_B16R16_2PLANE_444_UNORM: return 2;
			default: return 0;
			}
		}
	}

	public PlaneMetadata GetPlane(int idx)
	{
		switch (this)
		{
		case .UNDEFINED: Runtime.FatalError("Attempted to access format metadata for VK_FORMAT_UNDEFINED");
		case .G8_B8_R8_3PLANE_420_UNORM:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R8_UNORM);
			case 1: return .(idx, 2, 2, .R8_UNORM);
			case 2: return .(idx, 2, 2, .R8_UNORM);
			default: Runtime.FatalError("Index out of range");
			}
		case .G8_B8R8_2PLANE_420_UNORM:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R8_UNORM);
			case 1: return .(idx, 2, 2, .R8G8_UNORM);
			default: Runtime.FatalError("Index out of range");
			}
		case .G8_B8_R8_3PLANE_422_UNORM:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R8_UNORM);
			case 1: return .(idx, 2, 1, .R8_UNORM);
			case 2: return .(idx, 2, 1, .R8_UNORM);
			default: Runtime.FatalError("Index out of range");
			}
		case .G8_B8R8_2PLANE_422_UNORM:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R8_UNORM);
			case 1: return .(idx, 2, 1, .R8G8_UNORM);
			default: Runtime.FatalError("Index out of range");
			}
		case .G8_B8_R8_3PLANE_444_UNORM:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R8_UNORM);
			case 1: return .(idx, 1, 1, .R8_UNORM);
			case 2: return .(idx, 1, 1, .R8_UNORM);
			default: Runtime.FatalError("Index out of range");
			}
		case .G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R10X6_UNORM_PACK16);
			case 1: return .(idx, 2, 2, .R10X6_UNORM_PACK16);
			case 2: return .(idx, 2, 2, .R10X6_UNORM_PACK16);
			default: Runtime.FatalError("Index out of range");
			}
		case .G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R10X6_UNORM_PACK16);
			case 1: return .(idx, 2, 2, .R10X6G10X6_UNORM_2PACK16);
			default: Runtime.FatalError("Index out of range");
			}
		case .G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R10X6_UNORM_PACK16);
			case 1: return .(idx, 2, 1, .R10X6_UNORM_PACK16);
			case 2: return .(idx, 2, 1, .R10X6_UNORM_PACK16);
			default: Runtime.FatalError("Index out of range");
			}
		case .G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R10X6_UNORM_PACK16);
			case 1: return .(idx, 2, 1, .R10X6G10X6_UNORM_2PACK16);
			default: Runtime.FatalError("Index out of range");
			}
		case .G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R10X6_UNORM_PACK16);
			case 1: return .(idx, 1, 1, .R10X6_UNORM_PACK16);
			case 2: return .(idx, 1, 1, .R10X6_UNORM_PACK16);
			default: Runtime.FatalError("Index out of range");
			}
		case .G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R12X4_UNORM_PACK16);
			case 1: return .(idx, 2, 2, .R12X4_UNORM_PACK16);
			case 2: return .(idx, 2, 2, .R12X4_UNORM_PACK16);
			default: Runtime.FatalError("Index out of range");
			}
		case .G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R12X4_UNORM_PACK16);
			case 1: return .(idx, 2, 2, .R12X4G12X4_UNORM_2PACK16);
			default: Runtime.FatalError("Index out of range");
			}
		case .G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R12X4_UNORM_PACK16);
			case 1: return .(idx, 2, 1, .R12X4_UNORM_PACK16);
			case 2: return .(idx, 2, 1, .R12X4_UNORM_PACK16);
			default: Runtime.FatalError("Index out of range");
			}
		case .G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R12X4_UNORM_PACK16);
			case 1: return .(idx, 2, 1, .R12X4G12X4_UNORM_2PACK16);
			default: Runtime.FatalError("Index out of range");
			}
		case .G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R12X4_UNORM_PACK16);
			case 1: return .(idx, 1, 1, .R12X4_UNORM_PACK16);
			case 2: return .(idx, 1, 1, .R12X4_UNORM_PACK16);
			default: Runtime.FatalError("Index out of range");
			}
		case .G16_B16_R16_3PLANE_420_UNORM:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R16_UNORM);
			case 1: return .(idx, 2, 2, .R16_UNORM);
			case 2: return .(idx, 2, 2, .R16_UNORM);
			default: Runtime.FatalError("Index out of range");
			}
		case .G16_B16R16_2PLANE_420_UNORM:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R16_UNORM);
			case 1: return .(idx, 2, 2, .R16G16_UNORM);
			default: Runtime.FatalError("Index out of range");
			}
		case .G16_B16_R16_3PLANE_422_UNORM:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R16_UNORM);
			case 1: return .(idx, 2, 1, .R16_UNORM);
			case 2: return .(idx, 2, 1, .R16_UNORM);
			default: Runtime.FatalError("Index out of range");
			}
		case .G16_B16R16_2PLANE_422_UNORM:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R16_UNORM);
			case 1: return .(idx, 2, 1, .R16G16_UNORM);
			default: Runtime.FatalError("Index out of range");
			}
		case .G16_B16_R16_3PLANE_444_UNORM:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R16_UNORM);
			case 1: return .(idx, 1, 1, .R16_UNORM);
			case 2: return .(idx, 1, 1, .R16_UNORM);
			default: Runtime.FatalError("Index out of range");
			}
		case .G8_B8R8_2PLANE_444_UNORM:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R8_UNORM);
			case 1: return .(idx, 1, 1, .R8G8_UNORM);
			default: Runtime.FatalError("Index out of range");
			}
		case .G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R10X6_UNORM_PACK16);
			case 1: return .(idx, 1, 1, .R10X6G10X6_UNORM_2PACK16);
			default: Runtime.FatalError("Index out of range");
			}
		case .G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R12X4_UNORM_PACK16);
			case 1: return .(idx, 1, 1, .R12X4G12X4_UNORM_2PACK16);
			default: Runtime.FatalError("Index out of range");
			}
		case .G16_B16R16_2PLANE_444_UNORM:
			switch (idx)
			{
			case 0: return .(idx, 1, 1, .R16_UNORM);
			case 1: return .(idx, 1, 1, .R16G16_UNORM);
			default: Runtime.FatalError("Index out of range");
			}
		default: Runtime.FatalError("Index out of range");
		}
	}
}

namespace Vulkan.Metadata;

static class VulkanCommandMetadata
{
	private static VkResult[?] vkCreateInstance__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateInstance => vkCreateInstance__successcodes;
	private static VkResult[?] vkCreateInstance__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInitializationFailed, .VkErrorLayerNotPresent, .VkErrorExtensionNotPresent, .VkErrorIncompatibleDriver);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateInstance => vkCreateInstance__errorcodes;
	private static VkResult[?] vkEnumeratePhysicalDevices__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkEnumeratePhysicalDevices => vkEnumeratePhysicalDevices__successcodes;
	private static VkResult[?] vkEnumeratePhysicalDevices__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInitializationFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkEnumeratePhysicalDevices => vkEnumeratePhysicalDevices__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceImageFormatProperties__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceImageFormatProperties => vkGetPhysicalDeviceImageFormatProperties__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceImageFormatProperties__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorFormatNotSupported);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceImageFormatProperties => vkGetPhysicalDeviceImageFormatProperties__errorcodes;
	private static VkResult[?] vkCreateDevice__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateDevice => vkCreateDevice__successcodes;
	private static VkResult[?] vkCreateDevice__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInitializationFailed, .VkErrorExtensionNotPresent, .VkErrorFeatureNotPresent, .VkErrorTooManyObjects, .VkErrorDeviceLost);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateDevice => vkCreateDevice__errorcodes;
	private static VkResult[?] vkEnumerateInstanceVersion__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkEnumerateInstanceVersion => vkEnumerateInstanceVersion__successcodes;
	private static VkResult[?] vkEnumerateInstanceVersion__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkEnumerateInstanceVersion => vkEnumerateInstanceVersion__errorcodes;
	private static VkResult[?] vkEnumerateInstanceLayerProperties__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkEnumerateInstanceLayerProperties => vkEnumerateInstanceLayerProperties__successcodes;
	private static VkResult[?] vkEnumerateInstanceLayerProperties__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkEnumerateInstanceLayerProperties => vkEnumerateInstanceLayerProperties__errorcodes;
	private static VkResult[?] vkEnumerateInstanceExtensionProperties__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkEnumerateInstanceExtensionProperties => vkEnumerateInstanceExtensionProperties__successcodes;
	private static VkResult[?] vkEnumerateInstanceExtensionProperties__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorLayerNotPresent);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkEnumerateInstanceExtensionProperties => vkEnumerateInstanceExtensionProperties__errorcodes;
	private static VkResult[?] vkEnumerateDeviceLayerProperties__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkEnumerateDeviceLayerProperties => vkEnumerateDeviceLayerProperties__successcodes;
	private static VkResult[?] vkEnumerateDeviceLayerProperties__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkEnumerateDeviceLayerProperties => vkEnumerateDeviceLayerProperties__errorcodes;
	private static VkResult[?] vkEnumerateDeviceExtensionProperties__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkEnumerateDeviceExtensionProperties => vkEnumerateDeviceExtensionProperties__successcodes;
	private static VkResult[?] vkEnumerateDeviceExtensionProperties__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorLayerNotPresent);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkEnumerateDeviceExtensionProperties => vkEnumerateDeviceExtensionProperties__errorcodes;
	private static VkResult[?] vkQueueSubmit__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkQueueSubmit => vkQueueSubmit__successcodes;
	private static VkResult[?] vkQueueSubmit__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkQueueSubmit => vkQueueSubmit__errorcodes;
	private static VkResult[?] vkQueueWaitIdle__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkQueueWaitIdle => vkQueueWaitIdle__successcodes;
	private static VkResult[?] vkQueueWaitIdle__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkQueueWaitIdle => vkQueueWaitIdle__errorcodes;
	private static VkResult[?] vkDeviceWaitIdle__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkDeviceWaitIdle => vkDeviceWaitIdle__successcodes;
	private static VkResult[?] vkDeviceWaitIdle__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkDeviceWaitIdle => vkDeviceWaitIdle__errorcodes;
	private static VkResult[?] vkAllocateMemory__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkAllocateMemory => vkAllocateMemory__successcodes;
	private static VkResult[?] vkAllocateMemory__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInvalidExternalHandle, .VkErrorInvalidOpaqueCaptureAddressKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkAllocateMemory => vkAllocateMemory__errorcodes;
	private static VkResult[?] vkMapMemory__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkMapMemory => vkMapMemory__successcodes;
	private static VkResult[?] vkMapMemory__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorMemoryMapFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkMapMemory => vkMapMemory__errorcodes;
	private static VkResult[?] vkFlushMappedMemoryRanges__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkFlushMappedMemoryRanges => vkFlushMappedMemoryRanges__successcodes;
	private static VkResult[?] vkFlushMappedMemoryRanges__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkFlushMappedMemoryRanges => vkFlushMappedMemoryRanges__errorcodes;
	private static VkResult[?] vkInvalidateMappedMemoryRanges__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkInvalidateMappedMemoryRanges => vkInvalidateMappedMemoryRanges__successcodes;
	private static VkResult[?] vkInvalidateMappedMemoryRanges__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkInvalidateMappedMemoryRanges => vkInvalidateMappedMemoryRanges__errorcodes;
	private static VkResult[?] vkBindBufferMemory__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkBindBufferMemory => vkBindBufferMemory__successcodes;
	private static VkResult[?] vkBindBufferMemory__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInvalidOpaqueCaptureAddressKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkBindBufferMemory => vkBindBufferMemory__errorcodes;
	private static VkResult[?] vkBindImageMemory__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkBindImageMemory => vkBindImageMemory__successcodes;
	private static VkResult[?] vkBindImageMemory__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkBindImageMemory => vkBindImageMemory__errorcodes;
	private static VkResult[?] vkQueueBindSparse__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkQueueBindSparse => vkQueueBindSparse__successcodes;
	private static VkResult[?] vkQueueBindSparse__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkQueueBindSparse => vkQueueBindSparse__errorcodes;
	private static VkQueueFlags vkQueueBindSparse__queues = .SparseBinding;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkQueueBindSparse => vkQueueBindSparse__queues;
	private static VkResult[?] vkCreateFence__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateFence => vkCreateFence__successcodes;
	private static VkResult[?] vkCreateFence__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateFence => vkCreateFence__errorcodes;
	private static VkResult[?] vkResetFences__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkResetFences => vkResetFences__successcodes;
	private static VkResult[?] vkResetFences__errorcodes = .(.VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkResetFences => vkResetFences__errorcodes;
	private static VkResult[?] vkGetFenceStatus__successcodes = .(.VkSuccess, .VkNotReady);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetFenceStatus => vkGetFenceStatus__successcodes;
	private static VkResult[?] vkGetFenceStatus__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetFenceStatus => vkGetFenceStatus__errorcodes;
	private static VkResult[?] vkWaitForFences__successcodes = .(.VkSuccess, .VkTimeout);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkWaitForFences => vkWaitForFences__successcodes;
	private static VkResult[?] vkWaitForFences__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkWaitForFences => vkWaitForFences__errorcodes;
	private static VkResult[?] vkCreateSemaphore__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateSemaphore => vkCreateSemaphore__successcodes;
	private static VkResult[?] vkCreateSemaphore__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateSemaphore => vkCreateSemaphore__errorcodes;
	private static VkResult[?] vkCreateEvent__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateEvent => vkCreateEvent__successcodes;
	private static VkResult[?] vkCreateEvent__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateEvent => vkCreateEvent__errorcodes;
	private static VkResult[?] vkGetEventStatus__successcodes = .(.VkEventSet, .VkEventReset);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetEventStatus => vkGetEventStatus__successcodes;
	private static VkResult[?] vkGetEventStatus__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetEventStatus => vkGetEventStatus__errorcodes;
	private static VkResult[?] vkSetEvent__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkSetEvent => vkSetEvent__successcodes;
	private static VkResult[?] vkSetEvent__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkSetEvent => vkSetEvent__errorcodes;
	private static VkResult[?] vkResetEvent__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkResetEvent => vkResetEvent__successcodes;
	private static VkResult[?] vkResetEvent__errorcodes = .(.VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkResetEvent => vkResetEvent__errorcodes;
	private static VkResult[?] vkCreateQueryPool__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateQueryPool => vkCreateQueryPool__successcodes;
	private static VkResult[?] vkCreateQueryPool__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateQueryPool => vkCreateQueryPool__errorcodes;
	private static VkResult[?] vkGetQueryPoolResults__successcodes = .(.VkSuccess, .VkNotReady);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetQueryPoolResults => vkGetQueryPoolResults__successcodes;
	private static VkResult[?] vkGetQueryPoolResults__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetQueryPoolResults => vkGetQueryPoolResults__errorcodes;
	private static VkResult[?] vkCreateBuffer__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateBuffer => vkCreateBuffer__successcodes;
	private static VkResult[?] vkCreateBuffer__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInvalidOpaqueCaptureAddressKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateBuffer => vkCreateBuffer__errorcodes;
	private static VkResult[?] vkCreateBufferView__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateBufferView => vkCreateBufferView__successcodes;
	private static VkResult[?] vkCreateBufferView__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateBufferView => vkCreateBufferView__errorcodes;
	private static VkResult[?] vkCreateImage__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateImage => vkCreateImage__successcodes;
	private static VkResult[?] vkCreateImage__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorCompressionExhaustedEXT, .VkErrorInvalidOpaqueCaptureAddressKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateImage => vkCreateImage__errorcodes;
	private static VkResult[?] vkCreateImageView__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateImageView => vkCreateImageView__successcodes;
	private static VkResult[?] vkCreateImageView__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInvalidOpaqueCaptureAddressKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateImageView => vkCreateImageView__errorcodes;
	private static VkResult[?] vkCreateShaderModule__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateShaderModule => vkCreateShaderModule__successcodes;
	private static VkResult[?] vkCreateShaderModule__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInvalidShaderNV);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateShaderModule => vkCreateShaderModule__errorcodes;
	private static VkResult[?] vkCreatePipelineCache__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreatePipelineCache => vkCreatePipelineCache__successcodes;
	private static VkResult[?] vkCreatePipelineCache__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreatePipelineCache => vkCreatePipelineCache__errorcodes;
	private static VkResult[?] vkGetPipelineCacheData__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPipelineCacheData => vkGetPipelineCacheData__successcodes;
	private static VkResult[?] vkGetPipelineCacheData__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPipelineCacheData => vkGetPipelineCacheData__errorcodes;
	private static VkResult[?] vkMergePipelineCaches__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkMergePipelineCaches => vkMergePipelineCaches__successcodes;
	private static VkResult[?] vkMergePipelineCaches__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkMergePipelineCaches => vkMergePipelineCaches__errorcodes;
	private static VkResult[?] vkCreatePipelineBinariesKHR__successcodes = .(.VkSuccess, .VkIncomplete, .VkPipelineBinaryMissingKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreatePipelineBinariesKHR => vkCreatePipelineBinariesKHR__successcodes;
	private static VkResult[?] vkCreatePipelineBinariesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInitializationFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreatePipelineBinariesKHR => vkCreatePipelineBinariesKHR__errorcodes;
	private static VkResult[?] vkGetPipelineKeyKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPipelineKeyKHR => vkGetPipelineKeyKHR__successcodes;
	private static VkResult[?] vkGetPipelineKeyKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPipelineKeyKHR => vkGetPipelineKeyKHR__errorcodes;
	private static VkResult[?] vkGetPipelineBinaryDataKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPipelineBinaryDataKHR => vkGetPipelineBinaryDataKHR__successcodes;
	private static VkResult[?] vkGetPipelineBinaryDataKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorNotEnoughSpaceKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPipelineBinaryDataKHR => vkGetPipelineBinaryDataKHR__errorcodes;
	private static VkResult[?] vkReleaseCapturedPipelineDataKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkReleaseCapturedPipelineDataKHR => vkReleaseCapturedPipelineDataKHR__successcodes;
	private static VkResult[?] vkCreateGraphicsPipelines__successcodes = .(.VkSuccess, .VkPipelineCompileRequiredEXT);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateGraphicsPipelines => vkCreateGraphicsPipelines__successcodes;
	private static VkResult[?] vkCreateGraphicsPipelines__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInvalidShaderNV);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateGraphicsPipelines => vkCreateGraphicsPipelines__errorcodes;
	private static VkResult[?] vkCreateComputePipelines__successcodes = .(.VkSuccess, .VkPipelineCompileRequiredEXT);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateComputePipelines => vkCreateComputePipelines__successcodes;
	private static VkResult[?] vkCreateComputePipelines__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInvalidShaderNV);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateComputePipelines => vkCreateComputePipelines__errorcodes;
	private static VkResult[?] vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI => vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI__successcodes;
	private static VkResult[?] vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI => vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI__errorcodes;
	private static VkResult[?] vkCreatePipelineLayout__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreatePipelineLayout => vkCreatePipelineLayout__successcodes;
	private static VkResult[?] vkCreatePipelineLayout__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreatePipelineLayout => vkCreatePipelineLayout__errorcodes;
	private static VkResult[?] vkCreateSampler__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateSampler => vkCreateSampler__successcodes;
	private static VkResult[?] vkCreateSampler__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInvalidOpaqueCaptureAddressKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateSampler => vkCreateSampler__errorcodes;
	private static VkResult[?] vkCreateDescriptorSetLayout__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateDescriptorSetLayout => vkCreateDescriptorSetLayout__successcodes;
	private static VkResult[?] vkCreateDescriptorSetLayout__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateDescriptorSetLayout => vkCreateDescriptorSetLayout__errorcodes;
	private static VkResult[?] vkCreateDescriptorPool__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateDescriptorPool => vkCreateDescriptorPool__successcodes;
	private static VkResult[?] vkCreateDescriptorPool__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorFragmentationEXT);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateDescriptorPool => vkCreateDescriptorPool__errorcodes;
	private static VkResult[?] vkResetDescriptorPool__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkResetDescriptorPool => vkResetDescriptorPool__successcodes;
	private static VkResult[?] vkAllocateDescriptorSets__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkAllocateDescriptorSets => vkAllocateDescriptorSets__successcodes;
	private static VkResult[?] vkAllocateDescriptorSets__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorFragmentedPool, .VkErrorOutOfPoolMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkAllocateDescriptorSets => vkAllocateDescriptorSets__errorcodes;
	private static VkResult[?] vkFreeDescriptorSets__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkFreeDescriptorSets => vkFreeDescriptorSets__successcodes;
	private static VkResult[?] vkCreateFramebuffer__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateFramebuffer => vkCreateFramebuffer__successcodes;
	private static VkResult[?] vkCreateFramebuffer__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateFramebuffer => vkCreateFramebuffer__errorcodes;
	private static VkResult[?] vkCreateRenderPass__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateRenderPass => vkCreateRenderPass__successcodes;
	private static VkResult[?] vkCreateRenderPass__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateRenderPass => vkCreateRenderPass__errorcodes;
	private static VkResult[?] vkCreateCommandPool__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateCommandPool => vkCreateCommandPool__successcodes;
	private static VkResult[?] vkCreateCommandPool__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateCommandPool => vkCreateCommandPool__errorcodes;
	private static VkResult[?] vkResetCommandPool__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkResetCommandPool => vkResetCommandPool__successcodes;
	private static VkResult[?] vkResetCommandPool__errorcodes = .(.VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkResetCommandPool => vkResetCommandPool__errorcodes;
	private static VkResult[?] vkAllocateCommandBuffers__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkAllocateCommandBuffers => vkAllocateCommandBuffers__successcodes;
	private static VkResult[?] vkAllocateCommandBuffers__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkAllocateCommandBuffers => vkAllocateCommandBuffers__errorcodes;
	private static VkResult[?] vkBeginCommandBuffer__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkBeginCommandBuffer => vkBeginCommandBuffer__successcodes;
	private static VkResult[?] vkBeginCommandBuffer__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkBeginCommandBuffer => vkBeginCommandBuffer__errorcodes;
	private static VkResult[?] vkEndCommandBuffer__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkEndCommandBuffer => vkEndCommandBuffer__successcodes;
	private static VkResult[?] vkEndCommandBuffer__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInvalidVideoStdParametersKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkEndCommandBuffer => vkEndCommandBuffer__errorcodes;
	private static VkResult[?] vkResetCommandBuffer__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkResetCommandBuffer => vkResetCommandBuffer__successcodes;
	private static VkResult[?] vkResetCommandBuffer__errorcodes = .(.VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkResetCommandBuffer => vkResetCommandBuffer__errorcodes;
	private static VkQueueFlags vkCmdBindPipeline__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindPipeline => vkCmdBindPipeline__queues;
	private static RenderPassLocation vkCmdBindPipeline__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindPipeline => vkCmdBindPipeline__renderpass;
	private static CmdBufferLevel vkCmdBindPipeline__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindPipeline => vkCmdBindPipeline__cmdbufferlevel;
	private static Task vkCmdBindPipeline__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindPipeline => vkCmdBindPipeline__tasks;
	private static VkQueueFlags vkCmdSetAttachmentFeedbackLoopEnableEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT => vkCmdSetAttachmentFeedbackLoopEnableEXT__queues;
	private static RenderPassLocation vkCmdSetAttachmentFeedbackLoopEnableEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT => vkCmdSetAttachmentFeedbackLoopEnableEXT__renderpass;
	private static CmdBufferLevel vkCmdSetAttachmentFeedbackLoopEnableEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT => vkCmdSetAttachmentFeedbackLoopEnableEXT__cmdbufferlevel;
	private static Task vkCmdSetAttachmentFeedbackLoopEnableEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT => vkCmdSetAttachmentFeedbackLoopEnableEXT__tasks;
	private static VkQueueFlags vkCmdSetViewport__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetViewport => vkCmdSetViewport__queues;
	private static RenderPassLocation vkCmdSetViewport__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetViewport => vkCmdSetViewport__renderpass;
	private static CmdBufferLevel vkCmdSetViewport__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetViewport => vkCmdSetViewport__cmdbufferlevel;
	private static Task vkCmdSetViewport__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetViewport => vkCmdSetViewport__tasks;
	private static VkQueueFlags vkCmdSetScissor__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetScissor => vkCmdSetScissor__queues;
	private static RenderPassLocation vkCmdSetScissor__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetScissor => vkCmdSetScissor__renderpass;
	private static CmdBufferLevel vkCmdSetScissor__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetScissor => vkCmdSetScissor__cmdbufferlevel;
	private static Task vkCmdSetScissor__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetScissor => vkCmdSetScissor__tasks;
	private static VkQueueFlags vkCmdSetLineWidth__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetLineWidth => vkCmdSetLineWidth__queues;
	private static RenderPassLocation vkCmdSetLineWidth__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetLineWidth => vkCmdSetLineWidth__renderpass;
	private static CmdBufferLevel vkCmdSetLineWidth__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetLineWidth => vkCmdSetLineWidth__cmdbufferlevel;
	private static Task vkCmdSetLineWidth__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetLineWidth => vkCmdSetLineWidth__tasks;
	private static VkQueueFlags vkCmdSetDepthBias__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDepthBias => vkCmdSetDepthBias__queues;
	private static RenderPassLocation vkCmdSetDepthBias__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDepthBias => vkCmdSetDepthBias__renderpass;
	private static CmdBufferLevel vkCmdSetDepthBias__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDepthBias => vkCmdSetDepthBias__cmdbufferlevel;
	private static Task vkCmdSetDepthBias__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDepthBias => vkCmdSetDepthBias__tasks;
	private static VkQueueFlags vkCmdSetBlendConstants__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetBlendConstants => vkCmdSetBlendConstants__queues;
	private static RenderPassLocation vkCmdSetBlendConstants__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetBlendConstants => vkCmdSetBlendConstants__renderpass;
	private static CmdBufferLevel vkCmdSetBlendConstants__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetBlendConstants => vkCmdSetBlendConstants__cmdbufferlevel;
	private static Task vkCmdSetBlendConstants__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetBlendConstants => vkCmdSetBlendConstants__tasks;
	private static VkQueueFlags vkCmdSetDepthBounds__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDepthBounds => vkCmdSetDepthBounds__queues;
	private static RenderPassLocation vkCmdSetDepthBounds__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDepthBounds => vkCmdSetDepthBounds__renderpass;
	private static CmdBufferLevel vkCmdSetDepthBounds__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDepthBounds => vkCmdSetDepthBounds__cmdbufferlevel;
	private static Task vkCmdSetDepthBounds__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDepthBounds => vkCmdSetDepthBounds__tasks;
	private static VkQueueFlags vkCmdSetStencilCompareMask__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetStencilCompareMask => vkCmdSetStencilCompareMask__queues;
	private static RenderPassLocation vkCmdSetStencilCompareMask__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetStencilCompareMask => vkCmdSetStencilCompareMask__renderpass;
	private static CmdBufferLevel vkCmdSetStencilCompareMask__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetStencilCompareMask => vkCmdSetStencilCompareMask__cmdbufferlevel;
	private static Task vkCmdSetStencilCompareMask__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetStencilCompareMask => vkCmdSetStencilCompareMask__tasks;
	private static VkQueueFlags vkCmdSetStencilWriteMask__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetStencilWriteMask => vkCmdSetStencilWriteMask__queues;
	private static RenderPassLocation vkCmdSetStencilWriteMask__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetStencilWriteMask => vkCmdSetStencilWriteMask__renderpass;
	private static CmdBufferLevel vkCmdSetStencilWriteMask__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetStencilWriteMask => vkCmdSetStencilWriteMask__cmdbufferlevel;
	private static Task vkCmdSetStencilWriteMask__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetStencilWriteMask => vkCmdSetStencilWriteMask__tasks;
	private static VkQueueFlags vkCmdSetStencilReference__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetStencilReference => vkCmdSetStencilReference__queues;
	private static RenderPassLocation vkCmdSetStencilReference__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetStencilReference => vkCmdSetStencilReference__renderpass;
	private static CmdBufferLevel vkCmdSetStencilReference__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetStencilReference => vkCmdSetStencilReference__cmdbufferlevel;
	private static Task vkCmdSetStencilReference__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetStencilReference => vkCmdSetStencilReference__tasks;
	private static VkQueueFlags vkCmdBindDescriptorSets__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindDescriptorSets => vkCmdBindDescriptorSets__queues;
	private static RenderPassLocation vkCmdBindDescriptorSets__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindDescriptorSets => vkCmdBindDescriptorSets__renderpass;
	private static CmdBufferLevel vkCmdBindDescriptorSets__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindDescriptorSets => vkCmdBindDescriptorSets__cmdbufferlevel;
	private static Task vkCmdBindDescriptorSets__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindDescriptorSets => vkCmdBindDescriptorSets__tasks;
	private static VkQueueFlags vkCmdBindIndexBuffer__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindIndexBuffer => vkCmdBindIndexBuffer__queues;
	private static RenderPassLocation vkCmdBindIndexBuffer__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindIndexBuffer => vkCmdBindIndexBuffer__renderpass;
	private static CmdBufferLevel vkCmdBindIndexBuffer__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindIndexBuffer => vkCmdBindIndexBuffer__cmdbufferlevel;
	private static Task vkCmdBindIndexBuffer__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindIndexBuffer => vkCmdBindIndexBuffer__tasks;
	private static VkQueueFlags vkCmdBindVertexBuffers__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindVertexBuffers => vkCmdBindVertexBuffers__queues;
	private static RenderPassLocation vkCmdBindVertexBuffers__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindVertexBuffers => vkCmdBindVertexBuffers__renderpass;
	private static CmdBufferLevel vkCmdBindVertexBuffers__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindVertexBuffers => vkCmdBindVertexBuffers__cmdbufferlevel;
	private static Task vkCmdBindVertexBuffers__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindVertexBuffers => vkCmdBindVertexBuffers__tasks;
	private static VkQueueFlags vkCmdDraw__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDraw => vkCmdDraw__queues;
	private static RenderPassLocation vkCmdDraw__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDraw => vkCmdDraw__renderpass;
	private static CmdBufferLevel vkCmdDraw__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDraw => vkCmdDraw__cmdbufferlevel;
	private static Task vkCmdDraw__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDraw => vkCmdDraw__tasks;
	private static VkQueueFlags vkCmdDrawIndexed__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawIndexed => vkCmdDrawIndexed__queues;
	private static RenderPassLocation vkCmdDrawIndexed__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawIndexed => vkCmdDrawIndexed__renderpass;
	private static CmdBufferLevel vkCmdDrawIndexed__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawIndexed => vkCmdDrawIndexed__cmdbufferlevel;
	private static Task vkCmdDrawIndexed__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawIndexed => vkCmdDrawIndexed__tasks;
	private static VkQueueFlags vkCmdDrawMultiEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawMultiEXT => vkCmdDrawMultiEXT__queues;
	private static RenderPassLocation vkCmdDrawMultiEXT__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawMultiEXT => vkCmdDrawMultiEXT__renderpass;
	private static CmdBufferLevel vkCmdDrawMultiEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawMultiEXT => vkCmdDrawMultiEXT__cmdbufferlevel;
	private static Task vkCmdDrawMultiEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawMultiEXT => vkCmdDrawMultiEXT__tasks;
	private static VkQueueFlags vkCmdDrawMultiIndexedEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawMultiIndexedEXT => vkCmdDrawMultiIndexedEXT__queues;
	private static RenderPassLocation vkCmdDrawMultiIndexedEXT__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawMultiIndexedEXT => vkCmdDrawMultiIndexedEXT__renderpass;
	private static CmdBufferLevel vkCmdDrawMultiIndexedEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawMultiIndexedEXT => vkCmdDrawMultiIndexedEXT__cmdbufferlevel;
	private static Task vkCmdDrawMultiIndexedEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawMultiIndexedEXT => vkCmdDrawMultiIndexedEXT__tasks;
	private static VkQueueFlags vkCmdDrawIndirect__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawIndirect => vkCmdDrawIndirect__queues;
	private static RenderPassLocation vkCmdDrawIndirect__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawIndirect => vkCmdDrawIndirect__renderpass;
	private static CmdBufferLevel vkCmdDrawIndirect__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawIndirect => vkCmdDrawIndirect__cmdbufferlevel;
	private static Task vkCmdDrawIndirect__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawIndirect => vkCmdDrawIndirect__tasks;
	private static VkQueueFlags vkCmdDrawIndexedIndirect__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawIndexedIndirect => vkCmdDrawIndexedIndirect__queues;
	private static RenderPassLocation vkCmdDrawIndexedIndirect__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawIndexedIndirect => vkCmdDrawIndexedIndirect__renderpass;
	private static CmdBufferLevel vkCmdDrawIndexedIndirect__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawIndexedIndirect => vkCmdDrawIndexedIndirect__cmdbufferlevel;
	private static Task vkCmdDrawIndexedIndirect__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawIndexedIndirect => vkCmdDrawIndexedIndirect__tasks;
	private static VkQueueFlags vkCmdDispatch__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDispatch => vkCmdDispatch__queues;
	private static RenderPassLocation vkCmdDispatch__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDispatch => vkCmdDispatch__renderpass;
	private static CmdBufferLevel vkCmdDispatch__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDispatch => vkCmdDispatch__cmdbufferlevel;
	private static Task vkCmdDispatch__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDispatch => vkCmdDispatch__tasks;
	private static VkQueueFlags vkCmdDispatchIndirect__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDispatchIndirect => vkCmdDispatchIndirect__queues;
	private static RenderPassLocation vkCmdDispatchIndirect__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDispatchIndirect => vkCmdDispatchIndirect__renderpass;
	private static CmdBufferLevel vkCmdDispatchIndirect__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDispatchIndirect => vkCmdDispatchIndirect__cmdbufferlevel;
	private static Task vkCmdDispatchIndirect__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDispatchIndirect => vkCmdDispatchIndirect__tasks;
	private static VkQueueFlags vkCmdSubpassShadingHUAWEI__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSubpassShadingHUAWEI => vkCmdSubpassShadingHUAWEI__queues;
	private static RenderPassLocation vkCmdSubpassShadingHUAWEI__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSubpassShadingHUAWEI => vkCmdSubpassShadingHUAWEI__renderpass;
	private static CmdBufferLevel vkCmdSubpassShadingHUAWEI__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSubpassShadingHUAWEI => vkCmdSubpassShadingHUAWEI__cmdbufferlevel;
	private static Task vkCmdSubpassShadingHUAWEI__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSubpassShadingHUAWEI => vkCmdSubpassShadingHUAWEI__tasks;
	private static VkQueueFlags vkCmdDrawClusterHUAWEI__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawClusterHUAWEI => vkCmdDrawClusterHUAWEI__queues;
	private static RenderPassLocation vkCmdDrawClusterHUAWEI__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawClusterHUAWEI => vkCmdDrawClusterHUAWEI__renderpass;
	private static CmdBufferLevel vkCmdDrawClusterHUAWEI__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawClusterHUAWEI => vkCmdDrawClusterHUAWEI__cmdbufferlevel;
	private static Task vkCmdDrawClusterHUAWEI__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawClusterHUAWEI => vkCmdDrawClusterHUAWEI__tasks;
	private static VkQueueFlags vkCmdDrawClusterIndirectHUAWEI__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawClusterIndirectHUAWEI => vkCmdDrawClusterIndirectHUAWEI__queues;
	private static RenderPassLocation vkCmdDrawClusterIndirectHUAWEI__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawClusterIndirectHUAWEI => vkCmdDrawClusterIndirectHUAWEI__renderpass;
	private static CmdBufferLevel vkCmdDrawClusterIndirectHUAWEI__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawClusterIndirectHUAWEI => vkCmdDrawClusterIndirectHUAWEI__cmdbufferlevel;
	private static Task vkCmdDrawClusterIndirectHUAWEI__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawClusterIndirectHUAWEI => vkCmdDrawClusterIndirectHUAWEI__tasks;
	private static VkQueueFlags vkCmdUpdatePipelineIndirectBufferNV__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdUpdatePipelineIndirectBufferNV => vkCmdUpdatePipelineIndirectBufferNV__queues;
	private static RenderPassLocation vkCmdUpdatePipelineIndirectBufferNV__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdUpdatePipelineIndirectBufferNV => vkCmdUpdatePipelineIndirectBufferNV__renderpass;
	private static CmdBufferLevel vkCmdUpdatePipelineIndirectBufferNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdUpdatePipelineIndirectBufferNV => vkCmdUpdatePipelineIndirectBufferNV__cmdbufferlevel;
	private static Task vkCmdUpdatePipelineIndirectBufferNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdUpdatePipelineIndirectBufferNV => vkCmdUpdatePipelineIndirectBufferNV__tasks;
	private static VkQueueFlags vkCmdCopyBuffer__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyBuffer => vkCmdCopyBuffer__queues;
	private static RenderPassLocation vkCmdCopyBuffer__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyBuffer => vkCmdCopyBuffer__renderpass;
	private static CmdBufferLevel vkCmdCopyBuffer__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyBuffer => vkCmdCopyBuffer__cmdbufferlevel;
	private static Task vkCmdCopyBuffer__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyBuffer => vkCmdCopyBuffer__tasks;
	private static VkQueueFlags vkCmdCopyImage__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyImage => vkCmdCopyImage__queues;
	private static RenderPassLocation vkCmdCopyImage__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyImage => vkCmdCopyImage__renderpass;
	private static CmdBufferLevel vkCmdCopyImage__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyImage => vkCmdCopyImage__cmdbufferlevel;
	private static Task vkCmdCopyImage__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyImage => vkCmdCopyImage__tasks;
	private static VkQueueFlags vkCmdBlitImage__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBlitImage => vkCmdBlitImage__queues;
	private static RenderPassLocation vkCmdBlitImage__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBlitImage => vkCmdBlitImage__renderpass;
	private static CmdBufferLevel vkCmdBlitImage__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBlitImage => vkCmdBlitImage__cmdbufferlevel;
	private static Task vkCmdBlitImage__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBlitImage => vkCmdBlitImage__tasks;
	private static VkQueueFlags vkCmdCopyBufferToImage__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyBufferToImage => vkCmdCopyBufferToImage__queues;
	private static RenderPassLocation vkCmdCopyBufferToImage__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyBufferToImage => vkCmdCopyBufferToImage__renderpass;
	private static CmdBufferLevel vkCmdCopyBufferToImage__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyBufferToImage => vkCmdCopyBufferToImage__cmdbufferlevel;
	private static Task vkCmdCopyBufferToImage__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyBufferToImage => vkCmdCopyBufferToImage__tasks;
	private static VkQueueFlags vkCmdCopyImageToBuffer__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyImageToBuffer => vkCmdCopyImageToBuffer__queues;
	private static RenderPassLocation vkCmdCopyImageToBuffer__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyImageToBuffer => vkCmdCopyImageToBuffer__renderpass;
	private static CmdBufferLevel vkCmdCopyImageToBuffer__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyImageToBuffer => vkCmdCopyImageToBuffer__cmdbufferlevel;
	private static Task vkCmdCopyImageToBuffer__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyImageToBuffer => vkCmdCopyImageToBuffer__tasks;
	private static VkQueueFlags vkCmdCopyMemoryIndirectNV__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyMemoryIndirectNV => vkCmdCopyMemoryIndirectNV__queues;
	private static RenderPassLocation vkCmdCopyMemoryIndirectNV__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyMemoryIndirectNV => vkCmdCopyMemoryIndirectNV__renderpass;
	private static CmdBufferLevel vkCmdCopyMemoryIndirectNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyMemoryIndirectNV => vkCmdCopyMemoryIndirectNV__cmdbufferlevel;
	private static Task vkCmdCopyMemoryIndirectNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyMemoryIndirectNV => vkCmdCopyMemoryIndirectNV__tasks;
	private static VkQueueFlags vkCmdCopyMemoryToImageIndirectNV__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyMemoryToImageIndirectNV => vkCmdCopyMemoryToImageIndirectNV__queues;
	private static RenderPassLocation vkCmdCopyMemoryToImageIndirectNV__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyMemoryToImageIndirectNV => vkCmdCopyMemoryToImageIndirectNV__renderpass;
	private static CmdBufferLevel vkCmdCopyMemoryToImageIndirectNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyMemoryToImageIndirectNV => vkCmdCopyMemoryToImageIndirectNV__cmdbufferlevel;
	private static Task vkCmdCopyMemoryToImageIndirectNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyMemoryToImageIndirectNV => vkCmdCopyMemoryToImageIndirectNV__tasks;
	private static VkQueueFlags vkCmdUpdateBuffer__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdUpdateBuffer => vkCmdUpdateBuffer__queues;
	private static RenderPassLocation vkCmdUpdateBuffer__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdUpdateBuffer => vkCmdUpdateBuffer__renderpass;
	private static CmdBufferLevel vkCmdUpdateBuffer__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdUpdateBuffer => vkCmdUpdateBuffer__cmdbufferlevel;
	private static Task vkCmdUpdateBuffer__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdUpdateBuffer => vkCmdUpdateBuffer__tasks;
	private static VkQueueFlags vkCmdFillBuffer__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdFillBuffer => vkCmdFillBuffer__queues;
	private static RenderPassLocation vkCmdFillBuffer__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdFillBuffer => vkCmdFillBuffer__renderpass;
	private static CmdBufferLevel vkCmdFillBuffer__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdFillBuffer => vkCmdFillBuffer__cmdbufferlevel;
	private static Task vkCmdFillBuffer__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdFillBuffer => vkCmdFillBuffer__tasks;
	private static VkQueueFlags vkCmdClearColorImage__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdClearColorImage => vkCmdClearColorImage__queues;
	private static RenderPassLocation vkCmdClearColorImage__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdClearColorImage => vkCmdClearColorImage__renderpass;
	private static CmdBufferLevel vkCmdClearColorImage__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdClearColorImage => vkCmdClearColorImage__cmdbufferlevel;
	private static Task vkCmdClearColorImage__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdClearColorImage => vkCmdClearColorImage__tasks;
	private static VkQueueFlags vkCmdClearDepthStencilImage__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdClearDepthStencilImage => vkCmdClearDepthStencilImage__queues;
	private static RenderPassLocation vkCmdClearDepthStencilImage__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdClearDepthStencilImage => vkCmdClearDepthStencilImage__renderpass;
	private static CmdBufferLevel vkCmdClearDepthStencilImage__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdClearDepthStencilImage => vkCmdClearDepthStencilImage__cmdbufferlevel;
	private static Task vkCmdClearDepthStencilImage__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdClearDepthStencilImage => vkCmdClearDepthStencilImage__tasks;
	private static VkQueueFlags vkCmdClearAttachments__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdClearAttachments => vkCmdClearAttachments__queues;
	private static RenderPassLocation vkCmdClearAttachments__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdClearAttachments => vkCmdClearAttachments__renderpass;
	private static CmdBufferLevel vkCmdClearAttachments__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdClearAttachments => vkCmdClearAttachments__cmdbufferlevel;
	private static Task vkCmdClearAttachments__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdClearAttachments => vkCmdClearAttachments__tasks;
	private static VkQueueFlags vkCmdResolveImage__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdResolveImage => vkCmdResolveImage__queues;
	private static RenderPassLocation vkCmdResolveImage__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdResolveImage => vkCmdResolveImage__renderpass;
	private static CmdBufferLevel vkCmdResolveImage__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdResolveImage => vkCmdResolveImage__cmdbufferlevel;
	private static Task vkCmdResolveImage__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdResolveImage => vkCmdResolveImage__tasks;
	private static VkQueueFlags vkCmdSetEvent__queues = .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetEvent => vkCmdSetEvent__queues;
	private static RenderPassLocation vkCmdSetEvent__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetEvent => vkCmdSetEvent__renderpass;
	private static CmdBufferLevel vkCmdSetEvent__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetEvent => vkCmdSetEvent__cmdbufferlevel;
	private static Task vkCmdSetEvent__tasks = .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetEvent => vkCmdSetEvent__tasks;
	private static VkQueueFlags vkCmdResetEvent__queues = .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdResetEvent => vkCmdResetEvent__queues;
	private static RenderPassLocation vkCmdResetEvent__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdResetEvent => vkCmdResetEvent__renderpass;
	private static CmdBufferLevel vkCmdResetEvent__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdResetEvent => vkCmdResetEvent__cmdbufferlevel;
	private static Task vkCmdResetEvent__tasks = .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdResetEvent => vkCmdResetEvent__tasks;
	private static VkQueueFlags vkCmdWaitEvents__queues = .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdWaitEvents => vkCmdWaitEvents__queues;
	private static RenderPassLocation vkCmdWaitEvents__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdWaitEvents => vkCmdWaitEvents__renderpass;
	private static CmdBufferLevel vkCmdWaitEvents__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdWaitEvents => vkCmdWaitEvents__cmdbufferlevel;
	private static Task vkCmdWaitEvents__tasks = .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdWaitEvents => vkCmdWaitEvents__tasks;
	private static VkQueueFlags vkCmdPipelineBarrier__queues = .Transfer | .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdPipelineBarrier => vkCmdPipelineBarrier__queues;
	private static RenderPassLocation vkCmdPipelineBarrier__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdPipelineBarrier => vkCmdPipelineBarrier__renderpass;
	private static CmdBufferLevel vkCmdPipelineBarrier__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdPipelineBarrier => vkCmdPipelineBarrier__cmdbufferlevel;
	private static Task vkCmdPipelineBarrier__tasks = .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdPipelineBarrier => vkCmdPipelineBarrier__tasks;
	private static VkQueueFlags vkCmdBeginQuery__queues = .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBeginQuery => vkCmdBeginQuery__queues;
	private static RenderPassLocation vkCmdBeginQuery__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBeginQuery => vkCmdBeginQuery__renderpass;
	private static CmdBufferLevel vkCmdBeginQuery__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBeginQuery => vkCmdBeginQuery__cmdbufferlevel;
	private static Task vkCmdBeginQuery__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBeginQuery => vkCmdBeginQuery__tasks;
	private static VkQueueFlags vkCmdEndQuery__queues = .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdEndQuery => vkCmdEndQuery__queues;
	private static RenderPassLocation vkCmdEndQuery__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdEndQuery => vkCmdEndQuery__renderpass;
	private static CmdBufferLevel vkCmdEndQuery__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdEndQuery => vkCmdEndQuery__cmdbufferlevel;
	private static Task vkCmdEndQuery__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdEndQuery => vkCmdEndQuery__tasks;
	private static VkQueueFlags vkCmdBeginConditionalRenderingEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBeginConditionalRenderingEXT => vkCmdBeginConditionalRenderingEXT__queues;
	private static RenderPassLocation vkCmdBeginConditionalRenderingEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBeginConditionalRenderingEXT => vkCmdBeginConditionalRenderingEXT__renderpass;
	private static CmdBufferLevel vkCmdBeginConditionalRenderingEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBeginConditionalRenderingEXT => vkCmdBeginConditionalRenderingEXT__cmdbufferlevel;
	private static Task vkCmdBeginConditionalRenderingEXT__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBeginConditionalRenderingEXT => vkCmdBeginConditionalRenderingEXT__tasks;
	private static VkQueueFlags vkCmdEndConditionalRenderingEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdEndConditionalRenderingEXT => vkCmdEndConditionalRenderingEXT__queues;
	private static RenderPassLocation vkCmdEndConditionalRenderingEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdEndConditionalRenderingEXT => vkCmdEndConditionalRenderingEXT__renderpass;
	private static CmdBufferLevel vkCmdEndConditionalRenderingEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdEndConditionalRenderingEXT => vkCmdEndConditionalRenderingEXT__cmdbufferlevel;
	private static Task vkCmdEndConditionalRenderingEXT__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdEndConditionalRenderingEXT => vkCmdEndConditionalRenderingEXT__tasks;
	private static VkQueueFlags vkCmdResetQueryPool__queues = .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR | .OpticalFlowNV;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdResetQueryPool => vkCmdResetQueryPool__queues;
	private static RenderPassLocation vkCmdResetQueryPool__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdResetQueryPool => vkCmdResetQueryPool__renderpass;
	private static CmdBufferLevel vkCmdResetQueryPool__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdResetQueryPool => vkCmdResetQueryPool__cmdbufferlevel;
	private static Task vkCmdResetQueryPool__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdResetQueryPool => vkCmdResetQueryPool__tasks;
	private static VkQueueFlags vkCmdWriteTimestamp__queues = .Transfer | .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR | .OpticalFlowNV;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdWriteTimestamp => vkCmdWriteTimestamp__queues;
	private static RenderPassLocation vkCmdWriteTimestamp__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdWriteTimestamp => vkCmdWriteTimestamp__renderpass;
	private static CmdBufferLevel vkCmdWriteTimestamp__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdWriteTimestamp => vkCmdWriteTimestamp__cmdbufferlevel;
	private static Task vkCmdWriteTimestamp__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdWriteTimestamp => vkCmdWriteTimestamp__tasks;
	private static VkQueueFlags vkCmdCopyQueryPoolResults__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyQueryPoolResults => vkCmdCopyQueryPoolResults__queues;
	private static RenderPassLocation vkCmdCopyQueryPoolResults__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyQueryPoolResults => vkCmdCopyQueryPoolResults__renderpass;
	private static CmdBufferLevel vkCmdCopyQueryPoolResults__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyQueryPoolResults => vkCmdCopyQueryPoolResults__cmdbufferlevel;
	private static Task vkCmdCopyQueryPoolResults__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyQueryPoolResults => vkCmdCopyQueryPoolResults__tasks;
	private static VkQueueFlags vkCmdPushConstants__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdPushConstants => vkCmdPushConstants__queues;
	private static RenderPassLocation vkCmdPushConstants__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdPushConstants => vkCmdPushConstants__renderpass;
	private static CmdBufferLevel vkCmdPushConstants__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdPushConstants => vkCmdPushConstants__cmdbufferlevel;
	private static Task vkCmdPushConstants__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdPushConstants => vkCmdPushConstants__tasks;
	private static VkQueueFlags vkCmdBeginRenderPass__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBeginRenderPass => vkCmdBeginRenderPass__queues;
	private static RenderPassLocation vkCmdBeginRenderPass__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBeginRenderPass => vkCmdBeginRenderPass__renderpass;
	private static CmdBufferLevel vkCmdBeginRenderPass__cmdbufferlevel = .Primary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBeginRenderPass => vkCmdBeginRenderPass__cmdbufferlevel;
	private static Task vkCmdBeginRenderPass__tasks = .Action | .State | .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBeginRenderPass => vkCmdBeginRenderPass__tasks;
	private static VkQueueFlags vkCmdNextSubpass__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdNextSubpass => vkCmdNextSubpass__queues;
	private static RenderPassLocation vkCmdNextSubpass__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdNextSubpass => vkCmdNextSubpass__renderpass;
	private static CmdBufferLevel vkCmdNextSubpass__cmdbufferlevel = .Primary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdNextSubpass => vkCmdNextSubpass__cmdbufferlevel;
	private static Task vkCmdNextSubpass__tasks = .Action | .State | .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdNextSubpass => vkCmdNextSubpass__tasks;
	private static VkQueueFlags vkCmdEndRenderPass__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdEndRenderPass => vkCmdEndRenderPass__queues;
	private static RenderPassLocation vkCmdEndRenderPass__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdEndRenderPass => vkCmdEndRenderPass__renderpass;
	private static CmdBufferLevel vkCmdEndRenderPass__cmdbufferlevel = .Primary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdEndRenderPass => vkCmdEndRenderPass__cmdbufferlevel;
	private static Task vkCmdEndRenderPass__tasks = .Action | .State | .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdEndRenderPass => vkCmdEndRenderPass__tasks;
	private static VkQueueFlags vkCmdExecuteCommands__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdExecuteCommands => vkCmdExecuteCommands__queues;
	private static RenderPassLocation vkCmdExecuteCommands__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdExecuteCommands => vkCmdExecuteCommands__renderpass;
	private static CmdBufferLevel vkCmdExecuteCommands__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdExecuteCommands => vkCmdExecuteCommands__cmdbufferlevel;
	private static Task vkCmdExecuteCommands__tasks = .Indirection;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdExecuteCommands => vkCmdExecuteCommands__tasks;
	private static VkResult[?] vkGetPhysicalDeviceDisplayPropertiesKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceDisplayPropertiesKHR => vkGetPhysicalDeviceDisplayPropertiesKHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceDisplayPropertiesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceDisplayPropertiesKHR => vkGetPhysicalDeviceDisplayPropertiesKHR__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceDisplayPlanePropertiesKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR => vkGetPhysicalDeviceDisplayPlanePropertiesKHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceDisplayPlanePropertiesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR => vkGetPhysicalDeviceDisplayPlanePropertiesKHR__errorcodes;
	private static VkResult[?] vkGetDisplayPlaneSupportedDisplaysKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetDisplayPlaneSupportedDisplaysKHR => vkGetDisplayPlaneSupportedDisplaysKHR__successcodes;
	private static VkResult[?] vkGetDisplayPlaneSupportedDisplaysKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetDisplayPlaneSupportedDisplaysKHR => vkGetDisplayPlaneSupportedDisplaysKHR__errorcodes;
	private static VkResult[?] vkGetDisplayModePropertiesKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetDisplayModePropertiesKHR => vkGetDisplayModePropertiesKHR__successcodes;
	private static VkResult[?] vkGetDisplayModePropertiesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetDisplayModePropertiesKHR => vkGetDisplayModePropertiesKHR__errorcodes;
	private static VkResult[?] vkCreateDisplayModeKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateDisplayModeKHR => vkCreateDisplayModeKHR__successcodes;
	private static VkResult[?] vkCreateDisplayModeKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInitializationFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateDisplayModeKHR => vkCreateDisplayModeKHR__errorcodes;
	private static VkResult[?] vkGetDisplayPlaneCapabilitiesKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetDisplayPlaneCapabilitiesKHR => vkGetDisplayPlaneCapabilitiesKHR__successcodes;
	private static VkResult[?] vkGetDisplayPlaneCapabilitiesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetDisplayPlaneCapabilitiesKHR => vkGetDisplayPlaneCapabilitiesKHR__errorcodes;
	private static VkResult[?] vkCreateDisplayPlaneSurfaceKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateDisplayPlaneSurfaceKHR => vkCreateDisplayPlaneSurfaceKHR__successcodes;
	private static VkResult[?] vkCreateDisplayPlaneSurfaceKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateDisplayPlaneSurfaceKHR => vkCreateDisplayPlaneSurfaceKHR__errorcodes;
	private static VkResult[?] vkCreateSharedSwapchainsKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateSharedSwapchainsKHR => vkCreateSharedSwapchainsKHR__successcodes;
	private static VkResult[?] vkCreateSharedSwapchainsKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorIncompatibleDisplayKHR, .VkErrorDeviceLost, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateSharedSwapchainsKHR => vkCreateSharedSwapchainsKHR__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceSurfaceSupportKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfaceSupportKHR => vkGetPhysicalDeviceSurfaceSupportKHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceSurfaceSupportKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfaceSupportKHR => vkGetPhysicalDeviceSurfaceSupportKHR__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceSurfaceCapabilitiesKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR => vkGetPhysicalDeviceSurfaceCapabilitiesKHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceSurfaceCapabilitiesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR => vkGetPhysicalDeviceSurfaceCapabilitiesKHR__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceSurfaceFormatsKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfaceFormatsKHR => vkGetPhysicalDeviceSurfaceFormatsKHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceSurfaceFormatsKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfaceFormatsKHR => vkGetPhysicalDeviceSurfaceFormatsKHR__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceSurfacePresentModesKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfacePresentModesKHR => vkGetPhysicalDeviceSurfacePresentModesKHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceSurfacePresentModesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfacePresentModesKHR => vkGetPhysicalDeviceSurfacePresentModesKHR__errorcodes;
	private static VkResult[?] vkCreateSwapchainKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateSwapchainKHR => vkCreateSwapchainKHR__successcodes;
	private static VkResult[?] vkCreateSwapchainKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost, .VkErrorSurfaceLostKHR, .VkErrorNativeWindowInUseKHR, .VkErrorInitializationFailed, .VkErrorCompressionExhaustedEXT);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateSwapchainKHR => vkCreateSwapchainKHR__errorcodes;
	private static VkResult[?] vkGetSwapchainImagesKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetSwapchainImagesKHR => vkGetSwapchainImagesKHR__successcodes;
	private static VkResult[?] vkGetSwapchainImagesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetSwapchainImagesKHR => vkGetSwapchainImagesKHR__errorcodes;
	private static VkResult[?] vkAcquireNextImageKHR__successcodes = .(.VkSuccess, .VkTimeout, .VkNotReady, .VkSuboptimalKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkAcquireNextImageKHR => vkAcquireNextImageKHR__successcodes;
	private static VkResult[?] vkAcquireNextImageKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost, .VkErrorOutOfDateKHR, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkAcquireNextImageKHR => vkAcquireNextImageKHR__errorcodes;
	private static VkResult[?] vkQueuePresentKHR__successcodes = .(.VkSuccess, .VkSuboptimalKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkQueuePresentKHR => vkQueuePresentKHR__successcodes;
	private static VkResult[?] vkQueuePresentKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost, .VkErrorOutOfDateKHR, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkQueuePresentKHR => vkQueuePresentKHR__errorcodes;
	private static VkResult[?] vkCreateDebugReportCallbackEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateDebugReportCallbackEXT => vkCreateDebugReportCallbackEXT__successcodes;
	private static VkResult[?] vkCreateDebugReportCallbackEXT__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateDebugReportCallbackEXT => vkCreateDebugReportCallbackEXT__errorcodes;
	private static VkResult[?] vkDebugMarkerSetObjectNameEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkDebugMarkerSetObjectNameEXT => vkDebugMarkerSetObjectNameEXT__successcodes;
	private static VkResult[?] vkDebugMarkerSetObjectNameEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkDebugMarkerSetObjectNameEXT => vkDebugMarkerSetObjectNameEXT__errorcodes;
	private static VkResult[?] vkDebugMarkerSetObjectTagEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkDebugMarkerSetObjectTagEXT => vkDebugMarkerSetObjectTagEXT__successcodes;
	private static VkResult[?] vkDebugMarkerSetObjectTagEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkDebugMarkerSetObjectTagEXT => vkDebugMarkerSetObjectTagEXT__errorcodes;
	private static VkQueueFlags vkCmdDebugMarkerBeginEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDebugMarkerBeginEXT => vkCmdDebugMarkerBeginEXT__queues;
	private static RenderPassLocation vkCmdDebugMarkerBeginEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDebugMarkerBeginEXT => vkCmdDebugMarkerBeginEXT__renderpass;
	private static CmdBufferLevel vkCmdDebugMarkerBeginEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDebugMarkerBeginEXT => vkCmdDebugMarkerBeginEXT__cmdbufferlevel;
	private static Task vkCmdDebugMarkerBeginEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDebugMarkerBeginEXT => vkCmdDebugMarkerBeginEXT__tasks;
	private static VkQueueFlags vkCmdDebugMarkerEndEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDebugMarkerEndEXT => vkCmdDebugMarkerEndEXT__queues;
	private static RenderPassLocation vkCmdDebugMarkerEndEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDebugMarkerEndEXT => vkCmdDebugMarkerEndEXT__renderpass;
	private static CmdBufferLevel vkCmdDebugMarkerEndEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDebugMarkerEndEXT => vkCmdDebugMarkerEndEXT__cmdbufferlevel;
	private static Task vkCmdDebugMarkerEndEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDebugMarkerEndEXT => vkCmdDebugMarkerEndEXT__tasks;
	private static VkQueueFlags vkCmdDebugMarkerInsertEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDebugMarkerInsertEXT => vkCmdDebugMarkerInsertEXT__queues;
	private static RenderPassLocation vkCmdDebugMarkerInsertEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDebugMarkerInsertEXT => vkCmdDebugMarkerInsertEXT__renderpass;
	private static CmdBufferLevel vkCmdDebugMarkerInsertEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDebugMarkerInsertEXT => vkCmdDebugMarkerInsertEXT__cmdbufferlevel;
	private static Task vkCmdDebugMarkerInsertEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDebugMarkerInsertEXT => vkCmdDebugMarkerInsertEXT__tasks;
	private static VkResult[?] vkGetPhysicalDeviceExternalImageFormatPropertiesNV__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV => vkGetPhysicalDeviceExternalImageFormatPropertiesNV__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceExternalImageFormatPropertiesNV__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorFormatNotSupported);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV => vkGetPhysicalDeviceExternalImageFormatPropertiesNV__errorcodes;
	private static VkQueueFlags vkCmdExecuteGeneratedCommandsNV__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdExecuteGeneratedCommandsNV => vkCmdExecuteGeneratedCommandsNV__queues;
	private static RenderPassLocation vkCmdExecuteGeneratedCommandsNV__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdExecuteGeneratedCommandsNV => vkCmdExecuteGeneratedCommandsNV__renderpass;
	private static CmdBufferLevel vkCmdExecuteGeneratedCommandsNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdExecuteGeneratedCommandsNV => vkCmdExecuteGeneratedCommandsNV__cmdbufferlevel;
	private static Task vkCmdExecuteGeneratedCommandsNV__tasks = .Action | .Indirection;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdExecuteGeneratedCommandsNV => vkCmdExecuteGeneratedCommandsNV__tasks;
	private static VkQueueFlags vkCmdPreprocessGeneratedCommandsNV__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdPreprocessGeneratedCommandsNV => vkCmdPreprocessGeneratedCommandsNV__queues;
	private static RenderPassLocation vkCmdPreprocessGeneratedCommandsNV__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdPreprocessGeneratedCommandsNV => vkCmdPreprocessGeneratedCommandsNV__renderpass;
	private static CmdBufferLevel vkCmdPreprocessGeneratedCommandsNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdPreprocessGeneratedCommandsNV => vkCmdPreprocessGeneratedCommandsNV__cmdbufferlevel;
	private static Task vkCmdPreprocessGeneratedCommandsNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdPreprocessGeneratedCommandsNV => vkCmdPreprocessGeneratedCommandsNV__tasks;
	private static VkQueueFlags vkCmdBindPipelineShaderGroupNV__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindPipelineShaderGroupNV => vkCmdBindPipelineShaderGroupNV__queues;
	private static RenderPassLocation vkCmdBindPipelineShaderGroupNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindPipelineShaderGroupNV => vkCmdBindPipelineShaderGroupNV__renderpass;
	private static CmdBufferLevel vkCmdBindPipelineShaderGroupNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindPipelineShaderGroupNV => vkCmdBindPipelineShaderGroupNV__cmdbufferlevel;
	private static Task vkCmdBindPipelineShaderGroupNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindPipelineShaderGroupNV => vkCmdBindPipelineShaderGroupNV__tasks;
	private static VkResult[?] vkCreateIndirectCommandsLayoutNV__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateIndirectCommandsLayoutNV => vkCreateIndirectCommandsLayoutNV__successcodes;
	private static VkResult[?] vkCreateIndirectCommandsLayoutNV__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateIndirectCommandsLayoutNV => vkCreateIndirectCommandsLayoutNV__errorcodes;
	private static VkQueueFlags vkCmdExecuteGeneratedCommandsEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdExecuteGeneratedCommandsEXT => vkCmdExecuteGeneratedCommandsEXT__queues;
	private static RenderPassLocation vkCmdExecuteGeneratedCommandsEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdExecuteGeneratedCommandsEXT => vkCmdExecuteGeneratedCommandsEXT__renderpass;
	private static CmdBufferLevel vkCmdExecuteGeneratedCommandsEXT__cmdbufferlevel = .Primary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdExecuteGeneratedCommandsEXT => vkCmdExecuteGeneratedCommandsEXT__cmdbufferlevel;
	private static Task vkCmdExecuteGeneratedCommandsEXT__tasks = .Action | .Indirection;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdExecuteGeneratedCommandsEXT => vkCmdExecuteGeneratedCommandsEXT__tasks;
	private static VkQueueFlags vkCmdPreprocessGeneratedCommandsEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdPreprocessGeneratedCommandsEXT => vkCmdPreprocessGeneratedCommandsEXT__queues;
	private static RenderPassLocation vkCmdPreprocessGeneratedCommandsEXT__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdPreprocessGeneratedCommandsEXT => vkCmdPreprocessGeneratedCommandsEXT__renderpass;
	private static CmdBufferLevel vkCmdPreprocessGeneratedCommandsEXT__cmdbufferlevel = .Primary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdPreprocessGeneratedCommandsEXT => vkCmdPreprocessGeneratedCommandsEXT__cmdbufferlevel;
	private static Task vkCmdPreprocessGeneratedCommandsEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdPreprocessGeneratedCommandsEXT => vkCmdPreprocessGeneratedCommandsEXT__tasks;
	private static VkResult[?] vkCreateIndirectCommandsLayoutEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateIndirectCommandsLayoutEXT => vkCreateIndirectCommandsLayoutEXT__successcodes;
	private static VkResult[?] vkCreateIndirectCommandsLayoutEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateIndirectCommandsLayoutEXT => vkCreateIndirectCommandsLayoutEXT__errorcodes;
	private static VkResult[?] vkCreateIndirectExecutionSetEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateIndirectExecutionSetEXT => vkCreateIndirectExecutionSetEXT__successcodes;
	private static VkResult[?] vkCreateIndirectExecutionSetEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateIndirectExecutionSetEXT => vkCreateIndirectExecutionSetEXT__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceImageFormatProperties2__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceImageFormatProperties2 => vkGetPhysicalDeviceImageFormatProperties2__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceImageFormatProperties2__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorFormatNotSupported, .VkErrorImageUsageNotSupportedKHR, .VkErrorVideoProfileOperationNotSupportedKHR, .VkErrorVideoProfileFormatNotSupportedKHR, .VkErrorVideoPictureLayoutNotSupportedKHR, .VkErrorVideoProfileCodecNotSupportedKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceImageFormatProperties2 => vkGetPhysicalDeviceImageFormatProperties2__errorcodes;
	private static VkQueueFlags vkCmdPushDescriptorSet__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdPushDescriptorSet => vkCmdPushDescriptorSet__queues;
	private static RenderPassLocation vkCmdPushDescriptorSet__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdPushDescriptorSet => vkCmdPushDescriptorSet__renderpass;
	private static CmdBufferLevel vkCmdPushDescriptorSet__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdPushDescriptorSet => vkCmdPushDescriptorSet__cmdbufferlevel;
	private static Task vkCmdPushDescriptorSet__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdPushDescriptorSet => vkCmdPushDescriptorSet__tasks;
	private static VkResult[?] vkGetMemoryFdKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetMemoryFdKHR => vkGetMemoryFdKHR__successcodes;
	private static VkResult[?] vkGetMemoryFdKHR__errorcodes = .(.VkErrorTooManyObjects, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetMemoryFdKHR => vkGetMemoryFdKHR__errorcodes;
	private static VkResult[?] vkGetMemoryFdPropertiesKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetMemoryFdPropertiesKHR => vkGetMemoryFdPropertiesKHR__successcodes;
	private static VkResult[?] vkGetMemoryFdPropertiesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorInvalidExternalHandle);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetMemoryFdPropertiesKHR => vkGetMemoryFdPropertiesKHR__errorcodes;
	private static VkResult[?] vkGetMemoryRemoteAddressNV__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetMemoryRemoteAddressNV => vkGetMemoryRemoteAddressNV__successcodes;
	private static VkResult[?] vkGetMemoryRemoteAddressNV__errorcodes = .(.VkErrorInvalidExternalHandle);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetMemoryRemoteAddressNV => vkGetMemoryRemoteAddressNV__errorcodes;
	private static VkResult[?] vkGetSemaphoreFdKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetSemaphoreFdKHR => vkGetSemaphoreFdKHR__successcodes;
	private static VkResult[?] vkGetSemaphoreFdKHR__errorcodes = .(.VkErrorTooManyObjects, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetSemaphoreFdKHR => vkGetSemaphoreFdKHR__errorcodes;
	private static VkResult[?] vkImportSemaphoreFdKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkImportSemaphoreFdKHR => vkImportSemaphoreFdKHR__successcodes;
	private static VkResult[?] vkImportSemaphoreFdKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorInvalidExternalHandle);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkImportSemaphoreFdKHR => vkImportSemaphoreFdKHR__errorcodes;
	private static VkResult[?] vkGetFenceFdKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetFenceFdKHR => vkGetFenceFdKHR__successcodes;
	private static VkResult[?] vkGetFenceFdKHR__errorcodes = .(.VkErrorTooManyObjects, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetFenceFdKHR => vkGetFenceFdKHR__errorcodes;
	private static VkResult[?] vkImportFenceFdKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkImportFenceFdKHR => vkImportFenceFdKHR__successcodes;
	private static VkResult[?] vkImportFenceFdKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorInvalidExternalHandle);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkImportFenceFdKHR => vkImportFenceFdKHR__errorcodes;
	private static VkResult[?] vkReleaseDisplayEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkReleaseDisplayEXT => vkReleaseDisplayEXT__successcodes;
	private static VkResult[?] vkDisplayPowerControlEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkDisplayPowerControlEXT => vkDisplayPowerControlEXT__successcodes;
	private static VkResult[?] vkDisplayPowerControlEXT__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkDisplayPowerControlEXT => vkDisplayPowerControlEXT__errorcodes;
	private static VkResult[?] vkRegisterDeviceEventEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkRegisterDeviceEventEXT => vkRegisterDeviceEventEXT__successcodes;
	private static VkResult[?] vkRegisterDeviceEventEXT__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkRegisterDeviceEventEXT => vkRegisterDeviceEventEXT__errorcodes;
	private static VkResult[?] vkRegisterDisplayEventEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkRegisterDisplayEventEXT => vkRegisterDisplayEventEXT__successcodes;
	private static VkResult[?] vkRegisterDisplayEventEXT__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkRegisterDisplayEventEXT => vkRegisterDisplayEventEXT__errorcodes;
	private static VkResult[?] vkGetSwapchainCounterEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetSwapchainCounterEXT => vkGetSwapchainCounterEXT__successcodes;
	private static VkResult[?] vkGetSwapchainCounterEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorDeviceLost, .VkErrorOutOfDateKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetSwapchainCounterEXT => vkGetSwapchainCounterEXT__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceSurfaceCapabilities2EXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT => vkGetPhysicalDeviceSurfaceCapabilities2EXT__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceSurfaceCapabilities2EXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT => vkGetPhysicalDeviceSurfaceCapabilities2EXT__errorcodes;
	private static VkResult[?] vkEnumeratePhysicalDeviceGroups__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkEnumeratePhysicalDeviceGroups => vkEnumeratePhysicalDeviceGroups__successcodes;
	private static VkResult[?] vkEnumeratePhysicalDeviceGroups__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInitializationFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkEnumeratePhysicalDeviceGroups => vkEnumeratePhysicalDeviceGroups__errorcodes;
	private static VkResult[?] vkBindBufferMemory2__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkBindBufferMemory2 => vkBindBufferMemory2__successcodes;
	private static VkResult[?] vkBindBufferMemory2__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInvalidOpaqueCaptureAddressKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkBindBufferMemory2 => vkBindBufferMemory2__errorcodes;
	private static VkResult[?] vkBindImageMemory2__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkBindImageMemory2 => vkBindImageMemory2__successcodes;
	private static VkResult[?] vkBindImageMemory2__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkBindImageMemory2 => vkBindImageMemory2__errorcodes;
	private static VkQueueFlags vkCmdSetDeviceMask__queues = .Graphics | .Compute | .Transfer;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDeviceMask => vkCmdSetDeviceMask__queues;
	private static RenderPassLocation vkCmdSetDeviceMask__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDeviceMask => vkCmdSetDeviceMask__renderpass;
	private static CmdBufferLevel vkCmdSetDeviceMask__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDeviceMask => vkCmdSetDeviceMask__cmdbufferlevel;
	private static Task vkCmdSetDeviceMask__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDeviceMask => vkCmdSetDeviceMask__tasks;
	private static VkResult[?] vkGetDeviceGroupPresentCapabilitiesKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetDeviceGroupPresentCapabilitiesKHR => vkGetDeviceGroupPresentCapabilitiesKHR__successcodes;
	private static VkResult[?] vkGetDeviceGroupPresentCapabilitiesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetDeviceGroupPresentCapabilitiesKHR => vkGetDeviceGroupPresentCapabilitiesKHR__errorcodes;
	private static VkResult[?] vkGetDeviceGroupSurfacePresentModesKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetDeviceGroupSurfacePresentModesKHR => vkGetDeviceGroupSurfacePresentModesKHR__successcodes;
	private static VkResult[?] vkGetDeviceGroupSurfacePresentModesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetDeviceGroupSurfacePresentModesKHR => vkGetDeviceGroupSurfacePresentModesKHR__errorcodes;
	private static VkResult[?] vkAcquireNextImage2KHR__successcodes = .(.VkSuccess, .VkTimeout, .VkNotReady, .VkSuboptimalKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkAcquireNextImage2KHR => vkAcquireNextImage2KHR__successcodes;
	private static VkResult[?] vkAcquireNextImage2KHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost, .VkErrorOutOfDateKHR, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkAcquireNextImage2KHR => vkAcquireNextImage2KHR__errorcodes;
	private static VkQueueFlags vkCmdDispatchBase__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDispatchBase => vkCmdDispatchBase__queues;
	private static RenderPassLocation vkCmdDispatchBase__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDispatchBase => vkCmdDispatchBase__renderpass;
	private static CmdBufferLevel vkCmdDispatchBase__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDispatchBase => vkCmdDispatchBase__cmdbufferlevel;
	private static Task vkCmdDispatchBase__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDispatchBase => vkCmdDispatchBase__tasks;
	private static VkResult[?] vkGetPhysicalDevicePresentRectanglesKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDevicePresentRectanglesKHR => vkGetPhysicalDevicePresentRectanglesKHR__successcodes;
	private static VkResult[?] vkGetPhysicalDevicePresentRectanglesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDevicePresentRectanglesKHR => vkGetPhysicalDevicePresentRectanglesKHR__errorcodes;
	private static VkResult[?] vkCreateDescriptorUpdateTemplate__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateDescriptorUpdateTemplate => vkCreateDescriptorUpdateTemplate__successcodes;
	private static VkResult[?] vkCreateDescriptorUpdateTemplate__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateDescriptorUpdateTemplate => vkCreateDescriptorUpdateTemplate__errorcodes;
	private static VkQueueFlags vkCmdPushDescriptorSetWithTemplate__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdPushDescriptorSetWithTemplate => vkCmdPushDescriptorSetWithTemplate__queues;
	private static RenderPassLocation vkCmdPushDescriptorSetWithTemplate__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdPushDescriptorSetWithTemplate => vkCmdPushDescriptorSetWithTemplate__renderpass;
	private static CmdBufferLevel vkCmdPushDescriptorSetWithTemplate__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdPushDescriptorSetWithTemplate => vkCmdPushDescriptorSetWithTemplate__cmdbufferlevel;
	private static Task vkCmdPushDescriptorSetWithTemplate__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdPushDescriptorSetWithTemplate => vkCmdPushDescriptorSetWithTemplate__tasks;
	private static VkResult[?] vkGetSwapchainStatusKHR__successcodes = .(.VkSuccess, .VkSuboptimalKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetSwapchainStatusKHR => vkGetSwapchainStatusKHR__successcodes;
	private static VkResult[?] vkGetSwapchainStatusKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost, .VkErrorOutOfDateKHR, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetSwapchainStatusKHR => vkGetSwapchainStatusKHR__errorcodes;
	private static VkResult[?] vkGetRefreshCycleDurationGOOGLE__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetRefreshCycleDurationGOOGLE => vkGetRefreshCycleDurationGOOGLE__successcodes;
	private static VkResult[?] vkGetRefreshCycleDurationGOOGLE__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorDeviceLost, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetRefreshCycleDurationGOOGLE => vkGetRefreshCycleDurationGOOGLE__errorcodes;
	private static VkResult[?] vkGetPastPresentationTimingGOOGLE__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPastPresentationTimingGOOGLE => vkGetPastPresentationTimingGOOGLE__successcodes;
	private static VkResult[?] vkGetPastPresentationTimingGOOGLE__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorDeviceLost, .VkErrorOutOfDateKHR, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPastPresentationTimingGOOGLE => vkGetPastPresentationTimingGOOGLE__errorcodes;
	private static VkQueueFlags vkCmdSetViewportWScalingNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetViewportWScalingNV => vkCmdSetViewportWScalingNV__queues;
	private static RenderPassLocation vkCmdSetViewportWScalingNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetViewportWScalingNV => vkCmdSetViewportWScalingNV__renderpass;
	private static CmdBufferLevel vkCmdSetViewportWScalingNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetViewportWScalingNV => vkCmdSetViewportWScalingNV__cmdbufferlevel;
	private static Task vkCmdSetViewportWScalingNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetViewportWScalingNV => vkCmdSetViewportWScalingNV__tasks;
	private static VkQueueFlags vkCmdSetDiscardRectangleEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDiscardRectangleEXT => vkCmdSetDiscardRectangleEXT__queues;
	private static RenderPassLocation vkCmdSetDiscardRectangleEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDiscardRectangleEXT => vkCmdSetDiscardRectangleEXT__renderpass;
	private static CmdBufferLevel vkCmdSetDiscardRectangleEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDiscardRectangleEXT => vkCmdSetDiscardRectangleEXT__cmdbufferlevel;
	private static Task vkCmdSetDiscardRectangleEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDiscardRectangleEXT => vkCmdSetDiscardRectangleEXT__tasks;
	private static VkQueueFlags vkCmdSetDiscardRectangleEnableEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDiscardRectangleEnableEXT => vkCmdSetDiscardRectangleEnableEXT__queues;
	private static RenderPassLocation vkCmdSetDiscardRectangleEnableEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDiscardRectangleEnableEXT => vkCmdSetDiscardRectangleEnableEXT__renderpass;
	private static CmdBufferLevel vkCmdSetDiscardRectangleEnableEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDiscardRectangleEnableEXT => vkCmdSetDiscardRectangleEnableEXT__cmdbufferlevel;
	private static Task vkCmdSetDiscardRectangleEnableEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDiscardRectangleEnableEXT => vkCmdSetDiscardRectangleEnableEXT__tasks;
	private static VkQueueFlags vkCmdSetDiscardRectangleModeEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDiscardRectangleModeEXT => vkCmdSetDiscardRectangleModeEXT__queues;
	private static RenderPassLocation vkCmdSetDiscardRectangleModeEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDiscardRectangleModeEXT => vkCmdSetDiscardRectangleModeEXT__renderpass;
	private static CmdBufferLevel vkCmdSetDiscardRectangleModeEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDiscardRectangleModeEXT => vkCmdSetDiscardRectangleModeEXT__cmdbufferlevel;
	private static Task vkCmdSetDiscardRectangleModeEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDiscardRectangleModeEXT => vkCmdSetDiscardRectangleModeEXT__tasks;
	private static VkQueueFlags vkCmdSetSampleLocationsEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetSampleLocationsEXT => vkCmdSetSampleLocationsEXT__queues;
	private static RenderPassLocation vkCmdSetSampleLocationsEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetSampleLocationsEXT => vkCmdSetSampleLocationsEXT__renderpass;
	private static CmdBufferLevel vkCmdSetSampleLocationsEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetSampleLocationsEXT => vkCmdSetSampleLocationsEXT__cmdbufferlevel;
	private static Task vkCmdSetSampleLocationsEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetSampleLocationsEXT => vkCmdSetSampleLocationsEXT__tasks;
	private static VkResult[?] vkGetPhysicalDeviceSurfaceCapabilities2KHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR => vkGetPhysicalDeviceSurfaceCapabilities2KHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceSurfaceCapabilities2KHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR => vkGetPhysicalDeviceSurfaceCapabilities2KHR__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceSurfaceFormats2KHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfaceFormats2KHR => vkGetPhysicalDeviceSurfaceFormats2KHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceSurfaceFormats2KHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceSurfaceFormats2KHR => vkGetPhysicalDeviceSurfaceFormats2KHR__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceDisplayProperties2KHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceDisplayProperties2KHR => vkGetPhysicalDeviceDisplayProperties2KHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceDisplayProperties2KHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceDisplayProperties2KHR => vkGetPhysicalDeviceDisplayProperties2KHR__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceDisplayPlaneProperties2KHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR => vkGetPhysicalDeviceDisplayPlaneProperties2KHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceDisplayPlaneProperties2KHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR => vkGetPhysicalDeviceDisplayPlaneProperties2KHR__errorcodes;
	private static VkResult[?] vkGetDisplayModeProperties2KHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetDisplayModeProperties2KHR => vkGetDisplayModeProperties2KHR__successcodes;
	private static VkResult[?] vkGetDisplayModeProperties2KHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetDisplayModeProperties2KHR => vkGetDisplayModeProperties2KHR__errorcodes;
	private static VkResult[?] vkGetDisplayPlaneCapabilities2KHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetDisplayPlaneCapabilities2KHR => vkGetDisplayPlaneCapabilities2KHR__successcodes;
	private static VkResult[?] vkGetDisplayPlaneCapabilities2KHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetDisplayPlaneCapabilities2KHR => vkGetDisplayPlaneCapabilities2KHR__errorcodes;
	private static VkResult[?] vkCreateSamplerYcbcrConversion__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateSamplerYcbcrConversion => vkCreateSamplerYcbcrConversion__successcodes;
	private static VkResult[?] vkCreateSamplerYcbcrConversion__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateSamplerYcbcrConversion => vkCreateSamplerYcbcrConversion__errorcodes;
	private static VkResult[?] vkCreateValidationCacheEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateValidationCacheEXT => vkCreateValidationCacheEXT__successcodes;
	private static VkResult[?] vkCreateValidationCacheEXT__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateValidationCacheEXT => vkCreateValidationCacheEXT__errorcodes;
	private static VkResult[?] vkGetValidationCacheDataEXT__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetValidationCacheDataEXT => vkGetValidationCacheDataEXT__successcodes;
	private static VkResult[?] vkGetValidationCacheDataEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetValidationCacheDataEXT => vkGetValidationCacheDataEXT__errorcodes;
	private static VkResult[?] vkMergeValidationCachesEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkMergeValidationCachesEXT => vkMergeValidationCachesEXT__successcodes;
	private static VkResult[?] vkMergeValidationCachesEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkMergeValidationCachesEXT => vkMergeValidationCachesEXT__errorcodes;
	private static VkResult[?] vkGetShaderInfoAMD__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetShaderInfoAMD => vkGetShaderInfoAMD__successcodes;
	private static VkResult[?] vkGetShaderInfoAMD__errorcodes = .(.VkErrorFeatureNotPresent, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetShaderInfoAMD => vkGetShaderInfoAMD__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceCalibrateableTimeDomainsKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR => vkGetPhysicalDeviceCalibrateableTimeDomainsKHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceCalibrateableTimeDomainsKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR => vkGetPhysicalDeviceCalibrateableTimeDomainsKHR__errorcodes;
	private static VkResult[?] vkGetCalibratedTimestampsKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetCalibratedTimestampsKHR => vkGetCalibratedTimestampsKHR__successcodes;
	private static VkResult[?] vkGetCalibratedTimestampsKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetCalibratedTimestampsKHR => vkGetCalibratedTimestampsKHR__errorcodes;
	private static VkResult[?] vkSetDebugUtilsObjectNameEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkSetDebugUtilsObjectNameEXT => vkSetDebugUtilsObjectNameEXT__successcodes;
	private static VkResult[?] vkSetDebugUtilsObjectNameEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkSetDebugUtilsObjectNameEXT => vkSetDebugUtilsObjectNameEXT__errorcodes;
	private static VkResult[?] vkSetDebugUtilsObjectTagEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkSetDebugUtilsObjectTagEXT => vkSetDebugUtilsObjectTagEXT__successcodes;
	private static VkResult[?] vkSetDebugUtilsObjectTagEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkSetDebugUtilsObjectTagEXT => vkSetDebugUtilsObjectTagEXT__errorcodes;
	private static VkQueueFlags vkCmdBeginDebugUtilsLabelEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBeginDebugUtilsLabelEXT => vkCmdBeginDebugUtilsLabelEXT__queues;
	private static RenderPassLocation vkCmdBeginDebugUtilsLabelEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBeginDebugUtilsLabelEXT => vkCmdBeginDebugUtilsLabelEXT__renderpass;
	private static CmdBufferLevel vkCmdBeginDebugUtilsLabelEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBeginDebugUtilsLabelEXT => vkCmdBeginDebugUtilsLabelEXT__cmdbufferlevel;
	private static Task vkCmdBeginDebugUtilsLabelEXT__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBeginDebugUtilsLabelEXT => vkCmdBeginDebugUtilsLabelEXT__tasks;
	private static VkQueueFlags vkCmdEndDebugUtilsLabelEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdEndDebugUtilsLabelEXT => vkCmdEndDebugUtilsLabelEXT__queues;
	private static RenderPassLocation vkCmdEndDebugUtilsLabelEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdEndDebugUtilsLabelEXT => vkCmdEndDebugUtilsLabelEXT__renderpass;
	private static CmdBufferLevel vkCmdEndDebugUtilsLabelEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdEndDebugUtilsLabelEXT => vkCmdEndDebugUtilsLabelEXT__cmdbufferlevel;
	private static Task vkCmdEndDebugUtilsLabelEXT__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdEndDebugUtilsLabelEXT => vkCmdEndDebugUtilsLabelEXT__tasks;
	private static VkQueueFlags vkCmdInsertDebugUtilsLabelEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdInsertDebugUtilsLabelEXT => vkCmdInsertDebugUtilsLabelEXT__queues;
	private static RenderPassLocation vkCmdInsertDebugUtilsLabelEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdInsertDebugUtilsLabelEXT => vkCmdInsertDebugUtilsLabelEXT__renderpass;
	private static CmdBufferLevel vkCmdInsertDebugUtilsLabelEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdInsertDebugUtilsLabelEXT => vkCmdInsertDebugUtilsLabelEXT__cmdbufferlevel;
	private static Task vkCmdInsertDebugUtilsLabelEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdInsertDebugUtilsLabelEXT => vkCmdInsertDebugUtilsLabelEXT__tasks;
	private static VkResult[?] vkCreateDebugUtilsMessengerEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateDebugUtilsMessengerEXT => vkCreateDebugUtilsMessengerEXT__successcodes;
	private static VkResult[?] vkCreateDebugUtilsMessengerEXT__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateDebugUtilsMessengerEXT => vkCreateDebugUtilsMessengerEXT__errorcodes;
	private static VkResult[?] vkGetMemoryHostPointerPropertiesEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetMemoryHostPointerPropertiesEXT => vkGetMemoryHostPointerPropertiesEXT__successcodes;
	private static VkResult[?] vkGetMemoryHostPointerPropertiesEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorInvalidExternalHandle);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetMemoryHostPointerPropertiesEXT => vkGetMemoryHostPointerPropertiesEXT__errorcodes;
	private static VkQueueFlags vkCmdWriteBufferMarkerAMD__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdWriteBufferMarkerAMD => vkCmdWriteBufferMarkerAMD__queues;
	private static RenderPassLocation vkCmdWriteBufferMarkerAMD__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdWriteBufferMarkerAMD => vkCmdWriteBufferMarkerAMD__renderpass;
	private static CmdBufferLevel vkCmdWriteBufferMarkerAMD__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdWriteBufferMarkerAMD => vkCmdWriteBufferMarkerAMD__cmdbufferlevel;
	private static Task vkCmdWriteBufferMarkerAMD__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdWriteBufferMarkerAMD => vkCmdWriteBufferMarkerAMD__tasks;
	private static VkResult[?] vkCreateRenderPass2__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateRenderPass2 => vkCreateRenderPass2__successcodes;
	private static VkResult[?] vkCreateRenderPass2__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateRenderPass2 => vkCreateRenderPass2__errorcodes;
	private static VkQueueFlags vkCmdBeginRenderPass2__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBeginRenderPass2 => vkCmdBeginRenderPass2__queues;
	private static RenderPassLocation vkCmdBeginRenderPass2__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBeginRenderPass2 => vkCmdBeginRenderPass2__renderpass;
	private static CmdBufferLevel vkCmdBeginRenderPass2__cmdbufferlevel = .Primary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBeginRenderPass2 => vkCmdBeginRenderPass2__cmdbufferlevel;
	private static Task vkCmdBeginRenderPass2__tasks = .Action | .State | .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBeginRenderPass2 => vkCmdBeginRenderPass2__tasks;
	private static VkQueueFlags vkCmdNextSubpass2__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdNextSubpass2 => vkCmdNextSubpass2__queues;
	private static RenderPassLocation vkCmdNextSubpass2__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdNextSubpass2 => vkCmdNextSubpass2__renderpass;
	private static CmdBufferLevel vkCmdNextSubpass2__cmdbufferlevel = .Primary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdNextSubpass2 => vkCmdNextSubpass2__cmdbufferlevel;
	private static Task vkCmdNextSubpass2__tasks = .Action | .State | .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdNextSubpass2 => vkCmdNextSubpass2__tasks;
	private static VkQueueFlags vkCmdEndRenderPass2__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdEndRenderPass2 => vkCmdEndRenderPass2__queues;
	private static RenderPassLocation vkCmdEndRenderPass2__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdEndRenderPass2 => vkCmdEndRenderPass2__renderpass;
	private static CmdBufferLevel vkCmdEndRenderPass2__cmdbufferlevel = .Primary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdEndRenderPass2 => vkCmdEndRenderPass2__cmdbufferlevel;
	private static Task vkCmdEndRenderPass2__tasks = .Action | .State | .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdEndRenderPass2 => vkCmdEndRenderPass2__tasks;
	private static VkResult[?] vkGetSemaphoreCounterValue__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetSemaphoreCounterValue => vkGetSemaphoreCounterValue__successcodes;
	private static VkResult[?] vkGetSemaphoreCounterValue__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetSemaphoreCounterValue => vkGetSemaphoreCounterValue__errorcodes;
	private static VkResult[?] vkWaitSemaphores__successcodes = .(.VkSuccess, .VkTimeout);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkWaitSemaphores => vkWaitSemaphores__successcodes;
	private static VkResult[?] vkWaitSemaphores__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkWaitSemaphores => vkWaitSemaphores__errorcodes;
	private static VkResult[?] vkSignalSemaphore__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkSignalSemaphore => vkSignalSemaphore__successcodes;
	private static VkResult[?] vkSignalSemaphore__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkSignalSemaphore => vkSignalSemaphore__errorcodes;
	private static VkQueueFlags vkCmdDrawIndirectCount__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawIndirectCount => vkCmdDrawIndirectCount__queues;
	private static RenderPassLocation vkCmdDrawIndirectCount__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawIndirectCount => vkCmdDrawIndirectCount__renderpass;
	private static CmdBufferLevel vkCmdDrawIndirectCount__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawIndirectCount => vkCmdDrawIndirectCount__cmdbufferlevel;
	private static Task vkCmdDrawIndirectCount__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawIndirectCount => vkCmdDrawIndirectCount__tasks;
	private static VkQueueFlags vkCmdDrawIndexedIndirectCount__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawIndexedIndirectCount => vkCmdDrawIndexedIndirectCount__queues;
	private static RenderPassLocation vkCmdDrawIndexedIndirectCount__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawIndexedIndirectCount => vkCmdDrawIndexedIndirectCount__renderpass;
	private static CmdBufferLevel vkCmdDrawIndexedIndirectCount__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawIndexedIndirectCount => vkCmdDrawIndexedIndirectCount__cmdbufferlevel;
	private static Task vkCmdDrawIndexedIndirectCount__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawIndexedIndirectCount => vkCmdDrawIndexedIndirectCount__tasks;
	private static VkQueueFlags vkCmdSetCheckpointNV__queues = .Graphics | .Compute | .Transfer;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetCheckpointNV => vkCmdSetCheckpointNV__queues;
	private static RenderPassLocation vkCmdSetCheckpointNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetCheckpointNV => vkCmdSetCheckpointNV__renderpass;
	private static CmdBufferLevel vkCmdSetCheckpointNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetCheckpointNV => vkCmdSetCheckpointNV__cmdbufferlevel;
	private static Task vkCmdSetCheckpointNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetCheckpointNV => vkCmdSetCheckpointNV__tasks;
	private static VkQueueFlags vkCmdBindTransformFeedbackBuffersEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindTransformFeedbackBuffersEXT => vkCmdBindTransformFeedbackBuffersEXT__queues;
	private static RenderPassLocation vkCmdBindTransformFeedbackBuffersEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindTransformFeedbackBuffersEXT => vkCmdBindTransformFeedbackBuffersEXT__renderpass;
	private static CmdBufferLevel vkCmdBindTransformFeedbackBuffersEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindTransformFeedbackBuffersEXT => vkCmdBindTransformFeedbackBuffersEXT__cmdbufferlevel;
	private static Task vkCmdBindTransformFeedbackBuffersEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindTransformFeedbackBuffersEXT => vkCmdBindTransformFeedbackBuffersEXT__tasks;
	private static VkQueueFlags vkCmdBeginTransformFeedbackEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBeginTransformFeedbackEXT => vkCmdBeginTransformFeedbackEXT__queues;
	private static RenderPassLocation vkCmdBeginTransformFeedbackEXT__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBeginTransformFeedbackEXT => vkCmdBeginTransformFeedbackEXT__renderpass;
	private static CmdBufferLevel vkCmdBeginTransformFeedbackEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBeginTransformFeedbackEXT => vkCmdBeginTransformFeedbackEXT__cmdbufferlevel;
	private static Task vkCmdBeginTransformFeedbackEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBeginTransformFeedbackEXT => vkCmdBeginTransformFeedbackEXT__tasks;
	private static VkQueueFlags vkCmdEndTransformFeedbackEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdEndTransformFeedbackEXT => vkCmdEndTransformFeedbackEXT__queues;
	private static RenderPassLocation vkCmdEndTransformFeedbackEXT__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdEndTransformFeedbackEXT => vkCmdEndTransformFeedbackEXT__renderpass;
	private static CmdBufferLevel vkCmdEndTransformFeedbackEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdEndTransformFeedbackEXT => vkCmdEndTransformFeedbackEXT__cmdbufferlevel;
	private static Task vkCmdEndTransformFeedbackEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdEndTransformFeedbackEXT => vkCmdEndTransformFeedbackEXT__tasks;
	private static VkQueueFlags vkCmdBeginQueryIndexedEXT__queues = .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBeginQueryIndexedEXT => vkCmdBeginQueryIndexedEXT__queues;
	private static RenderPassLocation vkCmdBeginQueryIndexedEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBeginQueryIndexedEXT => vkCmdBeginQueryIndexedEXT__renderpass;
	private static CmdBufferLevel vkCmdBeginQueryIndexedEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBeginQueryIndexedEXT => vkCmdBeginQueryIndexedEXT__cmdbufferlevel;
	private static Task vkCmdBeginQueryIndexedEXT__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBeginQueryIndexedEXT => vkCmdBeginQueryIndexedEXT__tasks;
	private static VkQueueFlags vkCmdEndQueryIndexedEXT__queues = .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdEndQueryIndexedEXT => vkCmdEndQueryIndexedEXT__queues;
	private static RenderPassLocation vkCmdEndQueryIndexedEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdEndQueryIndexedEXT => vkCmdEndQueryIndexedEXT__renderpass;
	private static CmdBufferLevel vkCmdEndQueryIndexedEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdEndQueryIndexedEXT => vkCmdEndQueryIndexedEXT__cmdbufferlevel;
	private static Task vkCmdEndQueryIndexedEXT__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdEndQueryIndexedEXT => vkCmdEndQueryIndexedEXT__tasks;
	private static VkQueueFlags vkCmdDrawIndirectByteCountEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawIndirectByteCountEXT => vkCmdDrawIndirectByteCountEXT__queues;
	private static RenderPassLocation vkCmdDrawIndirectByteCountEXT__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawIndirectByteCountEXT => vkCmdDrawIndirectByteCountEXT__renderpass;
	private static CmdBufferLevel vkCmdDrawIndirectByteCountEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawIndirectByteCountEXT => vkCmdDrawIndirectByteCountEXT__cmdbufferlevel;
	private static Task vkCmdDrawIndirectByteCountEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawIndirectByteCountEXT => vkCmdDrawIndirectByteCountEXT__tasks;
	private static VkQueueFlags vkCmdSetExclusiveScissorNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetExclusiveScissorNV => vkCmdSetExclusiveScissorNV__queues;
	private static RenderPassLocation vkCmdSetExclusiveScissorNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetExclusiveScissorNV => vkCmdSetExclusiveScissorNV__renderpass;
	private static CmdBufferLevel vkCmdSetExclusiveScissorNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetExclusiveScissorNV => vkCmdSetExclusiveScissorNV__cmdbufferlevel;
	private static Task vkCmdSetExclusiveScissorNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetExclusiveScissorNV => vkCmdSetExclusiveScissorNV__tasks;
	private static VkQueueFlags vkCmdSetExclusiveScissorEnableNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetExclusiveScissorEnableNV => vkCmdSetExclusiveScissorEnableNV__queues;
	private static RenderPassLocation vkCmdSetExclusiveScissorEnableNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetExclusiveScissorEnableNV => vkCmdSetExclusiveScissorEnableNV__renderpass;
	private static CmdBufferLevel vkCmdSetExclusiveScissorEnableNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetExclusiveScissorEnableNV => vkCmdSetExclusiveScissorEnableNV__cmdbufferlevel;
	private static Task vkCmdSetExclusiveScissorEnableNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetExclusiveScissorEnableNV => vkCmdSetExclusiveScissorEnableNV__tasks;
	private static VkQueueFlags vkCmdBindShadingRateImageNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindShadingRateImageNV => vkCmdBindShadingRateImageNV__queues;
	private static RenderPassLocation vkCmdBindShadingRateImageNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindShadingRateImageNV => vkCmdBindShadingRateImageNV__renderpass;
	private static CmdBufferLevel vkCmdBindShadingRateImageNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindShadingRateImageNV => vkCmdBindShadingRateImageNV__cmdbufferlevel;
	private static Task vkCmdBindShadingRateImageNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindShadingRateImageNV => vkCmdBindShadingRateImageNV__tasks;
	private static VkQueueFlags vkCmdSetViewportShadingRatePaletteNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetViewportShadingRatePaletteNV => vkCmdSetViewportShadingRatePaletteNV__queues;
	private static RenderPassLocation vkCmdSetViewportShadingRatePaletteNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetViewportShadingRatePaletteNV => vkCmdSetViewportShadingRatePaletteNV__renderpass;
	private static CmdBufferLevel vkCmdSetViewportShadingRatePaletteNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetViewportShadingRatePaletteNV => vkCmdSetViewportShadingRatePaletteNV__cmdbufferlevel;
	private static Task vkCmdSetViewportShadingRatePaletteNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetViewportShadingRatePaletteNV => vkCmdSetViewportShadingRatePaletteNV__tasks;
	private static VkQueueFlags vkCmdSetCoarseSampleOrderNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetCoarseSampleOrderNV => vkCmdSetCoarseSampleOrderNV__queues;
	private static RenderPassLocation vkCmdSetCoarseSampleOrderNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetCoarseSampleOrderNV => vkCmdSetCoarseSampleOrderNV__renderpass;
	private static CmdBufferLevel vkCmdSetCoarseSampleOrderNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetCoarseSampleOrderNV => vkCmdSetCoarseSampleOrderNV__cmdbufferlevel;
	private static Task vkCmdSetCoarseSampleOrderNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetCoarseSampleOrderNV => vkCmdSetCoarseSampleOrderNV__tasks;
	private static VkQueueFlags vkCmdDrawMeshTasksNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawMeshTasksNV => vkCmdDrawMeshTasksNV__queues;
	private static RenderPassLocation vkCmdDrawMeshTasksNV__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawMeshTasksNV => vkCmdDrawMeshTasksNV__renderpass;
	private static CmdBufferLevel vkCmdDrawMeshTasksNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawMeshTasksNV => vkCmdDrawMeshTasksNV__cmdbufferlevel;
	private static Task vkCmdDrawMeshTasksNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawMeshTasksNV => vkCmdDrawMeshTasksNV__tasks;
	private static VkQueueFlags vkCmdDrawMeshTasksIndirectNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawMeshTasksIndirectNV => vkCmdDrawMeshTasksIndirectNV__queues;
	private static RenderPassLocation vkCmdDrawMeshTasksIndirectNV__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawMeshTasksIndirectNV => vkCmdDrawMeshTasksIndirectNV__renderpass;
	private static CmdBufferLevel vkCmdDrawMeshTasksIndirectNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawMeshTasksIndirectNV => vkCmdDrawMeshTasksIndirectNV__cmdbufferlevel;
	private static Task vkCmdDrawMeshTasksIndirectNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawMeshTasksIndirectNV => vkCmdDrawMeshTasksIndirectNV__tasks;
	private static VkQueueFlags vkCmdDrawMeshTasksIndirectCountNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawMeshTasksIndirectCountNV => vkCmdDrawMeshTasksIndirectCountNV__queues;
	private static RenderPassLocation vkCmdDrawMeshTasksIndirectCountNV__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawMeshTasksIndirectCountNV => vkCmdDrawMeshTasksIndirectCountNV__renderpass;
	private static CmdBufferLevel vkCmdDrawMeshTasksIndirectCountNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawMeshTasksIndirectCountNV => vkCmdDrawMeshTasksIndirectCountNV__cmdbufferlevel;
	private static Task vkCmdDrawMeshTasksIndirectCountNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawMeshTasksIndirectCountNV => vkCmdDrawMeshTasksIndirectCountNV__tasks;
	private static VkQueueFlags vkCmdDrawMeshTasksEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawMeshTasksEXT => vkCmdDrawMeshTasksEXT__queues;
	private static RenderPassLocation vkCmdDrawMeshTasksEXT__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawMeshTasksEXT => vkCmdDrawMeshTasksEXT__renderpass;
	private static CmdBufferLevel vkCmdDrawMeshTasksEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawMeshTasksEXT => vkCmdDrawMeshTasksEXT__cmdbufferlevel;
	private static Task vkCmdDrawMeshTasksEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawMeshTasksEXT => vkCmdDrawMeshTasksEXT__tasks;
	private static VkQueueFlags vkCmdDrawMeshTasksIndirectEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawMeshTasksIndirectEXT => vkCmdDrawMeshTasksIndirectEXT__queues;
	private static RenderPassLocation vkCmdDrawMeshTasksIndirectEXT__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawMeshTasksIndirectEXT => vkCmdDrawMeshTasksIndirectEXT__renderpass;
	private static CmdBufferLevel vkCmdDrawMeshTasksIndirectEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawMeshTasksIndirectEXT => vkCmdDrawMeshTasksIndirectEXT__cmdbufferlevel;
	private static Task vkCmdDrawMeshTasksIndirectEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawMeshTasksIndirectEXT => vkCmdDrawMeshTasksIndirectEXT__tasks;
	private static VkQueueFlags vkCmdDrawMeshTasksIndirectCountEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDrawMeshTasksIndirectCountEXT => vkCmdDrawMeshTasksIndirectCountEXT__queues;
	private static RenderPassLocation vkCmdDrawMeshTasksIndirectCountEXT__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDrawMeshTasksIndirectCountEXT => vkCmdDrawMeshTasksIndirectCountEXT__renderpass;
	private static CmdBufferLevel vkCmdDrawMeshTasksIndirectCountEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDrawMeshTasksIndirectCountEXT => vkCmdDrawMeshTasksIndirectCountEXT__cmdbufferlevel;
	private static Task vkCmdDrawMeshTasksIndirectCountEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDrawMeshTasksIndirectCountEXT => vkCmdDrawMeshTasksIndirectCountEXT__tasks;
	private static VkResult[?] vkCompileDeferredNV__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCompileDeferredNV => vkCompileDeferredNV__successcodes;
	private static VkResult[?] vkCompileDeferredNV__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCompileDeferredNV => vkCompileDeferredNV__errorcodes;
	private static VkResult[?] vkCreateAccelerationStructureNV__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateAccelerationStructureNV => vkCreateAccelerationStructureNV__successcodes;
	private static VkResult[?] vkCreateAccelerationStructureNV__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateAccelerationStructureNV => vkCreateAccelerationStructureNV__errorcodes;
	private static VkQueueFlags vkCmdBindInvocationMaskHUAWEI__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindInvocationMaskHUAWEI => vkCmdBindInvocationMaskHUAWEI__queues;
	private static RenderPassLocation vkCmdBindInvocationMaskHUAWEI__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindInvocationMaskHUAWEI => vkCmdBindInvocationMaskHUAWEI__renderpass;
	private static CmdBufferLevel vkCmdBindInvocationMaskHUAWEI__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindInvocationMaskHUAWEI => vkCmdBindInvocationMaskHUAWEI__cmdbufferlevel;
	private static Task vkCmdBindInvocationMaskHUAWEI__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindInvocationMaskHUAWEI => vkCmdBindInvocationMaskHUAWEI__tasks;
	private static VkResult[?] vkBindAccelerationStructureMemoryNV__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkBindAccelerationStructureMemoryNV => vkBindAccelerationStructureMemoryNV__successcodes;
	private static VkResult[?] vkBindAccelerationStructureMemoryNV__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkBindAccelerationStructureMemoryNV => vkBindAccelerationStructureMemoryNV__errorcodes;
	private static VkQueueFlags vkCmdCopyAccelerationStructureNV__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyAccelerationStructureNV => vkCmdCopyAccelerationStructureNV__queues;
	private static RenderPassLocation vkCmdCopyAccelerationStructureNV__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyAccelerationStructureNV => vkCmdCopyAccelerationStructureNV__renderpass;
	private static CmdBufferLevel vkCmdCopyAccelerationStructureNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyAccelerationStructureNV => vkCmdCopyAccelerationStructureNV__cmdbufferlevel;
	private static Task vkCmdCopyAccelerationStructureNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyAccelerationStructureNV => vkCmdCopyAccelerationStructureNV__tasks;
	private static VkQueueFlags vkCmdCopyAccelerationStructureKHR__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyAccelerationStructureKHR => vkCmdCopyAccelerationStructureKHR__queues;
	private static RenderPassLocation vkCmdCopyAccelerationStructureKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyAccelerationStructureKHR => vkCmdCopyAccelerationStructureKHR__renderpass;
	private static CmdBufferLevel vkCmdCopyAccelerationStructureKHR__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyAccelerationStructureKHR => vkCmdCopyAccelerationStructureKHR__cmdbufferlevel;
	private static Task vkCmdCopyAccelerationStructureKHR__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyAccelerationStructureKHR => vkCmdCopyAccelerationStructureKHR__tasks;
	private static VkResult[?] vkCopyAccelerationStructureKHR__successcodes = .(.VkSuccess, .VkOperationDeferredKHR, .VkOperationNotDeferredKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCopyAccelerationStructureKHR => vkCopyAccelerationStructureKHR__successcodes;
	private static VkResult[?] vkCopyAccelerationStructureKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCopyAccelerationStructureKHR => vkCopyAccelerationStructureKHR__errorcodes;
	private static VkQueueFlags vkCmdCopyAccelerationStructureToMemoryKHR__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyAccelerationStructureToMemoryKHR => vkCmdCopyAccelerationStructureToMemoryKHR__queues;
	private static RenderPassLocation vkCmdCopyAccelerationStructureToMemoryKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyAccelerationStructureToMemoryKHR => vkCmdCopyAccelerationStructureToMemoryKHR__renderpass;
	private static CmdBufferLevel vkCmdCopyAccelerationStructureToMemoryKHR__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyAccelerationStructureToMemoryKHR => vkCmdCopyAccelerationStructureToMemoryKHR__cmdbufferlevel;
	private static Task vkCmdCopyAccelerationStructureToMemoryKHR__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyAccelerationStructureToMemoryKHR => vkCmdCopyAccelerationStructureToMemoryKHR__tasks;
	private static VkResult[?] vkCopyAccelerationStructureToMemoryKHR__successcodes = .(.VkSuccess, .VkOperationDeferredKHR, .VkOperationNotDeferredKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCopyAccelerationStructureToMemoryKHR => vkCopyAccelerationStructureToMemoryKHR__successcodes;
	private static VkResult[?] vkCopyAccelerationStructureToMemoryKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCopyAccelerationStructureToMemoryKHR => vkCopyAccelerationStructureToMemoryKHR__errorcodes;
	private static VkQueueFlags vkCmdCopyMemoryToAccelerationStructureKHR__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyMemoryToAccelerationStructureKHR => vkCmdCopyMemoryToAccelerationStructureKHR__queues;
	private static RenderPassLocation vkCmdCopyMemoryToAccelerationStructureKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyMemoryToAccelerationStructureKHR => vkCmdCopyMemoryToAccelerationStructureKHR__renderpass;
	private static CmdBufferLevel vkCmdCopyMemoryToAccelerationStructureKHR__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyMemoryToAccelerationStructureKHR => vkCmdCopyMemoryToAccelerationStructureKHR__cmdbufferlevel;
	private static Task vkCmdCopyMemoryToAccelerationStructureKHR__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyMemoryToAccelerationStructureKHR => vkCmdCopyMemoryToAccelerationStructureKHR__tasks;
	private static VkResult[?] vkCopyMemoryToAccelerationStructureKHR__successcodes = .(.VkSuccess, .VkOperationDeferredKHR, .VkOperationNotDeferredKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCopyMemoryToAccelerationStructureKHR => vkCopyMemoryToAccelerationStructureKHR__successcodes;
	private static VkResult[?] vkCopyMemoryToAccelerationStructureKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCopyMemoryToAccelerationStructureKHR => vkCopyMemoryToAccelerationStructureKHR__errorcodes;
	private static VkQueueFlags vkCmdWriteAccelerationStructuresPropertiesKHR__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdWriteAccelerationStructuresPropertiesKHR => vkCmdWriteAccelerationStructuresPropertiesKHR__queues;
	private static RenderPassLocation vkCmdWriteAccelerationStructuresPropertiesKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdWriteAccelerationStructuresPropertiesKHR => vkCmdWriteAccelerationStructuresPropertiesKHR__renderpass;
	private static CmdBufferLevel vkCmdWriteAccelerationStructuresPropertiesKHR__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdWriteAccelerationStructuresPropertiesKHR => vkCmdWriteAccelerationStructuresPropertiesKHR__cmdbufferlevel;
	private static Task vkCmdWriteAccelerationStructuresPropertiesKHR__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdWriteAccelerationStructuresPropertiesKHR => vkCmdWriteAccelerationStructuresPropertiesKHR__tasks;
	private static VkQueueFlags vkCmdWriteAccelerationStructuresPropertiesNV__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdWriteAccelerationStructuresPropertiesNV => vkCmdWriteAccelerationStructuresPropertiesNV__queues;
	private static RenderPassLocation vkCmdWriteAccelerationStructuresPropertiesNV__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdWriteAccelerationStructuresPropertiesNV => vkCmdWriteAccelerationStructuresPropertiesNV__renderpass;
	private static CmdBufferLevel vkCmdWriteAccelerationStructuresPropertiesNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdWriteAccelerationStructuresPropertiesNV => vkCmdWriteAccelerationStructuresPropertiesNV__cmdbufferlevel;
	private static Task vkCmdWriteAccelerationStructuresPropertiesNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdWriteAccelerationStructuresPropertiesNV => vkCmdWriteAccelerationStructuresPropertiesNV__tasks;
	private static VkQueueFlags vkCmdBuildAccelerationStructureNV__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBuildAccelerationStructureNV => vkCmdBuildAccelerationStructureNV__queues;
	private static RenderPassLocation vkCmdBuildAccelerationStructureNV__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBuildAccelerationStructureNV => vkCmdBuildAccelerationStructureNV__renderpass;
	private static CmdBufferLevel vkCmdBuildAccelerationStructureNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBuildAccelerationStructureNV => vkCmdBuildAccelerationStructureNV__cmdbufferlevel;
	private static Task vkCmdBuildAccelerationStructureNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBuildAccelerationStructureNV => vkCmdBuildAccelerationStructureNV__tasks;
	private static VkResult[?] vkWriteAccelerationStructuresPropertiesKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkWriteAccelerationStructuresPropertiesKHR => vkWriteAccelerationStructuresPropertiesKHR__successcodes;
	private static VkResult[?] vkWriteAccelerationStructuresPropertiesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkWriteAccelerationStructuresPropertiesKHR => vkWriteAccelerationStructuresPropertiesKHR__errorcodes;
	private static VkQueueFlags vkCmdTraceRaysKHR__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdTraceRaysKHR => vkCmdTraceRaysKHR__queues;
	private static RenderPassLocation vkCmdTraceRaysKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdTraceRaysKHR => vkCmdTraceRaysKHR__renderpass;
	private static CmdBufferLevel vkCmdTraceRaysKHR__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdTraceRaysKHR => vkCmdTraceRaysKHR__cmdbufferlevel;
	private static Task vkCmdTraceRaysKHR__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdTraceRaysKHR => vkCmdTraceRaysKHR__tasks;
	private static VkQueueFlags vkCmdTraceRaysNV__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdTraceRaysNV => vkCmdTraceRaysNV__queues;
	private static RenderPassLocation vkCmdTraceRaysNV__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdTraceRaysNV => vkCmdTraceRaysNV__renderpass;
	private static CmdBufferLevel vkCmdTraceRaysNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdTraceRaysNV => vkCmdTraceRaysNV__cmdbufferlevel;
	private static Task vkCmdTraceRaysNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdTraceRaysNV => vkCmdTraceRaysNV__tasks;
	private static VkResult[?] vkGetRayTracingShaderGroupHandlesKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetRayTracingShaderGroupHandlesKHR => vkGetRayTracingShaderGroupHandlesKHR__successcodes;
	private static VkResult[?] vkGetRayTracingShaderGroupHandlesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetRayTracingShaderGroupHandlesKHR => vkGetRayTracingShaderGroupHandlesKHR__errorcodes;
	private static VkResult[?] vkGetRayTracingCaptureReplayShaderGroupHandlesKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR => vkGetRayTracingCaptureReplayShaderGroupHandlesKHR__successcodes;
	private static VkResult[?] vkGetRayTracingCaptureReplayShaderGroupHandlesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR => vkGetRayTracingCaptureReplayShaderGroupHandlesKHR__errorcodes;
	private static VkResult[?] vkGetAccelerationStructureHandleNV__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetAccelerationStructureHandleNV => vkGetAccelerationStructureHandleNV__successcodes;
	private static VkResult[?] vkGetAccelerationStructureHandleNV__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetAccelerationStructureHandleNV => vkGetAccelerationStructureHandleNV__errorcodes;
	private static VkResult[?] vkCreateRayTracingPipelinesNV__successcodes = .(.VkSuccess, .VkPipelineCompileRequiredEXT);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateRayTracingPipelinesNV => vkCreateRayTracingPipelinesNV__successcodes;
	private static VkResult[?] vkCreateRayTracingPipelinesNV__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInvalidShaderNV);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateRayTracingPipelinesNV => vkCreateRayTracingPipelinesNV__errorcodes;
	private static VkResult[?] vkCreateRayTracingPipelinesKHR__successcodes = .(.VkSuccess, .VkOperationDeferredKHR, .VkOperationNotDeferredKHR, .VkPipelineCompileRequiredEXT);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateRayTracingPipelinesKHR => vkCreateRayTracingPipelinesKHR__successcodes;
	private static VkResult[?] vkCreateRayTracingPipelinesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInvalidOpaqueCaptureAddress);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateRayTracingPipelinesKHR => vkCreateRayTracingPipelinesKHR__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceCooperativeMatrixPropertiesNV__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV => vkGetPhysicalDeviceCooperativeMatrixPropertiesNV__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceCooperativeMatrixPropertiesNV__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV => vkGetPhysicalDeviceCooperativeMatrixPropertiesNV__errorcodes;
	private static VkQueueFlags vkCmdTraceRaysIndirectKHR__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdTraceRaysIndirectKHR => vkCmdTraceRaysIndirectKHR__queues;
	private static RenderPassLocation vkCmdTraceRaysIndirectKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdTraceRaysIndirectKHR => vkCmdTraceRaysIndirectKHR__renderpass;
	private static CmdBufferLevel vkCmdTraceRaysIndirectKHR__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdTraceRaysIndirectKHR => vkCmdTraceRaysIndirectKHR__cmdbufferlevel;
	private static Task vkCmdTraceRaysIndirectKHR__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdTraceRaysIndirectKHR => vkCmdTraceRaysIndirectKHR__tasks;
	private static VkQueueFlags vkCmdTraceRaysIndirect2KHR__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdTraceRaysIndirect2KHR => vkCmdTraceRaysIndirect2KHR__queues;
	private static RenderPassLocation vkCmdTraceRaysIndirect2KHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdTraceRaysIndirect2KHR => vkCmdTraceRaysIndirect2KHR__renderpass;
	private static CmdBufferLevel vkCmdTraceRaysIndirect2KHR__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdTraceRaysIndirect2KHR => vkCmdTraceRaysIndirect2KHR__cmdbufferlevel;
	private static Task vkCmdTraceRaysIndirect2KHR__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdTraceRaysIndirect2KHR => vkCmdTraceRaysIndirect2KHR__tasks;
	private static VkQueueFlags vkCmdSetRayTracingPipelineStackSizeKHR__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetRayTracingPipelineStackSizeKHR => vkCmdSetRayTracingPipelineStackSizeKHR__queues;
	private static RenderPassLocation vkCmdSetRayTracingPipelineStackSizeKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetRayTracingPipelineStackSizeKHR => vkCmdSetRayTracingPipelineStackSizeKHR__renderpass;
	private static CmdBufferLevel vkCmdSetRayTracingPipelineStackSizeKHR__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetRayTracingPipelineStackSizeKHR => vkCmdSetRayTracingPipelineStackSizeKHR__cmdbufferlevel;
	private static Task vkCmdSetRayTracingPipelineStackSizeKHR__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetRayTracingPipelineStackSizeKHR => vkCmdSetRayTracingPipelineStackSizeKHR__tasks;
	private static VkResult[?] vkGetImageViewAddressNVX__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetImageViewAddressNVX => vkGetImageViewAddressNVX__successcodes;
	private static VkResult[?] vkGetImageViewAddressNVX__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetImageViewAddressNVX => vkGetImageViewAddressNVX__errorcodes;
	private static VkResult[?] vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR => vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR__successcodes;
	private static VkResult[?] vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInitializationFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR => vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR__errorcodes;
	private static VkResult[?] vkAcquireProfilingLockKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkAcquireProfilingLockKHR => vkAcquireProfilingLockKHR__successcodes;
	private static VkResult[?] vkAcquireProfilingLockKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkTimeout);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkAcquireProfilingLockKHR => vkAcquireProfilingLockKHR__errorcodes;
	private static VkResult[?] vkGetImageDrmFormatModifierPropertiesEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetImageDrmFormatModifierPropertiesEXT => vkGetImageDrmFormatModifierPropertiesEXT__successcodes;
	private static VkResult[?] vkGetImageDrmFormatModifierPropertiesEXT__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetImageDrmFormatModifierPropertiesEXT => vkGetImageDrmFormatModifierPropertiesEXT__errorcodes;
	private static VkResult[?] vkCreateHeadlessSurfaceEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateHeadlessSurfaceEXT => vkCreateHeadlessSurfaceEXT__successcodes;
	private static VkResult[?] vkCreateHeadlessSurfaceEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateHeadlessSurfaceEXT => vkCreateHeadlessSurfaceEXT__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV => vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV => vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV__errorcodes;
	private static VkResult[?] vkInitializePerformanceApiINTEL__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkInitializePerformanceApiINTEL => vkInitializePerformanceApiINTEL__successcodes;
	private static VkResult[?] vkInitializePerformanceApiINTEL__errorcodes = .(.VkErrorTooManyObjects, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkInitializePerformanceApiINTEL => vkInitializePerformanceApiINTEL__errorcodes;
	private static VkResult[?] vkCmdSetPerformanceMarkerINTEL__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCmdSetPerformanceMarkerINTEL => vkCmdSetPerformanceMarkerINTEL__successcodes;
	private static VkResult[?] vkCmdSetPerformanceMarkerINTEL__errorcodes = .(.VkErrorTooManyObjects, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCmdSetPerformanceMarkerINTEL => vkCmdSetPerformanceMarkerINTEL__errorcodes;
	private static VkQueueFlags vkCmdSetPerformanceMarkerINTEL__queues = .Graphics | .Compute | .Transfer;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetPerformanceMarkerINTEL => vkCmdSetPerformanceMarkerINTEL__queues;
	private static RenderPassLocation vkCmdSetPerformanceMarkerINTEL__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetPerformanceMarkerINTEL => vkCmdSetPerformanceMarkerINTEL__renderpass;
	private static CmdBufferLevel vkCmdSetPerformanceMarkerINTEL__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetPerformanceMarkerINTEL => vkCmdSetPerformanceMarkerINTEL__cmdbufferlevel;
	private static Task vkCmdSetPerformanceMarkerINTEL__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetPerformanceMarkerINTEL => vkCmdSetPerformanceMarkerINTEL__tasks;
	private static VkResult[?] vkCmdSetPerformanceStreamMarkerINTEL__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCmdSetPerformanceStreamMarkerINTEL => vkCmdSetPerformanceStreamMarkerINTEL__successcodes;
	private static VkResult[?] vkCmdSetPerformanceStreamMarkerINTEL__errorcodes = .(.VkErrorTooManyObjects, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCmdSetPerformanceStreamMarkerINTEL => vkCmdSetPerformanceStreamMarkerINTEL__errorcodes;
	private static VkQueueFlags vkCmdSetPerformanceStreamMarkerINTEL__queues = .Graphics | .Compute | .Transfer;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetPerformanceStreamMarkerINTEL => vkCmdSetPerformanceStreamMarkerINTEL__queues;
	private static RenderPassLocation vkCmdSetPerformanceStreamMarkerINTEL__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetPerformanceStreamMarkerINTEL => vkCmdSetPerformanceStreamMarkerINTEL__renderpass;
	private static CmdBufferLevel vkCmdSetPerformanceStreamMarkerINTEL__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetPerformanceStreamMarkerINTEL => vkCmdSetPerformanceStreamMarkerINTEL__cmdbufferlevel;
	private static Task vkCmdSetPerformanceStreamMarkerINTEL__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetPerformanceStreamMarkerINTEL => vkCmdSetPerformanceStreamMarkerINTEL__tasks;
	private static VkResult[?] vkCmdSetPerformanceOverrideINTEL__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCmdSetPerformanceOverrideINTEL => vkCmdSetPerformanceOverrideINTEL__successcodes;
	private static VkResult[?] vkCmdSetPerformanceOverrideINTEL__errorcodes = .(.VkErrorTooManyObjects, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCmdSetPerformanceOverrideINTEL => vkCmdSetPerformanceOverrideINTEL__errorcodes;
	private static VkQueueFlags vkCmdSetPerformanceOverrideINTEL__queues = .Graphics | .Compute | .Transfer;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetPerformanceOverrideINTEL => vkCmdSetPerformanceOverrideINTEL__queues;
	private static RenderPassLocation vkCmdSetPerformanceOverrideINTEL__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetPerformanceOverrideINTEL => vkCmdSetPerformanceOverrideINTEL__renderpass;
	private static CmdBufferLevel vkCmdSetPerformanceOverrideINTEL__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetPerformanceOverrideINTEL => vkCmdSetPerformanceOverrideINTEL__cmdbufferlevel;
	private static Task vkCmdSetPerformanceOverrideINTEL__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetPerformanceOverrideINTEL => vkCmdSetPerformanceOverrideINTEL__tasks;
	private static VkResult[?] vkAcquirePerformanceConfigurationINTEL__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkAcquirePerformanceConfigurationINTEL => vkAcquirePerformanceConfigurationINTEL__successcodes;
	private static VkResult[?] vkAcquirePerformanceConfigurationINTEL__errorcodes = .(.VkErrorTooManyObjects, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkAcquirePerformanceConfigurationINTEL => vkAcquirePerformanceConfigurationINTEL__errorcodes;
	private static VkResult[?] vkReleasePerformanceConfigurationINTEL__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkReleasePerformanceConfigurationINTEL => vkReleasePerformanceConfigurationINTEL__successcodes;
	private static VkResult[?] vkReleasePerformanceConfigurationINTEL__errorcodes = .(.VkErrorTooManyObjects, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkReleasePerformanceConfigurationINTEL => vkReleasePerformanceConfigurationINTEL__errorcodes;
	private static VkResult[?] vkQueueSetPerformanceConfigurationINTEL__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkQueueSetPerformanceConfigurationINTEL => vkQueueSetPerformanceConfigurationINTEL__successcodes;
	private static VkResult[?] vkQueueSetPerformanceConfigurationINTEL__errorcodes = .(.VkErrorTooManyObjects, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkQueueSetPerformanceConfigurationINTEL => vkQueueSetPerformanceConfigurationINTEL__errorcodes;
	private static VkResult[?] vkGetPerformanceParameterINTEL__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPerformanceParameterINTEL => vkGetPerformanceParameterINTEL__successcodes;
	private static VkResult[?] vkGetPerformanceParameterINTEL__errorcodes = .(.VkErrorTooManyObjects, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPerformanceParameterINTEL => vkGetPerformanceParameterINTEL__errorcodes;
	private static VkResult[?] vkGetPipelineExecutablePropertiesKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPipelineExecutablePropertiesKHR => vkGetPipelineExecutablePropertiesKHR__successcodes;
	private static VkResult[?] vkGetPipelineExecutablePropertiesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPipelineExecutablePropertiesKHR => vkGetPipelineExecutablePropertiesKHR__errorcodes;
	private static VkResult[?] vkGetPipelineExecutableStatisticsKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPipelineExecutableStatisticsKHR => vkGetPipelineExecutableStatisticsKHR__successcodes;
	private static VkResult[?] vkGetPipelineExecutableStatisticsKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPipelineExecutableStatisticsKHR => vkGetPipelineExecutableStatisticsKHR__errorcodes;
	private static VkResult[?] vkGetPipelineExecutableInternalRepresentationsKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPipelineExecutableInternalRepresentationsKHR => vkGetPipelineExecutableInternalRepresentationsKHR__successcodes;
	private static VkResult[?] vkGetPipelineExecutableInternalRepresentationsKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPipelineExecutableInternalRepresentationsKHR => vkGetPipelineExecutableInternalRepresentationsKHR__errorcodes;
	private static VkQueueFlags vkCmdSetLineStipple__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetLineStipple => vkCmdSetLineStipple__queues;
	private static RenderPassLocation vkCmdSetLineStipple__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetLineStipple => vkCmdSetLineStipple__renderpass;
	private static CmdBufferLevel vkCmdSetLineStipple__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetLineStipple => vkCmdSetLineStipple__cmdbufferlevel;
	private static Task vkCmdSetLineStipple__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetLineStipple => vkCmdSetLineStipple__tasks;
	private static VkResult[?] vkGetPhysicalDeviceToolProperties__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceToolProperties => vkGetPhysicalDeviceToolProperties__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceToolProperties__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceToolProperties => vkGetPhysicalDeviceToolProperties__errorcodes;
	private static VkResult[?] vkCreateAccelerationStructureKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateAccelerationStructureKHR => vkCreateAccelerationStructureKHR__successcodes;
	private static VkResult[?] vkCreateAccelerationStructureKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorInvalidOpaqueCaptureAddressKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateAccelerationStructureKHR => vkCreateAccelerationStructureKHR__errorcodes;
	private static VkQueueFlags vkCmdBuildAccelerationStructuresKHR__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBuildAccelerationStructuresKHR => vkCmdBuildAccelerationStructuresKHR__queues;
	private static RenderPassLocation vkCmdBuildAccelerationStructuresKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBuildAccelerationStructuresKHR => vkCmdBuildAccelerationStructuresKHR__renderpass;
	private static CmdBufferLevel vkCmdBuildAccelerationStructuresKHR__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBuildAccelerationStructuresKHR => vkCmdBuildAccelerationStructuresKHR__cmdbufferlevel;
	private static Task vkCmdBuildAccelerationStructuresKHR__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBuildAccelerationStructuresKHR => vkCmdBuildAccelerationStructuresKHR__tasks;
	private static VkQueueFlags vkCmdBuildAccelerationStructuresIndirectKHR__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBuildAccelerationStructuresIndirectKHR => vkCmdBuildAccelerationStructuresIndirectKHR__queues;
	private static RenderPassLocation vkCmdBuildAccelerationStructuresIndirectKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBuildAccelerationStructuresIndirectKHR => vkCmdBuildAccelerationStructuresIndirectKHR__renderpass;
	private static CmdBufferLevel vkCmdBuildAccelerationStructuresIndirectKHR__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBuildAccelerationStructuresIndirectKHR => vkCmdBuildAccelerationStructuresIndirectKHR__cmdbufferlevel;
	private static Task vkCmdBuildAccelerationStructuresIndirectKHR__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBuildAccelerationStructuresIndirectKHR => vkCmdBuildAccelerationStructuresIndirectKHR__tasks;
	private static VkResult[?] vkBuildAccelerationStructuresKHR__successcodes = .(.VkSuccess, .VkOperationDeferredKHR, .VkOperationNotDeferredKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkBuildAccelerationStructuresKHR => vkBuildAccelerationStructuresKHR__successcodes;
	private static VkResult[?] vkBuildAccelerationStructuresKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkBuildAccelerationStructuresKHR => vkBuildAccelerationStructuresKHR__errorcodes;
	private static VkResult[?] vkCreateDeferredOperationKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateDeferredOperationKHR => vkCreateDeferredOperationKHR__successcodes;
	private static VkResult[?] vkCreateDeferredOperationKHR__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateDeferredOperationKHR => vkCreateDeferredOperationKHR__errorcodes;
	private static VkResult[?] vkGetDeferredOperationResultKHR__successcodes = .(.VkSuccess, .VkNotReady);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetDeferredOperationResultKHR => vkGetDeferredOperationResultKHR__successcodes;
	private static VkResult[?] vkDeferredOperationJoinKHR__successcodes = .(.VkSuccess, .VkThreadDoneKHR, .VkThreadIdleKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkDeferredOperationJoinKHR => vkDeferredOperationJoinKHR__successcodes;
	private static VkResult[?] vkDeferredOperationJoinKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkDeferredOperationJoinKHR => vkDeferredOperationJoinKHR__errorcodes;
	private static VkQueueFlags vkCmdSetCullMode__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetCullMode => vkCmdSetCullMode__queues;
	private static RenderPassLocation vkCmdSetCullMode__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetCullMode => vkCmdSetCullMode__renderpass;
	private static CmdBufferLevel vkCmdSetCullMode__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetCullMode => vkCmdSetCullMode__cmdbufferlevel;
	private static Task vkCmdSetCullMode__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetCullMode => vkCmdSetCullMode__tasks;
	private static VkQueueFlags vkCmdSetFrontFace__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetFrontFace => vkCmdSetFrontFace__queues;
	private static RenderPassLocation vkCmdSetFrontFace__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetFrontFace => vkCmdSetFrontFace__renderpass;
	private static CmdBufferLevel vkCmdSetFrontFace__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetFrontFace => vkCmdSetFrontFace__cmdbufferlevel;
	private static Task vkCmdSetFrontFace__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetFrontFace => vkCmdSetFrontFace__tasks;
	private static VkQueueFlags vkCmdSetPrimitiveTopology__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetPrimitiveTopology => vkCmdSetPrimitiveTopology__queues;
	private static RenderPassLocation vkCmdSetPrimitiveTopology__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetPrimitiveTopology => vkCmdSetPrimitiveTopology__renderpass;
	private static CmdBufferLevel vkCmdSetPrimitiveTopology__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetPrimitiveTopology => vkCmdSetPrimitiveTopology__cmdbufferlevel;
	private static Task vkCmdSetPrimitiveTopology__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetPrimitiveTopology => vkCmdSetPrimitiveTopology__tasks;
	private static VkQueueFlags vkCmdSetViewportWithCount__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetViewportWithCount => vkCmdSetViewportWithCount__queues;
	private static RenderPassLocation vkCmdSetViewportWithCount__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetViewportWithCount => vkCmdSetViewportWithCount__renderpass;
	private static CmdBufferLevel vkCmdSetViewportWithCount__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetViewportWithCount => vkCmdSetViewportWithCount__cmdbufferlevel;
	private static Task vkCmdSetViewportWithCount__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetViewportWithCount => vkCmdSetViewportWithCount__tasks;
	private static VkQueueFlags vkCmdSetScissorWithCount__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetScissorWithCount => vkCmdSetScissorWithCount__queues;
	private static RenderPassLocation vkCmdSetScissorWithCount__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetScissorWithCount => vkCmdSetScissorWithCount__renderpass;
	private static CmdBufferLevel vkCmdSetScissorWithCount__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetScissorWithCount => vkCmdSetScissorWithCount__cmdbufferlevel;
	private static Task vkCmdSetScissorWithCount__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetScissorWithCount => vkCmdSetScissorWithCount__tasks;
	private static VkQueueFlags vkCmdBindIndexBuffer2__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindIndexBuffer2 => vkCmdBindIndexBuffer2__queues;
	private static RenderPassLocation vkCmdBindIndexBuffer2__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindIndexBuffer2 => vkCmdBindIndexBuffer2__renderpass;
	private static CmdBufferLevel vkCmdBindIndexBuffer2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindIndexBuffer2 => vkCmdBindIndexBuffer2__cmdbufferlevel;
	private static Task vkCmdBindIndexBuffer2__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindIndexBuffer2 => vkCmdBindIndexBuffer2__tasks;
	private static VkQueueFlags vkCmdBindVertexBuffers2__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindVertexBuffers2 => vkCmdBindVertexBuffers2__queues;
	private static RenderPassLocation vkCmdBindVertexBuffers2__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindVertexBuffers2 => vkCmdBindVertexBuffers2__renderpass;
	private static CmdBufferLevel vkCmdBindVertexBuffers2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindVertexBuffers2 => vkCmdBindVertexBuffers2__cmdbufferlevel;
	private static Task vkCmdBindVertexBuffers2__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindVertexBuffers2 => vkCmdBindVertexBuffers2__tasks;
	private static VkQueueFlags vkCmdSetDepthTestEnable__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDepthTestEnable => vkCmdSetDepthTestEnable__queues;
	private static RenderPassLocation vkCmdSetDepthTestEnable__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDepthTestEnable => vkCmdSetDepthTestEnable__renderpass;
	private static CmdBufferLevel vkCmdSetDepthTestEnable__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDepthTestEnable => vkCmdSetDepthTestEnable__cmdbufferlevel;
	private static Task vkCmdSetDepthTestEnable__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDepthTestEnable => vkCmdSetDepthTestEnable__tasks;
	private static VkQueueFlags vkCmdSetDepthWriteEnable__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDepthWriteEnable => vkCmdSetDepthWriteEnable__queues;
	private static RenderPassLocation vkCmdSetDepthWriteEnable__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDepthWriteEnable => vkCmdSetDepthWriteEnable__renderpass;
	private static CmdBufferLevel vkCmdSetDepthWriteEnable__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDepthWriteEnable => vkCmdSetDepthWriteEnable__cmdbufferlevel;
	private static Task vkCmdSetDepthWriteEnable__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDepthWriteEnable => vkCmdSetDepthWriteEnable__tasks;
	private static VkQueueFlags vkCmdSetDepthCompareOp__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDepthCompareOp => vkCmdSetDepthCompareOp__queues;
	private static RenderPassLocation vkCmdSetDepthCompareOp__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDepthCompareOp => vkCmdSetDepthCompareOp__renderpass;
	private static CmdBufferLevel vkCmdSetDepthCompareOp__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDepthCompareOp => vkCmdSetDepthCompareOp__cmdbufferlevel;
	private static Task vkCmdSetDepthCompareOp__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDepthCompareOp => vkCmdSetDepthCompareOp__tasks;
	private static VkQueueFlags vkCmdSetDepthBoundsTestEnable__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDepthBoundsTestEnable => vkCmdSetDepthBoundsTestEnable__queues;
	private static RenderPassLocation vkCmdSetDepthBoundsTestEnable__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDepthBoundsTestEnable => vkCmdSetDepthBoundsTestEnable__renderpass;
	private static CmdBufferLevel vkCmdSetDepthBoundsTestEnable__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDepthBoundsTestEnable => vkCmdSetDepthBoundsTestEnable__cmdbufferlevel;
	private static Task vkCmdSetDepthBoundsTestEnable__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDepthBoundsTestEnable => vkCmdSetDepthBoundsTestEnable__tasks;
	private static VkQueueFlags vkCmdSetStencilTestEnable__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetStencilTestEnable => vkCmdSetStencilTestEnable__queues;
	private static RenderPassLocation vkCmdSetStencilTestEnable__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetStencilTestEnable => vkCmdSetStencilTestEnable__renderpass;
	private static CmdBufferLevel vkCmdSetStencilTestEnable__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetStencilTestEnable => vkCmdSetStencilTestEnable__cmdbufferlevel;
	private static Task vkCmdSetStencilTestEnable__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetStencilTestEnable => vkCmdSetStencilTestEnable__tasks;
	private static VkQueueFlags vkCmdSetStencilOp__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetStencilOp => vkCmdSetStencilOp__queues;
	private static RenderPassLocation vkCmdSetStencilOp__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetStencilOp => vkCmdSetStencilOp__renderpass;
	private static CmdBufferLevel vkCmdSetStencilOp__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetStencilOp => vkCmdSetStencilOp__cmdbufferlevel;
	private static Task vkCmdSetStencilOp__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetStencilOp => vkCmdSetStencilOp__tasks;
	private static VkQueueFlags vkCmdSetPatchControlPointsEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetPatchControlPointsEXT => vkCmdSetPatchControlPointsEXT__queues;
	private static RenderPassLocation vkCmdSetPatchControlPointsEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetPatchControlPointsEXT => vkCmdSetPatchControlPointsEXT__renderpass;
	private static CmdBufferLevel vkCmdSetPatchControlPointsEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetPatchControlPointsEXT => vkCmdSetPatchControlPointsEXT__cmdbufferlevel;
	private static Task vkCmdSetPatchControlPointsEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetPatchControlPointsEXT => vkCmdSetPatchControlPointsEXT__tasks;
	private static VkQueueFlags vkCmdSetRasterizerDiscardEnable__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetRasterizerDiscardEnable => vkCmdSetRasterizerDiscardEnable__queues;
	private static RenderPassLocation vkCmdSetRasterizerDiscardEnable__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetRasterizerDiscardEnable => vkCmdSetRasterizerDiscardEnable__renderpass;
	private static CmdBufferLevel vkCmdSetRasterizerDiscardEnable__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetRasterizerDiscardEnable => vkCmdSetRasterizerDiscardEnable__cmdbufferlevel;
	private static Task vkCmdSetRasterizerDiscardEnable__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetRasterizerDiscardEnable => vkCmdSetRasterizerDiscardEnable__tasks;
	private static VkQueueFlags vkCmdSetDepthBiasEnable__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDepthBiasEnable => vkCmdSetDepthBiasEnable__queues;
	private static RenderPassLocation vkCmdSetDepthBiasEnable__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDepthBiasEnable => vkCmdSetDepthBiasEnable__renderpass;
	private static CmdBufferLevel vkCmdSetDepthBiasEnable__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDepthBiasEnable => vkCmdSetDepthBiasEnable__cmdbufferlevel;
	private static Task vkCmdSetDepthBiasEnable__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDepthBiasEnable => vkCmdSetDepthBiasEnable__tasks;
	private static VkQueueFlags vkCmdSetLogicOpEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetLogicOpEXT => vkCmdSetLogicOpEXT__queues;
	private static RenderPassLocation vkCmdSetLogicOpEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetLogicOpEXT => vkCmdSetLogicOpEXT__renderpass;
	private static CmdBufferLevel vkCmdSetLogicOpEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetLogicOpEXT => vkCmdSetLogicOpEXT__cmdbufferlevel;
	private static Task vkCmdSetLogicOpEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetLogicOpEXT => vkCmdSetLogicOpEXT__tasks;
	private static VkQueueFlags vkCmdSetPrimitiveRestartEnable__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetPrimitiveRestartEnable => vkCmdSetPrimitiveRestartEnable__queues;
	private static RenderPassLocation vkCmdSetPrimitiveRestartEnable__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetPrimitiveRestartEnable => vkCmdSetPrimitiveRestartEnable__renderpass;
	private static CmdBufferLevel vkCmdSetPrimitiveRestartEnable__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetPrimitiveRestartEnable => vkCmdSetPrimitiveRestartEnable__cmdbufferlevel;
	private static Task vkCmdSetPrimitiveRestartEnable__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetPrimitiveRestartEnable => vkCmdSetPrimitiveRestartEnable__tasks;
	private static VkQueueFlags vkCmdSetTessellationDomainOriginEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetTessellationDomainOriginEXT => vkCmdSetTessellationDomainOriginEXT__queues;
	private static RenderPassLocation vkCmdSetTessellationDomainOriginEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetTessellationDomainOriginEXT => vkCmdSetTessellationDomainOriginEXT__renderpass;
	private static CmdBufferLevel vkCmdSetTessellationDomainOriginEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetTessellationDomainOriginEXT => vkCmdSetTessellationDomainOriginEXT__cmdbufferlevel;
	private static Task vkCmdSetTessellationDomainOriginEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetTessellationDomainOriginEXT => vkCmdSetTessellationDomainOriginEXT__tasks;
	private static VkQueueFlags vkCmdSetDepthClampEnableEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDepthClampEnableEXT => vkCmdSetDepthClampEnableEXT__queues;
	private static RenderPassLocation vkCmdSetDepthClampEnableEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDepthClampEnableEXT => vkCmdSetDepthClampEnableEXT__renderpass;
	private static CmdBufferLevel vkCmdSetDepthClampEnableEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDepthClampEnableEXT => vkCmdSetDepthClampEnableEXT__cmdbufferlevel;
	private static Task vkCmdSetDepthClampEnableEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDepthClampEnableEXT => vkCmdSetDepthClampEnableEXT__tasks;
	private static VkQueueFlags vkCmdSetPolygonModeEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetPolygonModeEXT => vkCmdSetPolygonModeEXT__queues;
	private static RenderPassLocation vkCmdSetPolygonModeEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetPolygonModeEXT => vkCmdSetPolygonModeEXT__renderpass;
	private static CmdBufferLevel vkCmdSetPolygonModeEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetPolygonModeEXT => vkCmdSetPolygonModeEXT__cmdbufferlevel;
	private static Task vkCmdSetPolygonModeEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetPolygonModeEXT => vkCmdSetPolygonModeEXT__tasks;
	private static VkQueueFlags vkCmdSetRasterizationSamplesEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetRasterizationSamplesEXT => vkCmdSetRasterizationSamplesEXT__queues;
	private static RenderPassLocation vkCmdSetRasterizationSamplesEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetRasterizationSamplesEXT => vkCmdSetRasterizationSamplesEXT__renderpass;
	private static CmdBufferLevel vkCmdSetRasterizationSamplesEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetRasterizationSamplesEXT => vkCmdSetRasterizationSamplesEXT__cmdbufferlevel;
	private static Task vkCmdSetRasterizationSamplesEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetRasterizationSamplesEXT => vkCmdSetRasterizationSamplesEXT__tasks;
	private static VkQueueFlags vkCmdSetSampleMaskEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetSampleMaskEXT => vkCmdSetSampleMaskEXT__queues;
	private static RenderPassLocation vkCmdSetSampleMaskEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetSampleMaskEXT => vkCmdSetSampleMaskEXT__renderpass;
	private static CmdBufferLevel vkCmdSetSampleMaskEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetSampleMaskEXT => vkCmdSetSampleMaskEXT__cmdbufferlevel;
	private static Task vkCmdSetSampleMaskEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetSampleMaskEXT => vkCmdSetSampleMaskEXT__tasks;
	private static VkQueueFlags vkCmdSetAlphaToCoverageEnableEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetAlphaToCoverageEnableEXT => vkCmdSetAlphaToCoverageEnableEXT__queues;
	private static RenderPassLocation vkCmdSetAlphaToCoverageEnableEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetAlphaToCoverageEnableEXT => vkCmdSetAlphaToCoverageEnableEXT__renderpass;
	private static CmdBufferLevel vkCmdSetAlphaToCoverageEnableEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetAlphaToCoverageEnableEXT => vkCmdSetAlphaToCoverageEnableEXT__cmdbufferlevel;
	private static Task vkCmdSetAlphaToCoverageEnableEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetAlphaToCoverageEnableEXT => vkCmdSetAlphaToCoverageEnableEXT__tasks;
	private static VkQueueFlags vkCmdSetAlphaToOneEnableEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetAlphaToOneEnableEXT => vkCmdSetAlphaToOneEnableEXT__queues;
	private static RenderPassLocation vkCmdSetAlphaToOneEnableEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetAlphaToOneEnableEXT => vkCmdSetAlphaToOneEnableEXT__renderpass;
	private static CmdBufferLevel vkCmdSetAlphaToOneEnableEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetAlphaToOneEnableEXT => vkCmdSetAlphaToOneEnableEXT__cmdbufferlevel;
	private static Task vkCmdSetAlphaToOneEnableEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetAlphaToOneEnableEXT => vkCmdSetAlphaToOneEnableEXT__tasks;
	private static VkQueueFlags vkCmdSetLogicOpEnableEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetLogicOpEnableEXT => vkCmdSetLogicOpEnableEXT__queues;
	private static RenderPassLocation vkCmdSetLogicOpEnableEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetLogicOpEnableEXT => vkCmdSetLogicOpEnableEXT__renderpass;
	private static CmdBufferLevel vkCmdSetLogicOpEnableEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetLogicOpEnableEXT => vkCmdSetLogicOpEnableEXT__cmdbufferlevel;
	private static Task vkCmdSetLogicOpEnableEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetLogicOpEnableEXT => vkCmdSetLogicOpEnableEXT__tasks;
	private static VkQueueFlags vkCmdSetColorBlendEnableEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetColorBlendEnableEXT => vkCmdSetColorBlendEnableEXT__queues;
	private static RenderPassLocation vkCmdSetColorBlendEnableEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetColorBlendEnableEXT => vkCmdSetColorBlendEnableEXT__renderpass;
	private static CmdBufferLevel vkCmdSetColorBlendEnableEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetColorBlendEnableEXT => vkCmdSetColorBlendEnableEXT__cmdbufferlevel;
	private static Task vkCmdSetColorBlendEnableEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetColorBlendEnableEXT => vkCmdSetColorBlendEnableEXT__tasks;
	private static VkQueueFlags vkCmdSetColorBlendEquationEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetColorBlendEquationEXT => vkCmdSetColorBlendEquationEXT__queues;
	private static RenderPassLocation vkCmdSetColorBlendEquationEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetColorBlendEquationEXT => vkCmdSetColorBlendEquationEXT__renderpass;
	private static CmdBufferLevel vkCmdSetColorBlendEquationEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetColorBlendEquationEXT => vkCmdSetColorBlendEquationEXT__cmdbufferlevel;
	private static Task vkCmdSetColorBlendEquationEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetColorBlendEquationEXT => vkCmdSetColorBlendEquationEXT__tasks;
	private static VkQueueFlags vkCmdSetColorWriteMaskEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetColorWriteMaskEXT => vkCmdSetColorWriteMaskEXT__queues;
	private static RenderPassLocation vkCmdSetColorWriteMaskEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetColorWriteMaskEXT => vkCmdSetColorWriteMaskEXT__renderpass;
	private static CmdBufferLevel vkCmdSetColorWriteMaskEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetColorWriteMaskEXT => vkCmdSetColorWriteMaskEXT__cmdbufferlevel;
	private static Task vkCmdSetColorWriteMaskEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetColorWriteMaskEXT => vkCmdSetColorWriteMaskEXT__tasks;
	private static VkQueueFlags vkCmdSetRasterizationStreamEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetRasterizationStreamEXT => vkCmdSetRasterizationStreamEXT__queues;
	private static RenderPassLocation vkCmdSetRasterizationStreamEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetRasterizationStreamEXT => vkCmdSetRasterizationStreamEXT__renderpass;
	private static CmdBufferLevel vkCmdSetRasterizationStreamEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetRasterizationStreamEXT => vkCmdSetRasterizationStreamEXT__cmdbufferlevel;
	private static Task vkCmdSetRasterizationStreamEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetRasterizationStreamEXT => vkCmdSetRasterizationStreamEXT__tasks;
	private static VkQueueFlags vkCmdSetConservativeRasterizationModeEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetConservativeRasterizationModeEXT => vkCmdSetConservativeRasterizationModeEXT__queues;
	private static RenderPassLocation vkCmdSetConservativeRasterizationModeEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetConservativeRasterizationModeEXT => vkCmdSetConservativeRasterizationModeEXT__renderpass;
	private static CmdBufferLevel vkCmdSetConservativeRasterizationModeEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetConservativeRasterizationModeEXT => vkCmdSetConservativeRasterizationModeEXT__cmdbufferlevel;
	private static Task vkCmdSetConservativeRasterizationModeEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetConservativeRasterizationModeEXT => vkCmdSetConservativeRasterizationModeEXT__tasks;
	private static VkQueueFlags vkCmdSetExtraPrimitiveOverestimationSizeEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT => vkCmdSetExtraPrimitiveOverestimationSizeEXT__queues;
	private static RenderPassLocation vkCmdSetExtraPrimitiveOverestimationSizeEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT => vkCmdSetExtraPrimitiveOverestimationSizeEXT__renderpass;
	private static CmdBufferLevel vkCmdSetExtraPrimitiveOverestimationSizeEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT => vkCmdSetExtraPrimitiveOverestimationSizeEXT__cmdbufferlevel;
	private static Task vkCmdSetExtraPrimitiveOverestimationSizeEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT => vkCmdSetExtraPrimitiveOverestimationSizeEXT__tasks;
	private static VkQueueFlags vkCmdSetDepthClipEnableEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDepthClipEnableEXT => vkCmdSetDepthClipEnableEXT__queues;
	private static RenderPassLocation vkCmdSetDepthClipEnableEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDepthClipEnableEXT => vkCmdSetDepthClipEnableEXT__renderpass;
	private static CmdBufferLevel vkCmdSetDepthClipEnableEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDepthClipEnableEXT => vkCmdSetDepthClipEnableEXT__cmdbufferlevel;
	private static Task vkCmdSetDepthClipEnableEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDepthClipEnableEXT => vkCmdSetDepthClipEnableEXT__tasks;
	private static VkQueueFlags vkCmdSetSampleLocationsEnableEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetSampleLocationsEnableEXT => vkCmdSetSampleLocationsEnableEXT__queues;
	private static RenderPassLocation vkCmdSetSampleLocationsEnableEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetSampleLocationsEnableEXT => vkCmdSetSampleLocationsEnableEXT__renderpass;
	private static CmdBufferLevel vkCmdSetSampleLocationsEnableEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetSampleLocationsEnableEXT => vkCmdSetSampleLocationsEnableEXT__cmdbufferlevel;
	private static Task vkCmdSetSampleLocationsEnableEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetSampleLocationsEnableEXT => vkCmdSetSampleLocationsEnableEXT__tasks;
	private static VkQueueFlags vkCmdSetColorBlendAdvancedEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetColorBlendAdvancedEXT => vkCmdSetColorBlendAdvancedEXT__queues;
	private static RenderPassLocation vkCmdSetColorBlendAdvancedEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetColorBlendAdvancedEXT => vkCmdSetColorBlendAdvancedEXT__renderpass;
	private static CmdBufferLevel vkCmdSetColorBlendAdvancedEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetColorBlendAdvancedEXT => vkCmdSetColorBlendAdvancedEXT__cmdbufferlevel;
	private static Task vkCmdSetColorBlendAdvancedEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetColorBlendAdvancedEXT => vkCmdSetColorBlendAdvancedEXT__tasks;
	private static VkQueueFlags vkCmdSetProvokingVertexModeEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetProvokingVertexModeEXT => vkCmdSetProvokingVertexModeEXT__queues;
	private static RenderPassLocation vkCmdSetProvokingVertexModeEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetProvokingVertexModeEXT => vkCmdSetProvokingVertexModeEXT__renderpass;
	private static CmdBufferLevel vkCmdSetProvokingVertexModeEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetProvokingVertexModeEXT => vkCmdSetProvokingVertexModeEXT__cmdbufferlevel;
	private static Task vkCmdSetProvokingVertexModeEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetProvokingVertexModeEXT => vkCmdSetProvokingVertexModeEXT__tasks;
	private static VkQueueFlags vkCmdSetLineRasterizationModeEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetLineRasterizationModeEXT => vkCmdSetLineRasterizationModeEXT__queues;
	private static RenderPassLocation vkCmdSetLineRasterizationModeEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetLineRasterizationModeEXT => vkCmdSetLineRasterizationModeEXT__renderpass;
	private static CmdBufferLevel vkCmdSetLineRasterizationModeEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetLineRasterizationModeEXT => vkCmdSetLineRasterizationModeEXT__cmdbufferlevel;
	private static Task vkCmdSetLineRasterizationModeEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetLineRasterizationModeEXT => vkCmdSetLineRasterizationModeEXT__tasks;
	private static VkQueueFlags vkCmdSetLineStippleEnableEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetLineStippleEnableEXT => vkCmdSetLineStippleEnableEXT__queues;
	private static RenderPassLocation vkCmdSetLineStippleEnableEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetLineStippleEnableEXT => vkCmdSetLineStippleEnableEXT__renderpass;
	private static CmdBufferLevel vkCmdSetLineStippleEnableEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetLineStippleEnableEXT => vkCmdSetLineStippleEnableEXT__cmdbufferlevel;
	private static Task vkCmdSetLineStippleEnableEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetLineStippleEnableEXT => vkCmdSetLineStippleEnableEXT__tasks;
	private static VkQueueFlags vkCmdSetDepthClipNegativeOneToOneEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDepthClipNegativeOneToOneEXT => vkCmdSetDepthClipNegativeOneToOneEXT__queues;
	private static RenderPassLocation vkCmdSetDepthClipNegativeOneToOneEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDepthClipNegativeOneToOneEXT => vkCmdSetDepthClipNegativeOneToOneEXT__renderpass;
	private static CmdBufferLevel vkCmdSetDepthClipNegativeOneToOneEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDepthClipNegativeOneToOneEXT => vkCmdSetDepthClipNegativeOneToOneEXT__cmdbufferlevel;
	private static Task vkCmdSetDepthClipNegativeOneToOneEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDepthClipNegativeOneToOneEXT => vkCmdSetDepthClipNegativeOneToOneEXT__tasks;
	private static VkQueueFlags vkCmdSetViewportWScalingEnableNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetViewportWScalingEnableNV => vkCmdSetViewportWScalingEnableNV__queues;
	private static RenderPassLocation vkCmdSetViewportWScalingEnableNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetViewportWScalingEnableNV => vkCmdSetViewportWScalingEnableNV__renderpass;
	private static CmdBufferLevel vkCmdSetViewportWScalingEnableNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetViewportWScalingEnableNV => vkCmdSetViewportWScalingEnableNV__cmdbufferlevel;
	private static Task vkCmdSetViewportWScalingEnableNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetViewportWScalingEnableNV => vkCmdSetViewportWScalingEnableNV__tasks;
	private static VkQueueFlags vkCmdSetViewportSwizzleNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetViewportSwizzleNV => vkCmdSetViewportSwizzleNV__queues;
	private static RenderPassLocation vkCmdSetViewportSwizzleNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetViewportSwizzleNV => vkCmdSetViewportSwizzleNV__renderpass;
	private static CmdBufferLevel vkCmdSetViewportSwizzleNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetViewportSwizzleNV => vkCmdSetViewportSwizzleNV__cmdbufferlevel;
	private static Task vkCmdSetViewportSwizzleNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetViewportSwizzleNV => vkCmdSetViewportSwizzleNV__tasks;
	private static VkQueueFlags vkCmdSetCoverageToColorEnableNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetCoverageToColorEnableNV => vkCmdSetCoverageToColorEnableNV__queues;
	private static RenderPassLocation vkCmdSetCoverageToColorEnableNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetCoverageToColorEnableNV => vkCmdSetCoverageToColorEnableNV__renderpass;
	private static CmdBufferLevel vkCmdSetCoverageToColorEnableNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetCoverageToColorEnableNV => vkCmdSetCoverageToColorEnableNV__cmdbufferlevel;
	private static Task vkCmdSetCoverageToColorEnableNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetCoverageToColorEnableNV => vkCmdSetCoverageToColorEnableNV__tasks;
	private static VkQueueFlags vkCmdSetCoverageToColorLocationNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetCoverageToColorLocationNV => vkCmdSetCoverageToColorLocationNV__queues;
	private static RenderPassLocation vkCmdSetCoverageToColorLocationNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetCoverageToColorLocationNV => vkCmdSetCoverageToColorLocationNV__renderpass;
	private static CmdBufferLevel vkCmdSetCoverageToColorLocationNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetCoverageToColorLocationNV => vkCmdSetCoverageToColorLocationNV__cmdbufferlevel;
	private static Task vkCmdSetCoverageToColorLocationNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetCoverageToColorLocationNV => vkCmdSetCoverageToColorLocationNV__tasks;
	private static VkQueueFlags vkCmdSetCoverageModulationModeNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetCoverageModulationModeNV => vkCmdSetCoverageModulationModeNV__queues;
	private static RenderPassLocation vkCmdSetCoverageModulationModeNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetCoverageModulationModeNV => vkCmdSetCoverageModulationModeNV__renderpass;
	private static CmdBufferLevel vkCmdSetCoverageModulationModeNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetCoverageModulationModeNV => vkCmdSetCoverageModulationModeNV__cmdbufferlevel;
	private static Task vkCmdSetCoverageModulationModeNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetCoverageModulationModeNV => vkCmdSetCoverageModulationModeNV__tasks;
	private static VkQueueFlags vkCmdSetCoverageModulationTableEnableNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetCoverageModulationTableEnableNV => vkCmdSetCoverageModulationTableEnableNV__queues;
	private static RenderPassLocation vkCmdSetCoverageModulationTableEnableNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetCoverageModulationTableEnableNV => vkCmdSetCoverageModulationTableEnableNV__renderpass;
	private static CmdBufferLevel vkCmdSetCoverageModulationTableEnableNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetCoverageModulationTableEnableNV => vkCmdSetCoverageModulationTableEnableNV__cmdbufferlevel;
	private static Task vkCmdSetCoverageModulationTableEnableNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetCoverageModulationTableEnableNV => vkCmdSetCoverageModulationTableEnableNV__tasks;
	private static VkQueueFlags vkCmdSetCoverageModulationTableNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetCoverageModulationTableNV => vkCmdSetCoverageModulationTableNV__queues;
	private static RenderPassLocation vkCmdSetCoverageModulationTableNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetCoverageModulationTableNV => vkCmdSetCoverageModulationTableNV__renderpass;
	private static CmdBufferLevel vkCmdSetCoverageModulationTableNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetCoverageModulationTableNV => vkCmdSetCoverageModulationTableNV__cmdbufferlevel;
	private static Task vkCmdSetCoverageModulationTableNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetCoverageModulationTableNV => vkCmdSetCoverageModulationTableNV__tasks;
	private static VkQueueFlags vkCmdSetShadingRateImageEnableNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetShadingRateImageEnableNV => vkCmdSetShadingRateImageEnableNV__queues;
	private static RenderPassLocation vkCmdSetShadingRateImageEnableNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetShadingRateImageEnableNV => vkCmdSetShadingRateImageEnableNV__renderpass;
	private static CmdBufferLevel vkCmdSetShadingRateImageEnableNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetShadingRateImageEnableNV => vkCmdSetShadingRateImageEnableNV__cmdbufferlevel;
	private static Task vkCmdSetShadingRateImageEnableNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetShadingRateImageEnableNV => vkCmdSetShadingRateImageEnableNV__tasks;
	private static VkQueueFlags vkCmdSetCoverageReductionModeNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetCoverageReductionModeNV => vkCmdSetCoverageReductionModeNV__queues;
	private static RenderPassLocation vkCmdSetCoverageReductionModeNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetCoverageReductionModeNV => vkCmdSetCoverageReductionModeNV__renderpass;
	private static CmdBufferLevel vkCmdSetCoverageReductionModeNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetCoverageReductionModeNV => vkCmdSetCoverageReductionModeNV__cmdbufferlevel;
	private static Task vkCmdSetCoverageReductionModeNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetCoverageReductionModeNV => vkCmdSetCoverageReductionModeNV__tasks;
	private static VkQueueFlags vkCmdSetRepresentativeFragmentTestEnableNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetRepresentativeFragmentTestEnableNV => vkCmdSetRepresentativeFragmentTestEnableNV__queues;
	private static RenderPassLocation vkCmdSetRepresentativeFragmentTestEnableNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetRepresentativeFragmentTestEnableNV => vkCmdSetRepresentativeFragmentTestEnableNV__renderpass;
	private static CmdBufferLevel vkCmdSetRepresentativeFragmentTestEnableNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetRepresentativeFragmentTestEnableNV => vkCmdSetRepresentativeFragmentTestEnableNV__cmdbufferlevel;
	private static Task vkCmdSetRepresentativeFragmentTestEnableNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetRepresentativeFragmentTestEnableNV => vkCmdSetRepresentativeFragmentTestEnableNV__tasks;
	private static VkResult[?] vkCreatePrivateDataSlot__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreatePrivateDataSlot => vkCreatePrivateDataSlot__successcodes;
	private static VkResult[?] vkCreatePrivateDataSlot__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreatePrivateDataSlot => vkCreatePrivateDataSlot__errorcodes;
	private static VkResult[?] vkSetPrivateData__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkSetPrivateData => vkSetPrivateData__successcodes;
	private static VkResult[?] vkSetPrivateData__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkSetPrivateData => vkSetPrivateData__errorcodes;
	private static VkQueueFlags vkCmdCopyBuffer2__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyBuffer2 => vkCmdCopyBuffer2__queues;
	private static RenderPassLocation vkCmdCopyBuffer2__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyBuffer2 => vkCmdCopyBuffer2__renderpass;
	private static CmdBufferLevel vkCmdCopyBuffer2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyBuffer2 => vkCmdCopyBuffer2__cmdbufferlevel;
	private static Task vkCmdCopyBuffer2__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyBuffer2 => vkCmdCopyBuffer2__tasks;
	private static VkQueueFlags vkCmdCopyImage2__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyImage2 => vkCmdCopyImage2__queues;
	private static RenderPassLocation vkCmdCopyImage2__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyImage2 => vkCmdCopyImage2__renderpass;
	private static CmdBufferLevel vkCmdCopyImage2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyImage2 => vkCmdCopyImage2__cmdbufferlevel;
	private static Task vkCmdCopyImage2__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyImage2 => vkCmdCopyImage2__tasks;
	private static VkQueueFlags vkCmdBlitImage2__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBlitImage2 => vkCmdBlitImage2__queues;
	private static RenderPassLocation vkCmdBlitImage2__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBlitImage2 => vkCmdBlitImage2__renderpass;
	private static CmdBufferLevel vkCmdBlitImage2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBlitImage2 => vkCmdBlitImage2__cmdbufferlevel;
	private static Task vkCmdBlitImage2__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBlitImage2 => vkCmdBlitImage2__tasks;
	private static VkQueueFlags vkCmdCopyBufferToImage2__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyBufferToImage2 => vkCmdCopyBufferToImage2__queues;
	private static RenderPassLocation vkCmdCopyBufferToImage2__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyBufferToImage2 => vkCmdCopyBufferToImage2__renderpass;
	private static CmdBufferLevel vkCmdCopyBufferToImage2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyBufferToImage2 => vkCmdCopyBufferToImage2__cmdbufferlevel;
	private static Task vkCmdCopyBufferToImage2__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyBufferToImage2 => vkCmdCopyBufferToImage2__tasks;
	private static VkQueueFlags vkCmdCopyImageToBuffer2__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyImageToBuffer2 => vkCmdCopyImageToBuffer2__queues;
	private static RenderPassLocation vkCmdCopyImageToBuffer2__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyImageToBuffer2 => vkCmdCopyImageToBuffer2__renderpass;
	private static CmdBufferLevel vkCmdCopyImageToBuffer2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyImageToBuffer2 => vkCmdCopyImageToBuffer2__cmdbufferlevel;
	private static Task vkCmdCopyImageToBuffer2__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyImageToBuffer2 => vkCmdCopyImageToBuffer2__tasks;
	private static VkQueueFlags vkCmdResolveImage2__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdResolveImage2 => vkCmdResolveImage2__queues;
	private static RenderPassLocation vkCmdResolveImage2__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdResolveImage2 => vkCmdResolveImage2__renderpass;
	private static CmdBufferLevel vkCmdResolveImage2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdResolveImage2 => vkCmdResolveImage2__cmdbufferlevel;
	private static Task vkCmdResolveImage2__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdResolveImage2 => vkCmdResolveImage2__tasks;
	private static VkQueueFlags vkCmdSetFragmentShadingRateKHR__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetFragmentShadingRateKHR => vkCmdSetFragmentShadingRateKHR__queues;
	private static RenderPassLocation vkCmdSetFragmentShadingRateKHR__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetFragmentShadingRateKHR => vkCmdSetFragmentShadingRateKHR__renderpass;
	private static CmdBufferLevel vkCmdSetFragmentShadingRateKHR__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetFragmentShadingRateKHR => vkCmdSetFragmentShadingRateKHR__cmdbufferlevel;
	private static Task vkCmdSetFragmentShadingRateKHR__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetFragmentShadingRateKHR => vkCmdSetFragmentShadingRateKHR__tasks;
	private static VkResult[?] vkGetPhysicalDeviceFragmentShadingRatesKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR => vkGetPhysicalDeviceFragmentShadingRatesKHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceFragmentShadingRatesKHR__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR => vkGetPhysicalDeviceFragmentShadingRatesKHR__errorcodes;
	private static VkQueueFlags vkCmdSetFragmentShadingRateEnumNV__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetFragmentShadingRateEnumNV => vkCmdSetFragmentShadingRateEnumNV__queues;
	private static RenderPassLocation vkCmdSetFragmentShadingRateEnumNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetFragmentShadingRateEnumNV => vkCmdSetFragmentShadingRateEnumNV__renderpass;
	private static CmdBufferLevel vkCmdSetFragmentShadingRateEnumNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetFragmentShadingRateEnumNV => vkCmdSetFragmentShadingRateEnumNV__cmdbufferlevel;
	private static Task vkCmdSetFragmentShadingRateEnumNV__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetFragmentShadingRateEnumNV => vkCmdSetFragmentShadingRateEnumNV__tasks;
	private static VkQueueFlags vkCmdSetVertexInputEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetVertexInputEXT => vkCmdSetVertexInputEXT__queues;
	private static RenderPassLocation vkCmdSetVertexInputEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetVertexInputEXT => vkCmdSetVertexInputEXT__renderpass;
	private static CmdBufferLevel vkCmdSetVertexInputEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetVertexInputEXT => vkCmdSetVertexInputEXT__cmdbufferlevel;
	private static Task vkCmdSetVertexInputEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetVertexInputEXT => vkCmdSetVertexInputEXT__tasks;
	private static VkQueueFlags vkCmdSetColorWriteEnableEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetColorWriteEnableEXT => vkCmdSetColorWriteEnableEXT__queues;
	private static RenderPassLocation vkCmdSetColorWriteEnableEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetColorWriteEnableEXT => vkCmdSetColorWriteEnableEXT__renderpass;
	private static CmdBufferLevel vkCmdSetColorWriteEnableEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetColorWriteEnableEXT => vkCmdSetColorWriteEnableEXT__cmdbufferlevel;
	private static Task vkCmdSetColorWriteEnableEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetColorWriteEnableEXT => vkCmdSetColorWriteEnableEXT__tasks;
	private static VkQueueFlags vkCmdSetEvent2__queues = .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetEvent2 => vkCmdSetEvent2__queues;
	private static RenderPassLocation vkCmdSetEvent2__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetEvent2 => vkCmdSetEvent2__renderpass;
	private static CmdBufferLevel vkCmdSetEvent2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetEvent2 => vkCmdSetEvent2__cmdbufferlevel;
	private static Task vkCmdSetEvent2__tasks = .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetEvent2 => vkCmdSetEvent2__tasks;
	private static VkQueueFlags vkCmdResetEvent2__queues = .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdResetEvent2 => vkCmdResetEvent2__queues;
	private static RenderPassLocation vkCmdResetEvent2__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdResetEvent2 => vkCmdResetEvent2__renderpass;
	private static CmdBufferLevel vkCmdResetEvent2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdResetEvent2 => vkCmdResetEvent2__cmdbufferlevel;
	private static Task vkCmdResetEvent2__tasks = .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdResetEvent2 => vkCmdResetEvent2__tasks;
	private static VkQueueFlags vkCmdWaitEvents2__queues = .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdWaitEvents2 => vkCmdWaitEvents2__queues;
	private static RenderPassLocation vkCmdWaitEvents2__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdWaitEvents2 => vkCmdWaitEvents2__renderpass;
	private static CmdBufferLevel vkCmdWaitEvents2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdWaitEvents2 => vkCmdWaitEvents2__cmdbufferlevel;
	private static Task vkCmdWaitEvents2__tasks = .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdWaitEvents2 => vkCmdWaitEvents2__tasks;
	private static VkQueueFlags vkCmdPipelineBarrier2__queues = .Transfer | .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdPipelineBarrier2 => vkCmdPipelineBarrier2__queues;
	private static RenderPassLocation vkCmdPipelineBarrier2__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdPipelineBarrier2 => vkCmdPipelineBarrier2__renderpass;
	private static CmdBufferLevel vkCmdPipelineBarrier2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdPipelineBarrier2 => vkCmdPipelineBarrier2__cmdbufferlevel;
	private static Task vkCmdPipelineBarrier2__tasks = .Synchronization;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdPipelineBarrier2 => vkCmdPipelineBarrier2__tasks;
	private static VkResult[?] vkQueueSubmit2__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkQueueSubmit2 => vkQueueSubmit2__successcodes;
	private static VkResult[?] vkQueueSubmit2__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkQueueSubmit2 => vkQueueSubmit2__errorcodes;
	private static VkQueueFlags vkCmdWriteTimestamp2__queues = .Transfer | .Graphics | .Compute | .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdWriteTimestamp2 => vkCmdWriteTimestamp2__queues;
	private static RenderPassLocation vkCmdWriteTimestamp2__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdWriteTimestamp2 => vkCmdWriteTimestamp2__renderpass;
	private static CmdBufferLevel vkCmdWriteTimestamp2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdWriteTimestamp2 => vkCmdWriteTimestamp2__cmdbufferlevel;
	private static Task vkCmdWriteTimestamp2__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdWriteTimestamp2 => vkCmdWriteTimestamp2__tasks;
	private static VkQueueFlags vkCmdWriteBufferMarker2AMD__queues = .Transfer | .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdWriteBufferMarker2AMD => vkCmdWriteBufferMarker2AMD__queues;
	private static RenderPassLocation vkCmdWriteBufferMarker2AMD__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdWriteBufferMarker2AMD => vkCmdWriteBufferMarker2AMD__renderpass;
	private static CmdBufferLevel vkCmdWriteBufferMarker2AMD__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdWriteBufferMarker2AMD => vkCmdWriteBufferMarker2AMD__cmdbufferlevel;
	private static Task vkCmdWriteBufferMarker2AMD__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdWriteBufferMarker2AMD => vkCmdWriteBufferMarker2AMD__tasks;
	private static VkResult[?] vkCopyMemoryToImage__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCopyMemoryToImage => vkCopyMemoryToImage__successcodes;
	private static VkResult[?] vkCopyMemoryToImage__errorcodes = .(.VkErrorInitializationFailed, .VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorMemoryMapFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCopyMemoryToImage => vkCopyMemoryToImage__errorcodes;
	private static VkResult[?] vkCopyImageToMemory__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCopyImageToMemory => vkCopyImageToMemory__successcodes;
	private static VkResult[?] vkCopyImageToMemory__errorcodes = .(.VkErrorInitializationFailed, .VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorMemoryMapFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCopyImageToMemory => vkCopyImageToMemory__errorcodes;
	private static VkResult[?] vkCopyImageToImage__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCopyImageToImage => vkCopyImageToImage__successcodes;
	private static VkResult[?] vkCopyImageToImage__errorcodes = .(.VkErrorInitializationFailed, .VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorMemoryMapFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCopyImageToImage => vkCopyImageToImage__errorcodes;
	private static VkResult[?] vkTransitionImageLayout__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkTransitionImageLayout => vkTransitionImageLayout__successcodes;
	private static VkResult[?] vkTransitionImageLayout__errorcodes = .(.VkErrorInitializationFailed, .VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorMemoryMapFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkTransitionImageLayout => vkTransitionImageLayout__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceVideoCapabilitiesKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR => vkGetPhysicalDeviceVideoCapabilitiesKHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceVideoCapabilitiesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorVideoProfileOperationNotSupportedKHR, .VkErrorVideoProfileFormatNotSupportedKHR, .VkErrorVideoPictureLayoutNotSupportedKHR, .VkErrorVideoProfileCodecNotSupportedKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR => vkGetPhysicalDeviceVideoCapabilitiesKHR__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceVideoFormatPropertiesKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR => vkGetPhysicalDeviceVideoFormatPropertiesKHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceVideoFormatPropertiesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorImageUsageNotSupportedKHR, .VkErrorVideoProfileOperationNotSupportedKHR, .VkErrorVideoProfileFormatNotSupportedKHR, .VkErrorVideoPictureLayoutNotSupportedKHR, .VkErrorVideoProfileCodecNotSupportedKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR => vkGetPhysicalDeviceVideoFormatPropertiesKHR__errorcodes;
	private static VkResult[?] vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR => vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorVideoProfileOperationNotSupportedKHR, .VkErrorVideoProfileFormatNotSupportedKHR, .VkErrorVideoPictureLayoutNotSupportedKHR, .VkErrorVideoProfileCodecNotSupportedKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR => vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR__errorcodes;
	private static VkResult[?] vkCreateVideoSessionKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateVideoSessionKHR => vkCreateVideoSessionKHR__successcodes;
	private static VkResult[?] vkCreateVideoSessionKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInitializationFailed, .VkErrorVideoStdVersionNotSupportedKHR, .VkErrorInvalidVideoStdParametersKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateVideoSessionKHR => vkCreateVideoSessionKHR__errorcodes;
	private static VkResult[?] vkCreateVideoSessionParametersKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateVideoSessionParametersKHR => vkCreateVideoSessionParametersKHR__successcodes;
	private static VkResult[?] vkCreateVideoSessionParametersKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInitializationFailed, .VkErrorInvalidVideoStdParametersKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateVideoSessionParametersKHR => vkCreateVideoSessionParametersKHR__errorcodes;
	private static VkResult[?] vkUpdateVideoSessionParametersKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkUpdateVideoSessionParametersKHR => vkUpdateVideoSessionParametersKHR__successcodes;
	private static VkResult[?] vkUpdateVideoSessionParametersKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInvalidVideoStdParametersKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkUpdateVideoSessionParametersKHR => vkUpdateVideoSessionParametersKHR__errorcodes;
	private static VkResult[?] vkGetEncodedVideoSessionParametersKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetEncodedVideoSessionParametersKHR => vkGetEncodedVideoSessionParametersKHR__successcodes;
	private static VkResult[?] vkGetEncodedVideoSessionParametersKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetEncodedVideoSessionParametersKHR => vkGetEncodedVideoSessionParametersKHR__errorcodes;
	private static VkResult[?] vkGetVideoSessionMemoryRequirementsKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetVideoSessionMemoryRequirementsKHR => vkGetVideoSessionMemoryRequirementsKHR__successcodes;
	private static VkResult[?] vkBindVideoSessionMemoryKHR__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkBindVideoSessionMemoryKHR => vkBindVideoSessionMemoryKHR__successcodes;
	private static VkResult[?] vkBindVideoSessionMemoryKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkBindVideoSessionMemoryKHR => vkBindVideoSessionMemoryKHR__errorcodes;
	private static VkQueueFlags vkCmdDecodeVideoKHR__queues = .VideoDecodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDecodeVideoKHR => vkCmdDecodeVideoKHR__queues;
	private static RenderPassLocation vkCmdDecodeVideoKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDecodeVideoKHR => vkCmdDecodeVideoKHR__renderpass;
	private static CmdBufferLevel vkCmdDecodeVideoKHR__cmdbufferlevel = .Primary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDecodeVideoKHR => vkCmdDecodeVideoKHR__cmdbufferlevel;
	private static Task vkCmdDecodeVideoKHR__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDecodeVideoKHR => vkCmdDecodeVideoKHR__tasks;
	private static VkQueueFlags vkCmdBeginVideoCodingKHR__queues = .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBeginVideoCodingKHR => vkCmdBeginVideoCodingKHR__queues;
	private static RenderPassLocation vkCmdBeginVideoCodingKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBeginVideoCodingKHR => vkCmdBeginVideoCodingKHR__renderpass;
	private static CmdBufferLevel vkCmdBeginVideoCodingKHR__cmdbufferlevel = .Primary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBeginVideoCodingKHR => vkCmdBeginVideoCodingKHR__cmdbufferlevel;
	private static Task vkCmdBeginVideoCodingKHR__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBeginVideoCodingKHR => vkCmdBeginVideoCodingKHR__tasks;
	private static VkQueueFlags vkCmdControlVideoCodingKHR__queues = .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdControlVideoCodingKHR => vkCmdControlVideoCodingKHR__queues;
	private static RenderPassLocation vkCmdControlVideoCodingKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdControlVideoCodingKHR => vkCmdControlVideoCodingKHR__renderpass;
	private static CmdBufferLevel vkCmdControlVideoCodingKHR__cmdbufferlevel = .Primary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdControlVideoCodingKHR => vkCmdControlVideoCodingKHR__cmdbufferlevel;
	private static Task vkCmdControlVideoCodingKHR__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdControlVideoCodingKHR => vkCmdControlVideoCodingKHR__tasks;
	private static VkQueueFlags vkCmdEndVideoCodingKHR__queues = .VideoDecodeKHR | .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdEndVideoCodingKHR => vkCmdEndVideoCodingKHR__queues;
	private static RenderPassLocation vkCmdEndVideoCodingKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdEndVideoCodingKHR => vkCmdEndVideoCodingKHR__renderpass;
	private static CmdBufferLevel vkCmdEndVideoCodingKHR__cmdbufferlevel = .Primary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdEndVideoCodingKHR => vkCmdEndVideoCodingKHR__cmdbufferlevel;
	private static Task vkCmdEndVideoCodingKHR__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdEndVideoCodingKHR => vkCmdEndVideoCodingKHR__tasks;
	private static VkQueueFlags vkCmdEncodeVideoKHR__queues = .VideoEncodeKHR;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdEncodeVideoKHR => vkCmdEncodeVideoKHR__queues;
	private static RenderPassLocation vkCmdEncodeVideoKHR__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdEncodeVideoKHR => vkCmdEncodeVideoKHR__renderpass;
	private static CmdBufferLevel vkCmdEncodeVideoKHR__cmdbufferlevel = .Primary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdEncodeVideoKHR => vkCmdEncodeVideoKHR__cmdbufferlevel;
	private static Task vkCmdEncodeVideoKHR__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdEncodeVideoKHR => vkCmdEncodeVideoKHR__tasks;
	private static VkQueueFlags vkCmdDecompressMemoryNV__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDecompressMemoryNV => vkCmdDecompressMemoryNV__queues;
	private static RenderPassLocation vkCmdDecompressMemoryNV__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDecompressMemoryNV => vkCmdDecompressMemoryNV__renderpass;
	private static CmdBufferLevel vkCmdDecompressMemoryNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDecompressMemoryNV => vkCmdDecompressMemoryNV__cmdbufferlevel;
	private static Task vkCmdDecompressMemoryNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDecompressMemoryNV => vkCmdDecompressMemoryNV__tasks;
	private static VkQueueFlags vkCmdDecompressMemoryIndirectCountNV__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdDecompressMemoryIndirectCountNV => vkCmdDecompressMemoryIndirectCountNV__queues;
	private static RenderPassLocation vkCmdDecompressMemoryIndirectCountNV__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdDecompressMemoryIndirectCountNV => vkCmdDecompressMemoryIndirectCountNV__renderpass;
	private static CmdBufferLevel vkCmdDecompressMemoryIndirectCountNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdDecompressMemoryIndirectCountNV => vkCmdDecompressMemoryIndirectCountNV__cmdbufferlevel;
	private static Task vkCmdDecompressMemoryIndirectCountNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdDecompressMemoryIndirectCountNV => vkCmdDecompressMemoryIndirectCountNV__tasks;
	private static VkResult[?] vkCreateCuModuleNVX__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateCuModuleNVX => vkCreateCuModuleNVX__successcodes;
	private static VkResult[?] vkCreateCuModuleNVX__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorInitializationFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateCuModuleNVX => vkCreateCuModuleNVX__errorcodes;
	private static VkResult[?] vkCreateCuFunctionNVX__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateCuFunctionNVX => vkCreateCuFunctionNVX__successcodes;
	private static VkResult[?] vkCreateCuFunctionNVX__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorInitializationFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateCuFunctionNVX => vkCreateCuFunctionNVX__errorcodes;
	private static VkQueueFlags vkCmdCuLaunchKernelNVX__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCuLaunchKernelNVX => vkCmdCuLaunchKernelNVX__queues;
	private static RenderPassLocation vkCmdCuLaunchKernelNVX__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCuLaunchKernelNVX => vkCmdCuLaunchKernelNVX__renderpass;
	private static CmdBufferLevel vkCmdCuLaunchKernelNVX__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCuLaunchKernelNVX => vkCmdCuLaunchKernelNVX__cmdbufferlevel;
	private static Task vkCmdCuLaunchKernelNVX__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCuLaunchKernelNVX => vkCmdCuLaunchKernelNVX__tasks;
	private static VkQueueFlags vkCmdBindDescriptorBuffersEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindDescriptorBuffersEXT => vkCmdBindDescriptorBuffersEXT__queues;
	private static RenderPassLocation vkCmdBindDescriptorBuffersEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindDescriptorBuffersEXT => vkCmdBindDescriptorBuffersEXT__renderpass;
	private static CmdBufferLevel vkCmdBindDescriptorBuffersEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindDescriptorBuffersEXT => vkCmdBindDescriptorBuffersEXT__cmdbufferlevel;
	private static Task vkCmdBindDescriptorBuffersEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindDescriptorBuffersEXT => vkCmdBindDescriptorBuffersEXT__tasks;
	private static VkQueueFlags vkCmdSetDescriptorBufferOffsetsEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDescriptorBufferOffsetsEXT => vkCmdSetDescriptorBufferOffsetsEXT__queues;
	private static RenderPassLocation vkCmdSetDescriptorBufferOffsetsEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDescriptorBufferOffsetsEXT => vkCmdSetDescriptorBufferOffsetsEXT__renderpass;
	private static CmdBufferLevel vkCmdSetDescriptorBufferOffsetsEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDescriptorBufferOffsetsEXT => vkCmdSetDescriptorBufferOffsetsEXT__cmdbufferlevel;
	private static Task vkCmdSetDescriptorBufferOffsetsEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDescriptorBufferOffsetsEXT => vkCmdSetDescriptorBufferOffsetsEXT__tasks;
	private static VkQueueFlags vkCmdBindDescriptorBufferEmbeddedSamplersEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT => vkCmdBindDescriptorBufferEmbeddedSamplersEXT__queues;
	private static RenderPassLocation vkCmdBindDescriptorBufferEmbeddedSamplersEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT => vkCmdBindDescriptorBufferEmbeddedSamplersEXT__renderpass;
	private static CmdBufferLevel vkCmdBindDescriptorBufferEmbeddedSamplersEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT => vkCmdBindDescriptorBufferEmbeddedSamplersEXT__cmdbufferlevel;
	private static Task vkCmdBindDescriptorBufferEmbeddedSamplersEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT => vkCmdBindDescriptorBufferEmbeddedSamplersEXT__tasks;
	private static VkResult[?] vkGetBufferOpaqueCaptureDescriptorDataEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT => vkGetBufferOpaqueCaptureDescriptorDataEXT__successcodes;
	private static VkResult[?] vkGetBufferOpaqueCaptureDescriptorDataEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT => vkGetBufferOpaqueCaptureDescriptorDataEXT__errorcodes;
	private static VkResult[?] vkGetImageOpaqueCaptureDescriptorDataEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetImageOpaqueCaptureDescriptorDataEXT => vkGetImageOpaqueCaptureDescriptorDataEXT__successcodes;
	private static VkResult[?] vkGetImageOpaqueCaptureDescriptorDataEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetImageOpaqueCaptureDescriptorDataEXT => vkGetImageOpaqueCaptureDescriptorDataEXT__errorcodes;
	private static VkResult[?] vkGetImageViewOpaqueCaptureDescriptorDataEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT => vkGetImageViewOpaqueCaptureDescriptorDataEXT__successcodes;
	private static VkResult[?] vkGetImageViewOpaqueCaptureDescriptorDataEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT => vkGetImageViewOpaqueCaptureDescriptorDataEXT__errorcodes;
	private static VkResult[?] vkGetSamplerOpaqueCaptureDescriptorDataEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT => vkGetSamplerOpaqueCaptureDescriptorDataEXT__successcodes;
	private static VkResult[?] vkGetSamplerOpaqueCaptureDescriptorDataEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT => vkGetSamplerOpaqueCaptureDescriptorDataEXT__errorcodes;
	private static VkResult[?] vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT => vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT__successcodes;
	private static VkResult[?] vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT => vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT__errorcodes;
	private static VkResult[?] vkAcquireDrmDisplayEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkAcquireDrmDisplayEXT => vkAcquireDrmDisplayEXT__successcodes;
	private static VkResult[?] vkAcquireDrmDisplayEXT__errorcodes = .(.VkErrorInitializationFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkAcquireDrmDisplayEXT => vkAcquireDrmDisplayEXT__errorcodes;
	private static VkResult[?] vkGetDrmDisplayEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetDrmDisplayEXT => vkGetDrmDisplayEXT__successcodes;
	private static VkResult[?] vkGetDrmDisplayEXT__errorcodes = .(.VkErrorInitializationFailed, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetDrmDisplayEXT => vkGetDrmDisplayEXT__errorcodes;
	private static VkResult[?] vkWaitForPresentKHR__successcodes = .(.VkSuccess, .VkTimeout, .VkSuboptimalKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkWaitForPresentKHR => vkWaitForPresentKHR__successcodes;
	private static VkResult[?] vkWaitForPresentKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorDeviceLost, .VkErrorOutOfDateKHR, .VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkWaitForPresentKHR => vkWaitForPresentKHR__errorcodes;
	private static VkResult[?] vkCreateCudaModuleNV__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateCudaModuleNV => vkCreateCudaModuleNV__successcodes;
	private static VkResult[?] vkCreateCudaModuleNV__errorcodes = .(.VkErrorInitializationFailed, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateCudaModuleNV => vkCreateCudaModuleNV__errorcodes;
	private static VkResult[?] vkGetCudaModuleCacheNV__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetCudaModuleCacheNV => vkGetCudaModuleCacheNV__successcodes;
	private static VkResult[?] vkGetCudaModuleCacheNV__errorcodes = .(.VkErrorInitializationFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetCudaModuleCacheNV => vkGetCudaModuleCacheNV__errorcodes;
	private static VkResult[?] vkCreateCudaFunctionNV__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateCudaFunctionNV => vkCreateCudaFunctionNV__successcodes;
	private static VkResult[?] vkCreateCudaFunctionNV__errorcodes = .(.VkErrorInitializationFailed, .VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateCudaFunctionNV => vkCreateCudaFunctionNV__errorcodes;
	private static VkQueueFlags vkCmdCudaLaunchKernelNV__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCudaLaunchKernelNV => vkCmdCudaLaunchKernelNV__queues;
	private static RenderPassLocation vkCmdCudaLaunchKernelNV__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCudaLaunchKernelNV => vkCmdCudaLaunchKernelNV__renderpass;
	private static CmdBufferLevel vkCmdCudaLaunchKernelNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCudaLaunchKernelNV => vkCmdCudaLaunchKernelNV__cmdbufferlevel;
	private static Task vkCmdCudaLaunchKernelNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCudaLaunchKernelNV => vkCmdCudaLaunchKernelNV__tasks;
	private static VkQueueFlags vkCmdBeginRendering__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBeginRendering => vkCmdBeginRendering__queues;
	private static RenderPassLocation vkCmdBeginRendering__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBeginRendering => vkCmdBeginRendering__renderpass;
	private static CmdBufferLevel vkCmdBeginRendering__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBeginRendering => vkCmdBeginRendering__cmdbufferlevel;
	private static Task vkCmdBeginRendering__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBeginRendering => vkCmdBeginRendering__tasks;
	private static VkQueueFlags vkCmdEndRendering__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdEndRendering => vkCmdEndRendering__queues;
	private static RenderPassLocation vkCmdEndRendering__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdEndRendering => vkCmdEndRendering__renderpass;
	private static CmdBufferLevel vkCmdEndRendering__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdEndRendering => vkCmdEndRendering__cmdbufferlevel;
	private static Task vkCmdEndRendering__tasks = .Action | .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdEndRendering => vkCmdEndRendering__tasks;
	private static VkResult[?] vkCreateMicromapEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateMicromapEXT => vkCreateMicromapEXT__successcodes;
	private static VkResult[?] vkCreateMicromapEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorInvalidOpaqueCaptureAddressKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateMicromapEXT => vkCreateMicromapEXT__errorcodes;
	private static VkQueueFlags vkCmdBuildMicromapsEXT__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBuildMicromapsEXT => vkCmdBuildMicromapsEXT__queues;
	private static RenderPassLocation vkCmdBuildMicromapsEXT__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBuildMicromapsEXT => vkCmdBuildMicromapsEXT__renderpass;
	private static CmdBufferLevel vkCmdBuildMicromapsEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBuildMicromapsEXT => vkCmdBuildMicromapsEXT__cmdbufferlevel;
	private static Task vkCmdBuildMicromapsEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBuildMicromapsEXT => vkCmdBuildMicromapsEXT__tasks;
	private static VkResult[?] vkBuildMicromapsEXT__successcodes = .(.VkSuccess, .VkOperationDeferredKHR, .VkOperationNotDeferredKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkBuildMicromapsEXT => vkBuildMicromapsEXT__successcodes;
	private static VkResult[?] vkBuildMicromapsEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkBuildMicromapsEXT => vkBuildMicromapsEXT__errorcodes;
	private static VkQueueFlags vkCmdCopyMicromapEXT__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyMicromapEXT => vkCmdCopyMicromapEXT__queues;
	private static RenderPassLocation vkCmdCopyMicromapEXT__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyMicromapEXT => vkCmdCopyMicromapEXT__renderpass;
	private static CmdBufferLevel vkCmdCopyMicromapEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyMicromapEXT => vkCmdCopyMicromapEXT__cmdbufferlevel;
	private static Task vkCmdCopyMicromapEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyMicromapEXT => vkCmdCopyMicromapEXT__tasks;
	private static VkResult[?] vkCopyMicromapEXT__successcodes = .(.VkSuccess, .VkOperationDeferredKHR, .VkOperationNotDeferredKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCopyMicromapEXT => vkCopyMicromapEXT__successcodes;
	private static VkResult[?] vkCopyMicromapEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCopyMicromapEXT => vkCopyMicromapEXT__errorcodes;
	private static VkQueueFlags vkCmdCopyMicromapToMemoryEXT__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyMicromapToMemoryEXT => vkCmdCopyMicromapToMemoryEXT__queues;
	private static RenderPassLocation vkCmdCopyMicromapToMemoryEXT__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyMicromapToMemoryEXT => vkCmdCopyMicromapToMemoryEXT__renderpass;
	private static CmdBufferLevel vkCmdCopyMicromapToMemoryEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyMicromapToMemoryEXT => vkCmdCopyMicromapToMemoryEXT__cmdbufferlevel;
	private static Task vkCmdCopyMicromapToMemoryEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyMicromapToMemoryEXT => vkCmdCopyMicromapToMemoryEXT__tasks;
	private static VkResult[?] vkCopyMicromapToMemoryEXT__successcodes = .(.VkSuccess, .VkOperationDeferredKHR, .VkOperationNotDeferredKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCopyMicromapToMemoryEXT => vkCopyMicromapToMemoryEXT__successcodes;
	private static VkResult[?] vkCopyMicromapToMemoryEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCopyMicromapToMemoryEXT => vkCopyMicromapToMemoryEXT__errorcodes;
	private static VkQueueFlags vkCmdCopyMemoryToMicromapEXT__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdCopyMemoryToMicromapEXT => vkCmdCopyMemoryToMicromapEXT__queues;
	private static RenderPassLocation vkCmdCopyMemoryToMicromapEXT__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdCopyMemoryToMicromapEXT => vkCmdCopyMemoryToMicromapEXT__renderpass;
	private static CmdBufferLevel vkCmdCopyMemoryToMicromapEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdCopyMemoryToMicromapEXT => vkCmdCopyMemoryToMicromapEXT__cmdbufferlevel;
	private static Task vkCmdCopyMemoryToMicromapEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdCopyMemoryToMicromapEXT => vkCmdCopyMemoryToMicromapEXT__tasks;
	private static VkResult[?] vkCopyMemoryToMicromapEXT__successcodes = .(.VkSuccess, .VkOperationDeferredKHR, .VkOperationNotDeferredKHR);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCopyMemoryToMicromapEXT => vkCopyMemoryToMicromapEXT__successcodes;
	private static VkResult[?] vkCopyMemoryToMicromapEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCopyMemoryToMicromapEXT => vkCopyMemoryToMicromapEXT__errorcodes;
	private static VkQueueFlags vkCmdWriteMicromapsPropertiesEXT__queues = .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdWriteMicromapsPropertiesEXT => vkCmdWriteMicromapsPropertiesEXT__queues;
	private static RenderPassLocation vkCmdWriteMicromapsPropertiesEXT__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdWriteMicromapsPropertiesEXT => vkCmdWriteMicromapsPropertiesEXT__renderpass;
	private static CmdBufferLevel vkCmdWriteMicromapsPropertiesEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdWriteMicromapsPropertiesEXT => vkCmdWriteMicromapsPropertiesEXT__cmdbufferlevel;
	private static Task vkCmdWriteMicromapsPropertiesEXT__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdWriteMicromapsPropertiesEXT => vkCmdWriteMicromapsPropertiesEXT__tasks;
	private static VkResult[?] vkWriteMicromapsPropertiesEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkWriteMicromapsPropertiesEXT => vkWriteMicromapsPropertiesEXT__successcodes;
	private static VkResult[?] vkWriteMicromapsPropertiesEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkWriteMicromapsPropertiesEXT => vkWriteMicromapsPropertiesEXT__errorcodes;
	private static VkResult[?] vkGetPipelinePropertiesEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPipelinePropertiesEXT => vkGetPipelinePropertiesEXT__successcodes;
	private static VkResult[?] vkGetPipelinePropertiesEXT__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPipelinePropertiesEXT => vkGetPipelinePropertiesEXT__errorcodes;
	private static VkResult[?] vkGetFramebufferTilePropertiesQCOM__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetFramebufferTilePropertiesQCOM => vkGetFramebufferTilePropertiesQCOM__successcodes;
	private static VkResult[?] vkGetDynamicRenderingTilePropertiesQCOM__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetDynamicRenderingTilePropertiesQCOM => vkGetDynamicRenderingTilePropertiesQCOM__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceOpticalFlowImageFormatsNV__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV => vkGetPhysicalDeviceOpticalFlowImageFormatsNV__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceOpticalFlowImageFormatsNV__errorcodes = .(.VkErrorExtensionNotPresent, .VkErrorInitializationFailed, .VkErrorFormatNotSupported);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV => vkGetPhysicalDeviceOpticalFlowImageFormatsNV__errorcodes;
	private static VkResult[?] vkCreateOpticalFlowSessionNV__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateOpticalFlowSessionNV => vkCreateOpticalFlowSessionNV__successcodes;
	private static VkResult[?] vkCreateOpticalFlowSessionNV__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorInitializationFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateOpticalFlowSessionNV => vkCreateOpticalFlowSessionNV__errorcodes;
	private static VkResult[?] vkBindOpticalFlowSessionImageNV__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkBindOpticalFlowSessionImageNV => vkBindOpticalFlowSessionImageNV__successcodes;
	private static VkResult[?] vkBindOpticalFlowSessionImageNV__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorInitializationFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkBindOpticalFlowSessionImageNV => vkBindOpticalFlowSessionImageNV__errorcodes;
	private static VkQueueFlags vkCmdOpticalFlowExecuteNV__queues = .OpticalFlowNV;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdOpticalFlowExecuteNV => vkCmdOpticalFlowExecuteNV__queues;
	private static RenderPassLocation vkCmdOpticalFlowExecuteNV__renderpass = .Outside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdOpticalFlowExecuteNV => vkCmdOpticalFlowExecuteNV__renderpass;
	private static CmdBufferLevel vkCmdOpticalFlowExecuteNV__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdOpticalFlowExecuteNV => vkCmdOpticalFlowExecuteNV__cmdbufferlevel;
	private static Task vkCmdOpticalFlowExecuteNV__tasks = .Action;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdOpticalFlowExecuteNV => vkCmdOpticalFlowExecuteNV__tasks;
	private static VkResult[?] vkGetDeviceFaultInfoEXT__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetDeviceFaultInfoEXT => vkGetDeviceFaultInfoEXT__successcodes;
	private static VkResult[?] vkGetDeviceFaultInfoEXT__errorcodes = .(.VkErrorOutOfHostMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetDeviceFaultInfoEXT => vkGetDeviceFaultInfoEXT__errorcodes;
	private static VkQueueFlags vkCmdSetDepthBias2EXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDepthBias2EXT => vkCmdSetDepthBias2EXT__queues;
	private static RenderPassLocation vkCmdSetDepthBias2EXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDepthBias2EXT => vkCmdSetDepthBias2EXT__renderpass;
	private static CmdBufferLevel vkCmdSetDepthBias2EXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDepthBias2EXT => vkCmdSetDepthBias2EXT__cmdbufferlevel;
	private static Task vkCmdSetDepthBias2EXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDepthBias2EXT => vkCmdSetDepthBias2EXT__tasks;
	private static VkResult[?] vkReleaseSwapchainImagesEXT__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkReleaseSwapchainImagesEXT => vkReleaseSwapchainImagesEXT__successcodes;
	private static VkResult[?] vkReleaseSwapchainImagesEXT__errorcodes = .(.VkErrorSurfaceLostKHR);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkReleaseSwapchainImagesEXT => vkReleaseSwapchainImagesEXT__errorcodes;
	private static VkResult[?] vkMapMemory2__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkMapMemory2 => vkMapMemory2__successcodes;
	private static VkResult[?] vkMapMemory2__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorMemoryMapFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkMapMemory2 => vkMapMemory2__errorcodes;
	private static VkResult[?] vkUnmapMemory2__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkUnmapMemory2 => vkUnmapMemory2__successcodes;
	private static VkResult[?] vkUnmapMemory2__errorcodes = .(.VkErrorMemoryMapFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkUnmapMemory2 => vkUnmapMemory2__errorcodes;
	private static VkResult[?] vkCreateShadersEXT__successcodes = .(.VkSuccess, .VkIncompatibleShaderBinaryEXT);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkCreateShadersEXT => vkCreateShadersEXT__successcodes;
	private static VkResult[?] vkCreateShadersEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory, .VkErrorInitializationFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkCreateShadersEXT => vkCreateShadersEXT__errorcodes;
	private static VkResult[?] vkGetShaderBinaryDataEXT__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetShaderBinaryDataEXT => vkGetShaderBinaryDataEXT__successcodes;
	private static VkResult[?] vkGetShaderBinaryDataEXT__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetShaderBinaryDataEXT => vkGetShaderBinaryDataEXT__errorcodes;
	private static VkQueueFlags vkCmdBindShadersEXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindShadersEXT => vkCmdBindShadersEXT__queues;
	private static RenderPassLocation vkCmdBindShadersEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindShadersEXT => vkCmdBindShadersEXT__renderpass;
	private static CmdBufferLevel vkCmdBindShadersEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindShadersEXT => vkCmdBindShadersEXT__cmdbufferlevel;
	private static Task vkCmdBindShadersEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindShadersEXT => vkCmdBindShadersEXT__tasks;
	private static VkResult[?] vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR => vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR => vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR__errorcodes;
	private static VkQueueFlags vkCmdBindDescriptorSets2__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindDescriptorSets2 => vkCmdBindDescriptorSets2__queues;
	private static RenderPassLocation vkCmdBindDescriptorSets2__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindDescriptorSets2 => vkCmdBindDescriptorSets2__renderpass;
	private static CmdBufferLevel vkCmdBindDescriptorSets2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindDescriptorSets2 => vkCmdBindDescriptorSets2__cmdbufferlevel;
	private static Task vkCmdBindDescriptorSets2__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindDescriptorSets2 => vkCmdBindDescriptorSets2__tasks;
	private static VkQueueFlags vkCmdPushConstants2__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdPushConstants2 => vkCmdPushConstants2__queues;
	private static RenderPassLocation vkCmdPushConstants2__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdPushConstants2 => vkCmdPushConstants2__renderpass;
	private static CmdBufferLevel vkCmdPushConstants2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdPushConstants2 => vkCmdPushConstants2__cmdbufferlevel;
	private static Task vkCmdPushConstants2__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdPushConstants2 => vkCmdPushConstants2__tasks;
	private static VkQueueFlags vkCmdPushDescriptorSet2__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdPushDescriptorSet2 => vkCmdPushDescriptorSet2__queues;
	private static RenderPassLocation vkCmdPushDescriptorSet2__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdPushDescriptorSet2 => vkCmdPushDescriptorSet2__renderpass;
	private static CmdBufferLevel vkCmdPushDescriptorSet2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdPushDescriptorSet2 => vkCmdPushDescriptorSet2__cmdbufferlevel;
	private static Task vkCmdPushDescriptorSet2__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdPushDescriptorSet2 => vkCmdPushDescriptorSet2__tasks;
	private static VkQueueFlags vkCmdPushDescriptorSetWithTemplate2__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdPushDescriptorSetWithTemplate2 => vkCmdPushDescriptorSetWithTemplate2__queues;
	private static RenderPassLocation vkCmdPushDescriptorSetWithTemplate2__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdPushDescriptorSetWithTemplate2 => vkCmdPushDescriptorSetWithTemplate2__renderpass;
	private static CmdBufferLevel vkCmdPushDescriptorSetWithTemplate2__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdPushDescriptorSetWithTemplate2 => vkCmdPushDescriptorSetWithTemplate2__cmdbufferlevel;
	private static Task vkCmdPushDescriptorSetWithTemplate2__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdPushDescriptorSetWithTemplate2 => vkCmdPushDescriptorSetWithTemplate2__tasks;
	private static VkQueueFlags vkCmdSetDescriptorBufferOffsets2EXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDescriptorBufferOffsets2EXT => vkCmdSetDescriptorBufferOffsets2EXT__queues;
	private static RenderPassLocation vkCmdSetDescriptorBufferOffsets2EXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDescriptorBufferOffsets2EXT => vkCmdSetDescriptorBufferOffsets2EXT__renderpass;
	private static CmdBufferLevel vkCmdSetDescriptorBufferOffsets2EXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDescriptorBufferOffsets2EXT => vkCmdSetDescriptorBufferOffsets2EXT__cmdbufferlevel;
	private static Task vkCmdSetDescriptorBufferOffsets2EXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDescriptorBufferOffsets2EXT => vkCmdSetDescriptorBufferOffsets2EXT__tasks;
	private static VkQueueFlags vkCmdBindDescriptorBufferEmbeddedSamplers2EXT__queues = .Graphics | .Compute;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT => vkCmdBindDescriptorBufferEmbeddedSamplers2EXT__queues;
	private static RenderPassLocation vkCmdBindDescriptorBufferEmbeddedSamplers2EXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT => vkCmdBindDescriptorBufferEmbeddedSamplers2EXT__renderpass;
	private static CmdBufferLevel vkCmdBindDescriptorBufferEmbeddedSamplers2EXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT => vkCmdBindDescriptorBufferEmbeddedSamplers2EXT__cmdbufferlevel;
	private static Task vkCmdBindDescriptorBufferEmbeddedSamplers2EXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT => vkCmdBindDescriptorBufferEmbeddedSamplers2EXT__tasks;
	private static VkResult[?] vkSetLatencySleepModeNV__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkSetLatencySleepModeNV => vkSetLatencySleepModeNV__successcodes;
	private static VkResult[?] vkSetLatencySleepModeNV__errorcodes = .(.VkErrorInitializationFailed);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkSetLatencySleepModeNV => vkSetLatencySleepModeNV__errorcodes;
	private static VkResult[?] vkLatencySleepNV__successcodes = .(.VkSuccess);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkLatencySleepNV => vkLatencySleepNV__successcodes;
	private static VkQueueFlags vkCmdSetRenderingAttachmentLocations__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetRenderingAttachmentLocations => vkCmdSetRenderingAttachmentLocations__queues;
	private static RenderPassLocation vkCmdSetRenderingAttachmentLocations__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetRenderingAttachmentLocations => vkCmdSetRenderingAttachmentLocations__renderpass;
	private static CmdBufferLevel vkCmdSetRenderingAttachmentLocations__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetRenderingAttachmentLocations => vkCmdSetRenderingAttachmentLocations__cmdbufferlevel;
	private static Task vkCmdSetRenderingAttachmentLocations__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetRenderingAttachmentLocations => vkCmdSetRenderingAttachmentLocations__tasks;
	private static VkQueueFlags vkCmdSetRenderingInputAttachmentIndices__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetRenderingInputAttachmentIndices => vkCmdSetRenderingInputAttachmentIndices__queues;
	private static RenderPassLocation vkCmdSetRenderingInputAttachmentIndices__renderpass = .Inside;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetRenderingInputAttachmentIndices => vkCmdSetRenderingInputAttachmentIndices__renderpass;
	private static CmdBufferLevel vkCmdSetRenderingInputAttachmentIndices__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetRenderingInputAttachmentIndices => vkCmdSetRenderingInputAttachmentIndices__cmdbufferlevel;
	private static Task vkCmdSetRenderingInputAttachmentIndices__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetRenderingInputAttachmentIndices => vkCmdSetRenderingInputAttachmentIndices__tasks;
	private static VkQueueFlags vkCmdSetDepthClampRangeEXT__queues = .Graphics;
	[Inline] public static VkQueueFlagBits Queues<T>() where T : PFN_vkCmdSetDepthClampRangeEXT => vkCmdSetDepthClampRangeEXT__queues;
	private static RenderPassLocation vkCmdSetDepthClampRangeEXT__renderpass = .Both;
	[Inline] public static RenderPassLocation RenderPassLocation<T>() where T : PFN_vkCmdSetDepthClampRangeEXT => vkCmdSetDepthClampRangeEXT__renderpass;
	private static CmdBufferLevel vkCmdSetDepthClampRangeEXT__cmdbufferlevel = .Primary | .Secondary;
	[Inline] public static CmdBufferLevel CmdBufferLevels<T>() where T : PFN_vkCmdSetDepthClampRangeEXT => vkCmdSetDepthClampRangeEXT__cmdbufferlevel;
	private static Task vkCmdSetDepthClampRangeEXT__tasks = .State;
	[Inline] public static Task Tasks<T>() where T : PFN_vkCmdSetDepthClampRangeEXT => vkCmdSetDepthClampRangeEXT__tasks;
	private static VkResult[?] vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV__successcodes = .(.VkSuccess, .VkIncomplete);
	[Inline] public static Span<VkResult> SuccessCodes<T>() where T : PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV => vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV__successcodes;
	private static VkResult[?] vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV__errorcodes = .(.VkErrorOutOfHostMemory, .VkErrorOutOfDeviceMemory);
	[Inline] public static Span<VkResult> ErrorCodes<T>() where T : PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV => vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV__errorcodes;
}
