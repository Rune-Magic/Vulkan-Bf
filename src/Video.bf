/*  Auto Generated by Setup/Program.bf
 *  DO NOT EDIT
 */

using System;
using System.Interop;

using Vulkan;

namespace Vulkan.Video;

static { public static uint32 VK_MAKE_VIDEO_STD_VERSION(uint32 major, uint32 minor, uint32 patch) => ((((uint32)(major)) << 22) | (((uint32)(minor)) << 12) | ((uint32)(patch))); }
static { public const uint32 STD_VIDEO_H264_CPB_CNT_LIST_SIZE = 32; }
static { public const uint32 STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS = 6; }
static { public const uint32 STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS = 16; }
static { public const uint32 STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS = 6; }
static { public const uint32 STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS = 64; }
static { public const uint32 STD_VIDEO_H264_MAX_NUM_LIST_REF = 32; }
static { public const uint32 STD_VIDEO_H264_MAX_CHROMA_PLANES = 2; }
static { public const uint32 STD_VIDEO_H264_NO_REFERENCE_PICTURE = 0xFF; }

[AllowDuplicates] enum StdVideoH264ChromaFormatIdc : int32
{
	Monochrome = 0,
	VK_420 = 1,
	VK_422 = 2,
	VK_444 = 3,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH264ProfileIdc : int32
{
	Baseline = 66, // Only constrained baseline is supported
	Main = 77,
	High = 100,
	High444Predictive = 244,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH264LevelIdc : int32
{
	VK_10 = 0,
	VK_11 = 1,
	VK_12 = 2,
	VK_13 = 3,
	VK_20 = 4,
	VK_21 = 5,
	VK_22 = 6,
	VK_30 = 7,
	VK_31 = 8,
	VK_32 = 9,
	VK_40 = 10,
	VK_41 = 11,
	VK_42 = 12,
	VK_50 = 13,
	VK_51 = 14,
	VK_52 = 15,
	VK_60 = 16,
	VK_61 = 17,
	VK_62 = 18,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH264PocType : int32
{
	VK_0 = 0,
	VK_1 = 1,
	VK_2 = 2,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH264AspectRatioIdc : int32
{
	Unspecified = 0,
	Square = 1,
	VK_1211 = 2,
	VK_1011 = 3,
	VK_1611 = 4,
	VK_4033 = 5,
	VK_2411 = 6,
	VK_2011 = 7,
	VK_3211 = 8,
	VK_8033 = 9,
	VK_1811 = 10,
	VK_1511 = 11,
	VK_6433 = 12,
	VK_16099 = 13,
	VK_43 = 14,
	VK_32 = 15,
	VK_21 = 16,
	ExtendedSar = 255,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH264WeightedBipredIdc : int32
{
	Default = 0,
	Explicit = 1,
	Implicit = 2,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH264ModificationOfPicNumsIdc : int32
{
	ShortTermSubtract = 0,
	ShortTermAdd = 1,
	LongTerm = 2,
	End = 3,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH264MemMgmtControlOp : int32
{
	End = 0,
	UnmarkShortTerm = 1,
	UnmarkLongTerm = 2,
	MarkLongTerm = 3,
	SetMaxLongTermIndex = 4,
	UnmarkAll = 5,
	MarkCurrentAsLongTerm = 6,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH264CabacInitIdc : int32
{
	VK_0 = 0,
	VK_1 = 1,
	VK_2 = 2,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH264DisableDeblockingFilterIdc : int32
{
	Disabled = 0,
	Enabled = 1,
	Partial = 2,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH264SliceType : int32
{
	P = 0,
	B = 1,
	I = 2,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH264PictureType : int32
{
	P = 0,
	B = 1,
	I = 2,
	Idr = 5,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH264NonVclNaluType : int32
{
	Sps = 0,
	Pps = 1,
	Aud = 2,
	Prefix = 3,
	EndOfSequence = 4,
	EndOfStream = 5,
	Precoded = 6,
	Invalid = 0x7FFFFFFF,
}

[CRepr] struct StdVideoH264SpsVuiFlags
{
	[Bitfield(.Public, .Bits(1), "aspect_ratio_info_present_flag")]
	[Bitfield(.Public, .Bits(1), "overscan_info_present_flag")]
	[Bitfield(.Public, .Bits(1), "overscan_appropriate_flag")]
	[Bitfield(.Public, .Bits(1), "video_signal_type_present_flag")]
	[Bitfield(.Public, .Bits(1), "video_full_range_flag")]
	[Bitfield(.Public, .Bits(1), "color_description_present_flag")]
	// colour_description_present_flag
	[Bitfield(.Public, .Bits(1), "chroma_loc_info_present_flag")]
	[Bitfield(.Public, .Bits(1), "timing_info_present_flag")]
	[Bitfield(.Public, .Bits(1), "fixed_frame_rate_flag")]
	[Bitfield(.Public, .Bits(1), "bitstream_restriction_flag")]
	[Bitfield(.Public, .Bits(1), "nal_hrd_parameters_present_flag")]
	[Bitfield(.Public, .Bits(1), "vcl_hrd_parameters_present_flag")]
	private uint32 __bitfields;

	public this(uint32 aspect_ratio_info_present_flag, uint32 overscan_info_present_flag, uint32 overscan_appropriate_flag, uint32 video_signal_type_present_flag, uint32 video_full_range_flag, uint32 color_description_present_flag, uint32 chroma_loc_info_present_flag, uint32 timing_info_present_flag, uint32 fixed_frame_rate_flag, uint32 bitstream_restriction_flag, uint32 nal_hrd_parameters_present_flag, uint32 vcl_hrd_parameters_present_flag) : this()
	{
		this.aspect_ratio_info_present_flag = aspect_ratio_info_present_flag;
		this.overscan_info_present_flag = overscan_info_present_flag;
		this.overscan_appropriate_flag = overscan_appropriate_flag;
		this.video_signal_type_present_flag = video_signal_type_present_flag;
		this.video_full_range_flag = video_full_range_flag;
		this.color_description_present_flag = color_description_present_flag;
		this.chroma_loc_info_present_flag = chroma_loc_info_present_flag;
		this.timing_info_present_flag = timing_info_present_flag;
		this.fixed_frame_rate_flag = fixed_frame_rate_flag;
		this.bitstream_restriction_flag = bitstream_restriction_flag;
		this.nal_hrd_parameters_present_flag = nal_hrd_parameters_present_flag;
		this.vcl_hrd_parameters_present_flag = vcl_hrd_parameters_present_flag;
	}

	public this()
	{
		this = default;
	}
}

// hrd_parameters
[CRepr] struct StdVideoH264HrdParameters
{
	public uint8 cpb_cnt_minus1;
	public uint8 bit_rate_scale;
	public uint8 cpb_size_scale;
	public uint8 reserved1; // Reserved for future use and must be initialized with 0.
	public uint32[STD_VIDEO_H264_CPB_CNT_LIST_SIZE] bit_rate_value_minus1; // cpb_cnt_minus1 number of valid elements
	public uint32[STD_VIDEO_H264_CPB_CNT_LIST_SIZE] cpb_size_value_minus1; // cpb_cnt_minus1 number of valid elements
	public uint8[STD_VIDEO_H264_CPB_CNT_LIST_SIZE] cbr_flag; // cpb_cnt_minus1 number of valid elements
	public uint32 initial_cpb_removal_delay_length_minus1;
	public uint32 cpb_removal_delay_length_minus1;
	public uint32 dpb_output_delay_length_minus1;
	public uint32 time_offset_length;

	public this(uint8 cpb_cnt_minus1, uint8 bit_rate_scale, uint8 cpb_size_scale, uint8 reserved1, uint32[STD_VIDEO_H264_CPB_CNT_LIST_SIZE] bit_rate_value_minus1, uint32[STD_VIDEO_H264_CPB_CNT_LIST_SIZE] cpb_size_value_minus1, uint8[STD_VIDEO_H264_CPB_CNT_LIST_SIZE] cbr_flag, uint32 initial_cpb_removal_delay_length_minus1, uint32 cpb_removal_delay_length_minus1, uint32 dpb_output_delay_length_minus1, uint32 time_offset_length)
	{
		this.cpb_cnt_minus1 = cpb_cnt_minus1;
		this.bit_rate_scale = bit_rate_scale;
		this.cpb_size_scale = cpb_size_scale;
		this.reserved1 = reserved1;
		this.bit_rate_value_minus1 = bit_rate_value_minus1;
		this.cpb_size_value_minus1 = cpb_size_value_minus1;
		this.cbr_flag = cbr_flag;
		this.initial_cpb_removal_delay_length_minus1 = initial_cpb_removal_delay_length_minus1;
		this.cpb_removal_delay_length_minus1 = cpb_removal_delay_length_minus1;
		this.dpb_output_delay_length_minus1 = dpb_output_delay_length_minus1;
		this.time_offset_length = time_offset_length;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH264SequenceParameterSetVui
{
	public StdVideoH264SpsVuiFlags flags;
	public StdVideoH264AspectRatioIdc aspect_ratio_idc;
	public uint16 sar_width;
	public uint16 sar_height;
	public uint8 video_format;
	public uint8 colour_primaries;
	public uint8 transfer_characteristics;
	public uint8 matrix_coefficients;
	public uint32 num_units_in_tick;
	public uint32 time_scale;
	public uint8 max_num_reorder_frames;
	public uint8 max_dec_frame_buffering;
	public uint8 chroma_sample_loc_type_top_field;
	public uint8 chroma_sample_loc_type_bottom_field;
	public uint32 reserved1; // Reserved for future use and must be initialized with 0.
	public StdVideoH264HrdParameters* pHrdParameters; // must be a valid ptr to hrd_parameters, if nal_hrd_parameters_present_flag or vcl_hrd_parameters_present_flag are set

	public this(StdVideoH264SpsVuiFlags flags, StdVideoH264AspectRatioIdc aspect_ratio_idc, uint16 sar_width, uint16 sar_height, uint8 video_format, uint8 colour_primaries, uint8 transfer_characteristics, uint8 matrix_coefficients, uint32 num_units_in_tick, uint32 time_scale, uint8 max_num_reorder_frames, uint8 max_dec_frame_buffering, uint8 chroma_sample_loc_type_top_field, uint8 chroma_sample_loc_type_bottom_field, uint32 reserved1, StdVideoH264HrdParameters* pHrdParameters)
	{
		this.flags = flags;
		this.aspect_ratio_idc = aspect_ratio_idc;
		this.sar_width = sar_width;
		this.sar_height = sar_height;
		this.video_format = video_format;
		this.colour_primaries = colour_primaries;
		this.transfer_characteristics = transfer_characteristics;
		this.matrix_coefficients = matrix_coefficients;
		this.num_units_in_tick = num_units_in_tick;
		this.time_scale = time_scale;
		this.max_num_reorder_frames = max_num_reorder_frames;
		this.max_dec_frame_buffering = max_dec_frame_buffering;
		this.chroma_sample_loc_type_top_field = chroma_sample_loc_type_top_field;
		this.chroma_sample_loc_type_bottom_field = chroma_sample_loc_type_bottom_field;
		this.reserved1 = reserved1;
		this.pHrdParameters = pHrdParameters;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH264SpsFlags
{
	[Bitfield(.Public, .Bits(1), "constraint_set0_flag")]
	[Bitfield(.Public, .Bits(1), "constraint_set1_flag")]
	[Bitfield(.Public, .Bits(1), "constraint_set2_flag")]
	[Bitfield(.Public, .Bits(1), "constraint_set3_flag")]
	[Bitfield(.Public, .Bits(1), "constraint_set4_flag")]
	[Bitfield(.Public, .Bits(1), "constraint_set5_flag")]
	[Bitfield(.Public, .Bits(1), "direct_8x8_inference_flag")]
	[Bitfield(.Public, .Bits(1), "mb_adaptive_frame_field_flag")]
	[Bitfield(.Public, .Bits(1), "frame_mbs_only_flag")]
	[Bitfield(.Public, .Bits(1), "delta_pic_order_always_zero_flag")]
	[Bitfield(.Public, .Bits(1), "separate_colour_plane_flag")]
	[Bitfield(.Public, .Bits(1), "gaps_in_frame_num_value_allowed_flag")]
	[Bitfield(.Public, .Bits(1), "qpprime_y_zero_transform_bypass_flag")]
	[Bitfield(.Public, .Bits(1), "frame_cropping_flag")]
	[Bitfield(.Public, .Bits(1), "seq_scaling_matrix_present_flag")]
	[Bitfield(.Public, .Bits(1), "vui_parameters_present_flag")]
	private uint32 __bitfields;

	public this(uint32 constraint_set0_flag, uint32 constraint_set1_flag, uint32 constraint_set2_flag, uint32 constraint_set3_flag, uint32 constraint_set4_flag, uint32 constraint_set5_flag, uint32 direct_8x8_inference_flag, uint32 mb_adaptive_frame_field_flag, uint32 frame_mbs_only_flag, uint32 delta_pic_order_always_zero_flag, uint32 separate_colour_plane_flag, uint32 gaps_in_frame_num_value_allowed_flag, uint32 qpprime_y_zero_transform_bypass_flag, uint32 frame_cropping_flag, uint32 seq_scaling_matrix_present_flag, uint32 vui_parameters_present_flag) : this()
	{
		this.constraint_set0_flag = constraint_set0_flag;
		this.constraint_set1_flag = constraint_set1_flag;
		this.constraint_set2_flag = constraint_set2_flag;
		this.constraint_set3_flag = constraint_set3_flag;
		this.constraint_set4_flag = constraint_set4_flag;
		this.constraint_set5_flag = constraint_set5_flag;
		this.direct_8x8_inference_flag = direct_8x8_inference_flag;
		this.mb_adaptive_frame_field_flag = mb_adaptive_frame_field_flag;
		this.frame_mbs_only_flag = frame_mbs_only_flag;
		this.delta_pic_order_always_zero_flag = delta_pic_order_always_zero_flag;
		this.separate_colour_plane_flag = separate_colour_plane_flag;
		this.gaps_in_frame_num_value_allowed_flag = gaps_in_frame_num_value_allowed_flag;
		this.qpprime_y_zero_transform_bypass_flag = qpprime_y_zero_transform_bypass_flag;
		this.frame_cropping_flag = frame_cropping_flag;
		this.seq_scaling_matrix_present_flag = seq_scaling_matrix_present_flag;
		this.vui_parameters_present_flag = vui_parameters_present_flag;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH264ScalingLists
{
	/* scaling_list_present_mask has one bit for each	 * seq_scaling_list_present_flag[i] for SPS OR
	 * pic_scaling_list_present_flag[i] for PPS,
	 * bit 0 - 5 are for each entry of ScalingList4x4
	 * bit 6 - 11 are for each entry plus 6 for ScalingList8x8
	 */
	public uint16 scaling_list_present_mask;
	/* use_default_scaling_matrix_mask has one bit for each	 * UseDefaultScalingMatrix4x4Flag[ i ] and
	 * UseDefaultScalingMatrix8x8Flag[ i - 6 ] for SPS OR PPS
	 * bit 0 - 5 are for each entry of ScalingList4x4
	 * bit 6 - 11 are for each entry plus 6 for ScalingList8x8
	 */
	public uint16 use_default_scaling_matrix_mask;
	public uint8[STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS][STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS] ScalingList4x4;
	public uint8[STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS][STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS] ScalingList8x8;

	public this(uint16 scaling_list_present_mask, uint16 use_default_scaling_matrix_mask, uint8[STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS][STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS] ScalingList4x4, uint8[STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS][STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS] ScalingList8x8)
	{
		this.scaling_list_present_mask = scaling_list_present_mask;
		this.use_default_scaling_matrix_mask = use_default_scaling_matrix_mask;
		this.ScalingList4x4 = ScalingList4x4;
		this.ScalingList8x8 = ScalingList8x8;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH264SequenceParameterSet
{
	public StdVideoH264SpsFlags flags;
	public StdVideoH264ProfileIdc profile_idc;
	public StdVideoH264LevelIdc level_idc;
	public StdVideoH264ChromaFormatIdc chroma_format_idc;
	public uint8 seq_parameter_set_id;
	public uint8 bit_depth_luma_minus8;
	public uint8 bit_depth_chroma_minus8;
	public uint8 log2_max_frame_num_minus4;
	public StdVideoH264PocType pic_order_cnt_type;
	public int32 offset_for_non_ref_pic;
	public int32 offset_for_top_to_bottom_field;
	public uint8 log2_max_pic_order_cnt_lsb_minus4;
	public uint8 num_ref_frames_in_pic_order_cnt_cycle;
	public uint8 max_num_ref_frames;
	public uint8 reserved1; // Reserved for future use and must be initialized with 0.
	public uint32 pic_width_in_mbs_minus1;
	public uint32 pic_height_in_map_units_minus1;
	public uint32 frame_crop_left_offset;
	public uint32 frame_crop_right_offset;
	public uint32 frame_crop_top_offset;
	public uint32 frame_crop_bottom_offset;
	public uint32 reserved2; // Reserved for future use and must be initialized with 0.
	/* pOffsetForRefFrame is a pointer representing the offset_for_ref_frame array with num_ref_frames_in_pic_order_cnt_cycle number of elements.	 * If pOffsetForRefFrame has nullptr value, then num_ref_frames_in_pic_order_cnt_cycle must also be "0".
	 */
	public int32* pOffsetForRefFrame;
	public StdVideoH264ScalingLists* pScalingLists; // Must be a valid pointer if seq_scaling_matrix_present_flag is set
	public StdVideoH264SequenceParameterSetVui* pSequenceParameterSetVui; // Must be a valid pointer if StdVideoH264SpsFlags:vui_parameters_present_flag is set

	public this(StdVideoH264SpsFlags flags, StdVideoH264ProfileIdc profile_idc, StdVideoH264LevelIdc level_idc, StdVideoH264ChromaFormatIdc chroma_format_idc, uint8 seq_parameter_set_id, uint8 bit_depth_luma_minus8, uint8 bit_depth_chroma_minus8, uint8 log2_max_frame_num_minus4, StdVideoH264PocType pic_order_cnt_type, int32 offset_for_non_ref_pic, int32 offset_for_top_to_bottom_field, uint8 log2_max_pic_order_cnt_lsb_minus4, uint8 num_ref_frames_in_pic_order_cnt_cycle, uint8 max_num_ref_frames, uint8 reserved1, uint32 pic_width_in_mbs_minus1, uint32 pic_height_in_map_units_minus1, uint32 frame_crop_left_offset, uint32 frame_crop_right_offset, uint32 frame_crop_top_offset, uint32 frame_crop_bottom_offset, uint32 reserved2, int32* pOffsetForRefFrame, StdVideoH264ScalingLists* pScalingLists, StdVideoH264SequenceParameterSetVui* pSequenceParameterSetVui)
	{
		this.flags = flags;
		this.profile_idc = profile_idc;
		this.level_idc = level_idc;
		this.chroma_format_idc = chroma_format_idc;
		this.seq_parameter_set_id = seq_parameter_set_id;
		this.bit_depth_luma_minus8 = bit_depth_luma_minus8;
		this.bit_depth_chroma_minus8 = bit_depth_chroma_minus8;
		this.log2_max_frame_num_minus4 = log2_max_frame_num_minus4;
		this.pic_order_cnt_type = pic_order_cnt_type;
		this.offset_for_non_ref_pic = offset_for_non_ref_pic;
		this.offset_for_top_to_bottom_field = offset_for_top_to_bottom_field;
		this.log2_max_pic_order_cnt_lsb_minus4 = log2_max_pic_order_cnt_lsb_minus4;
		this.num_ref_frames_in_pic_order_cnt_cycle = num_ref_frames_in_pic_order_cnt_cycle;
		this.max_num_ref_frames = max_num_ref_frames;
		this.reserved1 = reserved1;
		this.pic_width_in_mbs_minus1 = pic_width_in_mbs_minus1;
		this.pic_height_in_map_units_minus1 = pic_height_in_map_units_minus1;
		this.frame_crop_left_offset = frame_crop_left_offset;
		this.frame_crop_right_offset = frame_crop_right_offset;
		this.frame_crop_top_offset = frame_crop_top_offset;
		this.frame_crop_bottom_offset = frame_crop_bottom_offset;
		this.reserved2 = reserved2;
		this.pOffsetForRefFrame = pOffsetForRefFrame;
		this.pScalingLists = pScalingLists;
		this.pSequenceParameterSetVui = pSequenceParameterSetVui;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH264PpsFlags
{
	[Bitfield(.Public, .Bits(1), "transform_8x8_mode_flag")]
	[Bitfield(.Public, .Bits(1), "redundant_pic_cnt_present_flag")]
	[Bitfield(.Public, .Bits(1), "constrained_intra_pred_flag")]
	[Bitfield(.Public, .Bits(1), "deblocking_filter_control_present_flag")]
	[Bitfield(.Public, .Bits(1), "weighted_pred_flag")]
	[Bitfield(.Public, .Bits(1), "bottom_field_pic_order_in_frame_present_flag")]
	[Bitfield(.Public, .Bits(1), "entropy_coding_mode_flag")]
	[Bitfield(.Public, .Bits(1), "pic_scaling_matrix_present_flag")]
	private uint32 __bitfields;

	public this(uint32 transform_8x8_mode_flag, uint32 redundant_pic_cnt_present_flag, uint32 constrained_intra_pred_flag, uint32 deblocking_filter_control_present_flag, uint32 weighted_pred_flag, uint32 bottom_field_pic_order_in_frame_present_flag, uint32 entropy_coding_mode_flag, uint32 pic_scaling_matrix_present_flag) : this()
	{
		this.transform_8x8_mode_flag = transform_8x8_mode_flag;
		this.redundant_pic_cnt_present_flag = redundant_pic_cnt_present_flag;
		this.constrained_intra_pred_flag = constrained_intra_pred_flag;
		this.deblocking_filter_control_present_flag = deblocking_filter_control_present_flag;
		this.weighted_pred_flag = weighted_pred_flag;
		this.bottom_field_pic_order_in_frame_present_flag = bottom_field_pic_order_in_frame_present_flag;
		this.entropy_coding_mode_flag = entropy_coding_mode_flag;
		this.pic_scaling_matrix_present_flag = pic_scaling_matrix_present_flag;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH264PictureParameterSet
{
	public StdVideoH264PpsFlags flags;
	public uint8 seq_parameter_set_id;
	public uint8 pic_parameter_set_id;
	public uint8 num_ref_idx_l0_default_active_minus1;
	public uint8 num_ref_idx_l1_default_active_minus1;
	public StdVideoH264WeightedBipredIdc weighted_bipred_idc;
	public int8 pic_init_qp_minus26;
	public int8 pic_init_qs_minus26;
	public int8 chroma_qp_index_offset;
	public int8 second_chroma_qp_index_offset;
	public StdVideoH264ScalingLists* pScalingLists; // Must be a valid pointer if StdVideoH264PpsFlags::pic_scaling_matrix_present_flag is set.

	public this(StdVideoH264PpsFlags flags, uint8 seq_parameter_set_id, uint8 pic_parameter_set_id, uint8 num_ref_idx_l0_default_active_minus1, uint8 num_ref_idx_l1_default_active_minus1, StdVideoH264WeightedBipredIdc weighted_bipred_idc, int8 pic_init_qp_minus26, int8 pic_init_qs_minus26, int8 chroma_qp_index_offset, int8 second_chroma_qp_index_offset, StdVideoH264ScalingLists* pScalingLists)
	{
		this.flags = flags;
		this.seq_parameter_set_id = seq_parameter_set_id;
		this.pic_parameter_set_id = pic_parameter_set_id;
		this.num_ref_idx_l0_default_active_minus1 = num_ref_idx_l0_default_active_minus1;
		this.num_ref_idx_l1_default_active_minus1 = num_ref_idx_l1_default_active_minus1;
		this.weighted_bipred_idc = weighted_bipred_idc;
		this.pic_init_qp_minus26 = pic_init_qp_minus26;
		this.pic_init_qs_minus26 = pic_init_qs_minus26;
		this.chroma_qp_index_offset = chroma_qp_index_offset;
		this.second_chroma_qp_index_offset = second_chroma_qp_index_offset;
		this.pScalingLists = pScalingLists;
	}

	public this()
	{
		this = default;
	}
}

static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0 = VK_MAKE_VIDEO_STD_VERSION(1, 0, 0); }
static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_SPEC_VERSION = VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0; }
static { public const c_char* VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h264_decode"; }
static { public const uint32 STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE = 2; }

[AllowDuplicates] enum StdVideoDecodeH264FieldOrderCount : int32
{
	Top = 0,
	Bottom = 1,
	Invalid = 0x7FFFFFFF,
}

[CRepr] struct StdVideoDecodeH264PictureInfoFlags
{
	[Bitfield(.Public, .Bits(1), "field_pic_flag")] // Is field picture
	[Bitfield(.Public, .Bits(1), "is_intra")] // Is intra picture
	[Bitfield(.Public, .Bits(1), "IdrPicFlag")] // instantaneous decoding refresh (IDR) picture
	[Bitfield(.Public, .Bits(1), "bottom_field_flag")] // bottom (true) or top (false) field if field_pic_flag is set.
	[Bitfield(.Public, .Bits(1), "is_reference")] // This only applies to picture info, and not to the DPB lists.
	[Bitfield(.Public, .Bits(1), "complementary_field_pair")] // complementary field pair, complementary non-reference field pair, complementary reference field pair
	private uint32 __bitfields;

	public this(uint32 field_pic_flag, uint32 is_intra, uint32 IdrPicFlag, uint32 bottom_field_flag, uint32 is_reference, uint32 complementary_field_pair) : this()
	{
		this.field_pic_flag = field_pic_flag;
		this.is_intra = is_intra;
		this.IdrPicFlag = IdrPicFlag;
		this.bottom_field_flag = bottom_field_flag;
		this.is_reference = is_reference;
		this.complementary_field_pair = complementary_field_pair;
	}

	public this()
	{
		this = default;
	}
}

// requires tag is for PicOrderCnt, which needs the enum type
[CRepr] struct StdVideoDecodeH264PictureInfo
{
	public StdVideoDecodeH264PictureInfoFlags flags;
	public uint8 seq_parameter_set_id; // Selecting SPS id from the Sequence Parameters Set
	public uint8 pic_parameter_set_id; // Selecting PPS id from the Picture Parameters Set
	public uint8 reserved1; // Reserved for future use and must be initialized with 0.
	public uint8 reserved2; // Reserved for future use and must be initialized with 0.
	public uint16 frame_num; // 7.4.3 Slice header semantics
	public uint16 idr_pic_id; // 7.4.3 Slice header semantics
	// PicOrderCnt is based on TopFieldOrderCnt and BottomFieldOrderCnt. See 8.2.1 Decoding process for picture order count type 0 - 2
	public int32[STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE] PicOrderCnt; // TopFieldOrderCnt and BottomFieldOrderCnt fields.

	public this(StdVideoDecodeH264PictureInfoFlags flags, uint8 seq_parameter_set_id, uint8 pic_parameter_set_id, uint8 reserved1, uint8 reserved2, uint16 frame_num, uint16 idr_pic_id, int32[STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE] PicOrderCnt)
	{
		this.flags = flags;
		this.seq_parameter_set_id = seq_parameter_set_id;
		this.pic_parameter_set_id = pic_parameter_set_id;
		this.reserved1 = reserved1;
		this.reserved2 = reserved2;
		this.frame_num = frame_num;
		this.idr_pic_id = idr_pic_id;
		this.PicOrderCnt = PicOrderCnt;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoDecodeH264ReferenceInfoFlags
{
	[Bitfield(.Public, .Bits(1), "top_field_flag")] // Reference is used for top field reference.
	[Bitfield(.Public, .Bits(1), "bottom_field_flag")] // Reference is used for bottom field reference.
	[Bitfield(.Public, .Bits(1), "used_for_long_term_reference")] // A picture that is marked as "used for long-term reference", derived binary value from clause 8.2.5.1 Sequence of operations for decoded reference picture marking process
	[Bitfield(.Public, .Bits(1), "is_non_existing")] // Must be handled in accordance with 8.2.5.2: Decoding process for gaps in frame_num
	private uint32 __bitfields;

	public this(uint32 top_field_flag, uint32 bottom_field_flag, uint32 used_for_long_term_reference, uint32 is_non_existing) : this()
	{
		this.top_field_flag = top_field_flag;
		this.bottom_field_flag = bottom_field_flag;
		this.used_for_long_term_reference = used_for_long_term_reference;
		this.is_non_existing = is_non_existing;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoDecodeH264ReferenceInfo
{
	public StdVideoDecodeH264ReferenceInfoFlags flags;
	// FrameNum = used_for_long_term_reference ?  long_term_frame_idx : frame_num
	public uint16 FrameNum; // 7.4.3.3 Decoded reference picture marking semantics
	public uint16 reserved; // for structure members 32-bit packing/alignment
	public int32[STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE] PicOrderCnt; // TopFieldOrderCnt and BottomFieldOrderCnt fields.

	public this(StdVideoDecodeH264ReferenceInfoFlags flags, uint16 FrameNum, uint16 reserved, int32[STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE] PicOrderCnt)
	{
		this.flags = flags;
		this.FrameNum = FrameNum;
		this.reserved = reserved;
		this.PicOrderCnt = PicOrderCnt;
	}

	public this()
	{
		this = default;
	}
}

static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0 = VK_MAKE_VIDEO_STD_VERSION(1, 0, 0); }
static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_SPEC_VERSION = VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0; }
static { public const c_char* VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h264_encode"; }

[CRepr] struct StdVideoEncodeH264WeightTableFlags
{
	public uint32 luma_weight_l0_flag; // each bit n represents the nth entry in reference list l0, n <= num_ref_idx_l0_active_minus1
	public uint32 chroma_weight_l0_flag; // each bit n represents the nth entry in reference list l0, n <= num_ref_idx_l0_active_minus1
	public uint32 luma_weight_l1_flag; // each bit n represents the nth entry in reference list l1, n <= num_ref_idx_l1_active_minus1
	public uint32 chroma_weight_l1_flag; // each bit n represents the nth entry in reference list l1, n <= num_ref_idx_l1_active_minus1

	public this(uint32 luma_weight_l0_flag, uint32 chroma_weight_l0_flag, uint32 luma_weight_l1_flag, uint32 chroma_weight_l1_flag)
	{
		this.luma_weight_l0_flag = luma_weight_l0_flag;
		this.chroma_weight_l0_flag = chroma_weight_l0_flag;
		this.luma_weight_l1_flag = luma_weight_l1_flag;
		this.chroma_weight_l1_flag = chroma_weight_l1_flag;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH264WeightTable
{
	/* StdVideoEncodeH264WeightTable corresponds to the values produced by pred_weight_table() for the h.264 specification.	 * For details, refer to weighted_pred_flag, weighted_bipred_idc, pre_pred_weight_table_src and pred_weight_table().
	 */
	public StdVideoEncodeH264WeightTableFlags flags;
	public uint8 luma_log2_weight_denom;
	public uint8 chroma_log2_weight_denom;
	public int8[STD_VIDEO_H264_MAX_NUM_LIST_REF] luma_weight_l0; // valid entry range is [0, num_ref_idx_l0_active_minus1]
	public int8[STD_VIDEO_H264_MAX_NUM_LIST_REF] luma_offset_l0; // valid entry range is [0, num_ref_idx_l0_active_minus1]
	public int8[STD_VIDEO_H264_MAX_NUM_LIST_REF][STD_VIDEO_H264_MAX_CHROMA_PLANES] chroma_weight_l0; // [i][j]: valid entry range for i is [0, num_ref_idx_l0_active_minus1]; j = 0 for Cb, j = 1 for Cr
	public int8[STD_VIDEO_H264_MAX_NUM_LIST_REF][STD_VIDEO_H264_MAX_CHROMA_PLANES] chroma_offset_l0; // [i][j]: valid entry range for i is [0, num_ref_idx_l0_active_minus1]; j = 0 for Cb, j = 1 for Cr
	public int8[STD_VIDEO_H264_MAX_NUM_LIST_REF] luma_weight_l1; // valid entry range is [0, num_ref_idx_l1_active_minus1]
	public int8[STD_VIDEO_H264_MAX_NUM_LIST_REF] luma_offset_l1; // valid entry range is [0, num_ref_idx_l1_active_minus1]
	public int8[STD_VIDEO_H264_MAX_NUM_LIST_REF][STD_VIDEO_H264_MAX_CHROMA_PLANES] chroma_weight_l1; // [i][j]: valid entry range for i is [0, num_ref_idx_l1_active_minus1]; j = 0 for Cb, j = 1 for Cr
	public int8[STD_VIDEO_H264_MAX_NUM_LIST_REF][STD_VIDEO_H264_MAX_CHROMA_PLANES] chroma_offset_l1; // [i][j]: valid entry range for i is [0, num_ref_idx_l1_active_minus1]; j = 0 for Cb, j = 1 for Cr

	public this(StdVideoEncodeH264WeightTableFlags flags, uint8 luma_log2_weight_denom, uint8 chroma_log2_weight_denom, int8[STD_VIDEO_H264_MAX_NUM_LIST_REF] luma_weight_l0, int8[STD_VIDEO_H264_MAX_NUM_LIST_REF] luma_offset_l0, int8[STD_VIDEO_H264_MAX_NUM_LIST_REF][STD_VIDEO_H264_MAX_CHROMA_PLANES] chroma_weight_l0, int8[STD_VIDEO_H264_MAX_NUM_LIST_REF][STD_VIDEO_H264_MAX_CHROMA_PLANES] chroma_offset_l0, int8[STD_VIDEO_H264_MAX_NUM_LIST_REF] luma_weight_l1, int8[STD_VIDEO_H264_MAX_NUM_LIST_REF] luma_offset_l1, int8[STD_VIDEO_H264_MAX_NUM_LIST_REF][STD_VIDEO_H264_MAX_CHROMA_PLANES] chroma_weight_l1, int8[STD_VIDEO_H264_MAX_NUM_LIST_REF][STD_VIDEO_H264_MAX_CHROMA_PLANES] chroma_offset_l1)
	{
		this.flags = flags;
		this.luma_log2_weight_denom = luma_log2_weight_denom;
		this.chroma_log2_weight_denom = chroma_log2_weight_denom;
		this.luma_weight_l0 = luma_weight_l0;
		this.luma_offset_l0 = luma_offset_l0;
		this.chroma_weight_l0 = chroma_weight_l0;
		this.chroma_offset_l0 = chroma_offset_l0;
		this.luma_weight_l1 = luma_weight_l1;
		this.luma_offset_l1 = luma_offset_l1;
		this.chroma_weight_l1 = chroma_weight_l1;
		this.chroma_offset_l1 = chroma_offset_l1;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH264SliceHeaderFlags
{
	[Bitfield(.Public, .Bits(1), "direct_spatial_mv_pred_flag")]
	[Bitfield(.Public, .Bits(1), "num_ref_idx_active_override_flag")]
	[Bitfield(.Public, .Bits(30), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 direct_spatial_mv_pred_flag, uint32 num_ref_idx_active_override_flag, uint32 reserved) : this()
	{
		this.direct_spatial_mv_pred_flag = direct_spatial_mv_pred_flag;
		this.num_ref_idx_active_override_flag = num_ref_idx_active_override_flag;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH264PictureInfoFlags
{
	[Bitfield(.Public, .Bits(1), "IdrPicFlag")]
	[Bitfield(.Public, .Bits(1), "is_reference")] // A reference picture, i.e. a picture with nal_ref_idc not equal to 0, as defined in clause 3.136
	[Bitfield(.Public, .Bits(1), "no_output_of_prior_pics_flag")]
	[Bitfield(.Public, .Bits(1), "long_term_reference_flag")]
	[Bitfield(.Public, .Bits(1), "adaptive_ref_pic_marking_mode_flag")]
	[Bitfield(.Public, .Bits(27), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 IdrPicFlag, uint32 is_reference, uint32 no_output_of_prior_pics_flag, uint32 long_term_reference_flag, uint32 adaptive_ref_pic_marking_mode_flag, uint32 reserved) : this()
	{
		this.IdrPicFlag = IdrPicFlag;
		this.is_reference = is_reference;
		this.no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;
		this.long_term_reference_flag = long_term_reference_flag;
		this.adaptive_ref_pic_marking_mode_flag = adaptive_ref_pic_marking_mode_flag;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH264ReferenceInfoFlags
{
	[Bitfield(.Public, .Bits(1), "used_for_long_term_reference")] // A picture that is marked as "used for long-term reference", derived binary value from clause 8.2.5.1 Sequence of operations for decoded reference picture marking process
	[Bitfield(.Public, .Bits(31), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 used_for_long_term_reference, uint32 reserved) : this()
	{
		this.used_for_long_term_reference = used_for_long_term_reference;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH264ReferenceListsInfoFlags
{
	[Bitfield(.Public, .Bits(1), "ref_pic_list_modification_flag_l0")]
	[Bitfield(.Public, .Bits(1), "ref_pic_list_modification_flag_l1")]
	[Bitfield(.Public, .Bits(30), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 ref_pic_list_modification_flag_l0, uint32 ref_pic_list_modification_flag_l1, uint32 reserved) : this()
	{
		this.ref_pic_list_modification_flag_l0 = ref_pic_list_modification_flag_l0;
		this.ref_pic_list_modification_flag_l1 = ref_pic_list_modification_flag_l1;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH264RefListModEntry
{
	public StdVideoH264ModificationOfPicNumsIdc modification_of_pic_nums_idc;
	public uint16 abs_diff_pic_num_minus1;
	public uint16 long_term_pic_num;

	public this(StdVideoH264ModificationOfPicNumsIdc modification_of_pic_nums_idc, uint16 abs_diff_pic_num_minus1, uint16 long_term_pic_num)
	{
		this.modification_of_pic_nums_idc = modification_of_pic_nums_idc;
		this.abs_diff_pic_num_minus1 = abs_diff_pic_num_minus1;
		this.long_term_pic_num = long_term_pic_num;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH264RefPicMarkingEntry
{
	public StdVideoH264MemMgmtControlOp memory_management_control_operation;
	public uint16 difference_of_pic_nums_minus1;
	public uint16 long_term_pic_num;
	public uint16 long_term_frame_idx;
	public uint16 max_long_term_frame_idx_plus1;

	public this(StdVideoH264MemMgmtControlOp memory_management_control_operation, uint16 difference_of_pic_nums_minus1, uint16 long_term_pic_num, uint16 long_term_frame_idx, uint16 max_long_term_frame_idx_plus1)
	{
		this.memory_management_control_operation = memory_management_control_operation;
		this.difference_of_pic_nums_minus1 = difference_of_pic_nums_minus1;
		this.long_term_pic_num = long_term_pic_num;
		this.long_term_frame_idx = long_term_frame_idx;
		this.max_long_term_frame_idx_plus1 = max_long_term_frame_idx_plus1;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH264ReferenceListsInfo
{
	public StdVideoEncodeH264ReferenceListsInfoFlags flags;
	public uint8 num_ref_idx_l0_active_minus1;
	public uint8 num_ref_idx_l1_active_minus1;
	public uint8[STD_VIDEO_H264_MAX_NUM_LIST_REF] RefPicList0; // slotIndex as used in VkVideoReferenceSlotInfoKHR structures or STD_VIDEO_H264_NO_REFERENCE_PICTURE
	public uint8[STD_VIDEO_H264_MAX_NUM_LIST_REF] RefPicList1; // slotIndex as used in VkVideoReferenceSlotInfoKHR structures or STD_VIDEO_H264_NO_REFERENCE_PICTURE
	public uint8 refList0ModOpCount;
	public uint8 refList1ModOpCount;
	public uint8 refPicMarkingOpCount;
	public uint8[7] reserved1; // Reserved for future use and must be initialized with 0.
	public StdVideoEncodeH264RefListModEntry* pRefList0ModOperations; // Must be a valid pointer to an array with size refList0ModOpCount if ref_pic_list_modification_flag_l0 is set and contains the RefList0 modification parameters as defined in section 7.4.3.1
	public StdVideoEncodeH264RefListModEntry* pRefList1ModOperations; // Must be a valid pointer to an array with size refList1ModOpCount if ref_pic_list_modification_flag_l1 is set and contains the RefList1 modification parameters as defined in section 7.4.3.1
	public StdVideoEncodeH264RefPicMarkingEntry* pRefPicMarkingOperations; // Must be a valid pointer to an array with size refPicMarkingOpCount and contains the reference picture markings as defined in section 7.4.3.3

	public this(StdVideoEncodeH264ReferenceListsInfoFlags flags, uint8 num_ref_idx_l0_active_minus1, uint8 num_ref_idx_l1_active_minus1, uint8[STD_VIDEO_H264_MAX_NUM_LIST_REF] RefPicList0, uint8[STD_VIDEO_H264_MAX_NUM_LIST_REF] RefPicList1, uint8 refList0ModOpCount, uint8 refList1ModOpCount, uint8 refPicMarkingOpCount, uint8[7] reserved1, StdVideoEncodeH264RefListModEntry* pRefList0ModOperations, StdVideoEncodeH264RefListModEntry* pRefList1ModOperations, StdVideoEncodeH264RefPicMarkingEntry* pRefPicMarkingOperations)
	{
		this.flags = flags;
		this.num_ref_idx_l0_active_minus1 = num_ref_idx_l0_active_minus1;
		this.num_ref_idx_l1_active_minus1 = num_ref_idx_l1_active_minus1;
		this.RefPicList0 = RefPicList0;
		this.RefPicList1 = RefPicList1;
		this.refList0ModOpCount = refList0ModOpCount;
		this.refList1ModOpCount = refList1ModOpCount;
		this.refPicMarkingOpCount = refPicMarkingOpCount;
		this.reserved1 = reserved1;
		this.pRefList0ModOperations = pRefList0ModOperations;
		this.pRefList1ModOperations = pRefList1ModOperations;
		this.pRefPicMarkingOperations = pRefPicMarkingOperations;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH264PictureInfo
{
	public StdVideoEncodeH264PictureInfoFlags flags;
	public uint8 seq_parameter_set_id; // Selecting SPS id from the Sequence Parameters Set
	public uint8 pic_parameter_set_id; // Selecting PPS from the Picture Parameters for all StdVideoEncodeH264SliceHeader(s)
	public uint16 idr_pic_id;
	public StdVideoH264PictureType primary_pic_type;
	public uint32 frame_num;
	public int32 PicOrderCnt; // Picture order count, as defined in 8.2
	public uint8 temporal_id; // Temporal identifier of the picture, as defined in G.7.3.1.1 / G.7.4.1.1
	public uint8[3] reserved1; // Reserved for future use and must be initialized with 0.
	public StdVideoEncodeH264ReferenceListsInfo* pRefLists;

	public this(StdVideoEncodeH264PictureInfoFlags flags, uint8 seq_parameter_set_id, uint8 pic_parameter_set_id, uint16 idr_pic_id, StdVideoH264PictureType primary_pic_type, uint32 frame_num, int32 PicOrderCnt, uint8 temporal_id, uint8[3] reserved1, StdVideoEncodeH264ReferenceListsInfo* pRefLists)
	{
		this.flags = flags;
		this.seq_parameter_set_id = seq_parameter_set_id;
		this.pic_parameter_set_id = pic_parameter_set_id;
		this.idr_pic_id = idr_pic_id;
		this.primary_pic_type = primary_pic_type;
		this.frame_num = frame_num;
		this.PicOrderCnt = PicOrderCnt;
		this.temporal_id = temporal_id;
		this.reserved1 = reserved1;
		this.pRefLists = pRefLists;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH264ReferenceInfo
{
	public StdVideoEncodeH264ReferenceInfoFlags flags;
	public StdVideoH264PictureType primary_pic_type;
	public uint32 FrameNum; // Frame number, as defined in 8.2
	public int32 PicOrderCnt; // Picture order count, as defined in 8.2
	public uint16 long_term_pic_num;
	public uint16 long_term_frame_idx;
	public uint8 temporal_id; // Temporal identifier of the picture, as defined in G.7.3.1.1 / G.7.4.1.1

	public this(StdVideoEncodeH264ReferenceInfoFlags flags, StdVideoH264PictureType primary_pic_type, uint32 FrameNum, int32 PicOrderCnt, uint16 long_term_pic_num, uint16 long_term_frame_idx, uint8 temporal_id)
	{
		this.flags = flags;
		this.primary_pic_type = primary_pic_type;
		this.FrameNum = FrameNum;
		this.PicOrderCnt = PicOrderCnt;
		this.long_term_pic_num = long_term_pic_num;
		this.long_term_frame_idx = long_term_frame_idx;
		this.temporal_id = temporal_id;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH264SliceHeader
{
	public StdVideoEncodeH264SliceHeaderFlags flags;
	public uint32 first_mb_in_slice;
	public StdVideoH264SliceType slice_type;
	public int8 slice_alpha_c0_offset_div2;
	public int8 slice_beta_offset_div2;
	public int8 slice_qp_delta;
	public uint8 reserved1; // Reserved for future use and must be initialized with 0.
	public StdVideoH264CabacInitIdc cabac_init_idc;
	public StdVideoH264DisableDeblockingFilterIdc disable_deblocking_filter_idc;
	public StdVideoEncodeH264WeightTable* pWeightTable;

	public this(StdVideoEncodeH264SliceHeaderFlags flags, uint32 first_mb_in_slice, StdVideoH264SliceType slice_type, int8 slice_alpha_c0_offset_div2, int8 slice_beta_offset_div2, int8 slice_qp_delta, uint8 reserved1, StdVideoH264CabacInitIdc cabac_init_idc, StdVideoH264DisableDeblockingFilterIdc disable_deblocking_filter_idc, StdVideoEncodeH264WeightTable* pWeightTable)
	{
		this.flags = flags;
		this.first_mb_in_slice = first_mb_in_slice;
		this.slice_type = slice_type;
		this.slice_alpha_c0_offset_div2 = slice_alpha_c0_offset_div2;
		this.slice_beta_offset_div2 = slice_beta_offset_div2;
		this.slice_qp_delta = slice_qp_delta;
		this.reserved1 = reserved1;
		this.cabac_init_idc = cabac_init_idc;
		this.disable_deblocking_filter_idc = disable_deblocking_filter_idc;
		this.pWeightTable = pWeightTable;
	}

	public this()
	{
		this = default;
	}
}

static { public const uint32 STD_VIDEO_H265_CPB_CNT_LIST_SIZE = 32; }
static { public const uint32 STD_VIDEO_H265_SUBLAYERS_LIST_SIZE = 7; }
static { public const uint32 STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS = 6; }
static { public const uint32 STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS = 16; }
static { public const uint32 STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS = 6; }
static { public const uint32 STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS = 64; }
static { public const uint32 STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS = 6; }
static { public const uint32 STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS = 64; }
static { public const uint32 STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS = 2; }
static { public const uint32 STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS = 64; }
static { public const uint32 STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE = 6; }
static { public const uint32 STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE = 19; }
static { public const uint32 STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE = 21; }
static { public const uint32 STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE = 3; }
static { public const uint32 STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE = 128; }
static { public const uint32 STD_VIDEO_H265_MAX_NUM_LIST_REF = 15; }
static { public const uint32 STD_VIDEO_H265_MAX_CHROMA_PLANES = 2; }
static { public const uint32 STD_VIDEO_H265_MAX_SHORT_TERM_REF_PIC_SETS = 64; }
static { public const uint32 STD_VIDEO_H265_MAX_DPB_SIZE = 16; }
static { public const uint32 STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS = 32; }
static { public const uint32 STD_VIDEO_H265_MAX_LONG_TERM_PICS = 16; }
static { public const uint32 STD_VIDEO_H265_MAX_DELTA_POC = 48; }
static { public const uint32 STD_VIDEO_H265_NO_REFERENCE_PICTURE = 0xFF; }

[AllowDuplicates] enum StdVideoH265ChromaFormatIdc : int32
{
	Monochrome = 0,
	VK_420 = 1,
	VK_422 = 2,
	VK_444 = 3,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH265ProfileIdc : int32
{
	Main = 1,
	Main10 = 2,
	MainStillPicture = 3,
	FormatRangeExtensions = 4,
	SccExtensions = 9,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH265LevelIdc : int32
{
	VK_10 = 0,
	VK_20 = 1,
	VK_21 = 2,
	VK_30 = 3,
	VK_31 = 4,
	VK_40 = 5,
	VK_41 = 6,
	VK_50 = 7,
	VK_51 = 8,
	VK_52 = 9,
	VK_60 = 10,
	VK_61 = 11,
	VK_62 = 12,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH265SliceType : int32
{
	B = 0,
	P = 1,
	I = 2,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH265PictureType : int32
{
	P = 0,
	B = 1,
	I = 2,
	Idr = 3,
	Invalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoH265AspectRatioIdc : int32
{
	Unspecified = 0,
	Square = 1,
	VK_1211 = 2,
	VK_1011 = 3,
	VK_1611 = 4,
	VK_4033 = 5,
	VK_2411 = 6,
	VK_2011 = 7,
	VK_3211 = 8,
	VK_8033 = 9,
	VK_1811 = 10,
	VK_1511 = 11,
	VK_6433 = 12,
	VK_16099 = 13,
	VK_43 = 14,
	VK_32 = 15,
	VK_21 = 16,
	ExtendedSar = 255,
	Invalid = 0x7FFFFFFF,
}

// sps_ or vps_ parameters, based on if the StdVideoH265DecPicBufMgr is used within the StdVideoH265SequenceParameterSet or StdVideoH265VideoParameterSet
[CRepr] struct StdVideoH265DecPicBufMgr
{
	public uint32[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE] max_latency_increase_plus1; // represents sps_max_latency_increase_plus1 or vps_max_latency_increase_plus1
	public uint8[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE] max_dec_pic_buffering_minus1; // represents sps_max_dec_pic_buffering_minus1 or vps_max_dec_pic_buffering_minus1
	public uint8[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE] max_num_reorder_pics; // represents sps_max_num_reorder_pics or vps_max_num_reorder_pics

	public this(uint32[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE] max_latency_increase_plus1, uint8[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE] max_dec_pic_buffering_minus1, uint8[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE] max_num_reorder_pics)
	{
		this.max_latency_increase_plus1 = max_latency_increase_plus1;
		this.max_dec_pic_buffering_minus1 = max_dec_pic_buffering_minus1;
		this.max_num_reorder_pics = max_num_reorder_pics;
	}

	public this()
	{
		this = default;
	}
}

// sub_layer_hrd_parameters
[CRepr] struct StdVideoH265SubLayerHrdParameters
{
	public uint32[STD_VIDEO_H265_CPB_CNT_LIST_SIZE] bit_rate_value_minus1;
	public uint32[STD_VIDEO_H265_CPB_CNT_LIST_SIZE] cpb_size_value_minus1;
	public uint32[STD_VIDEO_H265_CPB_CNT_LIST_SIZE] cpb_size_du_value_minus1;
	public uint32[STD_VIDEO_H265_CPB_CNT_LIST_SIZE] bit_rate_du_value_minus1;
	public uint32 cbr_flag; // each bit represents a range of CpbCounts (bit 0 - cpb_cnt_minus1) per sub-layer

	public this(uint32[STD_VIDEO_H265_CPB_CNT_LIST_SIZE] bit_rate_value_minus1, uint32[STD_VIDEO_H265_CPB_CNT_LIST_SIZE] cpb_size_value_minus1, uint32[STD_VIDEO_H265_CPB_CNT_LIST_SIZE] cpb_size_du_value_minus1, uint32[STD_VIDEO_H265_CPB_CNT_LIST_SIZE] bit_rate_du_value_minus1, uint32 cbr_flag)
	{
		this.bit_rate_value_minus1 = bit_rate_value_minus1;
		this.cpb_size_value_minus1 = cpb_size_value_minus1;
		this.cpb_size_du_value_minus1 = cpb_size_du_value_minus1;
		this.bit_rate_du_value_minus1 = bit_rate_du_value_minus1;
		this.cbr_flag = cbr_flag;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265HrdFlags
{
	[Bitfield(.Public, .Bits(1), "nal_hrd_parameters_present_flag")]
	[Bitfield(.Public, .Bits(1), "vcl_hrd_parameters_present_flag")]
	[Bitfield(.Public, .Bits(1), "sub_pic_hrd_params_present_flag")]
	[Bitfield(.Public, .Bits(1), "sub_pic_cpb_params_in_pic_timing_sei_flag")]
	[Bitfield(.Public, .Bits(8), "fixed_pic_rate_general_flag")] // each bit represents a sublayer, bit 0 - vps_max_sub_layers_minus1
	[Bitfield(.Public, .Bits(8), "fixed_pic_rate_within_cvs_flag")] // each bit represents a sublayer, bit 0 - vps_max_sub_layers_minus1
	[Bitfield(.Public, .Bits(8), "low_delay_hrd_flag")] // each bit represents a sublayer, bit 0 - vps_max_sub_layers_minus1
	private uint32 __bitfields;

	public this(uint32 nal_hrd_parameters_present_flag, uint32 vcl_hrd_parameters_present_flag, uint32 sub_pic_hrd_params_present_flag, uint32 sub_pic_cpb_params_in_pic_timing_sei_flag, uint32 fixed_pic_rate_general_flag, uint32 fixed_pic_rate_within_cvs_flag, uint32 low_delay_hrd_flag) : this()
	{
		this.nal_hrd_parameters_present_flag = nal_hrd_parameters_present_flag;
		this.vcl_hrd_parameters_present_flag = vcl_hrd_parameters_present_flag;
		this.sub_pic_hrd_params_present_flag = sub_pic_hrd_params_present_flag;
		this.sub_pic_cpb_params_in_pic_timing_sei_flag = sub_pic_cpb_params_in_pic_timing_sei_flag;
		this.fixed_pic_rate_general_flag = fixed_pic_rate_general_flag;
		this.fixed_pic_rate_within_cvs_flag = fixed_pic_rate_within_cvs_flag;
		this.low_delay_hrd_flag = low_delay_hrd_flag;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265HrdParameters
{
	public StdVideoH265HrdFlags flags;
	public uint8 tick_divisor_minus2;
	public uint8 du_cpb_removal_delay_increment_length_minus1;
	public uint8 dpb_output_delay_du_length_minus1;
	public uint8 bit_rate_scale;
	public uint8 cpb_size_scale;
	public uint8 cpb_size_du_scale;
	public uint8 initial_cpb_removal_delay_length_minus1;
	public uint8 au_cpb_removal_delay_length_minus1;
	public uint8 dpb_output_delay_length_minus1;
	public uint8[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE] cpb_cnt_minus1;
	public uint16[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE] elemental_duration_in_tc_minus1;
	public uint16[3] reserved; // Reserved for future use and must be initialized with 0.
	public StdVideoH265SubLayerHrdParameters* pSubLayerHrdParametersNal; // if flags.nal_hrd_parameters_present_flag is set, then this must be a ptr to an array of StdVideoH265SubLayerHrdParameters with a size specified by sps_max_sub_layers_minus1 + 1 or vps_max_sub_layers_minus1 + 1, depending on whether the HRD parameters are part of the SPS or VPS, respectively.
	public StdVideoH265SubLayerHrdParameters* pSubLayerHrdParametersVcl; // if flags.vcl_hrd_parameters_present_flag is set, then this must be a ptr to an array of StdVideoH265SubLayerHrdParameters with a size specified by sps_max_sub_layers_minus1 + 1 or vps_max_sub_layers_minus1 + 1, depending on whether the HRD parameters are part of the SPS or VPS, respectively.

	public this(StdVideoH265HrdFlags flags, uint8 tick_divisor_minus2, uint8 du_cpb_removal_delay_increment_length_minus1, uint8 dpb_output_delay_du_length_minus1, uint8 bit_rate_scale, uint8 cpb_size_scale, uint8 cpb_size_du_scale, uint8 initial_cpb_removal_delay_length_minus1, uint8 au_cpb_removal_delay_length_minus1, uint8 dpb_output_delay_length_minus1, uint8[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE] cpb_cnt_minus1, uint16[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE] elemental_duration_in_tc_minus1, uint16[3] reserved, StdVideoH265SubLayerHrdParameters* pSubLayerHrdParametersNal, StdVideoH265SubLayerHrdParameters* pSubLayerHrdParametersVcl)
	{
		this.flags = flags;
		this.tick_divisor_minus2 = tick_divisor_minus2;
		this.du_cpb_removal_delay_increment_length_minus1 = du_cpb_removal_delay_increment_length_minus1;
		this.dpb_output_delay_du_length_minus1 = dpb_output_delay_du_length_minus1;
		this.bit_rate_scale = bit_rate_scale;
		this.cpb_size_scale = cpb_size_scale;
		this.cpb_size_du_scale = cpb_size_du_scale;
		this.initial_cpb_removal_delay_length_minus1 = initial_cpb_removal_delay_length_minus1;
		this.au_cpb_removal_delay_length_minus1 = au_cpb_removal_delay_length_minus1;
		this.dpb_output_delay_length_minus1 = dpb_output_delay_length_minus1;
		this.cpb_cnt_minus1 = cpb_cnt_minus1;
		this.elemental_duration_in_tc_minus1 = elemental_duration_in_tc_minus1;
		this.reserved = reserved;
		this.pSubLayerHrdParametersNal = pSubLayerHrdParametersNal;
		this.pSubLayerHrdParametersVcl = pSubLayerHrdParametersVcl;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265VpsFlags
{
	[Bitfield(.Public, .Bits(1), "vps_temporal_id_nesting_flag")]
	[Bitfield(.Public, .Bits(1), "vps_sub_layer_ordering_info_present_flag")]
	[Bitfield(.Public, .Bits(1), "vps_timing_info_present_flag")]
	[Bitfield(.Public, .Bits(1), "vps_poc_proportional_to_timing_flag")]
	private uint32 __bitfields;

	public this(uint32 vps_temporal_id_nesting_flag, uint32 vps_sub_layer_ordering_info_present_flag, uint32 vps_timing_info_present_flag, uint32 vps_poc_proportional_to_timing_flag) : this()
	{
		this.vps_temporal_id_nesting_flag = vps_temporal_id_nesting_flag;
		this.vps_sub_layer_ordering_info_present_flag = vps_sub_layer_ordering_info_present_flag;
		this.vps_timing_info_present_flag = vps_timing_info_present_flag;
		this.vps_poc_proportional_to_timing_flag = vps_poc_proportional_to_timing_flag;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265ProfileTierLevelFlags
{
	[Bitfield(.Public, .Bits(1), "general_tier_flag")]
	[Bitfield(.Public, .Bits(1), "general_progressive_source_flag")]
	[Bitfield(.Public, .Bits(1), "general_interlaced_source_flag")]
	[Bitfield(.Public, .Bits(1), "general_non_packed_constraint_flag")]
	[Bitfield(.Public, .Bits(1), "general_frame_only_constraint_flag")]
	private uint32 __bitfields;

	public this(uint32 general_tier_flag, uint32 general_progressive_source_flag, uint32 general_interlaced_source_flag, uint32 general_non_packed_constraint_flag, uint32 general_frame_only_constraint_flag) : this()
	{
		this.general_tier_flag = general_tier_flag;
		this.general_progressive_source_flag = general_progressive_source_flag;
		this.general_interlaced_source_flag = general_interlaced_source_flag;
		this.general_non_packed_constraint_flag = general_non_packed_constraint_flag;
		this.general_frame_only_constraint_flag = general_frame_only_constraint_flag;
	}

	public this()
	{
		this = default;
	}
}

// profile_tier_level
[CRepr] struct StdVideoH265ProfileTierLevel
{
	public StdVideoH265ProfileTierLevelFlags flags;
	public StdVideoH265ProfileIdc general_profile_idc;
	public StdVideoH265LevelIdc general_level_idc;

	public this(StdVideoH265ProfileTierLevelFlags flags, StdVideoH265ProfileIdc general_profile_idc, StdVideoH265LevelIdc general_level_idc)
	{
		this.flags = flags;
		this.general_profile_idc = general_profile_idc;
		this.general_level_idc = general_level_idc;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265VideoParameterSet
{
	public StdVideoH265VpsFlags flags;
	public uint8 vps_video_parameter_set_id;
	public uint8 vps_max_sub_layers_minus1;
	public uint8 reserved1; // Reserved for future use and must be initialized with 0.
	public uint8 reserved2; // Reserved for future use and must be initialized with 0.
	public uint32 vps_num_units_in_tick;
	public uint32 vps_time_scale;
	public uint32 vps_num_ticks_poc_diff_one_minus1;
	public uint32 reserved3; // Reserved for future use and must be initialized with 0.
	public StdVideoH265DecPicBufMgr* pDecPicBufMgr;
	public StdVideoH265HrdParameters* pHrdParameters;
	public StdVideoH265ProfileTierLevel* pProfileTierLevel;

	public this(StdVideoH265VpsFlags flags, uint8 vps_video_parameter_set_id, uint8 vps_max_sub_layers_minus1, uint8 reserved1, uint8 reserved2, uint32 vps_num_units_in_tick, uint32 vps_time_scale, uint32 vps_num_ticks_poc_diff_one_minus1, uint32 reserved3, StdVideoH265DecPicBufMgr* pDecPicBufMgr, StdVideoH265HrdParameters* pHrdParameters, StdVideoH265ProfileTierLevel* pProfileTierLevel)
	{
		this.flags = flags;
		this.vps_video_parameter_set_id = vps_video_parameter_set_id;
		this.vps_max_sub_layers_minus1 = vps_max_sub_layers_minus1;
		this.reserved1 = reserved1;
		this.reserved2 = reserved2;
		this.vps_num_units_in_tick = vps_num_units_in_tick;
		this.vps_time_scale = vps_time_scale;
		this.vps_num_ticks_poc_diff_one_minus1 = vps_num_ticks_poc_diff_one_minus1;
		this.reserved3 = reserved3;
		this.pDecPicBufMgr = pDecPicBufMgr;
		this.pHrdParameters = pHrdParameters;
		this.pProfileTierLevel = pProfileTierLevel;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265ScalingLists
{
	public uint8[STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS][STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS] ScalingList4x4; // ScalingList[ 0 ][ MatrixID ][ i ] (sizeID = 0)
	public uint8[STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS][STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS] ScalingList8x8; // ScalingList[ 1 ][ MatrixID ][ i ] (sizeID = 1)
	public uint8[STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS][STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS] ScalingList16x16; // ScalingList[ 2 ][ Matri]xID ][ i ] (sizeID = 2)
	public uint8[STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS][STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS] ScalingList32x32; // ScalingList[ 3 ][ MatrixID ][ i ] (sizeID = 3)
	public uint8[STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS] ScalingListDCCoef16x16; // scaling_list_dc_coef_minus8[ sizeID - 2 ][ matrixID ] + 8, sizeID = 2
	public uint8[STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS] ScalingListDCCoef32x32; // scaling_list_dc_coef_minus8[ sizeID - 2 ][ matrixID ] + 8. sizeID = 3

	public this(uint8[STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS][STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS] ScalingList4x4, uint8[STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS][STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS] ScalingList8x8, uint8[STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS][STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS] ScalingList16x16, uint8[STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS][STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS] ScalingList32x32, uint8[STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS] ScalingListDCCoef16x16, uint8[STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS] ScalingListDCCoef32x32)
	{
		this.ScalingList4x4 = ScalingList4x4;
		this.ScalingList8x8 = ScalingList8x8;
		this.ScalingList16x16 = ScalingList16x16;
		this.ScalingList32x32 = ScalingList32x32;
		this.ScalingListDCCoef16x16 = ScalingListDCCoef16x16;
		this.ScalingListDCCoef32x32 = ScalingListDCCoef32x32;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265SpsVuiFlags
{
	[Bitfield(.Public, .Bits(1), "aspect_ratio_info_present_flag")]
	[Bitfield(.Public, .Bits(1), "overscan_info_present_flag")]
	[Bitfield(.Public, .Bits(1), "overscan_appropriate_flag")]
	[Bitfield(.Public, .Bits(1), "video_signal_type_present_flag")]
	[Bitfield(.Public, .Bits(1), "video_full_range_flag")]
	[Bitfield(.Public, .Bits(1), "colour_description_present_flag")]
	[Bitfield(.Public, .Bits(1), "chroma_loc_info_present_flag")]
	[Bitfield(.Public, .Bits(1), "neutral_chroma_indication_flag")]
	[Bitfield(.Public, .Bits(1), "field_seq_flag")]
	[Bitfield(.Public, .Bits(1), "frame_field_info_present_flag")]
	[Bitfield(.Public, .Bits(1), "default_display_window_flag")]
	[Bitfield(.Public, .Bits(1), "vui_timing_info_present_flag")]
	[Bitfield(.Public, .Bits(1), "vui_poc_proportional_to_timing_flag")]
	[Bitfield(.Public, .Bits(1), "vui_hrd_parameters_present_flag")]
	[Bitfield(.Public, .Bits(1), "bitstream_restriction_flag")]
	[Bitfield(.Public, .Bits(1), "tiles_fixed_structure_flag")]
	[Bitfield(.Public, .Bits(1), "motion_vectors_over_pic_boundaries_flag")]
	[Bitfield(.Public, .Bits(1), "restricted_ref_pic_lists_flag")]
	private uint32 __bitfields;

	public this(uint32 aspect_ratio_info_present_flag, uint32 overscan_info_present_flag, uint32 overscan_appropriate_flag, uint32 video_signal_type_present_flag, uint32 video_full_range_flag, uint32 colour_description_present_flag, uint32 chroma_loc_info_present_flag, uint32 neutral_chroma_indication_flag, uint32 field_seq_flag, uint32 frame_field_info_present_flag, uint32 default_display_window_flag, uint32 vui_timing_info_present_flag, uint32 vui_poc_proportional_to_timing_flag, uint32 vui_hrd_parameters_present_flag, uint32 bitstream_restriction_flag, uint32 tiles_fixed_structure_flag, uint32 motion_vectors_over_pic_boundaries_flag, uint32 restricted_ref_pic_lists_flag) : this()
	{
		this.aspect_ratio_info_present_flag = aspect_ratio_info_present_flag;
		this.overscan_info_present_flag = overscan_info_present_flag;
		this.overscan_appropriate_flag = overscan_appropriate_flag;
		this.video_signal_type_present_flag = video_signal_type_present_flag;
		this.video_full_range_flag = video_full_range_flag;
		this.colour_description_present_flag = colour_description_present_flag;
		this.chroma_loc_info_present_flag = chroma_loc_info_present_flag;
		this.neutral_chroma_indication_flag = neutral_chroma_indication_flag;
		this.field_seq_flag = field_seq_flag;
		this.frame_field_info_present_flag = frame_field_info_present_flag;
		this.default_display_window_flag = default_display_window_flag;
		this.vui_timing_info_present_flag = vui_timing_info_present_flag;
		this.vui_poc_proportional_to_timing_flag = vui_poc_proportional_to_timing_flag;
		this.vui_hrd_parameters_present_flag = vui_hrd_parameters_present_flag;
		this.bitstream_restriction_flag = bitstream_restriction_flag;
		this.tiles_fixed_structure_flag = tiles_fixed_structure_flag;
		this.motion_vectors_over_pic_boundaries_flag = motion_vectors_over_pic_boundaries_flag;
		this.restricted_ref_pic_lists_flag = restricted_ref_pic_lists_flag;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265SequenceParameterSetVui
{
	public StdVideoH265SpsVuiFlags flags;
	public StdVideoH265AspectRatioIdc aspect_ratio_idc;
	public uint16 sar_width;
	public uint16 sar_height;
	public uint8 video_format;
	public uint8 colour_primaries;
	public uint8 transfer_characteristics;
	public uint8 matrix_coeffs;
	public uint8 chroma_sample_loc_type_top_field;
	public uint8 chroma_sample_loc_type_bottom_field;
	public uint8 reserved1; // Reserved for future use and must be initialized with 0.
	public uint8 reserved2; // Reserved for future use and must be initialized with 0.
	public uint16 def_disp_win_left_offset;
	public uint16 def_disp_win_right_offset;
	public uint16 def_disp_win_top_offset;
	public uint16 def_disp_win_bottom_offset;
	public uint32 vui_num_units_in_tick;
	public uint32 vui_time_scale;
	public uint32 vui_num_ticks_poc_diff_one_minus1;
	public uint16 min_spatial_segmentation_idc;
	public uint16 reserved3; // Reserved for future use and must be initialized with 0.
	public uint8 max_bytes_per_pic_denom;
	public uint8 max_bits_per_min_cu_denom;
	public uint8 log2_max_mv_length_horizontal;
	public uint8 log2_max_mv_length_vertical;
	public StdVideoH265HrdParameters* pHrdParameters;

	public this(StdVideoH265SpsVuiFlags flags, StdVideoH265AspectRatioIdc aspect_ratio_idc, uint16 sar_width, uint16 sar_height, uint8 video_format, uint8 colour_primaries, uint8 transfer_characteristics, uint8 matrix_coeffs, uint8 chroma_sample_loc_type_top_field, uint8 chroma_sample_loc_type_bottom_field, uint8 reserved1, uint8 reserved2, uint16 def_disp_win_left_offset, uint16 def_disp_win_right_offset, uint16 def_disp_win_top_offset, uint16 def_disp_win_bottom_offset, uint32 vui_num_units_in_tick, uint32 vui_time_scale, uint32 vui_num_ticks_poc_diff_one_minus1, uint16 min_spatial_segmentation_idc, uint16 reserved3, uint8 max_bytes_per_pic_denom, uint8 max_bits_per_min_cu_denom, uint8 log2_max_mv_length_horizontal, uint8 log2_max_mv_length_vertical, StdVideoH265HrdParameters* pHrdParameters)
	{
		this.flags = flags;
		this.aspect_ratio_idc = aspect_ratio_idc;
		this.sar_width = sar_width;
		this.sar_height = sar_height;
		this.video_format = video_format;
		this.colour_primaries = colour_primaries;
		this.transfer_characteristics = transfer_characteristics;
		this.matrix_coeffs = matrix_coeffs;
		this.chroma_sample_loc_type_top_field = chroma_sample_loc_type_top_field;
		this.chroma_sample_loc_type_bottom_field = chroma_sample_loc_type_bottom_field;
		this.reserved1 = reserved1;
		this.reserved2 = reserved2;
		this.def_disp_win_left_offset = def_disp_win_left_offset;
		this.def_disp_win_right_offset = def_disp_win_right_offset;
		this.def_disp_win_top_offset = def_disp_win_top_offset;
		this.def_disp_win_bottom_offset = def_disp_win_bottom_offset;
		this.vui_num_units_in_tick = vui_num_units_in_tick;
		this.vui_time_scale = vui_time_scale;
		this.vui_num_ticks_poc_diff_one_minus1 = vui_num_ticks_poc_diff_one_minus1;
		this.min_spatial_segmentation_idc = min_spatial_segmentation_idc;
		this.reserved3 = reserved3;
		this.max_bytes_per_pic_denom = max_bytes_per_pic_denom;
		this.max_bits_per_min_cu_denom = max_bits_per_min_cu_denom;
		this.log2_max_mv_length_horizontal = log2_max_mv_length_horizontal;
		this.log2_max_mv_length_vertical = log2_max_mv_length_vertical;
		this.pHrdParameters = pHrdParameters;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265PredictorPaletteEntries
{
	public uint16[STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE][STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE] PredictorPaletteEntries;

	public this(uint16[STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE][STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE] PredictorPaletteEntries)
	{
		this.PredictorPaletteEntries = PredictorPaletteEntries;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265SpsFlags
{
	[Bitfield(.Public, .Bits(1), "sps_temporal_id_nesting_flag")]
	[Bitfield(.Public, .Bits(1), "separate_colour_plane_flag")]
	[Bitfield(.Public, .Bits(1), "conformance_window_flag")]
	[Bitfield(.Public, .Bits(1), "sps_sub_layer_ordering_info_present_flag")]
	[Bitfield(.Public, .Bits(1), "scaling_list_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "sps_scaling_list_data_present_flag")]
	[Bitfield(.Public, .Bits(1), "amp_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "sample_adaptive_offset_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "pcm_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "pcm_loop_filter_disabled_flag")]
	[Bitfield(.Public, .Bits(1), "long_term_ref_pics_present_flag")]
	[Bitfield(.Public, .Bits(1), "sps_temporal_mvp_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "strong_intra_smoothing_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "vui_parameters_present_flag")]
	[Bitfield(.Public, .Bits(1), "sps_extension_present_flag")]
	[Bitfield(.Public, .Bits(1), "sps_range_extension_flag")]
	// extension SPS flags, valid when STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS is set
	[Bitfield(.Public, .Bits(1), "transform_skip_rotation_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "transform_skip_context_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "implicit_rdpcm_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "explicit_rdpcm_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "extended_precision_processing_flag")]
	[Bitfield(.Public, .Bits(1), "intra_smoothing_disabled_flag")]
	[Bitfield(.Public, .Bits(1), "high_precision_offsets_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "persistent_rice_adaptation_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "cabac_bypass_alignment_enabled_flag")]
	// extension SPS flags, valid when STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS is set
	[Bitfield(.Public, .Bits(1), "sps_scc_extension_flag")]
	[Bitfield(.Public, .Bits(1), "sps_curr_pic_ref_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "palette_mode_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "sps_palette_predictor_initializers_present_flag")]
	[Bitfield(.Public, .Bits(1), "intra_boundary_filtering_disabled_flag")]
	private uint32 __bitfields;

	public this(uint32 sps_temporal_id_nesting_flag, uint32 separate_colour_plane_flag, uint32 conformance_window_flag, uint32 sps_sub_layer_ordering_info_present_flag, uint32 scaling_list_enabled_flag, uint32 sps_scaling_list_data_present_flag, uint32 amp_enabled_flag, uint32 sample_adaptive_offset_enabled_flag, uint32 pcm_enabled_flag, uint32 pcm_loop_filter_disabled_flag, uint32 long_term_ref_pics_present_flag, uint32 sps_temporal_mvp_enabled_flag, uint32 strong_intra_smoothing_enabled_flag, uint32 vui_parameters_present_flag, uint32 sps_extension_present_flag, uint32 sps_range_extension_flag, uint32 transform_skip_rotation_enabled_flag, uint32 transform_skip_context_enabled_flag, uint32 implicit_rdpcm_enabled_flag, uint32 explicit_rdpcm_enabled_flag, uint32 extended_precision_processing_flag, uint32 intra_smoothing_disabled_flag, uint32 high_precision_offsets_enabled_flag, uint32 persistent_rice_adaptation_enabled_flag, uint32 cabac_bypass_alignment_enabled_flag, uint32 sps_scc_extension_flag, uint32 sps_curr_pic_ref_enabled_flag, uint32 palette_mode_enabled_flag, uint32 sps_palette_predictor_initializers_present_flag, uint32 intra_boundary_filtering_disabled_flag) : this()
	{
		this.sps_temporal_id_nesting_flag = sps_temporal_id_nesting_flag;
		this.separate_colour_plane_flag = separate_colour_plane_flag;
		this.conformance_window_flag = conformance_window_flag;
		this.sps_sub_layer_ordering_info_present_flag = sps_sub_layer_ordering_info_present_flag;
		this.scaling_list_enabled_flag = scaling_list_enabled_flag;
		this.sps_scaling_list_data_present_flag = sps_scaling_list_data_present_flag;
		this.amp_enabled_flag = amp_enabled_flag;
		this.sample_adaptive_offset_enabled_flag = sample_adaptive_offset_enabled_flag;
		this.pcm_enabled_flag = pcm_enabled_flag;
		this.pcm_loop_filter_disabled_flag = pcm_loop_filter_disabled_flag;
		this.long_term_ref_pics_present_flag = long_term_ref_pics_present_flag;
		this.sps_temporal_mvp_enabled_flag = sps_temporal_mvp_enabled_flag;
		this.strong_intra_smoothing_enabled_flag = strong_intra_smoothing_enabled_flag;
		this.vui_parameters_present_flag = vui_parameters_present_flag;
		this.sps_extension_present_flag = sps_extension_present_flag;
		this.sps_range_extension_flag = sps_range_extension_flag;
		this.transform_skip_rotation_enabled_flag = transform_skip_rotation_enabled_flag;
		this.transform_skip_context_enabled_flag = transform_skip_context_enabled_flag;
		this.implicit_rdpcm_enabled_flag = implicit_rdpcm_enabled_flag;
		this.explicit_rdpcm_enabled_flag = explicit_rdpcm_enabled_flag;
		this.extended_precision_processing_flag = extended_precision_processing_flag;
		this.intra_smoothing_disabled_flag = intra_smoothing_disabled_flag;
		this.high_precision_offsets_enabled_flag = high_precision_offsets_enabled_flag;
		this.persistent_rice_adaptation_enabled_flag = persistent_rice_adaptation_enabled_flag;
		this.cabac_bypass_alignment_enabled_flag = cabac_bypass_alignment_enabled_flag;
		this.sps_scc_extension_flag = sps_scc_extension_flag;
		this.sps_curr_pic_ref_enabled_flag = sps_curr_pic_ref_enabled_flag;
		this.palette_mode_enabled_flag = palette_mode_enabled_flag;
		this.sps_palette_predictor_initializers_present_flag = sps_palette_predictor_initializers_present_flag;
		this.intra_boundary_filtering_disabled_flag = intra_boundary_filtering_disabled_flag;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265ShortTermRefPicSetFlags
{
	[Bitfield(.Public, .Bits(1), "inter_ref_pic_set_prediction_flag")]
	[Bitfield(.Public, .Bits(1), "delta_rps_sign")]
	private uint32 __bitfields;

	public this(uint32 inter_ref_pic_set_prediction_flag, uint32 delta_rps_sign) : this()
	{
		this.inter_ref_pic_set_prediction_flag = inter_ref_pic_set_prediction_flag;
		this.delta_rps_sign = delta_rps_sign;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265ShortTermRefPicSet
{
	public StdVideoH265ShortTermRefPicSetFlags flags;
	public uint32 delta_idx_minus1;
	public uint16 use_delta_flag; // each bit represents a use_delta_flag[j] syntax
	public uint16 abs_delta_rps_minus1;
	public uint16 used_by_curr_pic_flag; // each bit represents a used_by_curr_pic_flag[j] syntax
	public uint16 used_by_curr_pic_s0_flag; // each bit represents a used_by_curr_pic_s0_flag[i] syntax
	public uint16 used_by_curr_pic_s1_flag; // each bit represents a used_by_curr_pic_s1_flag[i] syntax
	public uint16 reserved1; // Reserved for future use and must be initialized with 0.
	public uint8 reserved2; // Reserved for future use and must be initialized with 0.
	public uint8 reserved3; // Reserved for future use and must be initialized with 0.
	public uint8 num_negative_pics;
	public uint8 num_positive_pics;
	public uint16[STD_VIDEO_H265_MAX_DPB_SIZE] delta_poc_s0_minus1;
	public uint16[STD_VIDEO_H265_MAX_DPB_SIZE] delta_poc_s1_minus1;

	public this(StdVideoH265ShortTermRefPicSetFlags flags, uint32 delta_idx_minus1, uint16 use_delta_flag, uint16 abs_delta_rps_minus1, uint16 used_by_curr_pic_flag, uint16 used_by_curr_pic_s0_flag, uint16 used_by_curr_pic_s1_flag, uint16 reserved1, uint8 reserved2, uint8 reserved3, uint8 num_negative_pics, uint8 num_positive_pics, uint16[STD_VIDEO_H265_MAX_DPB_SIZE] delta_poc_s0_minus1, uint16[STD_VIDEO_H265_MAX_DPB_SIZE] delta_poc_s1_minus1)
	{
		this.flags = flags;
		this.delta_idx_minus1 = delta_idx_minus1;
		this.use_delta_flag = use_delta_flag;
		this.abs_delta_rps_minus1 = abs_delta_rps_minus1;
		this.used_by_curr_pic_flag = used_by_curr_pic_flag;
		this.used_by_curr_pic_s0_flag = used_by_curr_pic_s0_flag;
		this.used_by_curr_pic_s1_flag = used_by_curr_pic_s1_flag;
		this.reserved1 = reserved1;
		this.reserved2 = reserved2;
		this.reserved3 = reserved3;
		this.num_negative_pics = num_negative_pics;
		this.num_positive_pics = num_positive_pics;
		this.delta_poc_s0_minus1 = delta_poc_s0_minus1;
		this.delta_poc_s1_minus1 = delta_poc_s1_minus1;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265LongTermRefPicsSps
{
	public uint32 used_by_curr_pic_lt_sps_flag; // each bit represents a used_by_curr_pic_lt_sps_flag[i] syntax
	public uint32[STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS] lt_ref_pic_poc_lsb_sps;

	public this(uint32 used_by_curr_pic_lt_sps_flag, uint32[STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS] lt_ref_pic_poc_lsb_sps)
	{
		this.used_by_curr_pic_lt_sps_flag = used_by_curr_pic_lt_sps_flag;
		this.lt_ref_pic_poc_lsb_sps = lt_ref_pic_poc_lsb_sps;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265SequenceParameterSet
{
	public StdVideoH265SpsFlags flags;
	public StdVideoH265ChromaFormatIdc chroma_format_idc;
	public uint32 pic_width_in_luma_samples;
	public uint32 pic_height_in_luma_samples;
	public uint8 sps_video_parameter_set_id;
	public uint8 sps_max_sub_layers_minus1;
	public uint8 sps_seq_parameter_set_id;
	public uint8 bit_depth_luma_minus8;
	public uint8 bit_depth_chroma_minus8;
	public uint8 log2_max_pic_order_cnt_lsb_minus4;
	public uint8 log2_min_luma_coding_block_size_minus3;
	public uint8 log2_diff_max_min_luma_coding_block_size;
	public uint8 log2_min_luma_transform_block_size_minus2;
	public uint8 log2_diff_max_min_luma_transform_block_size;
	public uint8 max_transform_hierarchy_depth_inter;
	public uint8 max_transform_hierarchy_depth_intra;
	public uint8 num_short_term_ref_pic_sets;
	public uint8 num_long_term_ref_pics_sps;
	public uint8 pcm_sample_bit_depth_luma_minus1;
	public uint8 pcm_sample_bit_depth_chroma_minus1;
	public uint8 log2_min_pcm_luma_coding_block_size_minus3;
	public uint8 log2_diff_max_min_pcm_luma_coding_block_size;
	public uint8 reserved1; // Reserved for future use and must be initialized with 0.
	public uint8 reserved2; // Reserved for future use and must be initialized with 0.
	// Start extension SPS flags, valid when STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS is set
	public uint8 palette_max_size;
	public uint8 delta_palette_max_predictor_size;
	public uint8 motion_vector_resolution_control_idc;
	public uint8 sps_num_palette_predictor_initializers_minus1;
	// End extension SPS flags, valid when STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS is set
	public uint32 conf_win_left_offset;
	public uint32 conf_win_right_offset;
	public uint32 conf_win_top_offset;
	public uint32 conf_win_bottom_offset;
	public StdVideoH265ProfileTierLevel* pProfileTierLevel;
	public StdVideoH265DecPicBufMgr* pDecPicBufMgr;
	public StdVideoH265ScalingLists* pScalingLists; // Must be a valid pointer if sps_scaling_list_data_present_flag is set
	public StdVideoH265ShortTermRefPicSet* pShortTermRefPicSet; // Must be a valid pointer to an array with size num_short_term_ref_pic_sets if num_short_term_ref_pic_sets is not 0.
	public StdVideoH265LongTermRefPicsSps* pLongTermRefPicsSps; // Must be a valid pointer if long_term_ref_pics_present_flag is set
	public StdVideoH265SequenceParameterSetVui* pSequenceParameterSetVui; // Must be a valid pointer if StdVideoH265SpsFlags:vui_parameters_present_flag is set palette_max_size
	public StdVideoH265PredictorPaletteEntries* pPredictorPaletteEntries; // Must be a valid pointer if sps_palette_predictor_initializer_present_flag is set

	public this(StdVideoH265SpsFlags flags, StdVideoH265ChromaFormatIdc chroma_format_idc, uint32 pic_width_in_luma_samples, uint32 pic_height_in_luma_samples, uint8 sps_video_parameter_set_id, uint8 sps_max_sub_layers_minus1, uint8 sps_seq_parameter_set_id, uint8 bit_depth_luma_minus8, uint8 bit_depth_chroma_minus8, uint8 log2_max_pic_order_cnt_lsb_minus4, uint8 log2_min_luma_coding_block_size_minus3, uint8 log2_diff_max_min_luma_coding_block_size, uint8 log2_min_luma_transform_block_size_minus2, uint8 log2_diff_max_min_luma_transform_block_size, uint8 max_transform_hierarchy_depth_inter, uint8 max_transform_hierarchy_depth_intra, uint8 num_short_term_ref_pic_sets, uint8 num_long_term_ref_pics_sps, uint8 pcm_sample_bit_depth_luma_minus1, uint8 pcm_sample_bit_depth_chroma_minus1, uint8 log2_min_pcm_luma_coding_block_size_minus3, uint8 log2_diff_max_min_pcm_luma_coding_block_size, uint8 reserved1, uint8 reserved2, uint8 palette_max_size, uint8 delta_palette_max_predictor_size, uint8 motion_vector_resolution_control_idc, uint8 sps_num_palette_predictor_initializers_minus1, uint32 conf_win_left_offset, uint32 conf_win_right_offset, uint32 conf_win_top_offset, uint32 conf_win_bottom_offset, StdVideoH265ProfileTierLevel* pProfileTierLevel, StdVideoH265DecPicBufMgr* pDecPicBufMgr, StdVideoH265ScalingLists* pScalingLists, StdVideoH265ShortTermRefPicSet* pShortTermRefPicSet, StdVideoH265LongTermRefPicsSps* pLongTermRefPicsSps, StdVideoH265SequenceParameterSetVui* pSequenceParameterSetVui, StdVideoH265PredictorPaletteEntries* pPredictorPaletteEntries)
	{
		this.flags = flags;
		this.chroma_format_idc = chroma_format_idc;
		this.pic_width_in_luma_samples = pic_width_in_luma_samples;
		this.pic_height_in_luma_samples = pic_height_in_luma_samples;
		this.sps_video_parameter_set_id = sps_video_parameter_set_id;
		this.sps_max_sub_layers_minus1 = sps_max_sub_layers_minus1;
		this.sps_seq_parameter_set_id = sps_seq_parameter_set_id;
		this.bit_depth_luma_minus8 = bit_depth_luma_minus8;
		this.bit_depth_chroma_minus8 = bit_depth_chroma_minus8;
		this.log2_max_pic_order_cnt_lsb_minus4 = log2_max_pic_order_cnt_lsb_minus4;
		this.log2_min_luma_coding_block_size_minus3 = log2_min_luma_coding_block_size_minus3;
		this.log2_diff_max_min_luma_coding_block_size = log2_diff_max_min_luma_coding_block_size;
		this.log2_min_luma_transform_block_size_minus2 = log2_min_luma_transform_block_size_minus2;
		this.log2_diff_max_min_luma_transform_block_size = log2_diff_max_min_luma_transform_block_size;
		this.max_transform_hierarchy_depth_inter = max_transform_hierarchy_depth_inter;
		this.max_transform_hierarchy_depth_intra = max_transform_hierarchy_depth_intra;
		this.num_short_term_ref_pic_sets = num_short_term_ref_pic_sets;
		this.num_long_term_ref_pics_sps = num_long_term_ref_pics_sps;
		this.pcm_sample_bit_depth_luma_minus1 = pcm_sample_bit_depth_luma_minus1;
		this.pcm_sample_bit_depth_chroma_minus1 = pcm_sample_bit_depth_chroma_minus1;
		this.log2_min_pcm_luma_coding_block_size_minus3 = log2_min_pcm_luma_coding_block_size_minus3;
		this.log2_diff_max_min_pcm_luma_coding_block_size = log2_diff_max_min_pcm_luma_coding_block_size;
		this.reserved1 = reserved1;
		this.reserved2 = reserved2;
		this.palette_max_size = palette_max_size;
		this.delta_palette_max_predictor_size = delta_palette_max_predictor_size;
		this.motion_vector_resolution_control_idc = motion_vector_resolution_control_idc;
		this.sps_num_palette_predictor_initializers_minus1 = sps_num_palette_predictor_initializers_minus1;
		this.conf_win_left_offset = conf_win_left_offset;
		this.conf_win_right_offset = conf_win_right_offset;
		this.conf_win_top_offset = conf_win_top_offset;
		this.conf_win_bottom_offset = conf_win_bottom_offset;
		this.pProfileTierLevel = pProfileTierLevel;
		this.pDecPicBufMgr = pDecPicBufMgr;
		this.pScalingLists = pScalingLists;
		this.pShortTermRefPicSet = pShortTermRefPicSet;
		this.pLongTermRefPicsSps = pLongTermRefPicsSps;
		this.pSequenceParameterSetVui = pSequenceParameterSetVui;
		this.pPredictorPaletteEntries = pPredictorPaletteEntries;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265PpsFlags
{
	[Bitfield(.Public, .Bits(1), "dependent_slice_segments_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "output_flag_present_flag")]
	[Bitfield(.Public, .Bits(1), "sign_data_hiding_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "cabac_init_present_flag")]
	[Bitfield(.Public, .Bits(1), "constrained_intra_pred_flag")]
	[Bitfield(.Public, .Bits(1), "transform_skip_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "cu_qp_delta_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "pps_slice_chroma_qp_offsets_present_flag")]
	[Bitfield(.Public, .Bits(1), "weighted_pred_flag")]
	[Bitfield(.Public, .Bits(1), "weighted_bipred_flag")]
	[Bitfield(.Public, .Bits(1), "transquant_bypass_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "tiles_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "entropy_coding_sync_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "uniform_spacing_flag")]
	[Bitfield(.Public, .Bits(1), "loop_filter_across_tiles_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "pps_loop_filter_across_slices_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "deblocking_filter_control_present_flag")]
	[Bitfield(.Public, .Bits(1), "deblocking_filter_override_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "pps_deblocking_filter_disabled_flag")]
	[Bitfield(.Public, .Bits(1), "pps_scaling_list_data_present_flag")]
	[Bitfield(.Public, .Bits(1), "lists_modification_present_flag")]
	[Bitfield(.Public, .Bits(1), "slice_segment_header_extension_present_flag")]
	[Bitfield(.Public, .Bits(1), "pps_extension_present_flag")]
	// extension PPS flags, valid when STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS is set
	[Bitfield(.Public, .Bits(1), "cross_component_prediction_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "chroma_qp_offset_list_enabled_flag")]
	// extension PPS flags, valid when STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS is set
	[Bitfield(.Public, .Bits(1), "pps_curr_pic_ref_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "residual_adaptive_colour_transform_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "pps_slice_act_qp_offsets_present_flag")]
	[Bitfield(.Public, .Bits(1), "pps_palette_predictor_initializers_present_flag")]
	[Bitfield(.Public, .Bits(1), "monochrome_palette_flag")]
	[Bitfield(.Public, .Bits(1), "pps_range_extension_flag")]
	private uint32 __bitfields;

	public this(uint32 dependent_slice_segments_enabled_flag, uint32 output_flag_present_flag, uint32 sign_data_hiding_enabled_flag, uint32 cabac_init_present_flag, uint32 constrained_intra_pred_flag, uint32 transform_skip_enabled_flag, uint32 cu_qp_delta_enabled_flag, uint32 pps_slice_chroma_qp_offsets_present_flag, uint32 weighted_pred_flag, uint32 weighted_bipred_flag, uint32 transquant_bypass_enabled_flag, uint32 tiles_enabled_flag, uint32 entropy_coding_sync_enabled_flag, uint32 uniform_spacing_flag, uint32 loop_filter_across_tiles_enabled_flag, uint32 pps_loop_filter_across_slices_enabled_flag, uint32 deblocking_filter_control_present_flag, uint32 deblocking_filter_override_enabled_flag, uint32 pps_deblocking_filter_disabled_flag, uint32 pps_scaling_list_data_present_flag, uint32 lists_modification_present_flag, uint32 slice_segment_header_extension_present_flag, uint32 pps_extension_present_flag, uint32 cross_component_prediction_enabled_flag, uint32 chroma_qp_offset_list_enabled_flag, uint32 pps_curr_pic_ref_enabled_flag, uint32 residual_adaptive_colour_transform_enabled_flag, uint32 pps_slice_act_qp_offsets_present_flag, uint32 pps_palette_predictor_initializers_present_flag, uint32 monochrome_palette_flag, uint32 pps_range_extension_flag) : this()
	{
		this.dependent_slice_segments_enabled_flag = dependent_slice_segments_enabled_flag;
		this.output_flag_present_flag = output_flag_present_flag;
		this.sign_data_hiding_enabled_flag = sign_data_hiding_enabled_flag;
		this.cabac_init_present_flag = cabac_init_present_flag;
		this.constrained_intra_pred_flag = constrained_intra_pred_flag;
		this.transform_skip_enabled_flag = transform_skip_enabled_flag;
		this.cu_qp_delta_enabled_flag = cu_qp_delta_enabled_flag;
		this.pps_slice_chroma_qp_offsets_present_flag = pps_slice_chroma_qp_offsets_present_flag;
		this.weighted_pred_flag = weighted_pred_flag;
		this.weighted_bipred_flag = weighted_bipred_flag;
		this.transquant_bypass_enabled_flag = transquant_bypass_enabled_flag;
		this.tiles_enabled_flag = tiles_enabled_flag;
		this.entropy_coding_sync_enabled_flag = entropy_coding_sync_enabled_flag;
		this.uniform_spacing_flag = uniform_spacing_flag;
		this.loop_filter_across_tiles_enabled_flag = loop_filter_across_tiles_enabled_flag;
		this.pps_loop_filter_across_slices_enabled_flag = pps_loop_filter_across_slices_enabled_flag;
		this.deblocking_filter_control_present_flag = deblocking_filter_control_present_flag;
		this.deblocking_filter_override_enabled_flag = deblocking_filter_override_enabled_flag;
		this.pps_deblocking_filter_disabled_flag = pps_deblocking_filter_disabled_flag;
		this.pps_scaling_list_data_present_flag = pps_scaling_list_data_present_flag;
		this.lists_modification_present_flag = lists_modification_present_flag;
		this.slice_segment_header_extension_present_flag = slice_segment_header_extension_present_flag;
		this.pps_extension_present_flag = pps_extension_present_flag;
		this.cross_component_prediction_enabled_flag = cross_component_prediction_enabled_flag;
		this.chroma_qp_offset_list_enabled_flag = chroma_qp_offset_list_enabled_flag;
		this.pps_curr_pic_ref_enabled_flag = pps_curr_pic_ref_enabled_flag;
		this.residual_adaptive_colour_transform_enabled_flag = residual_adaptive_colour_transform_enabled_flag;
		this.pps_slice_act_qp_offsets_present_flag = pps_slice_act_qp_offsets_present_flag;
		this.pps_palette_predictor_initializers_present_flag = pps_palette_predictor_initializers_present_flag;
		this.monochrome_palette_flag = monochrome_palette_flag;
		this.pps_range_extension_flag = pps_range_extension_flag;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoH265PictureParameterSet
{
	public StdVideoH265PpsFlags flags;
	public uint8 pps_pic_parameter_set_id;
	public uint8 pps_seq_parameter_set_id;
	public uint8 sps_video_parameter_set_id;
	public uint8 num_extra_slice_header_bits;
	public uint8 num_ref_idx_l0_default_active_minus1;
	public uint8 num_ref_idx_l1_default_active_minus1;
	public int8 init_qp_minus26;
	public uint8 diff_cu_qp_delta_depth;
	public int8 pps_cb_qp_offset;
	public int8 pps_cr_qp_offset;
	public int8 pps_beta_offset_div2;
	public int8 pps_tc_offset_div2;
	public uint8 log2_parallel_merge_level_minus2;
	// extension PPS, valid when STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS is set
	public uint8 log2_max_transform_skip_block_size_minus2;
	public uint8 diff_cu_chroma_qp_offset_depth;
	public uint8 chroma_qp_offset_list_len_minus1;
	public int8[STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE] cb_qp_offset_list;
	public int8[STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE] cr_qp_offset_list;
	public uint8 log2_sao_offset_scale_luma;
	public uint8 log2_sao_offset_scale_chroma;
	// extension PPS, valid when STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS is set
	public int8 pps_act_y_qp_offset_plus5;
	public int8 pps_act_cb_qp_offset_plus5;
	public int8 pps_act_cr_qp_offset_plus3;
	public uint8 pps_num_palette_predictor_initializers;
	public uint8 luma_bit_depth_entry_minus8;
	public uint8 chroma_bit_depth_entry_minus8;
	public uint8 num_tile_columns_minus1;
	public uint8 num_tile_rows_minus1;
	public uint8 reserved1; // Reserved for future use and must be initialized with 0.
	public uint8 reserved2; // Reserved for future use and must be initialized with 0.
	public uint16[STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE] column_width_minus1;
	public uint16[STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE] row_height_minus1;
	public uint32 reserved3; // Reserved for future use and must be initialized with 0.
	public StdVideoH265ScalingLists* pScalingLists; // Must be a valid pointer if pps_scaling_list_data_present_flag is set
	public StdVideoH265PredictorPaletteEntries* pPredictorPaletteEntries; // Must be a valid pointer if pps_palette_predictor_initializer_present_flag is set

	public this(StdVideoH265PpsFlags flags, uint8 pps_pic_parameter_set_id, uint8 pps_seq_parameter_set_id, uint8 sps_video_parameter_set_id, uint8 num_extra_slice_header_bits, uint8 num_ref_idx_l0_default_active_minus1, uint8 num_ref_idx_l1_default_active_minus1, int8 init_qp_minus26, uint8 diff_cu_qp_delta_depth, int8 pps_cb_qp_offset, int8 pps_cr_qp_offset, int8 pps_beta_offset_div2, int8 pps_tc_offset_div2, uint8 log2_parallel_merge_level_minus2, uint8 log2_max_transform_skip_block_size_minus2, uint8 diff_cu_chroma_qp_offset_depth, uint8 chroma_qp_offset_list_len_minus1, int8[STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE] cb_qp_offset_list, int8[STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE] cr_qp_offset_list, uint8 log2_sao_offset_scale_luma, uint8 log2_sao_offset_scale_chroma, int8 pps_act_y_qp_offset_plus5, int8 pps_act_cb_qp_offset_plus5, int8 pps_act_cr_qp_offset_plus3, uint8 pps_num_palette_predictor_initializers, uint8 luma_bit_depth_entry_minus8, uint8 chroma_bit_depth_entry_minus8, uint8 num_tile_columns_minus1, uint8 num_tile_rows_minus1, uint8 reserved1, uint8 reserved2, uint16[STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE] column_width_minus1, uint16[STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE] row_height_minus1, uint32 reserved3, StdVideoH265ScalingLists* pScalingLists, StdVideoH265PredictorPaletteEntries* pPredictorPaletteEntries)
	{
		this.flags = flags;
		this.pps_pic_parameter_set_id = pps_pic_parameter_set_id;
		this.pps_seq_parameter_set_id = pps_seq_parameter_set_id;
		this.sps_video_parameter_set_id = sps_video_parameter_set_id;
		this.num_extra_slice_header_bits = num_extra_slice_header_bits;
		this.num_ref_idx_l0_default_active_minus1 = num_ref_idx_l0_default_active_minus1;
		this.num_ref_idx_l1_default_active_minus1 = num_ref_idx_l1_default_active_minus1;
		this.init_qp_minus26 = init_qp_minus26;
		this.diff_cu_qp_delta_depth = diff_cu_qp_delta_depth;
		this.pps_cb_qp_offset = pps_cb_qp_offset;
		this.pps_cr_qp_offset = pps_cr_qp_offset;
		this.pps_beta_offset_div2 = pps_beta_offset_div2;
		this.pps_tc_offset_div2 = pps_tc_offset_div2;
		this.log2_parallel_merge_level_minus2 = log2_parallel_merge_level_minus2;
		this.log2_max_transform_skip_block_size_minus2 = log2_max_transform_skip_block_size_minus2;
		this.diff_cu_chroma_qp_offset_depth = diff_cu_chroma_qp_offset_depth;
		this.chroma_qp_offset_list_len_minus1 = chroma_qp_offset_list_len_minus1;
		this.cb_qp_offset_list = cb_qp_offset_list;
		this.cr_qp_offset_list = cr_qp_offset_list;
		this.log2_sao_offset_scale_luma = log2_sao_offset_scale_luma;
		this.log2_sao_offset_scale_chroma = log2_sao_offset_scale_chroma;
		this.pps_act_y_qp_offset_plus5 = pps_act_y_qp_offset_plus5;
		this.pps_act_cb_qp_offset_plus5 = pps_act_cb_qp_offset_plus5;
		this.pps_act_cr_qp_offset_plus3 = pps_act_cr_qp_offset_plus3;
		this.pps_num_palette_predictor_initializers = pps_num_palette_predictor_initializers;
		this.luma_bit_depth_entry_minus8 = luma_bit_depth_entry_minus8;
		this.chroma_bit_depth_entry_minus8 = chroma_bit_depth_entry_minus8;
		this.num_tile_columns_minus1 = num_tile_columns_minus1;
		this.num_tile_rows_minus1 = num_tile_rows_minus1;
		this.reserved1 = reserved1;
		this.reserved2 = reserved2;
		this.column_width_minus1 = column_width_minus1;
		this.row_height_minus1 = row_height_minus1;
		this.reserved3 = reserved3;
		this.pScalingLists = pScalingLists;
		this.pPredictorPaletteEntries = pPredictorPaletteEntries;
	}

	public this()
	{
		this = default;
	}
}

static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0 = VK_MAKE_VIDEO_STD_VERSION(1, 0, 0); }
static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_SPEC_VERSION = VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0; }
static { public const c_char* VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h265_decode"; }
static { public const uint32 STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE = 8; }

[CRepr] struct StdVideoDecodeH265PictureInfoFlags
{
	[Bitfield(.Public, .Bits(1), "IrapPicFlag")]
	[Bitfield(.Public, .Bits(1), "IdrPicFlag")]
	[Bitfield(.Public, .Bits(1), "IsReference")]
	[Bitfield(.Public, .Bits(1), "short_term_ref_pic_set_sps_flag")]
	private uint32 __bitfields;

	public this(uint32 IrapPicFlag, uint32 IdrPicFlag, uint32 IsReference, uint32 short_term_ref_pic_set_sps_flag) : this()
	{
		this.IrapPicFlag = IrapPicFlag;
		this.IdrPicFlag = IdrPicFlag;
		this.IsReference = IsReference;
		this.short_term_ref_pic_set_sps_flag = short_term_ref_pic_set_sps_flag;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoDecodeH265PictureInfo
{
	public StdVideoDecodeH265PictureInfoFlags flags;
	public uint8 sps_video_parameter_set_id; // Selecting VPS id from the Video Parameters Set
	public uint8 pps_seq_parameter_set_id; // Selecting SPS id from the Sequence Parameters Set
	public uint8 pps_pic_parameter_set_id; // Selecting PPS id from the Picture Parameters Set
	public uint8 NumDeltaPocsOfRefRpsIdx; // NumDeltaPocs[ RefRpsIdx ] when short_term_ref_pic_set_sps_flag = 1, otherwise 0
	public int32 PicOrderCntVal;
	public uint16 NumBitsForSTRefPicSetInSlice; // number of bits used in st_ref_pic_set() when short_term_ref_pic_set_sps_flag is 0otherwise set to 0.
	public uint16 reserved;
	public uint8[STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE] RefPicSetStCurrBefore; // slotIndex as used in VkVideoReferenceSlotInfoKHR structures representing pReferenceSlots in VkVideoDecodeInfoKHR or STD_VIDEO_H265_NO_REFERENCE_PICTURE
	public uint8[STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE] RefPicSetStCurrAfter; // slotIndex as used in VkVideoReferenceSlotInfoKHR structures representing pReferenceSlots in VkVideoDecodeInfoKHR or STD_VIDEO_H265_NO_REFERENCE_PICTURE
	public uint8[STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE] RefPicSetLtCurr; // slotIndex as used in VkVideoReferenceSlotInfoKHR structures representing pReferenceSlots in VkVideoDecodeInfoKHR or STD_VIDEO_H265_NO_REFERENCE_PICTURE

	public this(StdVideoDecodeH265PictureInfoFlags flags, uint8 sps_video_parameter_set_id, uint8 pps_seq_parameter_set_id, uint8 pps_pic_parameter_set_id, uint8 NumDeltaPocsOfRefRpsIdx, int32 PicOrderCntVal, uint16 NumBitsForSTRefPicSetInSlice, uint16 reserved, uint8[STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE] RefPicSetStCurrBefore, uint8[STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE] RefPicSetStCurrAfter, uint8[STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE] RefPicSetLtCurr)
	{
		this.flags = flags;
		this.sps_video_parameter_set_id = sps_video_parameter_set_id;
		this.pps_seq_parameter_set_id = pps_seq_parameter_set_id;
		this.pps_pic_parameter_set_id = pps_pic_parameter_set_id;
		this.NumDeltaPocsOfRefRpsIdx = NumDeltaPocsOfRefRpsIdx;
		this.PicOrderCntVal = PicOrderCntVal;
		this.NumBitsForSTRefPicSetInSlice = NumBitsForSTRefPicSetInSlice;
		this.reserved = reserved;
		this.RefPicSetStCurrBefore = RefPicSetStCurrBefore;
		this.RefPicSetStCurrAfter = RefPicSetStCurrAfter;
		this.RefPicSetLtCurr = RefPicSetLtCurr;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoDecodeH265ReferenceInfoFlags
{
	[Bitfield(.Public, .Bits(1), "used_for_long_term_reference")] // A picture that is marked as "used for long-term reference", derived binary value from clause 8.3.2 Decoding process for reference picture set
	[Bitfield(.Public, .Bits(1), "unused_for_reference")] // A picture that is marked as "unused for reference", derived binary value from clause 8.3.2 Decoding process for reference picture set
	private uint32 __bitfields;

	public this(uint32 used_for_long_term_reference, uint32 unused_for_reference) : this()
	{
		this.used_for_long_term_reference = used_for_long_term_reference;
		this.unused_for_reference = unused_for_reference;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoDecodeH265ReferenceInfo
{
	public StdVideoDecodeH265ReferenceInfoFlags flags;
	public int32 PicOrderCntVal;

	public this(StdVideoDecodeH265ReferenceInfoFlags flags, int32 PicOrderCntVal)
	{
		this.flags = flags;
		this.PicOrderCntVal = PicOrderCntVal;
	}

	public this()
	{
		this = default;
	}
}

static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0 = VK_MAKE_VIDEO_STD_VERSION(1, 0, 0); }
static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_SPEC_VERSION = VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0; }
static { public const c_char* VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_h265_encode"; }

[CRepr] struct StdVideoEncodeH265WeightTableFlags
{
	public uint16 luma_weight_l0_flag; // each bit n represents the nth entry in reference list l0, n <= num_ref_idx_l0_active_minus1
	public uint16 chroma_weight_l0_flag; // each bit n represents the nth entry in reference list l0, n <= num_ref_idx_l0_active_minus1
	public uint16 luma_weight_l1_flag; // each bit n represents the nth entry in reference list l1, n <= num_ref_idx_l1_active_minus1
	public uint16 chroma_weight_l1_flag; // each bit n represents the nth entry in reference list l1, n <= num_ref_idx_l1_active_minus1

	public this(uint16 luma_weight_l0_flag, uint16 chroma_weight_l0_flag, uint16 luma_weight_l1_flag, uint16 chroma_weight_l1_flag)
	{
		this.luma_weight_l0_flag = luma_weight_l0_flag;
		this.chroma_weight_l0_flag = chroma_weight_l0_flag;
		this.luma_weight_l1_flag = luma_weight_l1_flag;
		this.chroma_weight_l1_flag = chroma_weight_l1_flag;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH265WeightTable
{
	/* StdVideoEncodeH265WeightTable corresponds to the values produced by pred_weight_table() for the h.265 specification.	 * For details, refer to weighted_pred_flag, weighted_bipred_flag and pred_weight_table().
	 */
	public StdVideoEncodeH265WeightTableFlags flags;
	public uint8 luma_log2_weight_denom; // [0, 7]
	public int8 delta_chroma_log2_weight_denom;
	public int8[STD_VIDEO_H265_MAX_NUM_LIST_REF] delta_luma_weight_l0; // comment
	public int8[STD_VIDEO_H265_MAX_NUM_LIST_REF] luma_offset_l0; // comment
	public int8[STD_VIDEO_H265_MAX_NUM_LIST_REF][STD_VIDEO_H265_MAX_CHROMA_PLANES] delta_chroma_weight_l0; // [i][j]: valid entry range for i is [0, num_ref_idx_l0_active_minus1]; j = 0 for Cb, j = 1 for Cr
	public int8[STD_VIDEO_H265_MAX_NUM_LIST_REF][STD_VIDEO_H265_MAX_CHROMA_PLANES] delta_chroma_offset_l0; // [i][j]: valid entry range for i is [0, num_ref_idx_l0_active_minus1]; j = 0 for Cb, j = 1 for Cr
	public int8[STD_VIDEO_H265_MAX_NUM_LIST_REF] delta_luma_weight_l1;
	public int8[STD_VIDEO_H265_MAX_NUM_LIST_REF] luma_offset_l1;
	public int8[STD_VIDEO_H265_MAX_NUM_LIST_REF][STD_VIDEO_H265_MAX_CHROMA_PLANES] delta_chroma_weight_l1; // [i][j]: valid entry range for i is [0, num_ref_idx_l1_active_minus1]; j = 0 for Cb, j = 1 for Cr
	public int8[STD_VIDEO_H265_MAX_NUM_LIST_REF][STD_VIDEO_H265_MAX_CHROMA_PLANES] delta_chroma_offset_l1; // [i][j]: valid entry range for i is [0, num_ref_idx_l1_active_minus1]; j = 0 for Cb, j = 1 for Cr

	public this(StdVideoEncodeH265WeightTableFlags flags, uint8 luma_log2_weight_denom, int8 delta_chroma_log2_weight_denom, int8[STD_VIDEO_H265_MAX_NUM_LIST_REF] delta_luma_weight_l0, int8[STD_VIDEO_H265_MAX_NUM_LIST_REF] luma_offset_l0, int8[STD_VIDEO_H265_MAX_NUM_LIST_REF][STD_VIDEO_H265_MAX_CHROMA_PLANES] delta_chroma_weight_l0, int8[STD_VIDEO_H265_MAX_NUM_LIST_REF][STD_VIDEO_H265_MAX_CHROMA_PLANES] delta_chroma_offset_l0, int8[STD_VIDEO_H265_MAX_NUM_LIST_REF] delta_luma_weight_l1, int8[STD_VIDEO_H265_MAX_NUM_LIST_REF] luma_offset_l1, int8[STD_VIDEO_H265_MAX_NUM_LIST_REF][STD_VIDEO_H265_MAX_CHROMA_PLANES] delta_chroma_weight_l1, int8[STD_VIDEO_H265_MAX_NUM_LIST_REF][STD_VIDEO_H265_MAX_CHROMA_PLANES] delta_chroma_offset_l1)
	{
		this.flags = flags;
		this.luma_log2_weight_denom = luma_log2_weight_denom;
		this.delta_chroma_log2_weight_denom = delta_chroma_log2_weight_denom;
		this.delta_luma_weight_l0 = delta_luma_weight_l0;
		this.luma_offset_l0 = luma_offset_l0;
		this.delta_chroma_weight_l0 = delta_chroma_weight_l0;
		this.delta_chroma_offset_l0 = delta_chroma_offset_l0;
		this.delta_luma_weight_l1 = delta_luma_weight_l1;
		this.luma_offset_l1 = luma_offset_l1;
		this.delta_chroma_weight_l1 = delta_chroma_weight_l1;
		this.delta_chroma_offset_l1 = delta_chroma_offset_l1;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH265SliceSegmentHeaderFlags
{
	[Bitfield(.Public, .Bits(1), "first_slice_segment_in_pic_flag")]
	[Bitfield(.Public, .Bits(1), "dependent_slice_segment_flag")]
	[Bitfield(.Public, .Bits(1), "slice_sao_luma_flag")]
	[Bitfield(.Public, .Bits(1), "slice_sao_chroma_flag")]
	[Bitfield(.Public, .Bits(1), "num_ref_idx_active_override_flag")]
	[Bitfield(.Public, .Bits(1), "mvd_l1_zero_flag")]
	[Bitfield(.Public, .Bits(1), "cabac_init_flag")]
	[Bitfield(.Public, .Bits(1), "cu_chroma_qp_offset_enabled_flag")]
	[Bitfield(.Public, .Bits(1), "deblocking_filter_override_flag")]
	[Bitfield(.Public, .Bits(1), "slice_deblocking_filter_disabled_flag")]
	[Bitfield(.Public, .Bits(1), "collocated_from_l0_flag")]
	[Bitfield(.Public, .Bits(1), "slice_loop_filter_across_slices_enabled_flag")]
	[Bitfield(.Public, .Bits(20), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 first_slice_segment_in_pic_flag, uint32 dependent_slice_segment_flag, uint32 slice_sao_luma_flag, uint32 slice_sao_chroma_flag, uint32 num_ref_idx_active_override_flag, uint32 mvd_l1_zero_flag, uint32 cabac_init_flag, uint32 cu_chroma_qp_offset_enabled_flag, uint32 deblocking_filter_override_flag, uint32 slice_deblocking_filter_disabled_flag, uint32 collocated_from_l0_flag, uint32 slice_loop_filter_across_slices_enabled_flag, uint32 reserved) : this()
	{
		this.first_slice_segment_in_pic_flag = first_slice_segment_in_pic_flag;
		this.dependent_slice_segment_flag = dependent_slice_segment_flag;
		this.slice_sao_luma_flag = slice_sao_luma_flag;
		this.slice_sao_chroma_flag = slice_sao_chroma_flag;
		this.num_ref_idx_active_override_flag = num_ref_idx_active_override_flag;
		this.mvd_l1_zero_flag = mvd_l1_zero_flag;
		this.cabac_init_flag = cabac_init_flag;
		this.cu_chroma_qp_offset_enabled_flag = cu_chroma_qp_offset_enabled_flag;
		this.deblocking_filter_override_flag = deblocking_filter_override_flag;
		this.slice_deblocking_filter_disabled_flag = slice_deblocking_filter_disabled_flag;
		this.collocated_from_l0_flag = collocated_from_l0_flag;
		this.slice_loop_filter_across_slices_enabled_flag = slice_loop_filter_across_slices_enabled_flag;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH265SliceSegmentHeader
{
	public StdVideoEncodeH265SliceSegmentHeaderFlags flags;
	public StdVideoH265SliceType slice_type;
	public uint32 slice_segment_address;
	public uint8 collocated_ref_idx;
	public uint8 MaxNumMergeCand;
	public int8 slice_cb_qp_offset; // [-12, 12]
	public int8 slice_cr_qp_offset; // [-12, 12]
	public int8 slice_beta_offset_div2; // [-6, 6]
	public int8 slice_tc_offset_div2; // [-6, 6]
	public int8 slice_act_y_qp_offset;
	public int8 slice_act_cb_qp_offset;
	public int8 slice_act_cr_qp_offset;
	public int8 slice_qp_delta;
	public uint16 reserved1; // Reserved for future use and must be initialized with 0.
	public StdVideoEncodeH265WeightTable* pWeightTable;

	public this(StdVideoEncodeH265SliceSegmentHeaderFlags flags, StdVideoH265SliceType slice_type, uint32 slice_segment_address, uint8 collocated_ref_idx, uint8 MaxNumMergeCand, int8 slice_cb_qp_offset, int8 slice_cr_qp_offset, int8 slice_beta_offset_div2, int8 slice_tc_offset_div2, int8 slice_act_y_qp_offset, int8 slice_act_cb_qp_offset, int8 slice_act_cr_qp_offset, int8 slice_qp_delta, uint16 reserved1, StdVideoEncodeH265WeightTable* pWeightTable)
	{
		this.flags = flags;
		this.slice_type = slice_type;
		this.slice_segment_address = slice_segment_address;
		this.collocated_ref_idx = collocated_ref_idx;
		this.MaxNumMergeCand = MaxNumMergeCand;
		this.slice_cb_qp_offset = slice_cb_qp_offset;
		this.slice_cr_qp_offset = slice_cr_qp_offset;
		this.slice_beta_offset_div2 = slice_beta_offset_div2;
		this.slice_tc_offset_div2 = slice_tc_offset_div2;
		this.slice_act_y_qp_offset = slice_act_y_qp_offset;
		this.slice_act_cb_qp_offset = slice_act_cb_qp_offset;
		this.slice_act_cr_qp_offset = slice_act_cr_qp_offset;
		this.slice_qp_delta = slice_qp_delta;
		this.reserved1 = reserved1;
		this.pWeightTable = pWeightTable;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH265ReferenceListsInfoFlags
{
	[Bitfield(.Public, .Bits(1), "ref_pic_list_modification_flag_l0")]
	[Bitfield(.Public, .Bits(1), "ref_pic_list_modification_flag_l1")]
	[Bitfield(.Public, .Bits(30), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 ref_pic_list_modification_flag_l0, uint32 ref_pic_list_modification_flag_l1, uint32 reserved) : this()
	{
		this.ref_pic_list_modification_flag_l0 = ref_pic_list_modification_flag_l0;
		this.ref_pic_list_modification_flag_l1 = ref_pic_list_modification_flag_l1;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH265ReferenceListsInfo
{
	public StdVideoEncodeH265ReferenceListsInfoFlags flags;
	public uint8 num_ref_idx_l0_active_minus1;
	public uint8 num_ref_idx_l1_active_minus1;
	public uint8[STD_VIDEO_H265_MAX_NUM_LIST_REF] RefPicList0; // slotIndex as used in VkVideoReferenceSlotInfoKHR structures or STD_VIDEO_H265_NO_REFERENCE_PICTURE
	public uint8[STD_VIDEO_H265_MAX_NUM_LIST_REF] RefPicList1; // slotIndex as used in VkVideoReferenceSlotInfoKHR structures or STD_VIDEO_H265_NO_REFERENCE_PICTURE
	public uint8[STD_VIDEO_H265_MAX_NUM_LIST_REF] list_entry_l0;
	public uint8[STD_VIDEO_H265_MAX_NUM_LIST_REF] list_entry_l1;

	public this(StdVideoEncodeH265ReferenceListsInfoFlags flags, uint8 num_ref_idx_l0_active_minus1, uint8 num_ref_idx_l1_active_minus1, uint8[STD_VIDEO_H265_MAX_NUM_LIST_REF] RefPicList0, uint8[STD_VIDEO_H265_MAX_NUM_LIST_REF] RefPicList1, uint8[STD_VIDEO_H265_MAX_NUM_LIST_REF] list_entry_l0, uint8[STD_VIDEO_H265_MAX_NUM_LIST_REF] list_entry_l1)
	{
		this.flags = flags;
		this.num_ref_idx_l0_active_minus1 = num_ref_idx_l0_active_minus1;
		this.num_ref_idx_l1_active_minus1 = num_ref_idx_l1_active_minus1;
		this.RefPicList0 = RefPicList0;
		this.RefPicList1 = RefPicList1;
		this.list_entry_l0 = list_entry_l0;
		this.list_entry_l1 = list_entry_l1;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH265PictureInfoFlags
{
	[Bitfield(.Public, .Bits(1), "is_reference")] // A reference picture, as defined in clause 3.132
	[Bitfield(.Public, .Bits(1), "IrapPicFlag")] // A reference picture, as defined in clause 3.73
	[Bitfield(.Public, .Bits(1), "used_for_long_term_reference")] // A picture that is marked as "used for long-term reference", derived binary value from clause 8.3.2 Decoding process for reference picture set
	[Bitfield(.Public, .Bits(1), "discardable_flag")]
	[Bitfield(.Public, .Bits(1), "cross_layer_bla_flag")]
	[Bitfield(.Public, .Bits(1), "pic_output_flag")]
	[Bitfield(.Public, .Bits(1), "no_output_of_prior_pics_flag")]
	[Bitfield(.Public, .Bits(1), "short_term_ref_pic_set_sps_flag")]
	[Bitfield(.Public, .Bits(1), "slice_temporal_mvp_enabled_flag")]
	[Bitfield(.Public, .Bits(23), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 is_reference, uint32 IrapPicFlag, uint32 used_for_long_term_reference, uint32 discardable_flag, uint32 cross_layer_bla_flag, uint32 pic_output_flag, uint32 no_output_of_prior_pics_flag, uint32 short_term_ref_pic_set_sps_flag, uint32 slice_temporal_mvp_enabled_flag, uint32 reserved) : this()
	{
		this.is_reference = is_reference;
		this.IrapPicFlag = IrapPicFlag;
		this.used_for_long_term_reference = used_for_long_term_reference;
		this.discardable_flag = discardable_flag;
		this.cross_layer_bla_flag = cross_layer_bla_flag;
		this.pic_output_flag = pic_output_flag;
		this.no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;
		this.short_term_ref_pic_set_sps_flag = short_term_ref_pic_set_sps_flag;
		this.slice_temporal_mvp_enabled_flag = slice_temporal_mvp_enabled_flag;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH265LongTermRefPics
{
	public uint8 num_long_term_sps;
	public uint8 num_long_term_pics;
	public uint8[STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS] lt_idx_sps;
	public uint8[STD_VIDEO_H265_MAX_LONG_TERM_PICS] poc_lsb_lt;
	public uint16 used_by_curr_pic_lt_flag; // each bit represents a used_by_curr_pic_lt_flag[i] syntax
	public uint8[STD_VIDEO_H265_MAX_DELTA_POC] delta_poc_msb_present_flag;
	public uint8[STD_VIDEO_H265_MAX_DELTA_POC] delta_poc_msb_cycle_lt;

	public this(uint8 num_long_term_sps, uint8 num_long_term_pics, uint8[STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS] lt_idx_sps, uint8[STD_VIDEO_H265_MAX_LONG_TERM_PICS] poc_lsb_lt, uint16 used_by_curr_pic_lt_flag, uint8[STD_VIDEO_H265_MAX_DELTA_POC] delta_poc_msb_present_flag, uint8[STD_VIDEO_H265_MAX_DELTA_POC] delta_poc_msb_cycle_lt)
	{
		this.num_long_term_sps = num_long_term_sps;
		this.num_long_term_pics = num_long_term_pics;
		this.lt_idx_sps = lt_idx_sps;
		this.poc_lsb_lt = poc_lsb_lt;
		this.used_by_curr_pic_lt_flag = used_by_curr_pic_lt_flag;
		this.delta_poc_msb_present_flag = delta_poc_msb_present_flag;
		this.delta_poc_msb_cycle_lt = delta_poc_msb_cycle_lt;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH265PictureInfo
{
	public StdVideoEncodeH265PictureInfoFlags flags;
	public StdVideoH265PictureType pic_type;
	public uint8 sps_video_parameter_set_id; // Selecting VPS id from the Video Parameters Set
	public uint8 pps_seq_parameter_set_id; // Selecting SPS id from the Sequence Parameters Set
	public uint8 pps_pic_parameter_set_id; // Selecting PPS id from the Picture Parameters Set
	public uint8 short_term_ref_pic_set_idx;
	public int32 PicOrderCntVal; // Picture order count derived as specified in 8.3.1
	public uint8 TemporalId; // Temporal ID, as defined in 7.4.2.2
	public uint8[7] reserved1; // Reserved for future use and must be initialized with 0.
	public StdVideoEncodeH265ReferenceListsInfo* pRefLists;
	public StdVideoH265ShortTermRefPicSet* pShortTermRefPicSet; // Must be a valid pointer if short_term_ref_pic_set_sps_flag is not set
	public StdVideoEncodeH265LongTermRefPics* pLongTermRefPics; // Must be a valid pointer if long_term_ref_pics_present_flag is set

	public this(StdVideoEncodeH265PictureInfoFlags flags, StdVideoH265PictureType pic_type, uint8 sps_video_parameter_set_id, uint8 pps_seq_parameter_set_id, uint8 pps_pic_parameter_set_id, uint8 short_term_ref_pic_set_idx, int32 PicOrderCntVal, uint8 TemporalId, uint8[7] reserved1, StdVideoEncodeH265ReferenceListsInfo* pRefLists, StdVideoH265ShortTermRefPicSet* pShortTermRefPicSet, StdVideoEncodeH265LongTermRefPics* pLongTermRefPics)
	{
		this.flags = flags;
		this.pic_type = pic_type;
		this.sps_video_parameter_set_id = sps_video_parameter_set_id;
		this.pps_seq_parameter_set_id = pps_seq_parameter_set_id;
		this.pps_pic_parameter_set_id = pps_pic_parameter_set_id;
		this.short_term_ref_pic_set_idx = short_term_ref_pic_set_idx;
		this.PicOrderCntVal = PicOrderCntVal;
		this.TemporalId = TemporalId;
		this.reserved1 = reserved1;
		this.pRefLists = pRefLists;
		this.pShortTermRefPicSet = pShortTermRefPicSet;
		this.pLongTermRefPics = pLongTermRefPics;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH265ReferenceInfoFlags
{
	[Bitfield(.Public, .Bits(1), "used_for_long_term_reference")] // A picture that is marked as "used for long-term reference", derived binary value from clause 8.3.2 Decoding process for reference picture set
	[Bitfield(.Public, .Bits(1), "unused_for_reference")] // A picture that is marked as "unused for reference", derived binary value from clause 8.3.2 Decoding process for reference picture set
	[Bitfield(.Public, .Bits(30), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 used_for_long_term_reference, uint32 unused_for_reference, uint32 reserved) : this()
	{
		this.used_for_long_term_reference = used_for_long_term_reference;
		this.unused_for_reference = unused_for_reference;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeH265ReferenceInfo
{
	public StdVideoEncodeH265ReferenceInfoFlags flags;
	public StdVideoH265PictureType pic_type;
	public int32 PicOrderCntVal; // Picture order count derived as specified in 8.3.1
	public uint8 TemporalId; // Temporal ID, as defined in 7.4.2.2

	public this(StdVideoEncodeH265ReferenceInfoFlags flags, StdVideoH265PictureType pic_type, int32 PicOrderCntVal, uint8 TemporalId)
	{
		this.flags = flags;
		this.pic_type = pic_type;
		this.PicOrderCntVal = PicOrderCntVal;
		this.TemporalId = TemporalId;
	}

	public this()
	{
		this = default;
	}
}

static { public const uint32 STD_VIDEO_VP9_NUM_REF_FRAMES = 8; }
static { public const uint32 STD_VIDEO_VP9_REFS_PER_FRAME = 3; }
static { public const uint32 STD_VIDEO_VP9_MAX_REF_FRAMES = 4; }
static { public const uint32 STD_VIDEO_VP9_LOOP_FILTER_ADJUSTMENTS = 2; }
static { public const uint32 STD_VIDEO_VP9_MAX_SEGMENTS = 8; }
static { public const uint32 STD_VIDEO_VP9_SEG_LVL_MAX = 4; }
static { public const uint32 STD_VIDEO_VP9_MAX_SEGMENTATION_TREE_PROBS = 7; }
static { public const uint32 STD_VIDEO_VP9_MAX_SEGMENTATION_PRED_PROB = 3; }

[AllowDuplicates] enum StdVideoVP9Profile : int32
{
	StdVideoVp9Profile0 = 0,
	StdVideoVp9Profile1 = 1,
	StdVideoVp9Profile2 = 2,
	StdVideoVp9Profile3 = 3,
	StdVideoVp9ProfileInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoVP9Level : int32
{
	StdVideoVp9Level10 = 0,
	StdVideoVp9Level11 = 1,
	StdVideoVp9Level20 = 2,
	StdVideoVp9Level21 = 3,
	StdVideoVp9Level30 = 4,
	StdVideoVp9Level31 = 5,
	StdVideoVp9Level40 = 6,
	StdVideoVp9Level41 = 7,
	StdVideoVp9Level50 = 8,
	StdVideoVp9Level51 = 9,
	StdVideoVp9Level52 = 10,
	StdVideoVp9Level60 = 11,
	StdVideoVp9Level61 = 12,
	StdVideoVp9Level62 = 13,
	StdVideoVp9LevelInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoVP9FrameType : int32
{
	StdVideoVp9FrameTypeKey = 0,
	StdVideoVp9FrameTypeNonKey = 1,
	StdVideoVp9FrameTypeInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoVP9ReferenceName : int32
{
	StdVideoVp9ReferenceNameIntraFrame = 0,
	StdVideoVp9ReferenceNameLastFrame = 1,
	StdVideoVp9ReferenceNameGoldenFrame = 2,
	StdVideoVp9ReferenceNameAltrefFrame = 3,
	StdVideoVp9ReferenceNameInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoVP9InterpolationFilter : int32
{
	StdVideoVp9InterpolationFilterEighttap = 0,
	StdVideoVp9InterpolationFilterEighttapSmooth = 1,
	StdVideoVp9InterpolationFilterEighttapSharp = 2,
	StdVideoVp9InterpolationFilterBilinear = 3,
	StdVideoVp9InterpolationFilterSwitchable = 4,
	StdVideoVp9InterpolationFilterInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoVP9ColorSpace : int32
{
	StdVideoVp9ColorSpaceUnknown = 0,
	StdVideoVp9ColorSpaceBt601 = 1,
	StdVideoVp9ColorSpaceBt709 = 2,
	StdVideoVp9ColorSpaceSmpte170 = 3,
	StdVideoVp9ColorSpaceSmpte240 = 4,
	StdVideoVp9ColorSpaceBt2020 = 5,
	StdVideoVp9ColorSpaceReserved = 6,
	StdVideoVp9ColorSpaceRgb = 7,
	StdVideoVp9ColorSpaceInvalid = 0x7FFFFFFF,
}

[CRepr] struct StdVideoVP9ColorConfigFlags
{
	// Syntax defined in section 6.2.2, semantics defined in section 7.2.2
	[Bitfield(.Public, .Bits(1), "color_range")]
	[Bitfield(.Public, .Bits(31), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 color_range, uint32 reserved) : this()
	{
		this.color_range = color_range;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoVP9ColorConfig
{
	// Syntax defined in section 6.2.2, semantics defined in section 7.2.2
	public StdVideoVP9ColorConfigFlags flags;
	public uint8 BitDepth;
	public uint8 subsampling_x;
	public uint8 subsampling_y;
	public uint8 reserved1; // Reserved for future use and must be initialized with 0.
	public StdVideoVP9ColorSpace color_space;

	public this(StdVideoVP9ColorConfigFlags flags, uint8 BitDepth, uint8 subsampling_x, uint8 subsampling_y, uint8 reserved1, StdVideoVP9ColorSpace color_space)
	{
		this.flags = flags;
		this.BitDepth = BitDepth;
		this.subsampling_x = subsampling_x;
		this.subsampling_y = subsampling_y;
		this.reserved1 = reserved1;
		this.color_space = color_space;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoVP9LoopFilterFlags
{
	// Syntax defined in section 6.2.8, semantics defined in section 7.2.8
	[Bitfield(.Public, .Bits(1), "loop_filter_delta_enabled")]
	[Bitfield(.Public, .Bits(1), "loop_filter_delta_update")]
	[Bitfield(.Public, .Bits(30), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 loop_filter_delta_enabled, uint32 loop_filter_delta_update, uint32 reserved) : this()
	{
		this.loop_filter_delta_enabled = loop_filter_delta_enabled;
		this.loop_filter_delta_update = loop_filter_delta_update;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoVP9LoopFilter
{
	// Syntax defined in section 6.2.8, semantics defined in section 7.2.8
	public StdVideoVP9LoopFilterFlags flags;
	public uint8 loop_filter_level;
	public uint8 loop_filter_sharpness;
	public uint8 update_ref_delta;
	public int8[STD_VIDEO_VP9_MAX_REF_FRAMES] loop_filter_ref_deltas;
	public uint8 update_mode_delta;
	public int8[STD_VIDEO_VP9_LOOP_FILTER_ADJUSTMENTS] loop_filter_mode_deltas;

	public this(StdVideoVP9LoopFilterFlags flags, uint8 loop_filter_level, uint8 loop_filter_sharpness, uint8 update_ref_delta, int8[STD_VIDEO_VP9_MAX_REF_FRAMES] loop_filter_ref_deltas, uint8 update_mode_delta, int8[STD_VIDEO_VP9_LOOP_FILTER_ADJUSTMENTS] loop_filter_mode_deltas)
	{
		this.flags = flags;
		this.loop_filter_level = loop_filter_level;
		this.loop_filter_sharpness = loop_filter_sharpness;
		this.update_ref_delta = update_ref_delta;
		this.loop_filter_ref_deltas = loop_filter_ref_deltas;
		this.update_mode_delta = update_mode_delta;
		this.loop_filter_mode_deltas = loop_filter_mode_deltas;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoVP9SegmentationFlags
{
	// Syntax defined in section 6.2.11, semantics defined in section 7.2.10
	[Bitfield(.Public, .Bits(1), "segmentation_update_map")]
	[Bitfield(.Public, .Bits(1), "segmentation_temporal_update")]
	[Bitfield(.Public, .Bits(1), "segmentation_update_data")]
	[Bitfield(.Public, .Bits(1), "segmentation_abs_or_delta_update")]
	[Bitfield(.Public, .Bits(28), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 segmentation_update_map, uint32 segmentation_temporal_update, uint32 segmentation_update_data, uint32 segmentation_abs_or_delta_update, uint32 reserved) : this()
	{
		this.segmentation_update_map = segmentation_update_map;
		this.segmentation_temporal_update = segmentation_temporal_update;
		this.segmentation_update_data = segmentation_update_data;
		this.segmentation_abs_or_delta_update = segmentation_abs_or_delta_update;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoVP9Segmentation
{
	// Syntax defined in section 6.2.11, semantics defined in section 7.2.10
	public StdVideoVP9SegmentationFlags flags;
	public uint8[STD_VIDEO_VP9_MAX_SEGMENTATION_TREE_PROBS] segmentation_tree_probs;
	public uint8[STD_VIDEO_VP9_MAX_SEGMENTATION_PRED_PROB] segmentation_pred_prob;
	public uint8[STD_VIDEO_VP9_MAX_SEGMENTS] FeatureEnabled;
	// Each element contains 4 (SEG_LVL_MAX) bits, one bit for each feature within the segment
	public int16[STD_VIDEO_VP9_MAX_SEGMENTS][STD_VIDEO_VP9_SEG_LVL_MAX] FeatureData;

	public this(StdVideoVP9SegmentationFlags flags, uint8[STD_VIDEO_VP9_MAX_SEGMENTATION_TREE_PROBS] segmentation_tree_probs, uint8[STD_VIDEO_VP9_MAX_SEGMENTATION_PRED_PROB] segmentation_pred_prob, uint8[STD_VIDEO_VP9_MAX_SEGMENTS] FeatureEnabled, int16[STD_VIDEO_VP9_MAX_SEGMENTS][STD_VIDEO_VP9_SEG_LVL_MAX] FeatureData)
	{
		this.flags = flags;
		this.segmentation_tree_probs = segmentation_tree_probs;
		this.segmentation_pred_prob = segmentation_pred_prob;
		this.FeatureEnabled = FeatureEnabled;
		this.FeatureData = FeatureData;
	}

	public this()
	{
		this = default;
	}
}

static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_API_VERSION_1_0_0 = VK_MAKE_VIDEO_STD_VERSION(1, 0, 0); }
static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_SPEC_VERSION = VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_API_VERSION_1_0_0; }
static { public const c_char* VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_vp9_decode"; }

[CRepr] struct StdVideoDecodeVP9PictureInfoFlags
{
	// Syntax defined in section 6.2, semantics defined in section 7.2
	[Bitfield(.Public, .Bits(1), "error_resilient_mode")]
	[Bitfield(.Public, .Bits(1), "intra_only")]
	[Bitfield(.Public, .Bits(1), "allow_high_precision_mv")]
	[Bitfield(.Public, .Bits(1), "refresh_frame_context")]
	[Bitfield(.Public, .Bits(1), "frame_parallel_decoding_mode")]
	[Bitfield(.Public, .Bits(1), "segmentation_enabled")]
	[Bitfield(.Public, .Bits(1), "show_frame")]
	[Bitfield(.Public, .Bits(1), "UsePrevFrameMvs")]
	[Bitfield(.Public, .Bits(24), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 error_resilient_mode, uint32 intra_only, uint32 allow_high_precision_mv, uint32 refresh_frame_context, uint32 frame_parallel_decoding_mode, uint32 segmentation_enabled, uint32 show_frame, uint32 UsePrevFrameMvs, uint32 reserved) : this()
	{
		this.error_resilient_mode = error_resilient_mode;
		this.intra_only = intra_only;
		this.allow_high_precision_mv = allow_high_precision_mv;
		this.refresh_frame_context = refresh_frame_context;
		this.frame_parallel_decoding_mode = frame_parallel_decoding_mode;
		this.segmentation_enabled = segmentation_enabled;
		this.show_frame = show_frame;
		this.UsePrevFrameMvs = UsePrevFrameMvs;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoDecodeVP9PictureInfo
{
	// Syntax defined in section 6.2, semantics defined in section 7.2
	public StdVideoDecodeVP9PictureInfoFlags flags;
	public StdVideoVP9Profile profile;
	public StdVideoVP9FrameType frame_type;
	public uint8 frame_context_idx;
	public uint8 reset_frame_context;
	public uint8 refresh_frame_flags;
	public uint8 ref_frame_sign_bias_mask;
	public StdVideoVP9InterpolationFilter interpolation_filter;
	public uint8 base_q_idx;
	public int8 delta_q_y_dc;
	public int8 delta_q_uv_dc;
	public int8 delta_q_uv_ac;
	public uint8 tile_cols_log2;
	public uint8 tile_rows_log2;
	public uint16[3] reserved1; // Reserved for future use and must be initialized with 0.
	public StdVideoVP9ColorConfig* pColorConfig;
	public StdVideoVP9LoopFilter* pLoopFilter;
	public StdVideoVP9Segmentation* pSegmentation;

	public this(StdVideoDecodeVP9PictureInfoFlags flags, StdVideoVP9Profile profile, StdVideoVP9FrameType frame_type, uint8 frame_context_idx, uint8 reset_frame_context, uint8 refresh_frame_flags, uint8 ref_frame_sign_bias_mask, StdVideoVP9InterpolationFilter interpolation_filter, uint8 base_q_idx, int8 delta_q_y_dc, int8 delta_q_uv_dc, int8 delta_q_uv_ac, uint8 tile_cols_log2, uint8 tile_rows_log2, uint16[3] reserved1, StdVideoVP9ColorConfig* pColorConfig, StdVideoVP9LoopFilter* pLoopFilter, StdVideoVP9Segmentation* pSegmentation)
	{
		this.flags = flags;
		this.profile = profile;
		this.frame_type = frame_type;
		this.frame_context_idx = frame_context_idx;
		this.reset_frame_context = reset_frame_context;
		this.refresh_frame_flags = refresh_frame_flags;
		this.ref_frame_sign_bias_mask = ref_frame_sign_bias_mask;
		this.interpolation_filter = interpolation_filter;
		this.base_q_idx = base_q_idx;
		this.delta_q_y_dc = delta_q_y_dc;
		this.delta_q_uv_dc = delta_q_uv_dc;
		this.delta_q_uv_ac = delta_q_uv_ac;
		this.tile_cols_log2 = tile_cols_log2;
		this.tile_rows_log2 = tile_rows_log2;
		this.reserved1 = reserved1;
		this.pColorConfig = pColorConfig;
		this.pLoopFilter = pLoopFilter;
		this.pSegmentation = pSegmentation;
	}

	public this()
	{
		this = default;
	}
}

static { public const uint32 STD_VIDEO_AV1_NUM_REF_FRAMES = 8; }
static { public const uint32 STD_VIDEO_AV1_REFS_PER_FRAME = 7; }
static { public const uint32 STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME = 8; }
static { public const uint32 STD_VIDEO_AV1_MAX_TILE_COLS = 64; }
static { public const uint32 STD_VIDEO_AV1_MAX_TILE_ROWS = 64; }
static { public const uint32 STD_VIDEO_AV1_MAX_SEGMENTS = 8; }
static { public const uint32 STD_VIDEO_AV1_SEG_LVL_MAX = 8; }
static { public const uint32 STD_VIDEO_AV1_PRIMARY_REF_NONE = 7; }
static { public const uint32 STD_VIDEO_AV1_SELECT_INTEGER_MV = 2; }
static { public const uint32 STD_VIDEO_AV1_SELECT_SCREEN_CONTENT_TOOLS = 2; }
static { public const uint32 STD_VIDEO_AV1_SKIP_MODE_FRAMES = 2; }
static { public const uint32 STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS = 4; }
static { public const uint32 STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS = 2; }
static { public const uint32 STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS = 8; }
static { public const uint32 STD_VIDEO_AV1_MAX_NUM_PLANES = 3; }
static { public const uint32 STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS = 6; }
static { public const uint32 STD_VIDEO_AV1_MAX_NUM_Y_POINTS = 14; }
static { public const uint32 STD_VIDEO_AV1_MAX_NUM_CB_POINTS = 10; }
static { public const uint32 STD_VIDEO_AV1_MAX_NUM_CR_POINTS = 10; }
static { public const uint32 STD_VIDEO_AV1_MAX_NUM_POS_LUMA = 24; }
static { public const uint32 STD_VIDEO_AV1_MAX_NUM_POS_CHROMA = 25; }

[AllowDuplicates] enum StdVideoAV1Profile : int32
{
	StdVideoAv1ProfileMain = 0,
	StdVideoAv1ProfileHigh = 1,
	StdVideoAv1ProfileProfessional = 2,
	StdVideoAv1ProfileInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoAV1Level : int32
{
	StdVideoAv1Level20 = 0,
	StdVideoAv1Level21 = 1,
	StdVideoAv1Level22 = 2,
	StdVideoAv1Level23 = 3,
	StdVideoAv1Level30 = 4,
	StdVideoAv1Level31 = 5,
	StdVideoAv1Level32 = 6,
	StdVideoAv1Level33 = 7,
	StdVideoAv1Level40 = 8,
	StdVideoAv1Level41 = 9,
	StdVideoAv1Level42 = 10,
	StdVideoAv1Level43 = 11,
	StdVideoAv1Level50 = 12,
	StdVideoAv1Level51 = 13,
	StdVideoAv1Level52 = 14,
	StdVideoAv1Level53 = 15,
	StdVideoAv1Level60 = 16,
	StdVideoAv1Level61 = 17,
	StdVideoAv1Level62 = 18,
	StdVideoAv1Level63 = 19,
	StdVideoAv1Level70 = 20,
	StdVideoAv1Level71 = 21,
	StdVideoAv1Level72 = 22,
	StdVideoAv1Level73 = 23,
	StdVideoAv1LevelInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoAV1FrameType : int32
{
	StdVideoAv1FrameTypeKey = 0,
	StdVideoAv1FrameTypeInter = 1,
	StdVideoAv1FrameTypeIntraOnly = 2,
	StdVideoAv1FrameTypeSwitch = 3,
	StdVideoAv1FrameTypeInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoAV1ReferenceName : int32
{
	StdVideoAv1ReferenceNameIntraFrame = 0,
	StdVideoAv1ReferenceNameLastFrame = 1,
	StdVideoAv1ReferenceNameLast2Frame = 2,
	StdVideoAv1ReferenceNameLast3Frame = 3,
	StdVideoAv1ReferenceNameGoldenFrame = 4,
	StdVideoAv1ReferenceNameBwdrefFrame = 5,
	StdVideoAv1ReferenceNameAltref2Frame = 6,
	StdVideoAv1ReferenceNameAltrefFrame = 7,
	StdVideoAv1ReferenceNameInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoAV1InterpolationFilter : int32
{
	StdVideoAv1InterpolationFilterEighttap = 0,
	StdVideoAv1InterpolationFilterEighttapSmooth = 1,
	StdVideoAv1InterpolationFilterEighttapSharp = 2,
	StdVideoAv1InterpolationFilterBilinear = 3,
	StdVideoAv1InterpolationFilterSwitchable = 4,
	StdVideoAv1InterpolationFilterInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoAV1TxMode : int32
{
	StdVideoAv1TxModeOnly4x4 = 0,
	StdVideoAv1TxModeLargest = 1,
	StdVideoAv1TxModeSelect = 2,
	StdVideoAv1TxModeInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoAV1FrameRestorationType : int32
{
	StdVideoAv1FrameRestorationTypeNone = 0,
	StdVideoAv1FrameRestorationTypeWiener = 1,
	StdVideoAv1FrameRestorationTypeSgrproj = 2,
	StdVideoAv1FrameRestorationTypeSwitchable = 3,
	StdVideoAv1FrameRestorationTypeInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoAV1ColorPrimaries : int32
{
	StdVideoAv1ColorPrimariesBt709 = 1,
	StdVideoAv1ColorPrimariesUnspecified = 2,
	StdVideoAv1ColorPrimariesBtUnspecified = StdVideoAv1ColorPrimariesUnspecified,
	StdVideoAv1ColorPrimariesBt470M = 4,
	StdVideoAv1ColorPrimariesBt470BG = 5,
	StdVideoAv1ColorPrimariesBt601 = 6,
	StdVideoAv1ColorPrimariesSmpte240 = 7,
	StdVideoAv1ColorPrimariesGenericFilm = 8,
	StdVideoAv1ColorPrimariesBt2020 = 9,
	StdVideoAv1ColorPrimariesXyz = 10,
	StdVideoAv1ColorPrimariesSmpte431 = 11,
	StdVideoAv1ColorPrimariesSmpte432 = 12,
	StdVideoAv1ColorPrimariesEbu3213 = 22,
	StdVideoAv1ColorPrimariesInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoAV1TransferCharacteristics : int32
{
	StdVideoAv1TransferCharacteristicsReserved0 = 0,
	StdVideoAv1TransferCharacteristicsBt709 = 1,
	StdVideoAv1TransferCharacteristicsUnspecified = 2,
	StdVideoAv1TransferCharacteristicsReserved3 = 3,
	StdVideoAv1TransferCharacteristicsBt470M = 4,
	StdVideoAv1TransferCharacteristicsBt470BG = 5,
	StdVideoAv1TransferCharacteristicsBt601 = 6,
	StdVideoAv1TransferCharacteristicsSmpte240 = 7,
	StdVideoAv1TransferCharacteristicsLinear = 8,
	StdVideoAv1TransferCharacteristicsLog100 = 9,
	StdVideoAv1TransferCharacteristicsLog100Sqrt10 = 10,
	StdVideoAv1TransferCharacteristicsIec61966 = 11,
	StdVideoAv1TransferCharacteristicsBt1361 = 12,
	StdVideoAv1TransferCharacteristicsSrgb = 13,
	StdVideoAv1TransferCharacteristicsBt202010 = 14,
	StdVideoAv1TransferCharacteristicsBt202012 = 15,
	StdVideoAv1TransferCharacteristicsSmpte2084 = 16,
	StdVideoAv1TransferCharacteristicsSmpte428 = 17,
	StdVideoAv1TransferCharacteristicsHlg = 18,
	StdVideoAv1TransferCharacteristicsInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoAV1MatrixCoefficients : int32
{
	StdVideoAv1MatrixCoefficientsIdentity = 0,
	StdVideoAv1MatrixCoefficientsBt709 = 1,
	StdVideoAv1MatrixCoefficientsUnspecified = 2,
	StdVideoAv1MatrixCoefficientsReserved3 = 3,
	StdVideoAv1MatrixCoefficientsFcc = 4,
	StdVideoAv1MatrixCoefficientsBt470BG = 5,
	StdVideoAv1MatrixCoefficientsBt601 = 6,
	StdVideoAv1MatrixCoefficientsSmpte240 = 7,
	StdVideoAv1MatrixCoefficientsSmpteYcgco = 8,
	StdVideoAv1MatrixCoefficientsBt2020Ncl = 9,
	StdVideoAv1MatrixCoefficientsBt2020Cl = 10,
	StdVideoAv1MatrixCoefficientsSmpte2085 = 11,
	StdVideoAv1MatrixCoefficientsChromatNcl = 12,
	StdVideoAv1MatrixCoefficientsChromatCl = 13,
	StdVideoAv1MatrixCoefficientsIctcp = 14,
	StdVideoAv1MatrixCoefficientsInvalid = 0x7FFFFFFF,
}

[AllowDuplicates] enum StdVideoAV1ChromaSamplePosition : int32
{
	StdVideoAv1ChromaSamplePositionUnknown = 0,
	StdVideoAv1ChromaSamplePositionVertical = 1,
	StdVideoAv1ChromaSamplePositionColocated = 2,
	StdVideoAv1ChromaSamplePositionReserved = 3,
	StdVideoAv1ChromaSamplePositionInvalid = 0x7FFFFFFF,
}

[CRepr] struct StdVideoAV1ColorConfigFlags
{
	// Syntax defined in section 5.5.2, semantics defined in section 6.4.2
	[Bitfield(.Public, .Bits(1), "mono_chrome")]
	[Bitfield(.Public, .Bits(1), "color_range")]
	[Bitfield(.Public, .Bits(1), "separate_uv_delta_q")]
	[Bitfield(.Public, .Bits(1), "color_description_present_flag")]
	[Bitfield(.Public, .Bits(28), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 mono_chrome, uint32 color_range, uint32 separate_uv_delta_q, uint32 color_description_present_flag, uint32 reserved) : this()
	{
		this.mono_chrome = mono_chrome;
		this.color_range = color_range;
		this.separate_uv_delta_q = separate_uv_delta_q;
		this.color_description_present_flag = color_description_present_flag;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1ColorConfig
{
	// Syntax defined in section 5.5.2, semantics defined in section 6.4.2
	public StdVideoAV1ColorConfigFlags flags;
	public uint8 BitDepth;
	public uint8 subsampling_x;
	public uint8 subsampling_y;
	public uint8 reserved1; // Reserved for future use and must be initialized with 0.
	public StdVideoAV1ColorPrimaries color_primaries;
	public StdVideoAV1TransferCharacteristics transfer_characteristics;
	public StdVideoAV1MatrixCoefficients matrix_coefficients;
	public StdVideoAV1ChromaSamplePosition chroma_sample_position;

	public this(StdVideoAV1ColorConfigFlags flags, uint8 BitDepth, uint8 subsampling_x, uint8 subsampling_y, uint8 reserved1, StdVideoAV1ColorPrimaries color_primaries, StdVideoAV1TransferCharacteristics transfer_characteristics, StdVideoAV1MatrixCoefficients matrix_coefficients, StdVideoAV1ChromaSamplePosition chroma_sample_position)
	{
		this.flags = flags;
		this.BitDepth = BitDepth;
		this.subsampling_x = subsampling_x;
		this.subsampling_y = subsampling_y;
		this.reserved1 = reserved1;
		this.color_primaries = color_primaries;
		this.transfer_characteristics = transfer_characteristics;
		this.matrix_coefficients = matrix_coefficients;
		this.chroma_sample_position = chroma_sample_position;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1TimingInfoFlags
{
	// Syntax defined in section 5.5.3, semantics defined in section 6.4.3
	[Bitfield(.Public, .Bits(1), "equal_picture_interval")]
	[Bitfield(.Public, .Bits(31), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 equal_picture_interval, uint32 reserved) : this()
	{
		this.equal_picture_interval = equal_picture_interval;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1TimingInfo
{
	// Syntax defined in section 5.5.3, semantics defined in section 6.4.3
	public StdVideoAV1TimingInfoFlags flags;
	public uint32 num_units_in_display_tick;
	public uint32 time_scale;
	public uint32 num_ticks_per_picture_minus_1;

	public this(StdVideoAV1TimingInfoFlags flags, uint32 num_units_in_display_tick, uint32 time_scale, uint32 num_ticks_per_picture_minus_1)
	{
		this.flags = flags;
		this.num_units_in_display_tick = num_units_in_display_tick;
		this.time_scale = time_scale;
		this.num_ticks_per_picture_minus_1 = num_ticks_per_picture_minus_1;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1LoopFilterFlags
{
	// Syntax defined in section 5.9.11, semantics defined in section 6.8.10
	[Bitfield(.Public, .Bits(1), "loop_filter_delta_enabled")]
	[Bitfield(.Public, .Bits(1), "loop_filter_delta_update")]
	[Bitfield(.Public, .Bits(30), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 loop_filter_delta_enabled, uint32 loop_filter_delta_update, uint32 reserved) : this()
	{
		this.loop_filter_delta_enabled = loop_filter_delta_enabled;
		this.loop_filter_delta_update = loop_filter_delta_update;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1LoopFilter
{
	// Syntax defined in section 5.9.11, semantics defined in section 6.8.10
	public StdVideoAV1LoopFilterFlags flags;
	public uint8[STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS] loop_filter_level;
	public uint8 loop_filter_sharpness;
	public uint8 update_ref_delta;
	public int8[STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME] loop_filter_ref_deltas;
	public uint8 update_mode_delta;
	public int8[STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS] loop_filter_mode_deltas;

	public this(StdVideoAV1LoopFilterFlags flags, uint8[STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS] loop_filter_level, uint8 loop_filter_sharpness, uint8 update_ref_delta, int8[STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME] loop_filter_ref_deltas, uint8 update_mode_delta, int8[STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS] loop_filter_mode_deltas)
	{
		this.flags = flags;
		this.loop_filter_level = loop_filter_level;
		this.loop_filter_sharpness = loop_filter_sharpness;
		this.update_ref_delta = update_ref_delta;
		this.loop_filter_ref_deltas = loop_filter_ref_deltas;
		this.update_mode_delta = update_mode_delta;
		this.loop_filter_mode_deltas = loop_filter_mode_deltas;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1QuantizationFlags
{
	// Syntax defined in section 5.9.12, semantics defined in section 6.8.11
	[Bitfield(.Public, .Bits(1), "using_qmatrix")]
	[Bitfield(.Public, .Bits(1), "diff_uv_delta")]
	[Bitfield(.Public, .Bits(30), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 using_qmatrix, uint32 diff_uv_delta, uint32 reserved) : this()
	{
		this.using_qmatrix = using_qmatrix;
		this.diff_uv_delta = diff_uv_delta;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1Quantization
{
	// Syntax defined in section 5.9.12, semantics defined in section 6.8.11
	public StdVideoAV1QuantizationFlags flags;
	public uint8 base_q_idx;
	public int8 DeltaQYDc;
	public int8 DeltaQUDc;
	public int8 DeltaQUAc;
	public int8 DeltaQVDc;
	public int8 DeltaQVAc;
	public uint8 qm_y;
	public uint8 qm_u;
	public uint8 qm_v;

	public this(StdVideoAV1QuantizationFlags flags, uint8 base_q_idx, int8 DeltaQYDc, int8 DeltaQUDc, int8 DeltaQUAc, int8 DeltaQVDc, int8 DeltaQVAc, uint8 qm_y, uint8 qm_u, uint8 qm_v)
	{
		this.flags = flags;
		this.base_q_idx = base_q_idx;
		this.DeltaQYDc = DeltaQYDc;
		this.DeltaQUDc = DeltaQUDc;
		this.DeltaQUAc = DeltaQUAc;
		this.DeltaQVDc = DeltaQVDc;
		this.DeltaQVAc = DeltaQVAc;
		this.qm_y = qm_y;
		this.qm_u = qm_u;
		this.qm_v = qm_v;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1Segmentation
{
	// Syntax defined in section 5.9.14, semantics defined in section 6.8.13
	public uint8[STD_VIDEO_AV1_MAX_SEGMENTS] FeatureEnabled; // Each element contains 8 (SEG_LVL_MAX) bits, one bit for each feature within the segment
	public int16[STD_VIDEO_AV1_MAX_SEGMENTS][STD_VIDEO_AV1_SEG_LVL_MAX] FeatureData;

	public this(uint8[STD_VIDEO_AV1_MAX_SEGMENTS] FeatureEnabled, int16[STD_VIDEO_AV1_MAX_SEGMENTS][STD_VIDEO_AV1_SEG_LVL_MAX] FeatureData)
	{
		this.FeatureEnabled = FeatureEnabled;
		this.FeatureData = FeatureData;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1TileInfoFlags
{
	// Syntax defined in section 5.9.15, semantics defined in section 6.8.14
	[Bitfield(.Public, .Bits(1), "uniform_tile_spacing_flag")]
	[Bitfield(.Public, .Bits(31), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 uniform_tile_spacing_flag, uint32 reserved) : this()
	{
		this.uniform_tile_spacing_flag = uniform_tile_spacing_flag;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1TileInfo
{
	// Syntax defined in section 5.9.15, semantics defined in section 6.8.14
	public StdVideoAV1TileInfoFlags flags;
	public uint8 TileCols;
	public uint8 TileRows;
	public uint16 context_update_tile_id;
	public uint8 tile_size_bytes_minus_1;
	public uint8[7] reserved1; // Reserved for future use and must be initialized with 0.
	public uint16* pMiColStarts; // TileCols number of elements
	public uint16* pMiRowStarts; // TileRows number of elements
	public uint16* pWidthInSbsMinus1; // TileCols number of elements
	public uint16* pHeightInSbsMinus1; // TileRows number of elements

	public this(StdVideoAV1TileInfoFlags flags, uint8 TileCols, uint8 TileRows, uint16 context_update_tile_id, uint8 tile_size_bytes_minus_1, uint8[7] reserved1, uint16* pMiColStarts, uint16* pMiRowStarts, uint16* pWidthInSbsMinus1, uint16* pHeightInSbsMinus1)
	{
		this.flags = flags;
		this.TileCols = TileCols;
		this.TileRows = TileRows;
		this.context_update_tile_id = context_update_tile_id;
		this.tile_size_bytes_minus_1 = tile_size_bytes_minus_1;
		this.reserved1 = reserved1;
		this.pMiColStarts = pMiColStarts;
		this.pMiRowStarts = pMiRowStarts;
		this.pWidthInSbsMinus1 = pWidthInSbsMinus1;
		this.pHeightInSbsMinus1 = pHeightInSbsMinus1;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1CDEF
{
	// Syntax defined in section 5.9.19, semantics defined in section 6.10.14
	public uint8 cdef_damping_minus_3;
	public uint8 cdef_bits;
	public uint8[STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS] cdef_y_pri_strength;
	public uint8[STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS] cdef_y_sec_strength;
	public uint8[STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS] cdef_uv_pri_strength;
	public uint8[STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS] cdef_uv_sec_strength;

	public this(uint8 cdef_damping_minus_3, uint8 cdef_bits, uint8[STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS] cdef_y_pri_strength, uint8[STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS] cdef_y_sec_strength, uint8[STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS] cdef_uv_pri_strength, uint8[STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS] cdef_uv_sec_strength)
	{
		this.cdef_damping_minus_3 = cdef_damping_minus_3;
		this.cdef_bits = cdef_bits;
		this.cdef_y_pri_strength = cdef_y_pri_strength;
		this.cdef_y_sec_strength = cdef_y_sec_strength;
		this.cdef_uv_pri_strength = cdef_uv_pri_strength;
		this.cdef_uv_sec_strength = cdef_uv_sec_strength;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1LoopRestoration
{
	// Syntax defined in section 5.9.20, semantics defined in section 6.10.15
	public StdVideoAV1FrameRestorationType[STD_VIDEO_AV1_MAX_NUM_PLANES] FrameRestorationType;
	public uint16[STD_VIDEO_AV1_MAX_NUM_PLANES] LoopRestorationSize;

	public this(StdVideoAV1FrameRestorationType[STD_VIDEO_AV1_MAX_NUM_PLANES] FrameRestorationType, uint16[STD_VIDEO_AV1_MAX_NUM_PLANES] LoopRestorationSize)
	{
		this.FrameRestorationType = FrameRestorationType;
		this.LoopRestorationSize = LoopRestorationSize;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1GlobalMotion
{
	// Syntax defined in section 5.9.24, semantics defined in section 7.10
	public uint8[STD_VIDEO_AV1_NUM_REF_FRAMES] GmType;
	public int32[STD_VIDEO_AV1_NUM_REF_FRAMES][STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS] gm_params;

	public this(uint8[STD_VIDEO_AV1_NUM_REF_FRAMES] GmType, int32[STD_VIDEO_AV1_NUM_REF_FRAMES][STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS] gm_params)
	{
		this.GmType = GmType;
		this.gm_params = gm_params;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1FilmGrainFlags
{
	// Syntax defined in section 5.9.30, semantics defined in section 6.8.20
	[Bitfield(.Public, .Bits(1), "chroma_scaling_from_luma")]
	[Bitfield(.Public, .Bits(1), "overlap_flag")]
	[Bitfield(.Public, .Bits(1), "clip_to_restricted_range")]
	[Bitfield(.Public, .Bits(1), "update_grain")]
	[Bitfield(.Public, .Bits(28), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 chroma_scaling_from_luma, uint32 overlap_flag, uint32 clip_to_restricted_range, uint32 update_grain, uint32 reserved) : this()
	{
		this.chroma_scaling_from_luma = chroma_scaling_from_luma;
		this.overlap_flag = overlap_flag;
		this.clip_to_restricted_range = clip_to_restricted_range;
		this.update_grain = update_grain;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1FilmGrain
{
	// Syntax defined in section 5.9.30, semantics defined in section 6.8.20
	public StdVideoAV1FilmGrainFlags flags;
	public uint8 grain_scaling_minus_8;
	public uint8 ar_coeff_lag;
	public uint8 ar_coeff_shift_minus_6;
	public uint8 grain_scale_shift;
	public uint16 grain_seed;
	public uint8 film_grain_params_ref_idx;
	public uint8 num_y_points;
	public uint8[STD_VIDEO_AV1_MAX_NUM_Y_POINTS] point_y_value;
	public uint8[STD_VIDEO_AV1_MAX_NUM_Y_POINTS] point_y_scaling;
	public uint8 num_cb_points;
	public uint8[STD_VIDEO_AV1_MAX_NUM_CB_POINTS] point_cb_value;
	public uint8[STD_VIDEO_AV1_MAX_NUM_CB_POINTS] point_cb_scaling;
	public uint8 num_cr_points;
	public uint8[STD_VIDEO_AV1_MAX_NUM_CR_POINTS] point_cr_value;
	public uint8[STD_VIDEO_AV1_MAX_NUM_CR_POINTS] point_cr_scaling;
	public int8[STD_VIDEO_AV1_MAX_NUM_POS_LUMA] ar_coeffs_y_plus_128;
	public int8[STD_VIDEO_AV1_MAX_NUM_POS_CHROMA] ar_coeffs_cb_plus_128;
	public int8[STD_VIDEO_AV1_MAX_NUM_POS_CHROMA] ar_coeffs_cr_plus_128;
	public uint8 cb_mult;
	public uint8 cb_luma_mult;
	public uint16 cb_offset;
	public uint8 cr_mult;
	public uint8 cr_luma_mult;
	public uint16 cr_offset;

	public this(StdVideoAV1FilmGrainFlags flags, uint8 grain_scaling_minus_8, uint8 ar_coeff_lag, uint8 ar_coeff_shift_minus_6, uint8 grain_scale_shift, uint16 grain_seed, uint8 film_grain_params_ref_idx, uint8 num_y_points, uint8[STD_VIDEO_AV1_MAX_NUM_Y_POINTS] point_y_value, uint8[STD_VIDEO_AV1_MAX_NUM_Y_POINTS] point_y_scaling, uint8 num_cb_points, uint8[STD_VIDEO_AV1_MAX_NUM_CB_POINTS] point_cb_value, uint8[STD_VIDEO_AV1_MAX_NUM_CB_POINTS] point_cb_scaling, uint8 num_cr_points, uint8[STD_VIDEO_AV1_MAX_NUM_CR_POINTS] point_cr_value, uint8[STD_VIDEO_AV1_MAX_NUM_CR_POINTS] point_cr_scaling, int8[STD_VIDEO_AV1_MAX_NUM_POS_LUMA] ar_coeffs_y_plus_128, int8[STD_VIDEO_AV1_MAX_NUM_POS_CHROMA] ar_coeffs_cb_plus_128, int8[STD_VIDEO_AV1_MAX_NUM_POS_CHROMA] ar_coeffs_cr_plus_128, uint8 cb_mult, uint8 cb_luma_mult, uint16 cb_offset, uint8 cr_mult, uint8 cr_luma_mult, uint16 cr_offset)
	{
		this.flags = flags;
		this.grain_scaling_minus_8 = grain_scaling_minus_8;
		this.ar_coeff_lag = ar_coeff_lag;
		this.ar_coeff_shift_minus_6 = ar_coeff_shift_minus_6;
		this.grain_scale_shift = grain_scale_shift;
		this.grain_seed = grain_seed;
		this.film_grain_params_ref_idx = film_grain_params_ref_idx;
		this.num_y_points = num_y_points;
		this.point_y_value = point_y_value;
		this.point_y_scaling = point_y_scaling;
		this.num_cb_points = num_cb_points;
		this.point_cb_value = point_cb_value;
		this.point_cb_scaling = point_cb_scaling;
		this.num_cr_points = num_cr_points;
		this.point_cr_value = point_cr_value;
		this.point_cr_scaling = point_cr_scaling;
		this.ar_coeffs_y_plus_128 = ar_coeffs_y_plus_128;
		this.ar_coeffs_cb_plus_128 = ar_coeffs_cb_plus_128;
		this.ar_coeffs_cr_plus_128 = ar_coeffs_cr_plus_128;
		this.cb_mult = cb_mult;
		this.cb_luma_mult = cb_luma_mult;
		this.cb_offset = cb_offset;
		this.cr_mult = cr_mult;
		this.cr_luma_mult = cr_luma_mult;
		this.cr_offset = cr_offset;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1SequenceHeaderFlags
{
	// Syntax defined in section 5.5, semantics defined in section 6.4
	[Bitfield(.Public, .Bits(1), "still_picture")]
	[Bitfield(.Public, .Bits(1), "reduced_still_picture_header")]
	[Bitfield(.Public, .Bits(1), "use_128x128_superblock")]
	[Bitfield(.Public, .Bits(1), "enable_filter_intra")]
	[Bitfield(.Public, .Bits(1), "enable_intra_edge_filter")]
	[Bitfield(.Public, .Bits(1), "enable_interintra_compound")]
	[Bitfield(.Public, .Bits(1), "enable_masked_compound")]
	[Bitfield(.Public, .Bits(1), "enable_warped_motion")]
	[Bitfield(.Public, .Bits(1), "enable_dual_filter")]
	[Bitfield(.Public, .Bits(1), "enable_order_hint")]
	[Bitfield(.Public, .Bits(1), "enable_jnt_comp")]
	[Bitfield(.Public, .Bits(1), "enable_ref_frame_mvs")]
	[Bitfield(.Public, .Bits(1), "frame_id_numbers_present_flag")]
	[Bitfield(.Public, .Bits(1), "enable_superres")]
	[Bitfield(.Public, .Bits(1), "enable_cdef")]
	[Bitfield(.Public, .Bits(1), "enable_restoration")]
	[Bitfield(.Public, .Bits(1), "film_grain_params_present")]
	[Bitfield(.Public, .Bits(1), "timing_info_present_flag")]
	[Bitfield(.Public, .Bits(1), "initial_display_delay_present_flag")]
	[Bitfield(.Public, .Bits(13), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 still_picture, uint32 reduced_still_picture_header, uint32 use_128x128_superblock, uint32 enable_filter_intra, uint32 enable_intra_edge_filter, uint32 enable_interintra_compound, uint32 enable_masked_compound, uint32 enable_warped_motion, uint32 enable_dual_filter, uint32 enable_order_hint, uint32 enable_jnt_comp, uint32 enable_ref_frame_mvs, uint32 frame_id_numbers_present_flag, uint32 enable_superres, uint32 enable_cdef, uint32 enable_restoration, uint32 film_grain_params_present, uint32 timing_info_present_flag, uint32 initial_display_delay_present_flag, uint32 reserved) : this()
	{
		this.still_picture = still_picture;
		this.reduced_still_picture_header = reduced_still_picture_header;
		this.use_128x128_superblock = use_128x128_superblock;
		this.enable_filter_intra = enable_filter_intra;
		this.enable_intra_edge_filter = enable_intra_edge_filter;
		this.enable_interintra_compound = enable_interintra_compound;
		this.enable_masked_compound = enable_masked_compound;
		this.enable_warped_motion = enable_warped_motion;
		this.enable_dual_filter = enable_dual_filter;
		this.enable_order_hint = enable_order_hint;
		this.enable_jnt_comp = enable_jnt_comp;
		this.enable_ref_frame_mvs = enable_ref_frame_mvs;
		this.frame_id_numbers_present_flag = frame_id_numbers_present_flag;
		this.enable_superres = enable_superres;
		this.enable_cdef = enable_cdef;
		this.enable_restoration = enable_restoration;
		this.film_grain_params_present = film_grain_params_present;
		this.timing_info_present_flag = timing_info_present_flag;
		this.initial_display_delay_present_flag = initial_display_delay_present_flag;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoAV1SequenceHeader
{
	// Syntax defined in section 5.5, semantics defined in section 6.4
	public StdVideoAV1SequenceHeaderFlags flags;
	public StdVideoAV1Profile seq_profile;
	public uint8 frame_width_bits_minus_1;
	public uint8 frame_height_bits_minus_1;
	public uint16 max_frame_width_minus_1;
	public uint16 max_frame_height_minus_1;
	public uint8 delta_frame_id_length_minus_2;
	public uint8 additional_frame_id_length_minus_1;
	public uint8 order_hint_bits_minus_1;
	public uint8 seq_force_integer_mv; // The final value of of seq_force_integer_mv per the value of seq_choose_integer_mv.
	public uint8 seq_force_screen_content_tools; // The final value of of seq_force_screen_content_tools per the value of seq_choose_screen_content_tools.
	public uint8[5] reserved1; // Reserved for future use and must be initialized with 0.
	public StdVideoAV1ColorConfig* pColorConfig;
	public StdVideoAV1TimingInfo* pTimingInfo;

	public this(StdVideoAV1SequenceHeaderFlags flags, StdVideoAV1Profile seq_profile, uint8 frame_width_bits_minus_1, uint8 frame_height_bits_minus_1, uint16 max_frame_width_minus_1, uint16 max_frame_height_minus_1, uint8 delta_frame_id_length_minus_2, uint8 additional_frame_id_length_minus_1, uint8 order_hint_bits_minus_1, uint8 seq_force_integer_mv, uint8 seq_force_screen_content_tools, uint8[5] reserved1, StdVideoAV1ColorConfig* pColorConfig, StdVideoAV1TimingInfo* pTimingInfo)
	{
		this.flags = flags;
		this.seq_profile = seq_profile;
		this.frame_width_bits_minus_1 = frame_width_bits_minus_1;
		this.frame_height_bits_minus_1 = frame_height_bits_minus_1;
		this.max_frame_width_minus_1 = max_frame_width_minus_1;
		this.max_frame_height_minus_1 = max_frame_height_minus_1;
		this.delta_frame_id_length_minus_2 = delta_frame_id_length_minus_2;
		this.additional_frame_id_length_minus_1 = additional_frame_id_length_minus_1;
		this.order_hint_bits_minus_1 = order_hint_bits_minus_1;
		this.seq_force_integer_mv = seq_force_integer_mv;
		this.seq_force_screen_content_tools = seq_force_screen_content_tools;
		this.reserved1 = reserved1;
		this.pColorConfig = pColorConfig;
		this.pTimingInfo = pTimingInfo;
	}

	public this()
	{
		this = default;
	}
}

static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0 = VK_MAKE_VIDEO_STD_VERSION(1, 0, 0); }
static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_SPEC_VERSION = VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0; }
static { public const c_char* VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_av1_decode"; }

[CRepr] struct StdVideoDecodeAV1PictureInfoFlags
{
	// Syntax defined in section 5.9, semantics defined in section 6.8
	[Bitfield(.Public, .Bits(1), "error_resilient_mode")]
	[Bitfield(.Public, .Bits(1), "disable_cdf_update")]
	[Bitfield(.Public, .Bits(1), "use_superres")]
	[Bitfield(.Public, .Bits(1), "render_and_frame_size_different")]
	[Bitfield(.Public, .Bits(1), "allow_screen_content_tools")]
	[Bitfield(.Public, .Bits(1), "is_filter_switchable")]
	[Bitfield(.Public, .Bits(1), "force_integer_mv")]
	[Bitfield(.Public, .Bits(1), "frame_size_override_flag")]
	[Bitfield(.Public, .Bits(1), "buffer_removal_time_present_flag")]
	[Bitfield(.Public, .Bits(1), "allow_intrabc")]
	[Bitfield(.Public, .Bits(1), "frame_refs_short_signaling")]
	[Bitfield(.Public, .Bits(1), "allow_high_precision_mv")]
	[Bitfield(.Public, .Bits(1), "is_motion_mode_switchable")]
	[Bitfield(.Public, .Bits(1), "use_ref_frame_mvs")]
	[Bitfield(.Public, .Bits(1), "disable_frame_end_update_cdf")]
	[Bitfield(.Public, .Bits(1), "allow_warped_motion")]
	[Bitfield(.Public, .Bits(1), "reduced_tx_set")]
	[Bitfield(.Public, .Bits(1), "reference_select")]
	[Bitfield(.Public, .Bits(1), "skip_mode_present")]
	[Bitfield(.Public, .Bits(1), "delta_q_present")]
	[Bitfield(.Public, .Bits(1), "delta_lf_present")]
	[Bitfield(.Public, .Bits(1), "delta_lf_multi")]
	[Bitfield(.Public, .Bits(1), "segmentation_enabled")]
	[Bitfield(.Public, .Bits(1), "segmentation_update_map")]
	[Bitfield(.Public, .Bits(1), "segmentation_temporal_update")]
	[Bitfield(.Public, .Bits(1), "segmentation_update_data")]
	[Bitfield(.Public, .Bits(1), "UsesLr")]
	[Bitfield(.Public, .Bits(1), "usesChromaLr")]
	[Bitfield(.Public, .Bits(1), "apply_grain")]
	[Bitfield(.Public, .Bits(3), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 error_resilient_mode, uint32 disable_cdf_update, uint32 use_superres, uint32 render_and_frame_size_different, uint32 allow_screen_content_tools, uint32 is_filter_switchable, uint32 force_integer_mv, uint32 frame_size_override_flag, uint32 buffer_removal_time_present_flag, uint32 allow_intrabc, uint32 frame_refs_short_signaling, uint32 allow_high_precision_mv, uint32 is_motion_mode_switchable, uint32 use_ref_frame_mvs, uint32 disable_frame_end_update_cdf, uint32 allow_warped_motion, uint32 reduced_tx_set, uint32 reference_select, uint32 skip_mode_present, uint32 delta_q_present, uint32 delta_lf_present, uint32 delta_lf_multi, uint32 segmentation_enabled, uint32 segmentation_update_map, uint32 segmentation_temporal_update, uint32 segmentation_update_data, uint32 UsesLr, uint32 usesChromaLr, uint32 apply_grain, uint32 reserved) : this()
	{
		this.error_resilient_mode = error_resilient_mode;
		this.disable_cdf_update = disable_cdf_update;
		this.use_superres = use_superres;
		this.render_and_frame_size_different = render_and_frame_size_different;
		this.allow_screen_content_tools = allow_screen_content_tools;
		this.is_filter_switchable = is_filter_switchable;
		this.force_integer_mv = force_integer_mv;
		this.frame_size_override_flag = frame_size_override_flag;
		this.buffer_removal_time_present_flag = buffer_removal_time_present_flag;
		this.allow_intrabc = allow_intrabc;
		this.frame_refs_short_signaling = frame_refs_short_signaling;
		this.allow_high_precision_mv = allow_high_precision_mv;
		this.is_motion_mode_switchable = is_motion_mode_switchable;
		this.use_ref_frame_mvs = use_ref_frame_mvs;
		this.disable_frame_end_update_cdf = disable_frame_end_update_cdf;
		this.allow_warped_motion = allow_warped_motion;
		this.reduced_tx_set = reduced_tx_set;
		this.reference_select = reference_select;
		this.skip_mode_present = skip_mode_present;
		this.delta_q_present = delta_q_present;
		this.delta_lf_present = delta_lf_present;
		this.delta_lf_multi = delta_lf_multi;
		this.segmentation_enabled = segmentation_enabled;
		this.segmentation_update_map = segmentation_update_map;
		this.segmentation_temporal_update = segmentation_temporal_update;
		this.segmentation_update_data = segmentation_update_data;
		this.UsesLr = UsesLr;
		this.usesChromaLr = usesChromaLr;
		this.apply_grain = apply_grain;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoDecodeAV1PictureInfo
{
	// Syntax defined in sections 5.9 and 5.11.1, semantics defined in sections 6.8 and 6.10.1
	public StdVideoDecodeAV1PictureInfoFlags flags;
	public StdVideoAV1FrameType frame_type;
	public uint32 current_frame_id;
	public uint8 OrderHint;
	public uint8 primary_ref_frame;
	public uint8 refresh_frame_flags;
	public uint8 reserved1; // Reserved for future use and must be initialized with 0.
	public StdVideoAV1InterpolationFilter interpolation_filter;
	public StdVideoAV1TxMode TxMode;
	public uint8 delta_q_res;
	public uint8 delta_lf_res;
	public uint8[STD_VIDEO_AV1_SKIP_MODE_FRAMES] SkipModeFrame;
	public uint8 coded_denom;
	public uint8[3] reserved2; // Reserved for future use and must be initialized with 0.
	public uint8[STD_VIDEO_AV1_NUM_REF_FRAMES] OrderHints;
	public uint32[STD_VIDEO_AV1_NUM_REF_FRAMES] expectedFrameId;
	public StdVideoAV1TileInfo* pTileInfo;
	public StdVideoAV1Quantization* pQuantization;
	public StdVideoAV1Segmentation* pSegmentation;
	public StdVideoAV1LoopFilter* pLoopFilter;
	public StdVideoAV1CDEF* pCDEF;
	public StdVideoAV1LoopRestoration* pLoopRestoration;
	public StdVideoAV1GlobalMotion* pGlobalMotion;
	public StdVideoAV1FilmGrain* pFilmGrain;

	public this(StdVideoDecodeAV1PictureInfoFlags flags, StdVideoAV1FrameType frame_type, uint32 current_frame_id, uint8 OrderHint, uint8 primary_ref_frame, uint8 refresh_frame_flags, uint8 reserved1, StdVideoAV1InterpolationFilter interpolation_filter, StdVideoAV1TxMode TxMode, uint8 delta_q_res, uint8 delta_lf_res, uint8[STD_VIDEO_AV1_SKIP_MODE_FRAMES] SkipModeFrame, uint8 coded_denom, uint8[3] reserved2, uint8[STD_VIDEO_AV1_NUM_REF_FRAMES] OrderHints, uint32[STD_VIDEO_AV1_NUM_REF_FRAMES] expectedFrameId, StdVideoAV1TileInfo* pTileInfo, StdVideoAV1Quantization* pQuantization, StdVideoAV1Segmentation* pSegmentation, StdVideoAV1LoopFilter* pLoopFilter, StdVideoAV1CDEF* pCDEF, StdVideoAV1LoopRestoration* pLoopRestoration, StdVideoAV1GlobalMotion* pGlobalMotion, StdVideoAV1FilmGrain* pFilmGrain)
	{
		this.flags = flags;
		this.frame_type = frame_type;
		this.current_frame_id = current_frame_id;
		this.OrderHint = OrderHint;
		this.primary_ref_frame = primary_ref_frame;
		this.refresh_frame_flags = refresh_frame_flags;
		this.reserved1 = reserved1;
		this.interpolation_filter = interpolation_filter;
		this.TxMode = TxMode;
		this.delta_q_res = delta_q_res;
		this.delta_lf_res = delta_lf_res;
		this.SkipModeFrame = SkipModeFrame;
		this.coded_denom = coded_denom;
		this.reserved2 = reserved2;
		this.OrderHints = OrderHints;
		this.expectedFrameId = expectedFrameId;
		this.pTileInfo = pTileInfo;
		this.pQuantization = pQuantization;
		this.pSegmentation = pSegmentation;
		this.pLoopFilter = pLoopFilter;
		this.pCDEF = pCDEF;
		this.pLoopRestoration = pLoopRestoration;
		this.pGlobalMotion = pGlobalMotion;
		this.pFilmGrain = pFilmGrain;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoDecodeAV1ReferenceInfoFlags
{
	[Bitfield(.Public, .Bits(1), "disable_frame_end_update_cdf")]
	[Bitfield(.Public, .Bits(1), "segmentation_enabled")]
	[Bitfield(.Public, .Bits(30), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 disable_frame_end_update_cdf, uint32 segmentation_enabled, uint32 reserved) : this()
	{
		this.disable_frame_end_update_cdf = disable_frame_end_update_cdf;
		this.segmentation_enabled = segmentation_enabled;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoDecodeAV1ReferenceInfo
{
	public StdVideoDecodeAV1ReferenceInfoFlags flags;
	public uint8 frame_type;
	public uint8 RefFrameSignBias;
	public uint8 OrderHint;
	public uint8[STD_VIDEO_AV1_NUM_REF_FRAMES] SavedOrderHints;

	public this(StdVideoDecodeAV1ReferenceInfoFlags flags, uint8 frame_type, uint8 RefFrameSignBias, uint8 OrderHint, uint8[STD_VIDEO_AV1_NUM_REF_FRAMES] SavedOrderHints)
	{
		this.flags = flags;
		this.frame_type = frame_type;
		this.RefFrameSignBias = RefFrameSignBias;
		this.OrderHint = OrderHint;
		this.SavedOrderHints = SavedOrderHints;
	}

	public this()
	{
		this = default;
	}
}

static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_API_VERSION_1_0_0 = VK_MAKE_VIDEO_STD_VERSION(1, 0, 0); }
static { public const uint32 VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_SPEC_VERSION = VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_API_VERSION_1_0_0; }
static { public const c_char* VK_STD_VULKAN_VIDEO_CODEC_AV1_ENCODE_EXTENSION_NAME = "VK_STD_vulkan_video_codec_av1_encode"; }

[CRepr] struct StdVideoEncodeAV1DecoderModelInfo
{
	public uint8 buffer_delay_length_minus_1;
	public uint8 buffer_removal_time_length_minus_1;
	public uint8 frame_presentation_time_length_minus_1;
	public uint8 reserved1; // Reserved for future use and must be initialized with 0.
	public uint32 num_units_in_decoding_tick;

	public this(uint8 buffer_delay_length_minus_1, uint8 buffer_removal_time_length_minus_1, uint8 frame_presentation_time_length_minus_1, uint8 reserved1, uint32 num_units_in_decoding_tick)
	{
		this.buffer_delay_length_minus_1 = buffer_delay_length_minus_1;
		this.buffer_removal_time_length_minus_1 = buffer_removal_time_length_minus_1;
		this.frame_presentation_time_length_minus_1 = frame_presentation_time_length_minus_1;
		this.reserved1 = reserved1;
		this.num_units_in_decoding_tick = num_units_in_decoding_tick;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeAV1ExtensionHeader
{
	// Syntax defined in section 5.3.3, semantics defined in section 6.2.3
	public uint8 temporal_id;
	public uint8 spatial_id;

	public this(uint8 temporal_id, uint8 spatial_id)
	{
		this.temporal_id = temporal_id;
		this.spatial_id = spatial_id;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeAV1OperatingPointInfoFlags
{
	[Bitfield(.Public, .Bits(1), "decoder_model_present_for_this_op")]
	[Bitfield(.Public, .Bits(1), "low_delay_mode_flag")]
	[Bitfield(.Public, .Bits(1), "initial_display_delay_present_for_this_op")]
	[Bitfield(.Public, .Bits(29), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 decoder_model_present_for_this_op, uint32 low_delay_mode_flag, uint32 initial_display_delay_present_for_this_op, uint32 reserved) : this()
	{
		this.decoder_model_present_for_this_op = decoder_model_present_for_this_op;
		this.low_delay_mode_flag = low_delay_mode_flag;
		this.initial_display_delay_present_for_this_op = initial_display_delay_present_for_this_op;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeAV1OperatingPointInfo
{
	public StdVideoEncodeAV1OperatingPointInfoFlags flags;
	public uint16 operating_point_idc;
	public uint8 seq_level_idx;
	public uint8 seq_tier;
	public uint32 decoder_buffer_delay;
	public uint32 encoder_buffer_delay;
	public uint8 initial_display_delay_minus_1;

	public this(StdVideoEncodeAV1OperatingPointInfoFlags flags, uint16 operating_point_idc, uint8 seq_level_idx, uint8 seq_tier, uint32 decoder_buffer_delay, uint32 encoder_buffer_delay, uint8 initial_display_delay_minus_1)
	{
		this.flags = flags;
		this.operating_point_idc = operating_point_idc;
		this.seq_level_idx = seq_level_idx;
		this.seq_tier = seq_tier;
		this.decoder_buffer_delay = decoder_buffer_delay;
		this.encoder_buffer_delay = encoder_buffer_delay;
		this.initial_display_delay_minus_1 = initial_display_delay_minus_1;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeAV1PictureInfoFlags
{
	// Syntax defined in section 5.9, semantics defined in section 6.8
	[Bitfield(.Public, .Bits(1), "error_resilient_mode")]
	[Bitfield(.Public, .Bits(1), "disable_cdf_update")]
	[Bitfield(.Public, .Bits(1), "use_superres")]
	[Bitfield(.Public, .Bits(1), "render_and_frame_size_different")]
	[Bitfield(.Public, .Bits(1), "allow_screen_content_tools")]
	[Bitfield(.Public, .Bits(1), "is_filter_switchable")]
	[Bitfield(.Public, .Bits(1), "force_integer_mv")]
	[Bitfield(.Public, .Bits(1), "frame_size_override_flag")]
	[Bitfield(.Public, .Bits(1), "buffer_removal_time_present_flag")]
	[Bitfield(.Public, .Bits(1), "allow_intrabc")]
	[Bitfield(.Public, .Bits(1), "frame_refs_short_signaling")]
	[Bitfield(.Public, .Bits(1), "allow_high_precision_mv")]
	[Bitfield(.Public, .Bits(1), "is_motion_mode_switchable")]
	[Bitfield(.Public, .Bits(1), "use_ref_frame_mvs")]
	[Bitfield(.Public, .Bits(1), "disable_frame_end_update_cdf")]
	[Bitfield(.Public, .Bits(1), "allow_warped_motion")]
	[Bitfield(.Public, .Bits(1), "reduced_tx_set")]
	[Bitfield(.Public, .Bits(1), "skip_mode_present")]
	[Bitfield(.Public, .Bits(1), "delta_q_present")]
	[Bitfield(.Public, .Bits(1), "delta_lf_present")]
	[Bitfield(.Public, .Bits(1), "delta_lf_multi")]
	[Bitfield(.Public, .Bits(1), "segmentation_enabled")]
	[Bitfield(.Public, .Bits(1), "segmentation_update_map")]
	[Bitfield(.Public, .Bits(1), "segmentation_temporal_update")]
	[Bitfield(.Public, .Bits(1), "segmentation_update_data")]
	[Bitfield(.Public, .Bits(1), "UsesLr")]
	[Bitfield(.Public, .Bits(1), "usesChromaLr")]
	[Bitfield(.Public, .Bits(1), "show_frame")]
	[Bitfield(.Public, .Bits(1), "showable_frame")]
	[Bitfield(.Public, .Bits(3), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 error_resilient_mode, uint32 disable_cdf_update, uint32 use_superres, uint32 render_and_frame_size_different, uint32 allow_screen_content_tools, uint32 is_filter_switchable, uint32 force_integer_mv, uint32 frame_size_override_flag, uint32 buffer_removal_time_present_flag, uint32 allow_intrabc, uint32 frame_refs_short_signaling, uint32 allow_high_precision_mv, uint32 is_motion_mode_switchable, uint32 use_ref_frame_mvs, uint32 disable_frame_end_update_cdf, uint32 allow_warped_motion, uint32 reduced_tx_set, uint32 skip_mode_present, uint32 delta_q_present, uint32 delta_lf_present, uint32 delta_lf_multi, uint32 segmentation_enabled, uint32 segmentation_update_map, uint32 segmentation_temporal_update, uint32 segmentation_update_data, uint32 UsesLr, uint32 usesChromaLr, uint32 show_frame, uint32 showable_frame, uint32 reserved) : this()
	{
		this.error_resilient_mode = error_resilient_mode;
		this.disable_cdf_update = disable_cdf_update;
		this.use_superres = use_superres;
		this.render_and_frame_size_different = render_and_frame_size_different;
		this.allow_screen_content_tools = allow_screen_content_tools;
		this.is_filter_switchable = is_filter_switchable;
		this.force_integer_mv = force_integer_mv;
		this.frame_size_override_flag = frame_size_override_flag;
		this.buffer_removal_time_present_flag = buffer_removal_time_present_flag;
		this.allow_intrabc = allow_intrabc;
		this.frame_refs_short_signaling = frame_refs_short_signaling;
		this.allow_high_precision_mv = allow_high_precision_mv;
		this.is_motion_mode_switchable = is_motion_mode_switchable;
		this.use_ref_frame_mvs = use_ref_frame_mvs;
		this.disable_frame_end_update_cdf = disable_frame_end_update_cdf;
		this.allow_warped_motion = allow_warped_motion;
		this.reduced_tx_set = reduced_tx_set;
		this.skip_mode_present = skip_mode_present;
		this.delta_q_present = delta_q_present;
		this.delta_lf_present = delta_lf_present;
		this.delta_lf_multi = delta_lf_multi;
		this.segmentation_enabled = segmentation_enabled;
		this.segmentation_update_map = segmentation_update_map;
		this.segmentation_temporal_update = segmentation_temporal_update;
		this.segmentation_update_data = segmentation_update_data;
		this.UsesLr = UsesLr;
		this.usesChromaLr = usesChromaLr;
		this.show_frame = show_frame;
		this.showable_frame = showable_frame;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeAV1PictureInfo
{
	// Syntax defined in sections 5.9 and 5.11.1, semantics defined in sections 6.8 and 6.10.1
	public StdVideoEncodeAV1PictureInfoFlags flags;
	public StdVideoAV1FrameType frame_type;
	public uint32 frame_presentation_time;
	public uint32 current_frame_id;
	public uint8 order_hint;
	public uint8 primary_ref_frame;
	public uint8 refresh_frame_flags;
	public uint8 coded_denom;
	public uint16 render_width_minus_1;
	public uint16 render_height_minus_1;
	public StdVideoAV1InterpolationFilter interpolation_filter;
	public StdVideoAV1TxMode TxMode;
	public uint8 delta_q_res;
	public uint8 delta_lf_res;
	public uint8[STD_VIDEO_AV1_NUM_REF_FRAMES] ref_order_hint;
	public int8[STD_VIDEO_AV1_REFS_PER_FRAME] ref_frame_idx;
	public uint8[3] reserved1; // Reserved for future use and must be initialized with 0.
	public uint32[STD_VIDEO_AV1_REFS_PER_FRAME] delta_frame_id_minus_1;
	public StdVideoAV1TileInfo* pTileInfo;
	public StdVideoAV1Quantization* pQuantization;
	public StdVideoAV1Segmentation* pSegmentation;
	public StdVideoAV1LoopFilter* pLoopFilter;
	public StdVideoAV1CDEF* pCDEF;
	public StdVideoAV1LoopRestoration* pLoopRestoration;
	public StdVideoAV1GlobalMotion* pGlobalMotion;
	public StdVideoEncodeAV1ExtensionHeader* pExtensionHeader;
	public uint32* pBufferRemovalTimes;

	public this(StdVideoEncodeAV1PictureInfoFlags flags, StdVideoAV1FrameType frame_type, uint32 frame_presentation_time, uint32 current_frame_id, uint8 order_hint, uint8 primary_ref_frame, uint8 refresh_frame_flags, uint8 coded_denom, uint16 render_width_minus_1, uint16 render_height_minus_1, StdVideoAV1InterpolationFilter interpolation_filter, StdVideoAV1TxMode TxMode, uint8 delta_q_res, uint8 delta_lf_res, uint8[STD_VIDEO_AV1_NUM_REF_FRAMES] ref_order_hint, int8[STD_VIDEO_AV1_REFS_PER_FRAME] ref_frame_idx, uint8[3] reserved1, uint32[STD_VIDEO_AV1_REFS_PER_FRAME] delta_frame_id_minus_1, StdVideoAV1TileInfo* pTileInfo, StdVideoAV1Quantization* pQuantization, StdVideoAV1Segmentation* pSegmentation, StdVideoAV1LoopFilter* pLoopFilter, StdVideoAV1CDEF* pCDEF, StdVideoAV1LoopRestoration* pLoopRestoration, StdVideoAV1GlobalMotion* pGlobalMotion, StdVideoEncodeAV1ExtensionHeader* pExtensionHeader, uint32* pBufferRemovalTimes)
	{
		this.flags = flags;
		this.frame_type = frame_type;
		this.frame_presentation_time = frame_presentation_time;
		this.current_frame_id = current_frame_id;
		this.order_hint = order_hint;
		this.primary_ref_frame = primary_ref_frame;
		this.refresh_frame_flags = refresh_frame_flags;
		this.coded_denom = coded_denom;
		this.render_width_minus_1 = render_width_minus_1;
		this.render_height_minus_1 = render_height_minus_1;
		this.interpolation_filter = interpolation_filter;
		this.TxMode = TxMode;
		this.delta_q_res = delta_q_res;
		this.delta_lf_res = delta_lf_res;
		this.ref_order_hint = ref_order_hint;
		this.ref_frame_idx = ref_frame_idx;
		this.reserved1 = reserved1;
		this.delta_frame_id_minus_1 = delta_frame_id_minus_1;
		this.pTileInfo = pTileInfo;
		this.pQuantization = pQuantization;
		this.pSegmentation = pSegmentation;
		this.pLoopFilter = pLoopFilter;
		this.pCDEF = pCDEF;
		this.pLoopRestoration = pLoopRestoration;
		this.pGlobalMotion = pGlobalMotion;
		this.pExtensionHeader = pExtensionHeader;
		this.pBufferRemovalTimes = pBufferRemovalTimes;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeAV1ReferenceInfoFlags
{
	[Bitfield(.Public, .Bits(1), "disable_frame_end_update_cdf")]
	[Bitfield(.Public, .Bits(1), "segmentation_enabled")]
	[Bitfield(.Public, .Bits(30), "reserved")]
	private uint32 __bitfields_reserved;

	public this(uint32 disable_frame_end_update_cdf, uint32 segmentation_enabled, uint32 reserved) : this()
	{
		this.disable_frame_end_update_cdf = disable_frame_end_update_cdf;
		this.segmentation_enabled = segmentation_enabled;
		this.reserved = reserved;
	}

	public this()
	{
		this = default;
	}
}

[CRepr] struct StdVideoEncodeAV1ReferenceInfo
{
	public StdVideoEncodeAV1ReferenceInfoFlags flags;
	public uint32 RefFrameId;
	public StdVideoAV1FrameType frame_type;
	public uint8 OrderHint;
	public uint8[3] reserved1; // Reserved for future use and must be initialized with 0.
	public StdVideoEncodeAV1ExtensionHeader* pExtensionHeader;

	public this(StdVideoEncodeAV1ReferenceInfoFlags flags, uint32 RefFrameId, StdVideoAV1FrameType frame_type, uint8 OrderHint, uint8[3] reserved1, StdVideoEncodeAV1ExtensionHeader* pExtensionHeader)
	{
		this.flags = flags;
		this.RefFrameId = RefFrameId;
		this.frame_type = frame_type;
		this.OrderHint = OrderHint;
		this.reserved1 = reserved1;
		this.pExtensionHeader = pExtensionHeader;
	}

	public this()
	{
		this = default;
	}
}
